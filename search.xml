<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的工具列表</title>
      <link href="/posts/2025-10-29-tools.html"/>
      <url>/posts/2025-10-29-tools.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>类别</th><th>工具</th><th>说明</th></tr></thead><tbody><tr><td>计算机</td><td>MacBook Pro M1 2021, ThinkPad X260</td><td></td></tr><tr><td>操作系统</td><td>macOS, Debian 13 with xfce4, UOS with xfce4</td><td></td></tr><tr><td>笔记本支架</td><td>绿联笔记本支架</td><td></td></tr><tr><td>Java 开发环境</td><td><a href="https://www.jetbrains.com/idea/">IDEA</a></td><td></td></tr><tr><td>Go 开发环境</td><td><a href="https://www.jetbrains.com/go/">GoLand</a></td><td></td></tr><tr><td>Python 开发环境</td><td><a href="https://www.jetbrains.com/pycharm/">PyCharm</a></td><td></td></tr><tr><td>Web 前端开发环境</td><td><a href="https://www.jetbrains.com/webstorm/">WebStorm</a></td><td></td></tr><tr><td>PHP 开发环境</td><td><a href="https://www.jetbrains.com/phpstorm/">PhpStorm</a></td><td></td></tr><tr><td>数据库连接工具</td><td><a href="https://www.jetbrains.com/datagrip/">DataGrip</a>, <a href="https://dbeaver.io/">DBeaver</a></td><td></td></tr><tr><td>Markdown 工具</td><td><a href="https://typora.io/">Typora</a></td><td></td></tr><tr><td>配置文件编辑工具</td><td><a href="https://www.sublimetext.com/">Sublime Text 3</a>, Vim</td><td></td></tr><tr><td>Docker 工具</td><td><a href="https://orbstack.dev/">OrbStack</a>, Docker CE</td><td></td></tr><tr><td>虚拟机</td><td><a href="https://www.virtualbox.org/">VirtualBox</a>, <a href="https://orbstack.dev/">VM in OrbStack</a></td><td></td></tr><tr><td>代码编译环境</td><td><a href="https://www.debian.org/">Debian 13</a></td><td></td></tr><tr><td>终端工具</td><td><a href="https://iterm2.com/">iTerm 2</a>, terminator</td><td></td></tr><tr><td>FTP, SFTP 工具</td><td><a href="https://panic.com/transmit/">Transmit</a>, <a href="https://winscp.net/eng/download.php">WinSCP</a></td><td></td></tr><tr><td>架构图绘制</td><td><a href="https://github.com/jgraph/drawio">draw.io</a>, <a href="https://plantuml.com/zh/">PlantUML</a>, …</td><td></td></tr><tr><td>Redis 客户端</td><td><a href="https://github.com/qishibo/AnotherRedisDesktopManager">Another Redis Desktop Manager</a></td><td></td></tr><tr><td>思维导图</td><td><a href="https://xmind.com/">Xmind</a>, <a href="https://sourceforge.net/projects/freeplane/files/freeplane%20stable/">Freeplane</a></td><td></td></tr><tr><td>密码管理工具</td><td><a href="https://keepassxc.org/">KeePassXC</a></td><td></td></tr><tr><td>文本对比工具</td><td><a href="https://gnome.pages.gitlab.gnome.org/meld/">Meld</a></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Incus</title>
      <link href="/posts/2025-10-28-incus.html"/>
      <url>/posts/2025-10-28-incus.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础要求"><a href="#一、基础要求" class="headerlink" title="一、基础要求"></a>一、基础要求</h1><p>操作系统：Debian 13</p><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><pre><code>$ sudo apt update$ sudo apt install -y incus</code></pre><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><h2 id="3-1-查看列表"><a href="#3-1-查看列表" class="headerlink" title="3.1 查看列表"></a>3.1 查看列表</h2><pre><code>$ sudo incus list</code></pre><h2 id="3-2-创建一个容器"><a href="#3-2-创建一个容器" class="headerlink" title="3.2 创建一个容器"></a>3.2 创建一个容器</h2><pre><code>$ sudo incus launch images:ubuntu/24.04 first</code></pre><h2 id="3-3-拷贝容器"><a href="#3-3-拷贝容器" class="headerlink" title="3.3 拷贝容器"></a>3.3 拷贝容器</h2><pre><code>$ sudo incus copy first second</code></pre><h2 id="3-4-创建一个虚拟机"><a href="#3-4-创建一个虚拟机" class="headerlink" title="3.4 创建一个虚拟机"></a>3.4 创建一个虚拟机</h2><pre><code>$ sudo incus launch images:debian/12 debian --vm</code></pre><h2 id="3-5-启动"><a href="#3-5-启动" class="headerlink" title="3.5 启动"></a>3.5 启动</h2><pre><code>$ sudo incus start first</code></pre><h2 id="3-6-停止"><a href="#3-6-停止" class="headerlink" title="3.6 停止"></a>3.6 停止</h2><pre><code>$ sudo incus stop first</code></pre><h2 id="3-7-查看信息"><a href="#3-7-查看信息" class="headerlink" title="3.7 查看信息"></a>3.7 查看信息</h2><pre><code>$ sudo incus info first</code></pre><h2 id="3-8-删除"><a href="#3-8-删除" class="headerlink" title="3.8 删除"></a>3.8 删除</h2><pre><code>$ sudo incus delete first</code></pre><h2 id="3-9-进入执行命令"><a href="#3-9-进入执行命令" class="headerlink" title="3.9 进入执行命令"></a>3.9 进入执行命令</h2><pre><code>$ sudo incus exec first -- bash$ sudo incus exec first -- free -m</code></pre><h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><h2 id="4-1-No-root-device-could-be-found"><a href="#4-1-No-root-device-could-be-found" class="headerlink" title="4.1 No root device could be found"></a>4.1 No root device could be found</h2><p>报错信息：</p><pre><code>Error: Failed instance creation: Failed creating instance record: Failed initializing instance: Failed getting root disk: No root device could be found</code></pre><p>解决方法：</p><pre><code>$ sudo incus storage create default dir$ sudo incus profile device add default root disk path=/ pool=default</code></pre><p>验证：</p><pre><code>$ sudo incus profile show default</code></pre><p>期望输出：</p><pre><code>$ sudo incus profile show defaultconfig: &#123;&#125;description: Default Incus profiledevices:  root:    path: /    pool: default    type: diskname: defaultused_by: []project: default</code></pre><h2 id="4-2-doesn’t-have-any-network-attached-to-it"><a href="#4-2-doesn’t-have-any-network-attached-to-it" class="headerlink" title="4.2 doesn’t have any network attached to it"></a>4.2 doesn’t have any network attached to it</h2><p>报错信息：</p><pre><code>The instance you are starting doesn&#39;t have any network attached to it.  To create a new network, use: incus network create  To attach a network to an instance, use: incus network attach</code></pre><p>解决方法：</p><pre><code>$ sudo incus network create incusbr0$ sudo incus profile device add default eth0 nic network=incusbr0 name=eth0</code></pre><p>验证方法：</p><pre><code>$ sudo incus profile show default</code></pre><p>期望输出：</p><pre><code>$ sudo incus profile show defaultconfig: &#123;&#125;description: Default Incus profiledevices:  eth0:    name: eth0    network: incusbr0    type: nic  root:    path: /    pool: default    type: diskname: defaultused_by: []project: default</code></pre><h1 id="附录一、Debian-13-下一键安装并配置"><a href="#附录一、Debian-13-下一键安装并配置" class="headerlink" title="附录一、Debian 13 下一键安装并配置"></a>附录一、Debian 13 下一键安装并配置</h1><pre><code>$ sudo apt update &amp;&amp; \  sudo apt install -y incus &amp;&amp; \  sudo incus storage create default dir &amp;&amp; \  sudo incus profile device add default root disk path=/ pool=default &amp;&amp; \  sudo incus network create incusbr0 &amp;&amp; \  sudo incus profile device add default eth0 nic network=incusbr0 name=eth0 &amp;&amp; \  sudo incus profile show default</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Incus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好的开源项目</title>
      <link href="/posts/2025-10-25-good-open-source-project.html"/>
      <url>/posts/2025-10-25-good-open-source-project.html</url>
      
        <content type="html"><![CDATA[<p>是否是好的开源项目大致看以下三点：</p><ol><li>许可证：是否为 <a href="https://opensource.org/licenses">OSI 核准</a> 的开源协议。</li><li>自托管：能否把<strong>完整产品</strong>端到端地自己部署。</li><li>商业化：有没有商业中立、无厂商绑架；更妙的是，有 <strong>多家</strong> 公司背书而非一家独大。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Open Source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【已解决】Xrdp 远程桌面中出现 Authorization is required 的问题</title>
      <link href="/posts/2025-10-17-solved-xrdp-authorization-is-required-problem.html"/>
      <url>/posts/2025-10-17-solved-xrdp-authorization-is-required-problem.html</url>
      
        <content type="html"><![CDATA[<p>在使用 xrdp 远程桌面的过程中，比如我们需要挂载U盘、卸载U盘等操作时，会弹出一个授权窗口，需要输入密码。</p><p>主要原因是通过 <strong>xRDP 登录的会话</strong> 并没有经过真正的系统登录会话（即 <em>polkit</em> 认为“非本地登录”）。</p><p><strong>解决方法：</strong></p><p><strong>步骤一</strong>、创建文件 <code>/etc/polkit-1/rules.d/49-allow-sudo.rules</code> 并写入以下内容：</p><pre><code>polkit.addRule(function(action, subject) &#123;    if (subject.isInGroup(&quot;sudo&quot;)) &#123;        return polkit.Result.YES;    &#125;&#125;);</code></pre><p><strong>步骤二</strong>、重启服务</p><pre><code>$ sudo systemctl restart polkit</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 11 LTSC KMS 激活（不需要激活工具）</title>
      <link href="/posts/2025-10-17-windows-11-ltsc-kms.html"/>
      <url>/posts/2025-10-17-windows-11-ltsc-kms.html</url>
      
        <content type="html"><![CDATA[<p>以管理员身份打开命令提示符（或Powershell）执行以下命令：</p><pre><code>slmgr -ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462Dslmgr -skms kms.0t.net.cnslmgr -ato</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEAP 认证配置（Debian 13）</title>
      <link href="/posts/2025-10-14-debian-13-peap-configuration.html"/>
      <url>/posts/2025-10-14-debian-13-peap-configuration.html</url>
      
        <content type="html"><![CDATA[<p>编辑 <code>/etc/NetworkManager/system-connections/Wired</code> 文件，增加以下内容：</p><pre><code>[802-1x]eap=peap;identity=&lt;account&gt;password=&lt;password&gt;phase2-auth=gtc</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些配置文件编写原则</title>
      <link href="/posts/2025-09-26-configuration-principles.html"/>
      <url>/posts/2025-09-26-configuration-principles.html</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>原则</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>Endpoint</td><td>端点地址末尾不要加 &#x2F;</td><td><code>https://endpoint.example.com</code></td></tr><tr><td>路径</td><td>路径末尾不要加 &#x2F;</td><td><code>/var/lib/demo001/conf</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome/Chromium 浏览器启动参数</title>
      <link href="/posts/2025-09-26-chrome-arguments.html"/>
      <url>/posts/2025-09-26-chrome-arguments.html</url>
      
        <content type="html"><![CDATA[<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p><strong>Linux:</strong></p><pre><code>$ google-chrome-stable</code></pre><p><strong>macOS:</strong></p><pre><code>$ open -n &#39;/Applications/Google Chrome.app&#39;</code></pre><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>参数加在 <code>--args</code> 后面，例如：</p><pre><code>$ google-chrome-stable --args --user-data-dir=/data/chrome-data-001/</code></pre><p><strong>指定浏览器启动页面地址：</strong></p><pre><code>https://www.google.com/ncr</code></pre><p><strong>指定数据目录：</strong></p><pre><code>--user-data-dir=/data/chrome-data-001/</code></pre><p><strong>忽略不安全的Origin地址：</strong></p><pre><code>--unsafely-treat-insecure-origin-as-secure=http://172.20.10.5</code></pre><p><strong>禁用浏览器同源策略 (CORS) 和部分安全限制：</strong></p><pre><code>--disable-web-security</code></pre><p><strong>全屏显示：</strong></p><pre><code>--start-fullscreen</code></pre><p><strong>自助机模式：</strong></p><pre><code>--kiosk</code></pre><p><strong>禁用顶部提示条：</strong></p><pre><code>--disable-infobars</code></pre><p><strong>跳过首次运行时的欢迎界面：</strong></p><pre><code>--no-first-run</code></pre><p><strong>跳过初始化过程：</strong></p><pre><code>--fast --fast-start</code></pre><p><strong>禁用翻译功能：</strong></p><pre><code>--disable-translate</code></pre><p><strong>禁用内置翻译UI：</strong></p><pre><code>--disable-features=TranslateUI</code></pre><p><strong>设置代理：</strong></p><pre><code>--proxy-server=&#39;socks5://127.0.0.1:1080&#39;</code></pre><p><strong>禁用滚动条：</strong></p><pre><code>--hide-scrollbars</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apt Sources List</title>
      <link href="/posts/2025-09-24-apt-sources-list.html"/>
      <url>/posts/2025-09-24-apt-sources-list.html</url>
      
        <content type="html"><![CDATA[<h1 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h1><h2 id="Debian-10"><a href="#Debian-10" class="headerlink" title="Debian 10"></a>Debian 10</h2><p>传统格式（<code>/etc/apt/sources.list</code>）：</p><pre><code>deb http://mirrors.cloud.tencent.com/debian-archive/debian          buster         main contrib non-freedeb http://mirrors.cloud.tencent.com/debian-archive/debian          buster-updates main contrib non-freedeb http://mirrors.cloud.tencent.com/debian-archive/debian-security buster/updates main contrib non-free</code></pre><h2 id="Debian-11"><a href="#Debian-11" class="headerlink" title="Debian 11"></a>Debian 11</h2><p>传统格式（<code>/etc/apt/sources.list</code>）：</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/debian          bullseye          main contrib non-freedeb http://mirrors.tuna.tsinghua.edu.cn/debian          bullseye-updates  main contrib non-freedeb http://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</code></pre><h2 id="Debian-12"><a href="#Debian-12" class="headerlink" title="Debian 12"></a>Debian 12</h2><p>传统格式（<code>/etc/apt/sources.list</code>）：</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/debian/         bookworm           main contrib non-free non-free-firmwaredeb http://mirrors.tuna.tsinghua.edu.cn/debian/         bookworm-updates   main contrib non-free non-free-firmwaredeb http://mirrors.tuna.tsinghua.edu.cn/debian/         bookworm-backports main contrib non-free non-free-firmwaredeb http://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security  main contrib non-free non-free-firmware</code></pre><p>DEB822格式（<code>/etc/apt/sources.list.d/debian.sources</code>）：</p><pre><code>Types: debURIs: http://mirrors.tuna.tsinghua.edu.cn/debianSuites: bookworm bookworm-updates bookworm-backportsComponents: main contrib non-free non-free-firmwareSigned-By: /usr/share/keyrings/debian-archive-keyring.gpgTypes: debURIs: http://mirrors.tuna.tsinghua.edu.cn/debian-securitySuites: bookworm-securityComponents: main contrib non-free non-free-firmwareSigned-By: /usr/share/keyrings/debian-archive-keyring.gpg</code></pre><h2 id="Debian-13"><a href="#Debian-13" class="headerlink" title="Debian 13"></a>Debian 13</h2><p>传统格式（<code>/etc/apt/sources.list</code>）：</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/debian          trixie           main contrib non-free non-free-firmwaredeb http://mirrors.tuna.tsinghua.edu.cn/debian          trixie-updates   main contrib non-free non-free-firmwaredeb http://mirrors.tuna.tsinghua.edu.cn/debian          trixie-backports main contrib non-free non-free-firmwaredeb http://mirrors.tuna.tsinghua.edu.cn/debian-security trixie-security  main contrib non-free non-free-firmware</code></pre><p>DEB822格式（<code>/etc/apt/sources.list.d/debian.sources</code>）：</p><pre><code>Types: debURIs: http://mirrors.tuna.tsinghua.edu.cn/debianSuites: trixie trixie-updates trixie-backportsComponents: main contrib non-free non-free-firmwareSigned-By: /usr/share/keyrings/debian-archive-keyring.gpgTypes: debURIs: http://mirrors.tuna.tsinghua.edu.cn/debian-securitySuites: trixie-securityComponents: main contrib non-free non-free-firmwareSigned-By: /usr/share/keyrings/debian-archive-keyring.gpg</code></pre><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="Ubuntu-20-04-LTS"><a href="#Ubuntu-20-04-LTS" class="headerlink" title="Ubuntu 20.04 LTS"></a>Ubuntu 20.04 LTS</h2><p>传统格式（<code>/etc/apt/sources.list</code>）：</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal           main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates   main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-backports main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-security  main restricted universe multiverse</code></pre><h2 id="Ubuntu-24-04-LTS"><a href="#Ubuntu-24-04-LTS" class="headerlink" title="Ubuntu 24.04 LTS"></a>Ubuntu 24.04 LTS</h2><p>传统格式（<code>/etc/apt/sources.list</code>）：</p><pre><code>deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu noble           main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-updates   main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-backports main restricted universe multiversedeb http://mirrors.tuna.tsinghua.edu.cn/ubuntu noble-security  main restricted universe multiverse</code></pre><p>DEB822格式（<code>/etc/apt/sources.list.d/ubuntu.sources</code>）：</p><pre><code>Types: debURIs: http://mirrors.tuna.tsinghua.edu.cn/ubuntuSuites: noble noble-updates noble-backportsComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpgTypes: debURIs: http://mirrors.tuna.tsinghua.edu.cn/ubuntuSuites: noble-securityComponents: main restricted universe multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</code></pre><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>传统格式（<code>/etc/apt/sources.list.d/docker.list</code>）</p><p>文件 <code>/etc/apt/keyrings/docker.gpg</code> 创建方法（需要能访问互联网）：</p><pre><code>$ sudo mkdir -p /etc/apt/keyrings/ &amp;&amp; \  curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/gpg | \  sudo gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg &amp;&amp; \  echo &quot;OK&quot;</code></pre><p><code>/etc/apt/keyrings/docker.gpg</code> 文件 base64 编码结果：</p><pre><code>mQINBFit2ioBEADhWpZ8/wvZ6hUTiXOwQHXMAlaFHcPH9hAtr4F1y2+OYdbtMuthlqqwp028AqyY+PRfVMtSYMbjuQuu5byyKR01BbqYhuS3jtqQmljZ/bJvXqnmiVXh38UuLa+z077PxyxQhu5BbqntTPQMfiyqEiU+BKbq2WmANUKQf+1AmZY/IruOXbnqL4C1+gJ8vfmXQt99npCaxEjaNRVYfOS8QcixNzHUYnb6emjlANyEVlZzeqo7XKl7UrwV5inawTSzWNvtjEjj4nJL8NsLwscpLPQUhTQ+7BbQXAwAmeHCUTQIvvWXqw0Ncmhh4HgeQscQHYgOJjjDVfoY5MucvglbIgCqfzAHW9jxmRL4qbMZj+b1XoePEthtku4bIQN1X5P07fNWzlgaRL5Z4POXDDZTlIQ/El58j9kp4bnWRCJW0lya+f8ocodovZZ+Doi+fy4D5ZGrL4XEcIQP/Lv5uFyf+kQtl/94VFYVJOleAv8W92KdgDkhTcTDG7c0tIkVEKNUq48b3aQ64NOZQW7fVjfoKwEZdOqPE72Pa45jrZzvUFxSpdiNk2tZXYukHjlxxEgBdC/J3cMMNRE1F4NCA3ApfV1Y7/hTeOnmDuDYwr9/obA8t016Yljjq5rdkywPf4JF8mXUW5eCN1vAFHxeg9ZWemhBtQmGxXnw9M+z6hWwc6ahmwARAQABtCtEb2NrZXIgUmVsZWFzZSAoQ0UgZGViKSA8ZG9ja2VyQGRvY2tlci5jb20+iQI3BBMBCgAhBQJYrefAAhsvBQsJCAcDBRUKCQgLBRYCAwEAAh4BAheAAAoJEI2BgDwOv82IsskP/iQZo68flDQmNvn8X5XTd6RRaUH33kXYXquT6NkHJciS7E2gTJmqvMqdtI4mNYHCSEYxI5qrcYV5YqX9P6+Ko+vozo4nseUQLPH/ATQ4qL0Zok+1jkag3LgkjonyUf9bwtWxFp05HC3GMHPhhcUSexCxQLQvnFWXD2sWLKivHp2fT8QbRGeZ+d3m6fqcd5Fu7pxsqm0EUDK5NL+nPIgYhN+auTrhgzhK1CShfGccM/wfRlei9Utz6p9PXRKIlWnXtT4qNGZNTN0tR+NLG/6Bqd8OYBaFAUcue/w1VW6JQ2VGYZHnZu9S8LMcFYBa5Ig9PxwGQOgq6RDKDbV+PqTQT5EFMeR1mrjckk4DQJjbxeMZbiNMG5kGECA8g383P3elhn03WGbEEa4MNc3Z4+7c236QI3xWJfNPdUbXRaAwhy/6rTSFbzwKB0JmebwzQfwjQY6f55MiI/RqDCyuPj3r3jyVRkK86pQKBAJwFHyqj9KaKXMZjfVnowLh9svIGfNbGHpucATqREvUHuQbNnqkCx8VVhtYkhDb9fEP2xBu5VvHbR+3nfVhMut5G34Ct5RS7Jt6LIfFdtcn8CaSas/l1HbiGeRgc70X/9aYx/V/CEJv0lIe8gP6uDoWFPIZ7d6vH+Vro6xuWEGiuMaiznap2KhZmpkgfupyFmplh0s6knymuQINBFit2ioBEADneL9S9m4vhU3blaRjVUUyJ7b/qTjcSylvCH5XUE6R2k+ckEZjfAMZPLpO+/tFM2JIJMD4SifKuS3xck9KtZGCufGmcwiLQRzeHF7vJUKrLD5RTkNi23ydvWZgPjtxQ+DTT1Zcn7BrQFY6FgnRoUVIxwtdw1bMY/89rsFgS5wwuMESd3Q2RYgb7EOFOpnuw6da7WakWf4IhnF5nsNYGDVaIHzpiqCl+uTbf1epCjrOlIzkZ3Z3Yk5CM/TiFzPkz2lLz89cpD8U+NtCsfagWWfjd2U3jDapgH+7nQnCEWpROtzaKHG6lA3pXdix5zG8eRc6/0IbUSWvfjKxLLPfNeCS2pCL3IeEI5nothEEYdQH6szpLog79xB9dVnJyKJbVfxXnseoYqVrRz2VVbUI5Blwm6B40E3eGVfUQWiux54DspyVMMk41Mx7QJ3iynIa1N4ZAqVMAEruyXTRTxc9XW0tYhDMA/1GYvz0EmFpm8LzTHA6sFVtPm/ZlNCX6P1XzJwrv7DSQKD6GGlBQUX+OeEJ8tTkkf8QTJSPUdh8P8YxDFS5EOGAvhhpMBYD42kQpqXjEC+XcycTvGI7impgv9PDY1RCC1zkBjKPa120rNhv/hkVk/YhuGoajoHyy4h7ZQopdcMtpN2dgmhEegny9JCSwxfQmQ0zK0g7m6SHiKMwjwARAQABiQQ+BBgBCAAJBQJYrdoqAhsCAikJEI2BgDwOv82IwV0gBBkBCAAGBQJYrdoqAAoJEH6gqcPyc/zY1WAP/2wJ+R0gE6qsce3rjaIz58PJmc8goKrir5hnElWhPgbq7cYIsW5qiFyLhkdpYcMmhD9mRiPpQn6Ya2w3e3B8zfIVKipbMBnke/ytZ9M7qHmDCcjoiSmwEXN3wKYImD9VHONsl/CG1rU9Isw1jtB5g1YxuBA7M/m36XN6x2u+NtNMDB9P56yc4gfsZVESKA9v+yY2/l45L8d/WUkUi0YXomn6hyBGI7JrBLq0CX37GEYP6O9rrKipfz73XfO7JIGzOKZlljb/D9RX/g7nRbCn+3EtH7xnk+TK/50euEKw8SMUg147sJTcpQmv6UzZcM4JgL0HbHVCojV4C/plELwMddALOFeYQzTif6sMRPf+3DSj8frbInjChC3yOLy06br92KFom17EIj2CAcoeq7UPhi2oouYBwPxh5ytdehJkoo+sN7RIWua6P2WSmon5U888cSylXC0+ADFdgLX9K2zrDVYUG1vo8CX0vzxFBaHwN6Px26fhIT1/hYUHQR1zVfNDcyQmXqkOnZvvoMfz/Q0s9BhFJ/zU6AgQbIZE/hm1spsfgvtsD1frZfygXJ9firP+MSAI80xHSf91qSRZOj4Pl3ZJNbq4yYxv0b1pkMqeGdjdCYhLU+LZ4wbQmpCkSVe2prlLureigXtmZfkqevRz7FrIZiu9ky8wnCAPwC7/zmS18rgP/17bOtL4/iIzQhxAAoAMWVrGyJivSkjhSGx1uCojsWfsTAm11P7jsruIL61ZzMUVE2aM3Pmj5G+W9AcZ58Em+1WsVnAXdUR//bMmhyr8wL/G1YO1V3JEJTRdxsSxdYa4deGBBY/Adpsw24jxhOJR+lsJpqIUeb999+R8euDhRHG9eFO7DRu6weatUJ6suupoDTRWtr/4yGqedKxV3qQhNLSnaAzqW/1nA3iUB4k7kCaKZxhdhDbClf9P37qaRW467BLCVO/coL3yVm50dwdrNtKpMBh3ZpbB1uJvgi9mXtyBOMJ3v8RZeDzFiG8HdCtg9RvIt/AIFoHRH3S+U79NT6i0KPzLImDfs8T7RlpyuMc4Ufs8ggyg9v3Ae6cN3eQyxcK3w0cbBwsh/nQNfsA6uu+9H7NhbehBMhYnpNZyrHzCmzyXkauwRAqoCbGCNykTRwsur9gS41TQM8ssD1jFheOJf3hODnkKU+HKjvMROl1DK7zdmLdNzA1cvtZH/nCC9KPj1z8QC47Sxx+dTZSx4ONAhwbS/LN3PoKtn8LPjY9NP9uDWI+TWYquS2U+KHDrBDlsgozDbs/OjCxcpDzNmXpWQHEtHU7649OXHP7UeNST1mCUCH5qdank0V1iejF6/CfTFU4MfcrGYT90qFF93M3v01BbxP+EIY2/9tiIPbrd</code></pre><h2 id="Debian-10-1"><a href="#Debian-10-1" class="headerlink" title="Debian 10"></a>Debian 10</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable</code></pre><h2 id="Debian-11-1"><a href="#Debian-11-1" class="headerlink" title="Debian 11"></a>Debian 11</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian bullseye stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian bullseye stable</code></pre><h2 id="Debian-12-1"><a href="#Debian-12-1" class="headerlink" title="Debian 12"></a>Debian 12</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian bookworm stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian bookworm stable</code></pre><h2 id="Debian-13-1"><a href="#Debian-13-1" class="headerlink" title="Debian 13"></a>Debian 13</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian trixie stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian trixie stable</code></pre><h2 id="Ubuntu-20-04"><a href="#Ubuntu-20-04" class="headerlink" title="Ubuntu 20.04"></a>Ubuntu 20.04</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu focal stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu focal stable</code></pre><h2 id="Ubuntu-22-04"><a href="#Ubuntu-22-04" class="headerlink" title="Ubuntu 22.04"></a>Ubuntu 22.04</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu jammy stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu jammy stable</code></pre><h2 id="Ubuntu-24-04"><a href="#Ubuntu-24-04" class="headerlink" title="Ubuntu 24.04"></a>Ubuntu 24.04</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu noble stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu noble stable</code></pre><h2 id="deepin-v20-deepin-v25-UOS-Desktop-V20"><a href="#deepin-v20-deepin-v25-UOS-Desktop-V20" class="headerlink" title="deepin v20, deepin v25, UOS Desktop V20"></a>deepin v20, deepin v25, UOS Desktop V20</h2><p><strong>amd64:</strong></p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable</code></pre><p><strong>arm64:</strong></p><pre><code>deb [arch=arm64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YAML行尾不可见字符引发的问题</title>
      <link href="/posts/2025-07-10-how-hidden-trailing-characters-in-yaml.html"/>
      <url>/posts/2025-07-10-how-hidden-trailing-characters-in-yaml.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>YAML（YAML Ain’t Markup Language）作为一种<strong>人类可读性强的配置语言</strong>被广泛应用在各个应用系统中，包括：Kubernetes、Ansible、Docker Compose等等。</p><h2 id="1-1-基本语法规则"><a href="#1-1-基本语法规则" class="headerlink" title="1.1 基本语法规则"></a>1.1 基本语法规则</h2><p>键值对：</p><pre><code>name: Johnage: 30</code></pre><p>缩进表示层级：</p><ul><li>使用空格缩进，禁止使用 tab</li><li>通常每层缩进用 2 或 4 个空格</li></ul><pre><code>person:  name: John  age: 30</code></pre><p>列表（数组）：</p><pre><code>persons:  - name: John    age: 30  - name: Mike    age: 28</code></pre><p>嵌套结构：</p><pre><code>server:  host: localhost  ports:    - 80    - 443</code></pre><p>多行字符表示：</p><ul><li>使用 <code>|</code> 表示保留换行</li><li>使用 <code>&gt;</code> 表示折叠成一行</li></ul><pre><code>description: |  Line one  Line twosummary: &gt;  This is a very long  line that will be folded.</code></pre><p>注释：</p><pre><code>name: John  # 这是注释</code></pre><p>布尔、null、数字：</p><pre><code>enabled: truedisabled: falsenothing: nullcount: 100</code></pre><h2 id="1-2-常见使用错误"><a href="#1-2-常见使用错误" class="headerlink" title="1.2 常见使用错误"></a>1.2 常见使用错误</h2><ul><li>缩进混用空格和tab</li><li>缩进不对齐</li><li>键名重复</li><li>行尾隐藏字符（如空格、零宽字符等不可见字符）</li></ul><h1 id="二、行尾不可见字符"><a href="#二、行尾不可见字符" class="headerlink" title="二、行尾不可见字符"></a>二、行尾不可见字符</h1><p>常见的 YAML 行尾不可见字符</p><ol><li><strong>空格（space, <code>0x20</code>）</strong><ul><li>多余空格有时会影响多行字符串的拼接或注释识别。</li></ul></li><li><strong>制表符（tab, <code>0x09</code>）</strong><ul><li>YAML <strong>禁止使用 tab</strong> 来缩进，但若 tab 出现在行尾，不一定会报错，却可能影响格式或行为。</li></ul></li><li><strong>不可见的 Unicode 字符</strong>（如 <code>U+200B</code> 零宽空格）<ul><li>通常是从复制粘贴中引入，肉眼难以察觉。</li></ul></li></ol><h1 id="三、Go-程序解析"><a href="#三、Go-程序解析" class="headerlink" title="三、Go 程序解析"></a>三、Go 程序解析</h1><p>行尾不可见字符，程序解析 YAML 内容时，并不会读取行尾不可见字符，如果希望程序读取某个变量时，需要内容末尾的空格，那么整个内容需要通过引号进行包裹。</p><p>例如：</p><pre><code>version: 1name: &#39;Alice &#39;age: 30</code></pre><h1 id="四、Go-程序渲染"><a href="#四、Go-程序渲染" class="headerlink" title="四、Go 程序渲染"></a>四、Go 程序渲染</h1><p>以下程序用于将 test.yaml 中的内容嵌入作为 Config 结构体实例中 Content 变量的内容，并输出为 Config 结构体的 yaml 文本。</p><pre><code>package mainimport (    _ &quot;embed&quot;    &quot;fmt&quot;    &quot;gopkg.in/yaml.v3&quot;)type Config struct &#123;    Content string `yaml:&quot;content&quot;`&#125;//go:embed test.yamlvar content stringfunc main() &#123;    m := Config&#123;        Content: content,    &#125;    raw, err := yaml.Marshal(m)    if err != nil &#123;        panic(err)    &#125;    fmt.Println(string(raw))&#125;</code></pre><p><strong>首先，</strong>正常 test.yaml 内容如下：</p><pre><code>version: 1name: Aliceage: 30</code></pre><p>对应输出文本如下：</p><pre><code>content: |-    version: 1    name: Alice    age: 30</code></pre><p>可见，content 中的内容，依旧保持着 yaml 语法的人类可读性强的特点。</p><p><strong>然而，</strong>如果内容中某一行末尾存在不可见字符，比如下面 test.yaml 中的 name 行 Alice 后面还有一个空格：</p><pre><code>version: 1name: Alice age: 30</code></pre><p>那么在渲染文本时，YAML 就会对内容进行转义，对应输出文件如下：</p><pre><code>content: &quot;version: 1\n\nname: Alice \nage: 30&quot;</code></pre><p><strong>那么，</strong>遇到确实内容末尾需要加上空格，就必须使用引号进行包裹，比如：</p><pre><code>version: 1name: &#39;Alice &#39;age: 30</code></pre><p>其对应输出如下：</p><pre><code>content: |-    version: 1    name: &#39;Alice &#39;    age: 30</code></pre><p>依旧能够保持良好的可读性。</p><h1 id="五、Kubernetes-Config-Map"><a href="#五、Kubernetes-Config-Map" class="headerlink" title="五、Kubernetes Config Map"></a>五、Kubernetes Config Map</h1><p>以下是一份因为行尾跟随了不可见字符而渲染之后的 Kubernetes Config Map 配置：</p><pre><code>apiVersion: v1data:  api-config: &quot;server:\n  address: 0.0.0.0:80 \n  mode: debug&quot;kind: ConfigMap</code></pre><p>而这样的因为行尾不可见字符渲染出来的配置，往往会给排查环境问题工作带来麻烦。</p><p>而其对应正常内容应该如下：</p><pre><code>apiVersion: v1data:  api-config: |-    server:      address: 0.0.0.0:80      mode: debugkind: ConfigMap</code></pre><h1 id="六、检查与防范"><a href="#六、检查与防范" class="headerlink" title="六、检查与防范"></a>六、检查与防范</h1><h2 id="6-1-检查工具-cat"><a href="#6-1-检查工具-cat" class="headerlink" title="6.1 检查工具 cat"></a>6.1 检查工具 cat</h2><p>通过 cat 命令可以显示不可见字符：</p><pre><code>$ cat -A file.yaml</code></pre><p>其中：末尾 <code>$</code> 表示行尾</p><pre><code>version: 1$$name: Alice $age: 30$</code></pre><h2 id="6-2-清理"><a href="#6-2-清理" class="headerlink" title="6.2 清理"></a>6.2 清理</h2><p>通过 sed 命令可批量移除行尾空格：</p><pre><code>$ sed -i &#39;s/[ \t]*$//&#39; file.yaml</code></pre><h2 id="6-4-预防建议"><a href="#6-4-预防建议" class="headerlink" title="6.4 预防建议"></a>6.4 预防建议</h2><ul><li>统一使用空格缩进，禁用 tab</li><li>启用编辑器的“保存时自动去除行尾空格”</li><li>使用版本控制 + Lint 工具进行 YAML 格式校验</li><li>避免从网页、PDF、Excel 等非纯文本源复制内容进 YAML</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian 系统配置</title>
      <link href="/posts/2025-06-05-debian-settings.html"/>
      <url>/posts/2025-06-05-debian-settings.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Debian-11"><a href="#一、Debian-11" class="headerlink" title="一、Debian 11"></a>一、Debian 11</h1><h2 id="1-1-设置镜像地址"><a href="#1-1-设置镜像地址" class="headerlink" title="1.1 设置镜像地址"></a>1.1 设置镜像地址</h2><pre><code>$ sudo sed -i &#39;s+http://deb.debian.org/+https://mirrors.ustc.edu.cn/+g&#39; /etc/apt/sources.list</code></pre><h1 id="二、Debian-10"><a href="#二、Debian-10" class="headerlink" title="二、Debian 10"></a>二、Debian 10</h1><h2 id="2-1-设置镜像地址"><a href="#2-1-设置镜像地址" class="headerlink" title="2.1 设置镜像地址"></a>2.1 设置镜像地址</h2><pre><code>$ sudo sed -i &#39;s+http://deb.debian.org/+https://mirrors.ustc.edu.cn/+g&#39; /etc/apt/sources.list</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 Docker 安装 binfmt 支持多架构容器运行与构建</title>
      <link href="/posts/2025-05-26-enable-multi-architecture-container-support-with-binfmt-and-docker.html"/>
      <url>/posts/2025-05-26-enable-multi-architecture-container-support-with-binfmt-and-docker.html</url>
      
        <content type="html"><![CDATA[<p>在日常容器开发或镜像构建过程中，我们常常遇到这样的需求：<strong>在 x86 的主机上运行 ARM 架构的容器</strong>，或构建支持多架构（如 <code>amd64</code> 和 <code>arm64</code>）的镜像。这时候就需要借助 Linux 内核的 <code>binfmt_misc</code> 功能。</p><p>本文将介绍如何通过一条 Docker 命令快速为宿主机安装 <code>binfmt</code>，以支持跨架构容器运行。</p><h1 id="什么是-binfmt-misc？"><a href="#什么是-binfmt-misc？" class="headerlink" title="什么是 binfmt_misc？"></a>什么是 <code>binfmt_misc</code>？</h1><p><code>binfmt_misc</code>（Binary Format Miscellaneous）是 Linux 内核的一项功能，它允许用户为系统注册新的可执行文件格式。例如，当你尝试在 x86_64 的 Linux 上运行一个 ARM64 的二进制时，系统可以通过 <code>qemu-aarch64</code> 解释器将其运行，就像原生程序一样。</p><p>这项机制的关键在于：</p><ul><li>需要内核开启 <code>binfmt_misc</code> 支持（大多数发行版默认启用）</li><li>需要为目标架构注册对应的解释器（如 QEMU）</li></ul><h1 id="快速安装-binfmt-支持的命令"><a href="#快速安装-binfmt-支持的命令" class="headerlink" title="快速安装 binfmt 支持的命令"></a>快速安装 binfmt 支持的命令</h1><p>官方推荐使用 <code>tonistiigi/binfmt</code> 镜像，它是由 Docker 构建工具 <code>buildx</code> 的作者 Tonis Tiigi 提供的轻量级 binfmt 安装器。</p><p>执行以下命令即可：</p><pre><code>$ docker run --rm --privileged docker.1panel.live/tonistiigi/binfmt --install all</code></pre><p><strong>命令说明：</strong></p><ul><li><code>--rm</code>：容器在执行后立即删除，保持系统干净。</li><li><code>--privileged</code>：授予容器特权访问，允许其修改宿主机的内核设置。</li><li><code>docker.1panel.live/tonistiigi/binfmt</code>：镜像地址（也可以使用 <code>tonistiigi/binfmt</code> 官方源）。</li><li><code>--install all</code>：注册所有常用架构的 binfmt 支持，如：<ul><li><code>arm</code></li><li><code>arm64</code></li><li><code>386</code></li><li><code>s390x</code></li><li><code>ppc64le</code></li><li><code>riscv64</code></li></ul></li></ul><hr><h1 id="如何验证是否安装成功？"><a href="#如何验证是否安装成功？" class="headerlink" title="如何验证是否安装成功？"></a>如何验证是否安装成功？</h1><p>可以查看 <code>/proc/sys/fs/binfmt_misc/</code> 目录：</p><pre><code>$ ls /proc/sys/fs/binfmt_misc/</code></pre><p>如果看到如下输出：</p><pre><code>qemu-aarch64qemu-armqemu-ppc64leqemu-riscv64...</code></pre><p>说明安装成功，你现在可以在 x86 机器上运行 arm64 镜像了！</p><hr><h1 id="使用场景：构建多架构-Docker-镜像"><a href="#使用场景：构建多架构-Docker-镜像" class="headerlink" title="使用场景：构建多架构 Docker 镜像"></a>使用场景：构建多架构 Docker 镜像</h1><p>配合 <code>docker buildx</code>，我们可以构建支持多平台的镜像：</p><pre><code>$ docker buildx create --use$ docker buildx build --platform linux/amd64,linux/arm64 -t myimage:latest .</code></pre><p>这样，你构建的镜像就可以在树莓派（ARM）和普通 PC（x86）上都能使用。</p><hr><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="1-没有开启-binfmt-misc-支持怎么办？"><a href="#1-没有开启-binfmt-misc-支持怎么办？" class="headerlink" title="1. 没有开启 binfmt_misc 支持怎么办？"></a>1. 没有开启 <code>binfmt_misc</code> 支持怎么办？</h2><p>请确保你的内核支持该功能，并挂载了 <code>binfmt_misc</code>：</p><pre><code>$ sudo mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc</code></pre><h2 id="2-如何卸载已安装的解释器？"><a href="#2-如何卸载已安装的解释器？" class="headerlink" title="2. 如何卸载已安装的解释器？"></a>2. 如何卸载已安装的解释器？</h2><p>可以通过以下命令逐个取消注册：</p><pre><code>$ echo -1 &gt; /proc/sys/fs/binfmt_misc/qemu-aarch64</code></pre><p>或者卸载整个挂载点：</p><pre><code>$ sudo umount /proc/sys/fs/binfmt_misc</code></pre><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过执行一条简单的 Docker 命令：</p><pre><code>$ docker run --rm --privileged docker.1panel.live/tonistiigi/binfmt --install all</code></pre><p>你就可以为宿主机注册多架构支持，大大简化跨平台镜像构建与测试的流程。</p><p>无论你是想让 x86 主机运行 ARM 镜像，还是想打造通用镜像，<code>binfmt_misc</code> 都是不可或缺的一步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【检查清单】服务器系统安装检查清单</title>
      <link href="/posts/2025-05-22-server-system-installation.html"/>
      <url>/posts/2025-05-22-server-system-installation.html</url>
      
        <content type="html"><![CDATA[<p>以下内容应该在服务器系统安装完成后进行检查。</p><ul><li><p><input disabled="" type="checkbox"> 必备软件包</p><p><strong>Debian 系列：</strong></p><p>更新索引并升级软件包：</p><pre><code>$ sudo apt update &amp;&amp; sudo apt upgrade -y</code></pre><p>安装系统管理工具：</p><pre><code>$ sudo apt install -y htop glances tmux screen lsof strace dstat sysstat ncdu tree</code></pre><p>安装网络工具：</p><pre><code>$ sudo apt install -y iproute2 net-tools curl wget nmap traceroute mtr iperf3 tcpdump dnsutils</code></pre><p>安装监控与日志工具：</p><pre><code>$ sudo apt install -y logrotate goaccess</code></pre><p>安装安全相关工具：</p><pre><code>$ sudo apt install -y ufw fail2ban auditd iptables nftables</code></pre><p>安装文本和压缩工具：</p><pre><code>$ sudo apt install -y rsync vim pv tar gzip xz-utils zip unzip findutils grep sed</code></pre><p>安装版本控制和自动化工具：</p><pre><code>$ sudo apt install -y git cron ansible</code></pre><p><strong>CentOS 系列：</strong></p><p>更新索引并升级软件包：</p><pre><code>$ sudo yum update -y</code></pre><p>安装系统管理工具：</p><pre><code>$ sudo yum install -y htop tmux screen lsof strace sysstat ncdu tree</code></pre><p>安装网络工具：</p><pre><code>$ sudo yum install -y iproute net-tools curl wget nmap traceroute mtr iperf3 tcpdump bind-utils </code></pre><p>安装监控与日志工具</p><pre><code>$ sudo yum install -y logrotate</code></pre><p>安装安全相关工具</p><pre><code>$ sudo yum install -y firewalld audit sudo iptables-services nftables</code></pre><p>安装文本和压缩工具</p><pre><code>$ sudo yum install -y vim rsync pv tar gzip xz zip unzip findutils grep sed gawk</code></pre><p>安装版本控制和自动化工具</p><pre><code>$ sudo yum install -y git cronie ansible</code></pre></li><li><p><input disabled="" type="checkbox"> 配置 SSH 客户端保持在线</p><p>修改 <code>/etc/ssh/sshd_config</code> 中内容</p><pre><code>ClientAliveInterval 0ClientAliveCountMax 0</code></pre><p>并执行</p><pre><code>$ sudo systemctl restart sshd</code></pre></li><li><p><input disabled="" type="checkbox"> 配置 SSH 免密</p><p>方法一、通过 <code>ssh-copy-id</code> 添加免密公钥</p><p>方法二、将公钥内容加入到 <code>root</code> 账号的 <code>.ssh/authorized_keys</code> 文件中</p></li><li><p><input disabled="" type="checkbox"> 启用 sshd 服务</p><pre><code>$ sudo systemctl enable sshd --now</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Checklist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【检查清单】测试服务器系统安装后检查清单</title>
      <link href="/posts/2025-05-21-checklist-testing-pc-server.html"/>
      <url>/posts/2025-05-21-checklist-testing-pc-server.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><input disabled="" type="checkbox"> 禁用 lightdm</p><p>执行 <code>$ sudo systemctl disable lightdm --now</code></p></li><li><p><input disabled="" type="checkbox"> 禁用开机画面</p><p>修改 &#x2F;etc&#x2F;default&#x2F;grub 将 <code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;</code> 改成 <code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;</code> 并执行 <code>$ update-grub</code></p></li><li><p><input disabled="" type="checkbox"> 安装 xrdp</p><p>步骤一、安装 xrdp <code>$ sudo apt install -y xrdp</code></p><p>步骤二、修改 <code>/etc/xrdp/xrdp.ini</code> 将 <code>allow_channels</code> 值设置为 <code>false</code></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Checklist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【检查清单】问题跟进表格检查清单</title>
      <link href="/posts/2025-05-21-checklist-issue-tracking.html"/>
      <url>/posts/2025-05-21-checklist-issue-tracking.html</url>
      
        <content type="html"><![CDATA[<p>检查表头：</p><ul><li><input disabled="" type="checkbox"> 序号</li><li><input disabled="" type="checkbox"> 问题分类</li><li><input disabled="" type="checkbox"> 问题标题</li><li><input disabled="" type="checkbox"> 问题说明</li><li><input disabled="" type="checkbox"> 发现时间</li><li><input disabled="" type="checkbox"> 解决时间</li><li><input disabled="" type="checkbox"> 进度</li><li><input disabled="" type="checkbox"> 根因分析</li><li><input disabled="" type="checkbox"> 解决方法</li><li><input disabled="" type="checkbox"> 备注</li></ul><p>例如：</p><table><thead><tr><th>序号</th><th>问题分类</th><th>问题标题</th><th>问题说明</th><th>发现时间</th><th>解决时间</th><th>进度</th><th>根因分析</th><th>解决方法</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>XXXX</td><td>XXXX</td><td>XXXX</td><td>2025&#x2F;5&#x2F;13</td><td>2025&#x2F;5&#x2F;16</td><td>已解决</td><td>XXXX</td><td>XXXX</td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Checklist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源推荐</title>
      <link href="/posts/resource.html"/>
      <url>/posts/resource.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li><a href="https://wiki.csie.ncku.edu.tw/linux/schedule">Linux 核心設計&#x2F;實作 (Linux Kernel Internals)</a>, 黃敬群</li></ul><h1 id="算法竞赛"><a href="#算法竞赛" class="headerlink" title="算法竞赛"></a>算法竞赛</h1><ul><li><a href="https://github.com/OI-wiki/OI-wiki">OI-wiki</a>: 涵盖竞赛基础知识、常见题型、解题思路、常用工具等，帮助大家快速深入地学习编程竞赛。</li></ul><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><ul><li><a href="https://wangcc.me/LSHTMlearningnote/">醫學統計學</a>，<em>王 超辰 Chaochen Wang</em></li><li><a href="https://bookdown.org/hezhijian/book/">数理统计讲义</a>，<em>何志坚</em></li></ul><h1 id="技能图谱"><a href="#技能图谱" class="headerlink" title="技能图谱"></a>技能图谱</h1><ul><li><a href="https://github.com/TeamStuQ/skill-map">StuQ 程序员技能图谱</a>，开源地址：<a href="https://github.com/TeamStuQ/skill-map">https://github.com/TeamStuQ/skill-map</a></li></ul><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><ul><li><a href="https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.html">Cryptographic Mechanisms: Recommendations and Key Lengths</a>, 加密机制技术指南。<a href="https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.pdf?__blob=publicationFile&v=7">pdf</a></li></ul><h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><ul><li><a href="https://landscape.cncf.io/">Cloud Native Landscape</a> 云原生全景图。</li></ul><h1 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h1><ul><li><a href="https://freecomputerbooks.com/">https://freecomputerbooks.com/</a> 世界各地免费计算机、数学、技术书籍的链接。</li><li><a href="https://libgen.is/">Library Genesis</a></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li><a href="https://softwareengineering.stackexchange.com/questions/165725/git-branching-and-tagging-best-practices">Git branching and tagging best practices</a>, Git 分支和标签管理最佳实践，此文参考自：<a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>, <a href="https://nvie.com/files/Git-branching-model.pdf">pdf</a></li><li><a href="https://beej.us/guide/bggit/">Beej’s Guide to Git</a></li></ul><h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><h2 id="优秀的代码仓库"><a href="#优秀的代码仓库" class="headerlink" title="优秀的代码仓库"></a>优秀的代码仓库</h2><ul><li><a href="https://github.com/IBM/fp-go">https://github.com/IBM/fp-go</a></li><li><a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a></li></ul><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul><li><a href="https://github.com/darius-khll/golang-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md">Go开发者路线图</a></li><li><a href="https://gfw.go101.org/">Go 101</a></li><li><a href="https://www.topgoer.com/">Go语言入门资料</a></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul><li><a href="https://developer.aliyun.com/article/709387">数据库设计规范-阿里云开发者社区</a></li><li><a href="https://www.dboop.com/dba/%E4%BF%A1%E5%88%9B%E5%92%8C%E5%9B%BD%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93/">信创和国产数据库</a></li><li><a href="https://github.com/awesome-selfhosted/awesome-selfhosted">Awesome-Selfhosted</a> 自托管软件宝藏库。</li><li><a href="https://www.sqlite.org/testing.html">How SQLite Is Tested</a></li></ul><h1 id="开放课程"><a href="#开放课程" class="headerlink" title="开放课程"></a>开放课程</h1><ul><li><a href="https://ocw.aca.ntu.edu.tw/ntu-ocw/">臺大開放式課程 (NTU OpenCourseWare)</a></li><li><a href="https://www.hardbreak.wiki/">开源硬件黑客Wiki</a></li><li><a href="https://www.scattered-thoughts.net/writing/small-tech/">Small Tech</a></li></ul><h1 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h1><ul><li><a href="https://www.alignmentforum.org/posts/NfFST5Mio7BCAQHPA/an-extremely-opinionated-annotated-list-of-my-favourite">An Extremely Opinionated Annotated List of My Favourite Mechanistic Interpretability Papers v2</a>: 我最喜欢的机械可解释性论 文的极具主观性的注释列表 v2</li><li><a href="https://www.jeremykun.com/2024/05/04/fhe-overview/">全同态加密的高级技术概述</a></li><li><a href="https://eprint.iacr.org/">Cryptology ePrint Archive</a></li><li><a href="https://arxiv.org/">arXiv</a>是一个收集物理学、数学、计算机科学和生物学的论文预印本的网站。</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h2><ul><li><a href="https://asciinema.org/">asciinema</a> 是一个用于录制终端会话的工具。</li><li><a href="https://www.ventoy.net/">Ventoy</a>: 一个制作可启动U盘的开源工具，有了Ventoy你就无需反复地格式化U盘，只需要把 ISO&#x2F;WIM&#x2F;IMG&#x2F;VHD(x)&#x2F;EFI 等类型的文件直接拷贝到U盘里面即可。</li><li><a href="https://github.com/yudai/gotty">gotty</a>: 一个简单的Web浏览器中访问远端服务器终端命令行的工具。</li><li><a href="https://gnome-terminator.org/">terminator</a>: 一个使用简单但分屏功能强大的终端模拟器，极力推荐 Linux 用户使用🌟🌟🌟🌟🌟。Debian&#x2F;Ubuntu系列上只需要 <code>$ sudo apt install -y terminator</code> 即可安装。</li><li><a href="https://docs.xfce.org/apps/ristretto/start">ristretto</a> 是一款适配用于xfce4桌面环境的简易图像查看器。它能查看、全屏查看、缩放查看或以幻灯片视图查看图片。<pre><code>$ sudo apt install -y ristretto</code></pre></li><li><a href="engrampa">engrampa</a> 是 Linux 环境下非常优秀的压缩软件。<pre><code>$ sudo apt install -y engrampa</code></pre></li><li><a href="https://github.com/mate-desktop/atril">atril</a>: Linux 下文档阅读器。<pre><code>$ sudo apt install -y atril</code></pre></li></ul><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><ul><li><a href="https://www.notion.so/">Notion</a>: 是一款集成了笔记、知识库、数据表格、看板、日历等多种能力于一体的应用程序。非常值得推荐🌟🌟🌟🌟🌟。</li><li><a href="https://acronymify.com/">Acronymify!</a>: 一个可以用来生成缩写词的在线工具。</li><li><a href="https://www.windy.com/">Windy</a>: Wind map &amp; weather forecast.</li><li><a href="https://chat.lmsys.org/">LMSYS</a>: Benchmarking LLMs and VLMs in the Wild.</li><li><a href="https://www.freeplane.org/">freeplane</a> 是一款免费开源的软件应用，支持思考、分享信息、在工作、学校和家中完成任务。它为您提供了一套思维导图（也称为概念图或信息图）和导航映射信息的工具。Freeplane 的功能将吸引高级用户，但对于普通用户来说，它也是 Xmind、Mindmeister 和类似思维导图软件的更强大替代品。</li></ul><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li><p><a href="https://www.sublimetext.com/">Sublime Text</a><br>Debian&#x2F;Ubuntu 安装方法：<br>切换 <code>root</code> 账号下执行以下命令：</p><pre><code>$ wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | gpg --dearmor | tee /etc/apt/trusted.gpg.d/sublimehq-archive.gpg &gt; /dev/null$ echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | tee /etc/apt/sources.list.d/sublime-text.list$ apt-get update &amp;&amp; apt-get install sublime-text</code></pre></li><li><p><a href="https://tools.datapipe.top/">IT在线工具箱</a>: 涵盖UUID生成器、Base64编码解码、JSON美化等常用工具的在线网站。</p></li><li><p>JSON格式化 <a href="https://jsonviewer.stack.hu/">Online JSON Viewer and Formatter</a></p></li><li><p><a href="https://regex-vis.com/">Regex Vis</a>: 一个图形化解释正则表达式的在线网站。</p></li><li><p><a href="https://coolors.co/palettes/trending">Coolors</a>: 配色推荐。</p></li></ul><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><ul><li>dbeaver</li><li><a href="https://github.com/qishibo/AnotherRedisDesktopManager/releases">Another Redis Desktop Manager</a> 是一个支持 macOS, Windows, Linux 跨平台的 Redis 图形化客户端。</li></ul><h2 id="API-客户端"><a href="#API-客户端" class="headerlink" title="API 客户端"></a>API 客户端</h2><ul><li><a href="https://www.usebruno.com/">Bruno</a> 是一个开源用于替代Postman、Insomnia等的快速且Git友好的API客户端。</li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><ul><li><a href="https://www.jenkins.io/">Jenkins</a>: 自动构建流水线推荐使用 <a href="https://www.jenkins.io/">Jenkins</a> 部署。可以参照<a href="https://www.jenkins.io/doc/book/pipeline/syntax/">官方语法文档</a>，支持两种写法：声明式和脚本式。社区中很多人都在诟病基于 Groovy 语法的 Jenkinsfile 编写方式，有人开发出了支持 YAML 语法编写构建流水线脚本的插件 <a href="https://plugins.jenkins.io/pipeline-as-yaml/">Pipeline As Yaml Plugin for Jenkins</a> （链接含编写语法文档），不过这个插件目前还在孵化期，需要谨慎使用。</li></ul><h2 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h2><ul><li>meld</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><a href="https://locust.io/">Locust</a> 是一款支持分布式的性能压测工具。笔者还开发了一款用于部署Locust压测集群的工具 <a href="https://github.com/ismdeep/load-hive">load-hive</a> ，以及对应的示例项目 <a href="https://github.com/ismdeep/load-hive-demo">load-hive-demo</a></li></ul><h1 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h1><ul><li><a href="https://chromewebstore.google.com/detail/proxy-switchyomega-3-zero/pfnededegaaopdmhkdmcofjmoldfiped">Proxy SwitchyOmega 3 (ZeroOmega)</a></li><li><a href="https://chromewebstore.google.com/detail/octotree-github-code-tree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree - GitHub code tree</a></li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>代码文件长度检查（已 <code>.go</code> 文件为例）<pre><code>$ find ./ -type f -name &quot;*.go&quot; -exec awk &#39;length &gt; 120 &#123; print FILENAME &quot;:&quot; FNR; &#125;&#39; &#123;&#125; + | sed &#39;s|^\./||&#39;</code></pre></li><li>rsync<pre><code>$ rsync -a -r --no-i-r --info=progress2 --info=name0 --no-owner --no-group --no-perms --delete &#39;&lt;Src&gt;&#39; &#39;&lt;Dest&gt;&#39;</code></pre></li><li>进入被调用脚本所在目录<pre><code># Get to workdircd &quot;$(realpath &quot;$(dirname &quot;$(realpath &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot;)&quot;)&quot;</code></pre></li></ul><h1 id="编程字体"><a href="#编程字体" class="headerlink" title="编程字体"></a>编程字体</h1><ul><li><a href="https://www.youtube.com/watch?v=ww2mIn5OsEI">哪个是程序员最爱的编程字体？2百万阅读的帖子选出最帅的七种字体 7 Best Fonts for Programming and Coding</a></li></ul><h1 id="效率工具-1"><a href="#效率工具-1" class="headerlink" title="效率工具"></a>效率工具</h1><h2 id="文件整理方法"><a href="#文件整理方法" class="headerlink" title="文件整理方法"></a>文件整理方法</h2><ul><li><a href="https://www.youtube.com/watch?v=l5n4D8HepWY">【效率】如何在一秒钟内找到文件，够用一辈子的文件整理方法</a></li></ul><h2 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h2><ul><li><a href="https://www.youtube.com/watch?v=OeSBaVM4lFI">如何靠玩「乐高」，每年赚100万美元？</a></li></ul><h1 id="博客站点"><a href="#博客站点" class="headerlink" title="博客站点"></a>博客站点</h1><ul><li><a href="https://qiwsir.github.io/">老齐教室</a>，齐伟</li><li><a href="https://blog.trailofbits.com/">Trail of Bits Blog</a></li><li><a href="http://arthurchiao.art/">ArthurChiao’s Blog</a></li><li><a href="https://wiki.linuxchina.net/">https://wiki.linuxchina.net/</a></li><li><a href="https://www.dboop.com/">https://www.dboop.com/</a></li><li><a href="https://www.huihoo.com/">https://www.huihoo.com/</a></li><li><a href="https://dthompson.us/">https://dthompson.us/</a></li><li><a href="https://www.systeminit.com/blog">https://www.systeminit.com/blog</a></li><li><a href="https://manateelazycat.github.io/">https://manateelazycat.github.io/</a></li></ul><h1 id="有趣的项目"><a href="#有趣的项目" class="headerlink" title="有趣的项目"></a>有趣的项目</h1><ul><li><a href="https://github.com/ading2210/linuxpdf">LinuxPDF</a></li><li><a href="https://github.com/ading2210/doompdf">DoomPDF</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p><a href="https://www.youtube.com/watch?v=QZwgC5Ro-Vs">【没动力？没热情？】《认知觉醒》深度解析：成长你所需要知道的事情</a></p></li><li><p><a href="https://www.infoq.cn/article/FjTpGpRfPdWUyBWTQmd7">消息队列为何经久不衰</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/EcXRnfIrdyLgJyhl0ITprg">2025年，我的第一个建议是别当程序员了！但如果非要当，这些办法可以教会你如何提升自己</a></p></li><li><p><a href="https://www.youtube.com/watch?v=tiN6T1LewmQ">搜索技术，普通人变强的唯一外挂。全套详细宝藏教程~</a></p></li><li><p><a href="https://www.cnblogs.com/Tsingwaa/articles/15945821.html">【中文论文Latex写作】Mac&#x2F;Win 在VS Code 配置 XeLaTeX 和 Git - Tsingwaa - 博客园</a></p></li><li><p><a href="https://www.ilograph.com/blog/posts/diagram-mistakes/">架构图中的 7 个常见错误 |Ilograph 博客 — 7 Common Mistakes in Architecture Diagrams | Ilograph Blog</a></p></li><li><p><a href="https://speakdatascience.com/postgresql-best-practices/">7 Crucial PostgreSQL Best Practices - Speak Data Science</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Resource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerHub 国内加速镜像列表</title>
      <link href="/posts/2025-04-15-docker-registry-mirrors.html"/>
      <url>/posts/2025-04-15-docker-registry-mirrors.html</url>
      
        <content type="html"><![CDATA[<p>Docker Hub 是 Docker 提供的一项服务，用于与您的团队查找和共享容器映像。 它是世界上最大的容器映像存储库，其中包含一系列内容源，包括容器社区开发人员，开源项目和独立软件供应商（ISV），它们在容器中构建和分发其代码。</p><p>但是目前国内已经无法正常访问 Docker Hub 官方仓库了，对此通过镜像站拉取 Docker 镜像是一个不错的方案。以下列出一些优秀的镜像站相关的项目地址：</p><ul><li><a href="https://github.com/dongyubin/DockerHub">https://github.com/dongyubin/DockerHub</a></li><li><a href="https://github.com/kubesre/docker-registry-mirrors">https://github.com/kubesre/docker-registry-mirrors</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【已解决】CentOS系列系统在VirtualBox中Host-Only网络模式下没有默认路由</title>
      <link href="/posts/2025-03-26-fix-no-default-route-on-centos-in-virtualbox.html"/>
      <url>/posts/2025-03-26-fix-no-default-route-on-centos-in-virtualbox.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、现象"><a href="#一、现象" class="headerlink" title="一、现象"></a>一、现象</h1><p>执行 <code>$ ip route</code> 命令，输出中没有默认路由。</p><pre><code>[root@localhost ~]# ip route192.168.56.0/24 dev enp0s3 proto kernel scope link src 192.168.56.102 metric 100 </code></pre><h1 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h1><p>编辑以下文件并重启系统：</p><pre><code>/etc/sysconfig/network-scripts/ifcfg-enp0s3</code></pre><p>参数配置如下（有则修改，没有则添加）：</p><pre><code>BOOTPROTO=noneIPADDR=192.168.56.101PREFIX=24GATEWAY=192.168.56.1</code></pre><h1 id="三、结果"><a href="#三、结果" class="headerlink" title="三、结果"></a>三、结果</h1><pre><code>[root@localhost ~]# ip routedefault via 192.168.56.1 dev enp0s3 proto static metric 100 192.168.56.0/24 dev enp0s3 proto kernel scope link src 192.168.56.101 metric 100 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用 Linux 命令</title>
      <link href="/posts/2025-03-06-essential-linux-commands.html"/>
      <url>/posts/2025-03-06-essential-linux-commands.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>Rsync 同步文件</p><pre><code>$ rsync -a -r --no-i-r --info=progress2 --info=name0 \    --no-owner --no-group --no-perms \    &lt;SOURCE&gt; \    &lt;TARGET&gt;</code></pre></li><li><p>查看 Debian 更新源文件及内容</p><pre><code>$ find \    /etc/apt/sources.list \    /etc/apt/sources.list.d/ \    -type f \    -exec echo -e &quot;\n$ cat &#123;&#125;&quot; \; -exec cat &#123;&#125; \;</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象编程的核心思想：消息传递</title>
      <link href="/posts/2025-01-28-oop-messaging.html"/>
      <url>/posts/2025-01-28-oop-messaging.html</url>
      
        <content type="html"><![CDATA[<p>在面向对象编程（Object-Oriented Programming，OOP）中，我们常常听到封装、继承、多态和抽象被描述为其核心原则。然而，对于真正理解OOP来说，有一个更深层次、更具哲学意味的核心思想常被忽略，那就是<strong>消息传递（Message Passing）</strong>。</p><h1 id="什么是消息传递？"><a href="#什么是消息传递？" class="headerlink" title="什么是消息传递？"></a>什么是消息传递？</h1><p>消息传递指的是对象之间通过发送和接收消息进行交互。每个对象都拥有自己的状态（数据）和行为（方法），而消息传递是对象与对象之间沟通和协作的机制。简而言之，<strong>消息传递是OOP中实现对象之间互动的核心方式</strong>。</p><p>在实际编程中，消息传递的体现通常是通过方法调用实现的。对象A向对象B发送一条消息，请求其执行某个操作（调用方法），对象B接收到这条消息后，根据其内部的逻辑和状态作出相应的反应。</p><h1 id="Alan-Kay-对面向对象的定义"><a href="#Alan-Kay-对面向对象的定义" class="headerlink" title="Alan Kay 对面向对象的定义"></a>Alan Kay 对面向对象的定义</h1><p>Alan Kay，被誉为面向对象编程之父，曾这样定义OOP：</p><blockquote><p>“The big idea is ‘messaging’ — that is, the exchange of data by sending messages to objects. The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.”</p></blockquote><p>翻译：</p><blockquote><p>“核心理念是‘消息传递’——即通过向对象发送消息来交换数据。构建优秀且可扩展系统的关键，更在于设计模块之间如何通信，而不是关注它们的内部属性和行为。”</p></blockquote><h1 id="消息传递的重要性"><a href="#消息传递的重要性" class="headerlink" title="消息传递的重要性"></a>消息传递的重要性</h1><p>为什么说消息传递是面向对象编程的核心？它与OOP的其他原则紧密相连，共同支撑了面向对象的体系：</p><ol><li><strong>封装的基础</strong> 消息传递强调对象通过暴露有限的接口来接收消息，而不是直接让其他对象访问其内部数据。这种方式保证了对象内部实现的封装性，外部对象只需要知道如何发送消息，而不需要了解消息接收者的具体实现细节。</li><li><strong>多态性的体现</strong> 多态性在消息传递中尤为关键。当多个对象能够响应相同的消息（方法调用）时，它们可以根据自己的类型和特性作出不同的反应。这种机制使得对象之间的交互更加灵活，支持动态行为的扩展。</li><li><strong>松耦合设计</strong> 消息传递实现了对象之间的松耦合。一个对象不需要知道另一个对象的内部结构或实现细节，只需要知道如何向其发送消息。这样的设计增强了系统的模块化和可维护性。</li></ol><h1 id="消息传递的实际应用"><a href="#消息传递的实际应用" class="headerlink" title="消息传递的实际应用"></a>消息传递的实际应用</h1><p>以下是一个简单的例子，展示了消息传递的基本思想：</p><pre><code>class Car:    def start_engine(self):        print(&quot;The engine is now running.&quot;)class Driver:    def start_car(self, car):        car.start_engine()  # 发送消息给 Car 对象# 使用示例car = Car()driver = Driver()driver.start_car(car)</code></pre><p>在这个例子中：</p><ul><li><code>Driver</code> 对象通过调用 <code>start_car</code> 方法向 <code>Car</code> 对象发送一条消息（请求启动引擎）。</li><li><code>Car</code> 对象接收到消息后，执行 <code>start_engine</code> 方法，完成引擎的启动。</li></ul><p>消息传递的核心思想在这里清晰可见：<strong>对象之间并不直接操作对方的内部状态，而是通过发送和接收消息实现交互。</strong></p><h1 id="消息传递与现实世界的类比"><a href="#消息传递与现实世界的类比" class="headerlink" title="消息传递与现实世界的类比"></a>消息传递与现实世界的类比</h1><p>为了更好地理解消息传递，可以将其与现实生活中的通信进行类比。例如：</p><ul><li>当你向朋友发短信邀请他们共进晚餐时，你发送了一条消息。朋友可以根据自己的状态（是否有空、是否感兴趣）来决定是否接受邀请。这就像对象接收到消息后，依据自身逻辑决定执行什么操作。</li><li>在公司中，一个部门（对象A）向另一个部门（对象B）发送邮件请求某项资源。部门B根据邮件内容和当前资源状况作出回应。这种协作完全依赖消息的传递，而不是直接干涉对方的日常运作。</li></ul><h1 id="消息传递与面向对象编程的未来"><a href="#消息传递与面向对象编程的未来" class="headerlink" title="消息传递与面向对象编程的未来"></a>消息传递与面向对象编程的未来</h1><p>随着软件复杂度的提高，消息传递的思想正在以更现代的形式演化。例如：</p><ul><li><strong>微服务架构</strong>：微服务之间通过消息队列（如 RabbitMQ、Kafka）或 HTTP 请求传递消息，彼此独立运行，体现了OOP的消息传递核心思想。</li><li><strong>Actor 模型</strong>：在并发编程中，Actor 模型强调通过消息传递进行状态共享和任务分发，例如 Erlang 和 Akka。</li><li><strong>事件驱动架构</strong>：系统通过发布和订阅事件（消息）实现松耦合的模块交互，如 JavaScript 的事件循环机制或消息总线架构。</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>面向对象编程的核心不仅仅是代码中的类与对象的设计，更是一种关于对象如何交互的哲学。<strong>消息传递</strong>作为OOP的灵魂，赋予了对象自足性和协作能力，使得复杂系统能够被优雅地设计和扩展。</p><p>当我们在编写面向对象的代码时，不妨多思考对象之间如何通过消息传递有效地协作，而不仅仅是关注单个对象的实现细节。正是这种思想，让OOP成为现代软件开发的基石。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发：不仅仅是写几行代码</title>
      <link href="/posts/2025-01-22-beyond-code-the-essential-pillars-of-software-development.html"/>
      <url>/posts/2025-01-22-beyond-code-the-essential-pillars-of-software-development.html</url>
      
        <content type="html"><![CDATA[<p>当人们提到软件开发时，许多初学者可能会将其简单地理解为“写代码”。实际上，这只是整个软件开发流程中的冰山一角。随着项目复杂度的增加和团队协作的深入，我们会发现，软件开发是一个涵盖多层次、多方面的工程化过程。它不仅仅是代码的堆砌，还包括系统架构设计、文档撰写、测试保障、用户体验优化等多个环节。只有全面关注这些关键点，才能真正交付高质量的软件产品。</p><h1 id="系统架构：软件开发的地基"><a href="#系统架构：软件开发的地基" class="headerlink" title="系统架构：软件开发的地基"></a>系统架构：软件开发的地基</h1><p>系统架构是软件开发的顶层设计，它决定了系统的模块划分、数据流动和技术选型。好的架构能够帮助团队应对复杂性、减少技术债务并促进团队协作。</p><p>系统架构的核心价值在于：</p><ol><li><strong>应对复杂性</strong><br>在大型项目中，架构帮助开发团队明确每个模块的功能边界，确保模块间的独立性和稳定性。例如，微服务架构通过模块化设计使系统更具灵活性和扩展性。</li><li><strong>降低技术债务</strong><br>早期架构规划不到位会导致后续代码频繁返工，积累大量技术债务。而一个良好的架构可以减少开发中的“临时补救”，降低维护成本。</li><li><strong>支持团队协作</strong><br>架构为团队提供全局视图，让每位成员明确职责分工，减少沟通障碍，提升效率。</li></ol><h1 id="文档：连接代码与团队的桥梁"><a href="#文档：连接代码与团队的桥梁" class="headerlink" title="文档：连接代码与团队的桥梁"></a>文档：连接代码与团队的桥梁</h1><p>文档是软件项目中至关重要的部分，它记录了需求、设计和实现细节，是团队协作和后续维护的关键。</p><p>文档的种类与作用：</p><ol><li><strong>需求文档</strong><br>明确项目目标、用户需求和功能列表，为开发提供方向。</li><li><strong>架构文档</strong><br>描述系统的模块设计、数据流和技术决策，便于新成员快速上手。</li><li><strong>技术文档</strong><br>记录接口规范、数据库设计和实现逻辑，为后续开发和测试提供依据。</li><li><strong>测试文档</strong><br>包括测试计划、测试用例和测试报告，确保系统的功能和性能符合预期。</li></ol><p>有了清晰的文档，团队协作将更加顺畅，新成员也能快速融入项目，减少“摸索”的时间。</p><h1 id="用户手册：将技术转化为用户价值"><a href="#用户手册：将技术转化为用户价值" class="headerlink" title="用户手册：将技术转化为用户价值"></a>用户手册：将技术转化为用户价值</h1><p>软件最终是为用户服务的，而用户手册是用户了解系统、学习使用的第一步。一个好的用户手册能够有效降低学习成本，提升用户满意度。</p><p>优秀用户手册的特性：</p><ol><li><strong>清晰易懂</strong><br>避免技术术语，用通俗的语言帮助用户理解功能。</li><li><strong>结构合理</strong><br>提供直观的目录和索引，让用户能快速找到所需内容。</li><li><strong>图文并茂</strong><br>通过示意图、流程图或视频教程，帮助用户更好地理解复杂操作。</li><li><strong>持续更新</strong><br>软件更新后，手册也需要同步调整，避免信息过时。</li></ol><p>用户手册不仅是用户的指南，也是用户体验优化的重要一环。</p><h1 id="测试：软件质量的守门人"><a href="#测试：软件质量的守门人" class="headerlink" title="测试：软件质量的守门人"></a>测试：软件质量的守门人</h1><p>测试是确保软件质量的关键步骤，它贯穿开发生命周期的各个阶段，从开发初期的单元测试到上线前的回归测试，都是必不可少的环节。</p><p>测试的多层次保障：</p><ol><li><strong>单元测试</strong><br>验证每个模块的核心功能，确保基础逻辑的正确性。</li><li><strong>集成测试</strong><br>检查模块之间的交互是否正确，避免“单块正确、整体出错”的问题。</li><li><strong>性能测试</strong><br>模拟高负载场景，评估系统的响应速度和稳定性。</li><li><strong>回归测试</strong><br>确保新功能不会影响已有功能，保证系统整体质量。</li></ol><p>通过使用自动化测试工具（如 Selenium、JUnit 等），可以大大提高测试效率，减少人为失误。</p><h1 id="持续集成与持续交付（CI-CD）：加速开发与部署"><a href="#持续集成与持续交付（CI-CD）：加速开发与部署" class="headerlink" title="持续集成与持续交付（CI&#x2F;CD）：加速开发与部署"></a>持续集成与持续交付（CI&#x2F;CD）：加速开发与部署</h1><p>在快速迭代的开发模式下，持续集成（CI）与持续交付（CD）是提高效率和质量的重要手段。</p><p>CI&#x2F;CD 的主要优势：</p><ol><li><strong>自动化测试与构建</strong><br>每次代码提交后，CI 工具会自动运行测试，及时发现问题。</li><li><strong>快速交付</strong><br>通过自动化部署流水线，将新功能快速推送到测试或生产环境。</li><li><strong>增强稳定性</strong><br>每个交付阶段都有质量保障，减少发布风险。</li><li><strong>缩短反馈周期</strong><br>用户的反馈能更快传回团队，从而调整产品方向。</li></ol><h1 id="代码审查：团队协作的技术保障"><a href="#代码审查：团队协作的技术保障" class="headerlink" title="代码审查：团队协作的技术保障"></a>代码审查：团队协作的技术保障</h1><p>代码审查是团队文化的一部分，也是提高代码质量的有效手段。通过彼此审查代码，团队成员可以发现潜在问题并共享知识。</p><p>代码审查的好处：</p><ol><li><strong>提高代码质量</strong><br>审查过程可以发现逻辑漏洞、性能问题以及不规范的实现。</li><li><strong>促进知识共享</strong><br>开发者可以通过审查学习到团队的最佳实践和设计思路。</li><li><strong>减少技术债务</strong><br>及时审查可以防止低质量代码进入代码库。</li></ol><h1 id="安全性：贯穿开发全程的核心"><a href="#安全性：贯穿开发全程的核心" class="headerlink" title="安全性：贯穿开发全程的核心"></a>安全性：贯穿开发全程的核心</h1><p>安全性是软件开发中不能忽视的环节。数据泄露或系统被攻破可能会对企业声誉和用户信任造成严重影响。</p><p>安全开发的实践：</p><ol><li><strong>输入验证</strong><br>防止 SQL 注入和 XSS 攻击。</li><li><strong>权限控制</strong><br>确保只有授权用户才能访问特定功能和数据。</li><li><strong>数据加密</strong><br>对敏感数据进行加密存储和传输。</li><li><strong>依赖管理</strong><br>定期更新第三方库，避免已知漏洞。</li><li><strong>安全测试</strong><br>使用工具进行渗透测试和漏洞扫描，提前发现安全问题。</li></ol><h1 id="项目管理：平衡时间、资源与需求"><a href="#项目管理：平衡时间、资源与需求" class="headerlink" title="项目管理：平衡时间、资源与需求"></a>项目管理：平衡时间、资源与需求</h1><p>一个成功的项目离不开有效的项目管理，它不仅要确保项目按时交付，还要平衡资源与需求之间的矛盾。</p><p>项目管理的关键方法：</p><ol><li><strong>敏捷开发</strong><br>通过短迭代周期和频繁交付，让团队快速响应变化。</li><li><strong>合理估算</strong><br>在详细拆解任务后，进行准确的时间和资源估算。</li><li><strong>透明沟通</strong><br>定期召开站会或周会，保持团队同步。</li><li><strong>风险管理</strong><br>提前识别可能的风险，并制定应对策略。</li></ol><h1 id="知识沉淀：为未来铺路"><a href="#知识沉淀：为未来铺路" class="headerlink" title="知识沉淀：为未来铺路"></a>知识沉淀：为未来铺路</h1><p>开发完成并不意味着项目的结束。通过知识沉淀，团队可以为未来的维护和扩展提供支持。</p><p>知识沉淀的方法：</p><ol><li><strong>完善文档体系</strong><br>涵盖需求、设计、测试等各阶段的文档。</li><li><strong>技术博客或 Wiki</strong><br>记录开发中的经验和最佳实践。</li><li><strong>定期复盘总结</strong><br>项目结束后总结经验和教训，为下一个项目提供参考。</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>软件开发是一项复杂的工程，涵盖了架构设计、文档编写、测试保障、用户体验、安全管理等多个环节。它要求开发者不仅专注于代码实现，还需要具备全面的工程化思维。</p><p>唯有在每个环节上追求卓越，我们才能打造出高质量的软件产品，为用户和团队带来长期的价值。记住：代码只是开始，全面的规划和细致的执行，才是软件成功的关键。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 10 LTSC 2019 密钥激活</title>
      <link href="/posts/2024-09-25-windows-10-lstc-2019-kms.html"/>
      <url>/posts/2024-09-25-windows-10-lstc-2019-kms.html</url>
      
        <content type="html"><![CDATA[<p>以管理员身份运行 “命令提示符” 并执行以下命令：</p><pre><code>slmgr -ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462Dslmgr -skms kms.03k.orgslmgr -atoslmgr -dlv</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】什么是 DevOps 工程师以及 DevOps 工程师做什么？</title>
      <link href="/posts/2024-09-18-what-is-a-devops-engineer.html"/>
      <url>/posts/2024-09-18-what-is-a-devops-engineer.html</url>
      
        <content type="html"><![CDATA[<p>DevOps 工程师优化组织的软件交付流程以实现协作和创新。继续阅读以了解有关 DevOps 工程师的工作以及他们依赖的技能的更多信息。</p><h1 id="什么是-DevOps-工程师？"><a href="#什么是-DevOps-工程师？" class="headerlink" title="什么是 DevOps 工程师？"></a>什么是 DevOps 工程师？</h1><p>DevOps 工程师是管理组织的开发人员运营 (DevOps) 的 IT 专业人员，其中包括组织用于创建和管理软件的所有实践和工具。</p><p>DevOps 工程师在弥合传统上孤立的部门之间的差距方面发挥着至关重要的作用，以实现更高的一致性和有效的协作。它们通常充当开发团队和 IT 运营团队之间的纽带，帮助统一、优化和自动化软件开发生命周期中的流程。由于团队有不同的技能和目标，DevOps 工程师的工作是平衡所有团队的需求和目标，并找到使每个人都能做到最好的解决方案。</p><h1 id="DevOps-工程师做什么的？"><a href="#DevOps-工程师做什么的？" class="headerlink" title="DevOps 工程师做什么的？"></a>DevOps 工程师做什么的？</h1><p>DevOps 工程师的角色可能因组织而异，但 DevOps 工程师的职责通常涉及使用各种 DevOps 工具和策略来配置和管理基础设施、自动化流程、执行系统管理和管理安全性。 DevOps 工程师的其他职责可能包括编码、自动化、安全和基础设施管理。</p><h1 id="DevOps-工程师的常见职责包括："><a href="#DevOps-工程师的常见职责包括：" class="headerlink" title="DevOps 工程师的常见职责包括："></a>DevOps 工程师的常见职责包括：</h1><ul><li>沟通与协作：DevOps 工程师通常充当多个团队（包括开发和运营团队）之间的主要协作者。 DevOps 工程师的职责是确保每个团队传达快速、无缝地实施应用程序更改所需的内容，而不会产生可靠性和安全问题。</li><li>基础设施管理：DevOps 工程师专注于配置和管理系统管理以及部署和维护托管应用程序的服务器。他们还维护存储和网络资源，如物理服务器、存储设备、交换机和虚拟化软件。在混合设置中，DevOps 工程师还可以一起管理这些本地组件和基于云的组件的虚拟实例。</li><li>自动化：大多数 DevOps 工程师对自动化以及如何将自动化作为持续集成&#x2F;持续交付 (CI&#x2F;CD) 工具的一部分实施有深入的了解。 DevOps 工程师通常负责为其开发和 IT 运营团队开发自动化流程或修改现有自动化流程。</li><li>数据管理：除了为其部门构建基础设施和自动化流程之外，DevOps 工程师还负责这些结构中的实际内容和数据。 DevOps 工程师设计数据收集、存储和使用的流程。他们还管理它的访问方式以及谁有权访问它。</li><li>持续集成：DevOps 工程师对其组织的软件执行持续集成，其中包括确保定期构建、测试和验证新的代码更改，然后将其合并到 GitHub 等共享存储库以供组织的其他部分使用。此过程确保新代码在持续交付阶段发送到生产之前，通过单元和集成测试自动测试错误。</li><li>持续交付：DevOps 工程师还负责持续交付，这是一个自动发布经过测试和验证的生产代码的过程。这些经过验证和测试的代码通常会发送到一个存储库，所有开发和运营团队都可以访问该存储库，以便相对轻松地将应用程序部署到生产环境。</li><li>持续部署：DevOps 工程师还负责 CI&#x2F;CD 管道的最后阶段（称为持续部署）。此过程是持续交付过程的扩展，其中经过验证的代码会自动直接进入应用程序生产，而不是进入存储库。如果清除了所有错误和安全漏洞测试，此过程可以让新代码在几分钟内向公众发布。</li><li>质量保证：DevOps 工程师可能负责监督质量保证 (QA) 团队，以确保新代码没有缺陷。 QA 团队主要专注于冒烟测试、回归测试和集成测试。冒烟测试可确保应用程序代码不会立即引起问题，而回归和集成测试可确保新代码不会破坏现有功能或与其他现有功能发生冲突。</li><li>监控和日志记录：DevOps 工程师可能负责监控和记录部署到公众的代码每次迭代的性能。监控和记录的信息为 CI&#x2F;CD 流程创建即时反馈，以通知创建更新的迭代和应用程序的改进。</li><li>安全性：DevOps 工程师必须将安全性纳入其组织的 IT 生命周期中。实施安全措施的实践通常称为开发安全操作，重点是查找可能影响应用程序用户和组织的软件漏洞。优秀的 DevOps 工程师会找到在所有开发阶段和交付过程中实现安全自动化的方法。</li></ul><h1 id="成为-DevOps-工程师需要哪些技能？"><a href="#成为-DevOps-工程师需要哪些技能？" class="headerlink" title="成为 DevOps 工程师需要哪些技能？"></a>成为 DevOps 工程师需要哪些技能？</h1><p>大多数 DevOps 工程师都拥有强大的软件开发或 IT 运营背景，以及来自其他学科的其他技术技能和软技能。这些技能可能包括编程语言知识、自动化工具熟练程度、人际交往能力和分析问题解决能力。</p><h1 id="推荐给-DevOps-工程师的技能包括："><a href="#推荐给-DevOps-工程师的技能包括：" class="headerlink" title="推荐给 DevOps 工程师的技能包括："></a>推荐给 DevOps 工程师的技能包括：</h1><h2 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h2><ul><li>沟通和协作：DevOps 工程师最重要的技能之一是了解如何确保所有部门之间一致的沟通和协作。他们的人际交往能力帮助他们引导生产进入稳定、自动化的流程，并具有强大的反馈循环。</li><li>人际关系和管理技能：优秀的 DevOps 工程师知道如何在所有团队之间委派任务，以实现高效的生产和绩效。他们提供一致且清晰的反馈，帮助开发人员更有效、更高效地生成代码。他们还利用对不同学科和测试方法的广泛知识来担任团队的教练。</li><li>分析和解决问题的能力：DevOps 工程师必须知道如何解决出现的问题。由于他们横跨开发和运营团队的流程，因此他们需要知道如何实时解决安全漏洞等问题，并且必须能够找到自动执行重复性日常任务的方法，以便所有部门及时生产。</li></ul><h2 id="技术技能"><a href="#技术技能" class="headerlink" title="技术技能"></a>技术技能</h2><ul><li>编程语言：DevOps 工程师通常精通至少一种或多种编程语言来进行编码和脚本编写，例如 PHP、Java、Ruby、Python、C++、PowerShell 或 Bash。 DevOps 工程师应该知道如何使用这些编程语言编写自动化脚本，但他们也应该知道如何在流程中实施敏捷开发实践（例如：代码审查和源代码控制）。</li><li>自动化工具：DevOps 工程师应该具有维护自动化测试套件或使用 GitHub Actions 等自动化工具来帮助自动化 CI&#x2F;CD 管道中的流程工作流的经验。尽管某些组织可能还拥有自动化工程师来满足其自动化需求，但知道如何与自动化专家合作的 DevOps 工程师可以进一步帮助加强自动化流程。</li><li>云计算平台：DevOps 工程师通常具有使用 Microsoft Azure、Amazon Web Services 和 Google Cloud Platform 等云计算平台的经验。他们还应该知道如何平衡和自动化在本地或混合工作模型情况下完成的工作流程。</li><li>容器化：DevOps 工程师通常具有使用 Docker 和 Kubernetes 等容器化服务的经验，可以将应用程序代码及其运行时环境捆绑到同一个映像中。这有助于减少传统配置管理工具的必要性，因为传统配置管理工具会降低整体生产和效率。</li><li>系统架构和配置：DevOps 工程师应该了解如何设计、配置和管理系统架构和基础设施，包括基于云的和本地结构。 DevOps 工程师还应该了解基础设施即代码的知识，这是一种将 DevOps 软件开发的最佳实践应用到云基础设施管理的 IT 管理流程。</li></ul><h1 id="DevOps-工程师使用哪些工具？"><a href="#DevOps-工程师使用哪些工具？" class="headerlink" title="DevOps 工程师使用哪些工具？"></a>DevOps 工程师使用哪些工具？</h1><p>DevOps 工程师使用来自所有学科和方法论的各种工具来帮助维护开发和运营团队之间一致的工作流程。这些工具帮助他们解决出现的问题，并通过简单的自动化帮助防止某些问题。</p><p>DevOps 工程师工具的类型：</p><ul><li>配置管理：大多数 DevOps 工程师都有使用 Chef 或 Puppet 等配置管理工具的经验，可以帮助他们自动执行系统管理任务，例如应用安全补丁或部署新系统。</li><li>CI&#x2F;CD：如前所述，CI&#x2F;CD 涉及持续集成、持续交付和持续部署管道。许多 DevOps 工程师都有在 GitHub Actions 等项目中工作的经验，可以帮助他们在 CI&#x2F;CD 管道中自动化构建、测试和部署应用程序软件的流程。</li><li>基础设施自动化和监控：DevOps 工程师使用各种自动化工具进行基础设施配置、系统管理和基础设施监控。 DevOps 工程师用于这些流程的一些工具包括 Terraform、Pulumi 和 Vagrant。</li><li>容器编排：DevOps 工程师通常必须在整个组织中打包和交付应用程序代码。它们通常在 Docker、Podman、Buildah 和 Kubernetes 等程序中工作，以容器化和传输这些代码。每种工具在可扩展性、安全性以及部署或维护的简易性方面都有所不同，因此 DevOps 工程师通常会熟悉多个容器编排工具，并根据项目的需求使用不同的工具。</li></ul><h1 id="成为一名-DevOps-工程师"><a href="#成为一名-DevOps-工程师" class="headerlink" title="成为一名 DevOps 工程师"></a>成为一名 DevOps 工程师</h1><p>组织依靠 DevOps 工程师在整个应用程序开发生命周期中提供指导和领导。尽管许多 DevOps 工程师的职业生涯是从软件开发人员或 IT 管理专业人员开始的，但他们通常也会在此过程中从其他类似学科中学习新的技能、方法和策略。因此，DevOps 工程师通常是组织中经验最丰富的专业人士，DevOps 工程师可能需要很多年才能获得成功所需的所有技能。</p><p>有抱负的 DevOps 工程师可以在线访问资源，学习如何成为 DevOps 工程师或探索 DevOps 工程师的道路。有兴趣将 DevOps 工程师引入其团队的组织还可以找到有关如何加入 DevOps 工程师的资源。</p><p>原文：<a href="https://github.com/resources/articles/devops/what-is-a-devops-engineer">https://github.com/resources/articles/devops/what-is-a-devops-engineer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Ubuntu 上安装 Docker CE</title>
      <link href="/posts/2024-07-31-install-docker-ce-on-ubuntu.html"/>
      <url>/posts/2024-07-31-install-docker-ce-on-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>本文主要以 Ubuntu 20.04 为例讲述如何在 Debian&#x2F;Ubuntu 系列 Linux 发行版上通过上游官方仓库安装 Docker CE，其他发行版的安装方式也类似，不同地方主要在源地址配置中。</p><h1 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h1><h2 id="2-1-准备-GPG-证书"><a href="#2-1-准备-GPG-证书" class="headerlink" title="2.1 准备 GPG 证书"></a>2.1 准备 GPG 证书</h2><p>在 <code>root</code> 用户下执行以下命令写入仓库 GPG 证书。</p><pre><code>$ sudo mkdir -p /etc/apt/keyrings/ &amp;&amp; \  curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/gpg | \  sudo gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg &amp;&amp; \  echo &quot;OK&quot;</code></pre><h2 id="2-2-写入更新源"><a href="#2-2-写入更新源" class="headerlink" title="2.2 写入更新源"></a>2.2 写入更新源</h2><p>在 <code>/etc/apt/sources.list.d/docker.list</code> 文件中写入以下内容：</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu focal stable</code></pre><p>其中：</p><ol><li><p><code>https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu</code> 为仓库地址，根据所在地区可以选取不同的地址。</p><p>以下是一些常用镜像仓库地址：</p><ul><li><code>https://download.docker.com/linux/ubuntu</code></li><li><code>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu</code></li><li><code>https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu</code></li><li><code>https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu</code></li><li><code>https://mirror.sjtu.edu.cn/docker-ce/linux/ubuntu</code></li><li><code>https://mirrors.huaweicloud.com/docker-ce/linux/ubuntu</code></li></ul></li><li><p><code>focal</code> 为 Ubuntu 发行版代号。</p><p>以下是 Ubuntu 主要发行代号和版本号对应关系：</p><ul><li><code>focal</code>: Ubuntu 20.04</li><li><code>jammy</code>: Ubuntu 22.04</li><li><code>mantic</code>: Ubuntu 23.10</li><li><code>noble</code>: Ubuntu 24.04</li></ul></li></ol><h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>在GPG证书和更新源配置都准备完成之后，执行以下命令更新仓库索引并安装 <code>docker-ce</code> 软件包：</p><pre><code>$ sudo apt update$ sudo apt install -y docker-ce</code></pre><h1 id="三、检查"><a href="#三、检查" class="headerlink" title="三、检查"></a>三、检查</h1><p>通过以下命令查看安装的 Docker CE 版本号：</p><pre><code>$ sudo docker version</code></pre><p>示例：</p><pre><code>root@Lemuria:~# docker versionClient: Docker Engine - Community Version:           27.1.1 API version:       1.46 Go version:        go1.21.12 Git commit:        6312585 Built:             Tue Jul 23 19:56:56 2024 OS/Arch:           linux/amd64 Context:           defaultServer: Docker Engine - Community Engine:  Version:          27.1.1  API version:      1.46 (minimum version 1.24)  Go version:       go1.21.12  Git commit:       cc13f95  Built:            Tue Jul 23 19:56:56 2024  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.7.19  GitCommit:        2bf793ef6dc9a18e00cb12efb64355c2c9d5eb41 runc:  Version:          1.7.19  GitCommit:        v1.1.13-0-g58aa920 docker-init:  Version:          0.19.0  GitCommit:        de40ad0root@Lemuria:~#</code></pre><h1 id="四、安装-docker-compose"><a href="#四、安装-docker-compose" class="headerlink" title="四、安装 docker-compose"></a>四、安装 docker-compose</h1><p>通过以下命令将 Docker CE 自带的 docker-compose 插件安装至系统目录。</p><pre><code>$ sudo cp /usr/libexec/docker/cli-plugins/docker-compose /usr/bin/docker-compose</code></pre><p>安装完成后通过以下命令查看版本号：</p><pre><code>$ docker-compose version</code></pre><p>示例：</p><pre><code>root@Lemuria:~# docker-compose versionDocker Compose version v2.29.1</code></pre><h1 id="附录一、其他发行版更新配置源"><a href="#附录一、其他发行版更新配置源" class="headerlink" title="附录一、其他发行版更新配置源"></a>附录一、其他发行版更新配置源</h1><p>Debian 10</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable</code></pre><p>Debian 11</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian bullseye stable</code></pre><p>Debian 12</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian bookworm stable</code></pre><p>deepin v20, deepin v25, UOS Desktop V20</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian buster stable</code></pre><p>Ubuntu 24.04</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu noble stable</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Remove thinclient_drives folder from xrdp</title>
      <link href="/posts/2024-07-22-remove-thinclient-drives-folder-from-xrdp.html"/>
      <url>/posts/2024-07-22-remove-thinclient-drives-folder-from-xrdp.html</url>
      
        <content type="html"><![CDATA[<p>To remove the <code>thinclient_drives</code> folder from XRDP, you need to modify the XRDP configuration to prevent it from creating and using this directory. Here’s a step-by-step guide on how to do it:</p><ol><li><p>Open the XRDP configuration file</p><pre><code>$ sudo vim /etc/xrdp/xrdp.ini</code></pre></li><li><p>Change <code>allow_channels</code> value</p><pre><code>allow_channels=false</code></pre></li><li><p>Restart xrdp</p><pre><code>$ sudo systemctl restart xrdp</code></pre></li></ol><p>By following these steps, the <code>thinclient_drives</code> folder should no longer be created or used by XRDP.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】开源学习好帮手：最棒的50个开源博客</title>
      <link href="/posts/2024-07-14-10-50-best-opensource-blog.html"/>
      <url>/posts/2024-07-14-10-50-best-opensource-blog.html</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://www.oschina.net/news/10472/50-Best-opensource-blog">https://www.oschina.net/news/10472/50-Best-opensource-blog</a></p><p>开源软件由庞大的社区提供支持，这个充满活力的社区造就了一批一流的博客。它们涵盖了从开源新闻，到最新发布的教程和黑客技巧的各个方面。</p><p>我们精选出这些博客，因为他们精通相关专业，不仅定期更新，而且还易于浏览，同时又非常实用。去看一看吧，您肯定会学好很多新东西的。</p><ol><li><strong><a href="http://www.rationalplanet.com/">Alec Notes</a>:</strong> 一个专注于 Fedora Linux 的简单博客。Alec 是一名程序员，他精通 PHP，mySQL 和 Javascript，同时还是一名 Fedora Linux 发烧友。他没解决一个工作上遇到的问题，就会在他的博客上发布一篇解决方案。他还关注新的软件开发。</li><li><strong><a href="http://linuxforpro.blogspot.com/">All you will need on linux</a>:</strong> 这是一个 Linux 技巧博客。文章都是有关于作者所遇的具体问题的解决方法。</li><li><strong><a href="http://android-developers.blogspot.com/index.html">Android Developers</a>:</strong> 这个博客为 Android 编程人员提供了大量资源。里面包含了最新的 Android 新闻和更新提示。</li><li><strong><a href="http://biodegradablegeek.com/">Biodegradable Geek</a>:</strong> 这是一个开源编程爱好者的个人博客。</li><li><strong><a href="http://brightedges.blogspot.com/">Bright Edges</a>:</strong> Bright Edges 是一名工程系的学生，这是他的个人博客，其中包含了一些 Linux&#x2F;GNU 技巧。</li><li><strong><a href="http://bsdpunk.blogspot.com/">BSD Punk</a>:</strong> 这是 Tennessee 网络顾问的个人博客，该网站经常发布一些有趣的 Linux 和其他开源语言的技巧和提示。他同时还发布一些他感兴趣的新闻。</li><li><strong><a href="http://www.clububuntu.com/">Club Ubuntu</a>:</strong> Club Ubuntu 提供了大量 Ubuntu 教程和信息。</li><li><strong><a href="http://www.dckap.com/blog/">Dckap</a>:</strong> Dckap 是一个技术服务公司，它同时还维护着一个关于开源和商业的博客。</li><li><strong><a href="http://www.duniadistro.net/">Dedicated to Providing Quality Information on Linux and Distro</a>:</strong> 就像它的名字一样，这个博客将提供有关 Linux 及其发行版的相关资讯。信息。</li><li><strong><a href="http://developerstation.blogspot.com/">Developer Station</a>:</strong> 由计算机科学专业毕业生 Rahul Kavi 撰写，Developer Station 包含了很多关于开源软件的技巧和提示，大部分为 Python 和 Java 相关。</li><li><strong><a href="http://www.development-cycle.com/">Development Cycle</a>:</strong> Development Cycle 由 Australia 的一名 Linux 管理员维护。他一般发布技巧和科技新闻。</li><li><strong><a href="http://www.earthinfo.org/">Earth Info</a>:</strong> Earth Info 是一个关于 PHP 和 MySQL 教程，技巧，新闻的博客。</li><li><strong><a href="http://foxbunny.tumblr.com/">Fox Bunny’s Journal</a>:</strong> 由 Linux 程序员和游戏设计师 Branko Vukelic 撰写，Fox Bunny’s Journal 包含了很棒的技巧和教程。</li><li><strong><a href="http://freeware4review.blogspot.com/">Freeware 4 Review</a>:</strong> 就像它说的名字，Freeware 4 Review 对免费软件进行评论。</li><li><strong><a href="http://goinggnu.wordpress.com/">Going GNU</a>:</strong> Going GNU 由 Shrinivasan 撰写，他是一名 Linux 程序员，这个博客是他的每日体验。</li><li><strong><a href="http://www.howtoforge.com/">How to Forge</a>:</strong> 这个博客提供 Linux 技术性教程。秉承真正开源内涵，任何人都可以参加贡献并使用使用它们。</li><li><strong><a href="http://blog.ibeentoubuntu.com/">I’ Been to Ubuntu</a>:</strong> 这个博客提供 Ubuntu 和 Debian 的文字和视频教程。</li><li><strong><a href="http://www.internetling.com/">Internetling</a>:</strong> Internetling 是一个半个人的 Linux 新闻博客，提供 Linux 相关资讯。</li><li><strong><a href="http://javaforyou.wordpress.com/">Java PitStop</a>:</strong> Java PitStop 包含了非常实用的 Java-specific 新闻和信息。</li><li><strong><a href="http://larrythefreesoftwareguy.wordpress.com/about/">Larry the Free Software Guy</a>:</strong> Larry 是 Open Source and Free Software Reporter 的编辑和发布者。在他的博客里，他主要发布开源软件运动的相关新闻。</li><li><strong><a href="http://www.thelazysysadmin.net/">The Lazy Sys Admin</a>:</strong> Lazy Sys Admin 是一个关于 Linux 技巧和 hack 的博客，同时还包含一些博主所感兴趣的新闻事件。</li><li><strong><a href="https://indiaprab.blogspot.com/">LiFunTech</a>:</strong> LiFunTech 致力于查找并链接开源更新和应用程序。</li><li><strong><a href="http://linuxhug.blogspot.com/">Linux Hug</a>:</strong> 由 Janith Bandara 撰写，Linux Hug 提供 Linux 技巧，教程和新闻。</li><li><strong><a href="http://www.linuxinsider.com/">Linux Insider</a>:</strong> 该博客由 ECT News Network 释出，它是最大的电子商务和科技新闻发布商之一。由数个人维护并发布有关于 Linux 社区的新闻，通常政治类和商业类要多于科技类。</li><li><strong><a href="http://www.linuxinsight.com/">Linux Insight</a>:</strong> Linux Insight 提供 Linux 科技性技巧和教程。</li><li><strong><a href="http://www.linux-masters.com/">Linux Masters Blog</a>:</strong> Linux Masters 专注于 Linux 和 Linux 发行版教程，大部分是 Ubuntu。</li><li><strong><a href="http://www.linuxtoday.com/">Linux Today</a>:</strong> Linux Today 是一个热衷于开源新闻的博客。 is a zealously pro-open source news blog.</li><li><strong><a href="http://www.linux.com/news/featured-blogs">Linux.com Blog</a>:</strong> 由 Linux Foundation 维护的非盈利博客，致力于促进 Linux 的发展。有数位作者发布 Linux 新闻。, a non-profit dedicated to fostering the growth of Linux. The foundation has several writers who blog about Linux news.</li><li><strong><a href="http://blog.adityapatawari.com/">Looking for the Source Code of Life</a>:</strong> 由程序序员 Aditya Patawari 开设，Looking for the Source Code of Life 提供 Linux 及 Linux 发行版的技巧和教程。</li><li><strong><a href="http://www.cyberciti.biz/">nixCraft</a>:</strong> 由 Unix 系统管理员 Vivek Gite 撰写，nixCraft 提供丰富的 Linux 技巧，教程和新闻资讯。</li><li><strong><a href="http://www.linux-magazine.com/Online/Blogs/Off-the-Beat-Bruce-Byfield-s-Blog">Off the Beat</a>:</strong> Bruce Byfield 为 Linux Magazine 撰文。他的博客主要包含开源社区新闻。</li><li><strong><a href="http://omgubuntu.co.uk/">OMG! Ubuntu!</a>:</strong> OMG! Ubuntu! 发布与 Ubuntu 相关的新闻，文章，访谈和技巧。</li><li><strong><a href="http://bizcoach.blogspot.com/">Open Business</a>:</strong> Open Business 专注于开源技术为人类商业活动造成的影响的相关新闻。</li><li><strong><a href="http://news.cnet.com/openroad/">The Open Road</a>:</strong> 这个博客是 CNET 的一部分，由 Matt Asay 维护，他是一名领先的开源商务战略家。他以易于理解的方式，全面探讨开源战略和政治。</li><li><strong><a href="http://www.businessreviewonline.com/os/">Open Source Business Review</a>:</strong> Open Source Business Review 包含了开源商业社区的相关新闻。</li><li><strong><a href="http://www.businessreviewonline.com/os/">Open Source Development</a>:</strong> Open Source Development 关注开源技术的最新更新。它强调电子商务的创新。</li><li><strong><a href="http://ordinarytux.wordpress.com/">Ordinary Tux</a>:</strong> Ordinary Tux 发布 Linux，Android 和其他开源技术的相关教程和技巧提示。</li><li><strong><a href="http://davidsiegel.org/">The Plenitude of Arboreal Beauty</a>:</strong> 由程序员 David Siegel 撰写，PAB 包含了各种开源话题。</li><li><strong><a href="http://reboltutorial.com/">Rebol Tutorial</a>:</strong> Rebol Tutorial 提供 Rebol 的编程技巧和提示。</li><li><strong><a href="http://rhel5certs.blogspot.com/">Red Hat Enterprises</a>:</strong> Red Hat Enterprises 是一个关于 Red Hat’s Linux 事件更新的博客。</li><li><strong><a href="http://www.revoltwebdesign.com/blog.html">Revolt</a>:</strong> Revolt 提供开源和网页开发软件的更新资讯。</li><li><strong><a href="http://slashdot.org/">Slashdot</a>:</strong> 它的口号就说明了一切：News for Nerds Stuff That Matters。这个博客覆盖了各种开发主题，主要专注于 Linux 和开放软件。</li><li><strong><a href="http://www.delphigeist.com/">The Spirit of Delphi</a>:</strong> The Spirit of Delphi 提供了 Delphi，C#，C++，Ruby，Python 和 Java 编程的技巧和教程。同时还包含了一些关于软件管理的通用技巧和提示，以及与作者工作有关的其他科技工作。</li><li><strong><a href="http://www.stefanolaguardia.eu/en/">Stefano Laguardia</a>:</strong> Stefano Laguardia 是有个有趣的博客，它提供与法律焦点的开源新闻。</li><li><strong><a href="http://ownedboxes.blogspot.com/">Tech Stuff</a>:</strong> 您可以通过 Tech Stuff 下载很多非常棒的开源程序，有时也发布一些很棒的技巧提示和 hack。</li><li><strong><a href="http://pankajdangi.com/">Technical Zone</a>:</strong> Technical Zone 是查找犀利评论以及最新软件概要的好地方。</li><li><strong><a href="http://basicslinux.blogspot.com/">Things You Should Know About Linux!</a>:</strong> Things You Should Know About Linux 提供与 Linux 相关的新闻。</li><li><strong><a href="http://cviorel.easyblog.ro/">Ubuntu!</a>:</strong> Ubuntu! 是一个提供 Ubuntu 技巧，提示和教程的博客。</li><li><strong><a href="http://www.virtfoundry.com/blog/">VirtFoundry</a>:</strong> VirtFoundry 是一个关于 Linux，系统管理和虚拟化的博客。它主要聚焦于 Linux 技巧和提示。</li><li><strong><a href="http://webmaster-software.blogspot.com/">WebMasters Software</a>:</strong> WebMaster Software 关注开源软件开发，特别是基于手机和网络的。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Programmer </tag>
            
            <tag> Open Source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】对九个超级程序员的采访</title>
      <link href="/posts/2024-07-14-10-q-with-nine-great-programmers.html"/>
      <url>/posts/2024-07-14-10-q-with-nine-great-programmers.html</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://coolshell.cn/articles/8275.html">https://coolshell.cn/articles/8275.html</a></p><p>原文：《<a href="http://www.dodgycoder.net/2012/09/q-with-nine-great-programmers.html">Q&amp;A With Nine Great Programmers</a>》时间有限，我只能粗译，难免错误。</p><p><strong>这篇访谈源自2006年，最先发布在波兰程序员 Jaroslaw “sztywny” Rzeszótko (AKA “Stiff”) 的博客上。但是这篇博文现在找不到了。非常感谢他能授权我重新发布这个博文。</strong></p><p><em>在一个炎热无聊的下午，我突发奇想。我想通过电子邮件的方式对那些我非常感兴趣和非常敬重的程序员问10个问题。准备这10个问题我只花了5分钟，这些都是我个人想问他们的问题，所以，我基本上没想太多要问他们什么。最后两个问题和编程没有什么关系，我就是想问题这些人的一些兴趣爱好。另外，不是每一个人都想回答我的，这是我第一次做“访谈”，所以，我犯了一些错误，一些问题没有得到回答。不管怎么样，我得到了很多很有意思的内容，所以，这对我绝对是一次很有意义的经历。</em></p><p><em>并不是每一个人都回了我的邮件，也并不是每一个人都同意回答我的这些问题，也许在我发布这篇文章后我会得到那些回答，但是我已经迫不及待想把这些东西发布了，所以，我可能会更新这篇文章（更新：2006年3月8日，我收到了*Bjarne Stroustrup的回信*）</em></p><p><em>— Jaroslaw</em></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li><p><a href="https://en.wikipedia.org/wiki/Linus_Torvalds"><strong>Linus Torvalds</strong></a> – <a href="http://linux.org/">Linux kernel</a> 作者。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Dave_Thomas_(programmer)"><strong>Dave Thomas</strong></a> – “Pragmatic Programmer”(注：<a href="http://book.douban.com/subject/1417047/">douban</a>) 和 “Programming Ruby”(注：<a href="http://book.douban.com/subject/1422056/">douban</a>) 以及其它一些优秀书籍的作者。 你可以在 <a href="http://pragdave.pragprog.com/">这里</a> 读读他对编程的一些想法。</p></li><li><p><a href="https://en.wikipedia.org/wiki/David_Heinemeier_Hansson"><strong>David Heinemeier Hansson</strong></a> –  <a href="http://rubyonrails.org/">Rails Framework</a> 作者- 一个目前最新最热的Web开发框架。他的blog在 <a href="http://david.heinemeierhansson.com/">这里</a>. （陈皓注：他也是<a href="https://en.wikipedia.org/wiki/37signals">37signals</a>的领导人之一）</p></li><li><p><a href="https://en.wikipedia.org/wiki/Steve_Yegge"><strong>Steve Yegge</strong></a> – 他可能并不那么知名，但是他给了很多有意思的回答。他有一个很火的关于编程的 <a href="https://steve-yegge.blogspot.com/">blog</a>，他也是游戏 “Wyvern” 的作者。（陈皓注：他最火的是去年在google+上<a href="https://coolshell.cn/articles/5701.html">对google和amazon的吐槽</a>，06年他应该在google了）</p></li><li><p><a href="https://en.wikipedia.org/wiki/Peter_Norvig"><strong>Peter Norvig</strong></a> – Research Director at Google, 知名的 Lisper，AI书的著名作家，<a href="http://norvig.com/">个人主页</a>。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Guido_Van_Rossum"><strong>Guido Van Rossum</strong></a> – <a href="https://python.org/">Python</a> 发明者。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup"><strong>Bjarne Stroustrup</strong></a> – C++发明者， <a href="http://www.stroustrup.com/">个人主页</a>。</p></li><li><p><strong><a href="https://en.wikipedia.org/wiki/James_Gosling">James Gosling</a></strong> –  <a href="http://java.sun.com/">Java</a> 发明者。</p></li><li><p><strong><a href="https://en.wikipedia.org/wiki/Tim_bray">Tim Bray</a></strong> –  XML 和 Atom 规格说明书作者之一 <a href="http://www.tbray.org/ongoing/">个人博客</a> 。</p></li></ul><h4 id="Q-1-你是怎么学编程的？是从学校里学的吗？或者你没有上过学-？"><a href="#Q-1-你是怎么学编程的？是从学校里学的吗？或者你没有上过学-？" class="headerlink" title="Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？"></a>Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？</h4><p><em>Steve Yegge</em></p><p>在我17岁的时候，我在HP的计算器中用他们的RPN 栈语言自学编程的。在这之前，我尝试过学习编程一两次，但都没有学成。HP 28c 和 48g 的科学计算器是一个很牛的东西，而且还有不错的文档。我搞了一本3D图形的书，并很费力地把其中的Pascal语言转成RPN栈语言，并用48g写了一个3D的线框图渲染图。运行的还不错，在我买了PC和Turbo Pascal之后，我开始认真地学习编程。在我进入大学计算机科学专业之前，我已经是一个不错的程序员了。</p><p>我在华盛顿大学拿到了计算机科学学位，这绝对是有价值的，所以，我建议所有的程序员都应该得到计算机科学专业的学位。</p><p><em>Linus Torvalds</em></p><p>我没有在学校里学过编程，我在主要是读我自己想读的书，或是就直接去编程 (一开始在 <a href="https://en.wikipedia.org/wiki/Commodore_VIC-20">Commodore VIC-20</a> 学编程， 然后是 <a href="https://en.wikipedia.org/wiki/Sinclair_QL">Sinclair QL</a>上编程)。</p><p>当然，我觉得上大学非常有用。我没有去一个工科大学，我上了赫尔辛基大学，这是一个比较偏理论的大学，所以，那里的教育并没有那么多的编程的东西（编程只是很少一部分），这里大多数的课程都倾向于教一些基础概念的东西，如：复杂性分析。看上去很无聊，甚至有点浪费时间，但是我还是觉得这些课有用，我对大多数课都还比较enjoy。所以，我觉得我可能在这些方面是一个比较好的程序员。</p><p><em>David Heinemeier Hansson</em></p><p>我学编程是从用HTML做我的第一个网页开始的。那时，我想当我的网页能动态地显示一些内容，所以，我选择了ASP和PHP。在做完这个网页后，我知道了怎么去编程，于是我开始我的计算机科学和商业管理学位的学习。</p><p><em>Peter Norvig</em></p><p>我是从高中和大学课程中学编程的，但是我还是觉得我自己学得更多。</p><p><em>Dave Thomas</em></p><p>我是在高中学编程的。我完全地迷住了，我对编程爱得无法自拔，然后，我开始挑选那些提供软件开发课程的大学。最终，我去了伦敦大学的帝国学院。第二年我就开始学习软件开发的课程了，那绝对是非凡的，学生和教员在一起工作把教材做得更好，每一个人都可以从中学到很多。这些课程给了我难以置信和非常雄厚的软件开发背景。我在那里读到了博士，最后去创业了。</p><p>关于“我是怎么学编程的”这个问题，我的回答是“我现在还在学编程”。我认为好的程序员一生都在学编程。这并不是去学一门语言或是一个代码库，好的程序员会对他们的编程技艺一年又一年地精益求精。</p><p><em>Guido Van Rossum</em></p><p>我去的那个大学有一个大型主机和很多不同的计算机课程。这对我很重要。</p><p><em>James Gosling</em></p><p>起初，我是自学的。在我去上大学之前，我就找到了一份程序员的工作。但是我很高兴我去了大学，在那里有很多乐趣，最终我学到了博士。</p><p><em>Bjarne Stroustrup</em></p><p>我先上的是Aarhus大学， 然后是 剑桥大学(Cambridge)，这两个大学教了我很多很有用的东西，这些东西为了以后的工作打下了基础。另外，我对编程和钱的关系学得非常好——知道了真实世界的问题，正确性，维护性，准时交付，等等，这些比教育可能更重要。</p><p><em>Tim Bray</em></p><p>我本来想去做一个数学老师的。但是，那个学数学的大学要我去学几个计算机的课。</p><h4 id="Q-2-你们觉得对程序员最重要的事是什么？"><a href="#Q-2-你们觉得对程序员最重要的事是什么？" class="headerlink" title="Q 2: 你们觉得对程序员最重要的事是什么？"></a>Q 2: 你们觉得对程序员最重要的事是什么？</h4><p><em>Steve Yegge</em></p><p>沟通能力（写和说）。除非你可以让你的想法更有效率地传递出去，否则你不可能做得比编程更多的事。程序员应该疯狂地阅读，锻炼写作能力，参加一些写作培训课程，甚至锻炼在公开场合演讲的能力。</p><p><em>Linus Torvalds</em></p><p>It’s a thing I call “taste”. 有一件事，我把它叫做“品味”。</p><p>我倾向于不从熟练程度来评判那些和我工作过的人。这些人能非常艰苦地写出很多代码，但是我想从他们对别人的代码的反应做出评判，这样我们就可以明白他们自己写的代码怎么样，知道他们使用的方法怎么样。他们对别人的评判还告诉我，他们是不是有好的“品味”。是这样的，如果一个人没有“好的品味”，那么他一般不会很好的评判他人的代码，他自己写的代码通常也不会很好。</p><p>哦，这并不只是唯一的事。还有一件事，尤其在开源项目里，那是他是否有能力能和别人进行简单的沟通，告诉别人他要干什么，怎么干。这个能力可以告诉别人为什么你干的事是非常重要的，并不是所有的人都有这个能力。</p><p>也就是说，有一些人可以写出很不错的代码，但他们并不一定能解释这些代码，他们也并不一定有好的品味，但是代码可以运行得不错。有时，你需要另一个人（有那种不错的品味的人）把他的代码转成更好的形式。也就是说，任何一个程序员都需要那种可以用清晰的代码来解决复杂问题的基础能力。</p><p><em>David Heinemeier Hansson</em></p><p>很强的对有价值的事的感觉。你可以问问自己这个问题你有没有这种能力：我现在做的这个事值不值得做？很多程序员浪费了如大海一样的时间去做一些无意义的事。</p><p><em>Peter Norvig</em></p><p>我不觉得只有一个，如果要我说一个的话，我说是“专注”。</p><p><em>Dave Thomas</em></p><p>热情。</p><p><em>Guido Van Rossum</em></p><p>你的问题很难回答啊:-) 我猜，如果程序员会在早晨煎个鸡蛋做早餐，那真是无价的能力。</p><p><em>James Gosling</em></p><p>自我激发。你需要全身心地投入到你要做的事中。</p><p><em>Bjarne Stroustrup</em></p><p>把事想清楚的能力：程序必需要能清楚地理解问题并能清楚地表述解决方案。</p><p><em>Tim Bray</em></p><p>能为自己的直觉提供证据的能力。</p><h4 id="Q-3-你是否认为数学和-或物理是一种很重要的编程技能？为什么？"><a href="#Q-3-你是否认为数学和-或物理是一种很重要的编程技能？为什么？" class="headerlink" title="Q 3: 你是否认为数学和&#x2F;或物理是一种很重要的编程技能？为什么？"></a>Q 3: 你是否认为数学和&#x2F;或物理是一种很重要的编程技能？为什么？</h4><p><em>Steve Yegge</em></p><p>数学有很多的分支和程序员相关，他们是“离散数学”和“具体数学”。这些分支包括的学科有，概率论，组合数学，图论，归纳证明，和其它有用的东西。我会鼓励所有的程序员都去学习离散数学，无论能学多少，因为这总比什么都不懂强。</p><p>对于传统的数学，我也不经常用，但是我需要的时候这些数学知识会很管用。例如，在我之前的工作中我就用到了微积分。我需要估计每个小时中某服务的高峰时间的流量负载，所以，他的负载是跟着太阳走的就像一个正弦曲线一样。最简单的方式就是把每个小时的负载曲线给整合起来。如果我不知道微积分，我就不知道怎么更为准确地估计。</p><p>当年我在开发我的Wyvern游戏的时候，我的平面几何的知识对我非常有帮助。而且经常使用代数和线性代数的知识。但我很少在工作中使用三角学或微分方程，微积分同样也很少。</p><p>我想说，简单的数学基础让我的技能比一般程序员好过5%到10%。如果我了解更多的数学，我确信我会比今天做得更好，所以，我每周都会花几个小时学习数学。</p><p>我喜欢物理，我还在学习物理，我会花我一生去理解量子力学。但是我个却没有发现物理对我的程序员工作有多有用。当然，如果我从事一些和物理相关的工作，可能会有用，例如：3D游戏编程，或是某种物理特性仿真。</p><p><em>Linus Torvalds</em></p><p>我个人认为有很强的数学背景是一件好事。但我不确信物理是不是这样的，但是我深信懂数学的人会让你成为一个更好的程序员。这些智力模型都是相通的。</p><p><em>David Heinemeier Hansson</em></p><p>根本没用。至少对业务编程和Web应用来说没用。但是数学可能对一个人的写作有很重要的帮助。</p><p><em>Peter Norvig</em></p><p>是的。很多相法都是从数学来的：归纳，递归，逻辑，等等。</p><p><em>Dave Thomas</em></p><p>也许吧。但老实说，我没见到过懂这些学科和好的程序员有很大的相关性。</p><p>然而，我见过有音乐背景和好的编程技能有很强的相关性。我不知道这为什么，但是我怀疑大脑中的某个区域可以让人即可以写出好的音乐，也可以写出好的代码。（陈皓注：*<a href="http://www.weibo.com/n/Sir%E9%98%BF%E6%80%AA">@Sir阿怪</a>* 貌似就是这个例子）</p><p><em>Guido Van Rossum</em></p><p>数学，当然（对于一些学科是很重要的，我不关心微分方程，但是代数和逻辑学是很重要的），物理，我不觉得对编程技能有关，当然物理在其它很多地方很有意思。</p><p><em>James Gosling</em></p><p>当然！数学教会了我逻辑和推导……让我有了一双懂分析的眼睛。当我们分析算法的时候，数学是无法被取代的。</p><p><em>Bjarne Stroustrup</em></p><p>这要看程序员自己和项目性质了。以前的数学很有用，物理一般，但是学好物理是是学习应用数学最好的一条路。</p><p><em>Tim Bray</em></p><p>对我来说，在我的编程生涯中我从来都没有用过大学里教的数学。</p><h4 id="Q-4-关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑-？"><a href="#Q-4-关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑-？" class="headerlink" title="Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？"></a>Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？</h4><p><em>Steve Yegge</em></p><p>我认为Web编程会逐渐变成最最重要的客户端编程。而对于原来传统的客端端编程都会被废弃，如： GTK, Java Swing&#x2F;SWT, Qt, 当然，所有的和平台有关的东西，例如 Cocoa 和 Win32&#x2F;MFC&#x2F;等。</p><p>当然，这不会一晚上就发生了。这会在第一个十年内缓慢地发生，而在第二个十年内，Web Apps最终会胜利。工具，语言，协议，和浏览器技术都会进步得非常快，并会完全超出你今天能干的事。每一年都会向前进一步，而从今天开始，我会最终决定把我所有的应用开发全部切换到基于浏览器的应用。（陈皓注：我也是这么认为的，参看《<a href="https://coolshell.cn/articles/5815.html">来信，创业，移动互联网</a>》）</p><p>微软和苹果最终不愿意这个事发生，所以，触发这个事的第一步会是一个开源的浏览器（如：Firefox）开始到了支配市场的地位，然后会出现某种Firefox的杀手级应用（这种杀手级应用可能会像iTunes一样，所有的人都会用它，只需要下载Firefox）</p><p><em>Linus Torvalds</em></p><p>我并不认为我们会看到一个“大的跳跃”。我们只会看到很多的工作帮助我们把那些沉闷辛苦的工作变得更简单——会有一个更高级别的语言，也许把简单的数据库集成到语言中来会是其中最主要一个。</p><p>例如，我个人相信“Visual Basic”在编程方面比“面向对象”做得更多。当然，人们都在取笑VB是一个很烂的编程语言，并且人们在谈论OO语言都十多年了。但我还觉得不是这样的，Visual Basic 不是一个好的语言，但是我觉得VB那简单的数据库接口比OO更重要。</p><p>所以，我认为会语言有很多的改进，并且，硬件的改进会让编程更容易，但我并不期望会有巨大的生产力或是革命性的改进。</p><p>至少，你不会开始搞真正的AI的东西，我也不认为真的AI会变成某种你不需要编程的东西。</p><p><em>David Heinemeier Hansson</em></p><p>我从不试图预测未来。我也不相信命运一说。最好预测未来的方式就是去实现未来。</p><p><em>Peter Norvig</em></p><p>大规模的分布式处理</p><p><em>Dave Thomas</em></p><p>下一个最牛的事会被再下一个最牛的事所掩盖，然后再被再再下一个所掩盖，再再再下一个所掩盖……。这是一件没完没了的事，所以，我并不会试图去找最牛的事，因为这会让人们忘了那些最真实的问题：把基本的东西做对。我们要让用户更满意，专注于交付有价值的东西，自豪于我们做的事。一个程序员可以使用很多工具把这些事做得更好，而不是去追逐时尚和流行。</p><p><em>Guido Van Rossum</em></p><p>对不起，我没有那么多水晶球。我CGI被发明了5年后预测过它 :-)</p><p><em>James Gosling</em></p><p>有两个事是我现在最关心的，那就是要对付并行和复杂。</p><p><em>Bjarne Stroustrup</em></p><p>我不知道，我也不愿猜。</p><p><em>Tim Bray</em></p><p>不知道。</p><h4 id="Q-5-如果你有3个月学一个相对较新的技术，你会学什么？"><a href="#Q-5-如果你有3个月学一个相对较新的技术，你会学什么？" class="headerlink" title="Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？"></a>Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？</h4><p><em>Steve Yegge</em></p><p>我的确有3个月的业余时间，我准备学一下 Dojo (<a href="http://dojotoolkit.org/">http://dojotoolkit.org</a>) 和高级 AJAX 及 DHTML。我会通过开发一个相当牛的Web应用来学习他们。Dojo 真的酷，并且我确信它会越来越好。</p><p><em>Linus Torvalds</em></p><p>嗯，我真的很爱做 FPGA（可编程芯片），但我部是太忙了而不是坐来来开始学习。我喜爱和硬件打交道：很明显这个原因是因为我最终在做操作系统，因为操作系统（除了编译器）基本上都是在和硬件打交道，但我没有真正地自己去设计和做一个硬件。</p><p><em>David Heinemeier Hansson</em></p><p>Mac 的 Cocoa 编程</p><p><em>Peter Norvig</em></p><p>我想把 Javascript 学得更好，<del>然也</del>当然也想学 flash.</p><p><em>Dave Thomas</em></p><p>如果“新”是对于我来说，那么我会去学钢琴课。</p><p>如果“新”是说技术，我猜 我会选择学习某种和为残疾人服务的有关的技术。</p><p><em>Guido Van Rossum</em></p><p>单板滑雪。</p><p><em>James Gosling</em></p><p>搞点有乐趣的东西，我会学习最新的3D渲染技术。我可能会写一个光子映射渲染器。</p><p><em>Bjarne Stroustrup</em></p><p>3个月只有很少的东西你可以学，我觉得你只能参加某个成熟领域的培训。</p><p><em>Tim Bray</em></p><p>安全，加密，数字签名，身份标识，等等。对我来说，从没学过这些东西对我来说是个很大的问题。</p><h4 id="Q-6-你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？"><a href="#Q-6-你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？" class="headerlink" title="Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？"></a>Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？</h4><p><em>Steve Yegge</em></p><p>我想你应该考虑一下为什么不是让所有的程序员都一样牛。托马斯爱迪生有一句关于天才的名言也许会给你一些启示。</p><p><em>Linus Torvalds</em></p><p>我真的不知道，我想，一些人之所以更牛是因为他们可以专注于那些重要的事，而更多的只不过是在应付。那些我所知道的真的很牛的程序员从很年轻的时候就在做事了。</p><p><em>David Heinemeier Hansson</em></p><p>把难题变简单的能力。</p><p><em>Peter Norvig</em></p><p>把整体问题一次性放入大脑的能力。</p><p><em>Dave Thomas</em></p><p>他们关心他们做的事。</p><p><em>Guido Van Rossum</em></p><p>大脑结构基因不同。</p><p><em>James Gosling</em></p><p>他们知道他们要做什么，他们不并不急于仓促行事。他们有他们要做的事的整个蓝图。</p><p><em>Bjarne Stroustrup</em></p><p>首先，缺少足够的职业培训，或基础不够。其次，这些人要即聪明（那种可以把事情想清楚，直达核心的能力），又有经验，并有使用工具的知识。编程需要把理论和实践结合起来 – 并不是使用没有实际业务的知识。</p><p><em>Tim Bray</em></p><p>令人惊讶的思维改变。</p><h4 id="Q-7-什么工具是你的最爱（操作系统，编程-脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？"><a href="#Q-7-什么工具是你的最爱（操作系统，编程-脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？" class="headerlink" title="Q 7: 什么工具是你的最爱（操作系统，编程&#x2F;脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？"></a>Q 7: 什么工具是你的最爱（操作系统，编程&#x2F;脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？</h4><p><em>Steve Yegge</em></p><p>操作系统： Unix! 我用Linux，cygwin，和 darwin。你无法打败那些高效的工具。每一个程序员都应该学习使用&#x2F;bin和&#x2F;usr&#x2F;bin下的所有命令。</p><p>脚本语言：Ruby。我几乎对所有的重要的脚本语言都很熟悉： Perl, Python, Tcl, Lua, Awk, Bash, 和一些我忘了的。但是我太懒了，而Ruby是目前所有脚本语言中最简单的，它应该是天堂制造的。</p><p>编程语言：没有一个我喜欢的，我觉得所有的编程语言都很扯。我倾向于Java，因为它很强，可跨平台，有多不错的工具和类库。但是Java未来会进化或是灭亡，Java还没有好到可以永远保持其领先地位。</p><p>文本编辑器：Emacs，因为这是迄今最好的编辑器。</p><p>版本管理：SVN，Perforce更好一些，但是也很贵。</p><p>Shell脚本： Bash, 因为我太懒了去学一个更好的。</p><p>数据库： 当然是MySQL，没有之一。</p><p>其它：我发现GIMP是无价的，但也是令人恼<del>炎</del>火的。我用这个东西好几年了，但什么也没干，但是我没它活不了。很讽刺吧。Firefox 越来越是我最重要的工具。如果让我去用IE和Safari，我会有严重的窒息感。</p><p>注：所有的这些工具 (Unix, Emacs, Firefox, GIMP, MySQL, Bash, SVN, Perforce) 都有一个共同点：他们是可扩展的。例如：他们都有可编程的API。伟大的程序员知道怎么编写他们的工具，而不只是去使用。</p><p><em>Linus Torvalds</em></p><p>实际上，我最终也没有用过几个工具，而我却花了一些时间让这些工具为我工作。最大的事是我自己写了个操作系统，我也自己写了个版本管理系统（git），我用的文本编辑器是 micro-emacs – 最终我也定制和扩展了它。</p><p>除了上面三个，其它的东西，我深度关心我的邮件阅读软件，我使用“pine”，并不是因为它是史上最好的邮件阅读软件，因为我习惯了，用它我会有最低限度的大惊小怪。</p><p><em>David Heinemeier Hansson</em></p><p>OS X, TextMate, Ruby, Subversion, MySQL. 这些组合让我很快乐。我希望那些有好的品味的专注于重要的事的工具。</p><p><em>Peter Norvig</em></p><p>我不喜欢那三大操作系统 – Windows, Mac, Linux。我喜欢 Python 和 Lisp. Emacs.</p><p><em>Dave Thomas</em></p><p>在使用Linux10年后我转到Mac平台有两年多了。Mac并不见得有多好，但是它不需要很牛的技术，也不需要经常维护，这让我可以让我更专心得使用它。</p><p>我并不是一个单一工具的信仰者，我喜欢换来换去的，这样可以让我有更多的经历。现在，我使用 OSX, Emacs, TextMate, Rails, Ruby, SVN, CVS, Rake, make, xsltproc, TeX, MySQL, Postgres, 还有一堆高效的小工具。没人知道我明年会用什么。</p><p><em>Guido Van Rossum</em></p><p>Unix&#x2F;Linux, Python, vi+emacs, Firefox.</p><p><em>James Gosling</em></p><p>这些天，我在用 NetBeans. 用它可以干我想干的所有的事，清洁，简单和高效。这是最好的我永远要生活在其中的环境了。</p><p><em>Bjarne Stroustrup</em></p><p>Unix, sam (一个非常简单的文本编辑器), 当然，一个好的C++编译器。</p><p><em>Tim Bray</em></p><p>我喜欢 Unix-like 的操作系统，像 Python 和 Ruby 的动态语言，像Java的静态语言（具体说来是Java API） Emacs, 还有, bash, whatever, NetBeans.</p><h4 id="Q-8-你最喜欢的编程书是什么？"><a href="#Q-8-你最喜欢的编程书是什么？" class="headerlink" title="Q 8: 你最喜欢的编程书是什么？"></a>Q 8: 你最喜欢的编程书是什么？</h4><p><em>Steve Yegge</em></p><p>大哥，这个问题太难了。也许是”Gödel, Escher, Bach: an Eternal Golden Braid” (作者Hofstadter)？虽然这不是严格意义上的编程的书，如果你要明确意义上的编程书，那么可能是 SICP (mitpress.mit.edu).</p><p><em>Linus Torvalds</em></p><p>嗨。这两天我在读一些小说，或是非计算机读物（老的但是有用的 “The Selfish Gene” 作者 Richard Dawkins)。</p><p>如果要问我编程的书，我脑子里只出现了唯 一一本真正的经典的编程的书 Kernighan &amp; Ritchie 的 “The C Programming Language”，因为这本书太牛了，可读性强并且很短。考<del>虚</del>虑一下你想学到这世上一门最重要编程语言，并且它很要很薄，而且还有可读性，这真是一个奇迹。</p><p>也就是说，其它我很喜欢的书并不是编程的，而是关于计算机结构和硬件的。那显然是 Patterson &amp; Hennessy 的计算机结构的书，但是我个人也许更喜欢 Crawford &amp; Gelsinger 的 “Programming the 80386?，这是我在开始写Linux时用的书。</p><p>相似的原因，我还喜欢 Andrew Tanenbaum 的 “Operating Systems: Design and Implementation”.</p><p><em>David Heinemeier Hansson</em></p><p>我喜欢 Extreme Programming Explained 其摒弃了一般的编程实践，我还喜欢 Patterns of Enterprise Application Architecture 其出众地说明了抽象和具现的平衡。</p><p><em>Peter Norvig</em></p><p>Structure and Interpretation of Computer Programs</p><p><em>Dave Thomas</em></p><p>这关系到你所谓的“最喜欢”，也许我最喜欢的是IBM的 “IBM&#x2F;360 Principles of Operation.”</p><p><em>Guido Van Rossum</em></p><p>Neil Stephenson的 Quicksilver.</p><p><em>James Gosling</em></p><p>Programming Pearls 作者Jon Bentley.</p><p><em>Bjarne Stroustrup</em></p><p>K&amp;R.</p><p><em>Tim Bray</em></p><p>Bentley的 Programming Pearls</p><h4 id="Q-9-你最喜欢的和编程无关的一本书是什么？"><a href="#Q-9-你最喜欢的和编程无关的一本书是什么？" class="headerlink" title="Q 9: 你最喜欢的和编程无关的一本书是什么？"></a>Q 9: 你最喜欢的和编程无关的一本书是什么？</h4><p><em>Steve Yegge</em></p><p>只能是一本吗？这不可能。有太多太多我喜欢的书了。</p><p>我这个月读过最喜欢的书是 “Stardust” (Neil Gaiman) 和 “The Mind’s I” (Hofstadter&#x2F;Dennet).</p><p>我最喜欢的作者是 Kurt Vonnegut, Jr. 和 Jack Vance.</p><p><em>Linus Torvalds</em></p><p>我在前面说过 Dawkins的 Selfish Gene。在小说方面，有很多很多我enjoy的，但是几乎没有我特别喜欢的一本。我一般不会重读一本书，我的选择总是会变。我可能更喜欢科幻小说，如：”Stranger in a Strange Land” 作者 Heinlein，这是我青少年时期最喜欢的书，但现在并不是我喜欢的了。</p><p><em>David Heinemeier Hansson</em></p><p>1984, George Orwell.</p><p><em>Guido Van Rossum</em></p><p>Neil Stephenson 的 Quicksilver.</p><p><em>James Gosling</em></p><p>Guns, Germs &amp; Steel 作者 Jared Diamond</p><p><em>Bjarne Stroustrup</em></p><p>我没有固定喜欢的书。目前是 O’Brian 的 Aubrey&#x2F;Maturin 系列。</p><p><em>Tim Bray</em></p><p>One Day in the Life of Ivan Denisovich</p><h4 id="Q-10-你最喜欢的乐队-演奏家-作曲家？"><a href="#Q-10-你最喜欢的乐队-演奏家-作曲家？" class="headerlink" title="Q 10: 你最喜欢的乐队&#x2F;演奏家&#x2F;作曲家？"></a>Q 10: 你最喜欢的乐队&#x2F;演奏家&#x2F;作曲家？</h4><p><em>Steve Yegge</em></p><p>喜欢的风格：古典音乐，动漫原声音乐，电脑游戏音乐</p><p>喜欢的作曲家：Rachmaninoff, Chopin, Bach</p><p>喜欢的演奏者：David Russell (古典吉它), Sviatoslav Richter (钢琴)</p><p>喜欢的动漫音乐： Last Exile, Haibane Renmei</p><p><em>Linus Torvalds</em></p><p>实际上我并不太喜欢音乐，但是当我听音乐的时候，我一般听经典摇滚乐，如： Pink Floyd ，Beatles ，Queen 和 The Who 乐队。</p><p><em>David Heinemeier Hansson</em></p><p>我喜欢很多风格。 Beth Orton, Aimee Mann, Jewel, Lauryn Hill. Actually, 所有的这些都可以归到 Girls with Guitars ;).</p><p><em>Guido Van Rossum</em></p><p>Philip Glass.</p><p><em>James Gosling</em></p><p>我喜欢听民歌: Christine Lavin, Woody Guthrie, Pete Seeger…</p><p><em>Bjarne Stroustrup</em></p><p>乐队: The Dixie Chicks. 作曲家: Beethoven.</p><p><em>Tim Bray</em></p><p>看我的博客吧。</p><p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p><p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><strong>补充说明</strong></h4><p>我之所以发现这篇文章，是因为我读到了 Jeff Atwood 的这篇名为 “<a href="http://www.codinghorror.com/blog/2006/07/linus-torvalds-visual-basic-fan.html">Linus Torvalds, Visual Basic Fan</a>” 的文章，这篇文章指向了 “<a href="http://sztywny.titaniumhosting.com/2006/07/23/stiff-asks-great-programmers-answers/">STIFF ASKS, GREAT PROGRAMMERS ANSWER</a>” 这篇文章，但是链接已坏了，然后，我搜了一下也没有搜到这篇文章。然后我去了 archive.org 搜了一下，并找到了这篇由 Jaroslaw Rzeszótko 写的博客。</p><p>因为这篇博文现在找不到了，所以，我想我应该重新把它贴出来，这样其它人可以读一下这篇有意思的文章。所以，我向原作者取得了授权，再次感谢 Jaroslaw!</p><p>（全文完）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】10部程序员必看的纪录片</title>
      <link href="/posts/2024-07-14-10-programmer-documentary.html"/>
      <url>/posts/2024-07-14-10-programmer-documentary.html</url>
      
        <content type="html"><![CDATA[<p>从本文介绍的影片中可以看到各式各样的程序员：他们有的才华横溢，14岁就创造了RSS1.0规格，足迹遍及整个互联网，但英年早逝；有的活在自己世界并坚守着自己的理想，想法不为他人而决定；有的在尽自己最大的努力来挽救公司，永不言弃的精神在影片中体现的淋漓尽致；有的置生死于度外，揭露出鲜为人知的真相…</p><h1 id="一、互联网之子-The-Internet’s-Own-Boy-The-Story-of-Aaron-Swartz"><a href="#一、互联网之子-The-Internet’s-Own-Boy-The-Story-of-Aaron-Swartz" class="headerlink" title="一、互联网之子(The Internet’s Own Boy: The Story of Aaron Swartz)"></a>一、互联网之子(The Internet’s Own Boy: The Story of Aaron Swartz)</h1><p><strong>影片介绍：</strong></p><p>斯沃茨很早就参与网络标准的制订，并在14岁就参与创造RSS 1.0规格。 从那时开始他就成为 W3CRDF 核心工作小组的成员，跟John Gruber共同设计了排版语言Markdown（简书使用的编辑器就有Markdown），并参与其他许多计划。 斯沃茨在2006年创办了网ok ever published”)。斯沃茨早在 2000 年时就用wiki技术开发了 ‘theinfo’ 百科全书计划。他公司的后台也以 wiki 架设。Swartz曾在斯坦福大学读书，但很快辍学创建Infogami软件公司。Aaron Swartz还是社交新闻网站Reddit的三位创始人之一， 2006年初，Infogami与Reddit合并，并在2006年底被出售给出版公司Condé Nast。Swartz在20周岁生日前出售了他所持有的股份。 Swartz在2006年用wiki技术创办了网上免费图书馆Open Library, 目的是为了让每一本曾经出版过的书都有自己的网页(“one web page for every book ever published”)。Swartz在2010年创立了反对互联网审查的Demand Progress。这个机构通过Email及其他媒体组织群众，针对特定议题向国会议员及其他意见领袖表达意见、施予压力。2011年7月19日，Swartz因数字偷窃被捕，被控从MIT和JSTOR下载了480万篇学术论文，他在支付10万美元保释金后被释放。Swartz是利用外置硬盘、通过物理接触的方式从MIT内网运行脚本下载JSTOR论文的。2013年1月自杀身亡。</p><p><strong>精彩影评：</strong></p><blockquote><p>看到开头不久，他们说，他是一个与世界不太和睦的人，世界对他也不太和睦，当即想到自己，并且，已经猜测到他可能会有抑郁。因为但凡这种才华横溢又与传统不合作的人，要么，成为传奇，要么，成为牺牲品。当然，独享其一的人少，更多的，是两者兼得或两者兼弃的人，比如斯沃茨。</p></blockquote><h1 id="二、独立游戏大电影（Indie-Game-The-Movie）"><a href="#二、独立游戏大电影（Indie-Game-The-Movie）" class="headerlink" title="二、独立游戏大电影（Indie Game: The Movie）"></a>二、独立游戏大电影（Indie Game: The Movie）</h1><p><strong>影片介绍：</strong></p><p>Indie Game: The Movie 独立游戏大电影是一部关于独立游戏的纪录片，讲述独立游戏过往的精彩故事。随着二十一世纪的到来，新的一类独立艺术家诞生了：独立游戏开发者。他们有独立的构思，特别的设计以及个性鲜明的游戏。当然，他们也希望获得成功。影片中，设计师 Edmund McMillen 和程序员 Tommy Refenes 经过两年的努力，等待着他们第一款XBOX的游戏 Super Meat Boy “超级肉食男孩” 的发布。游戏讲述的是一个绷带男孩寻找女友的故事。而在一个名为 PAX 的视频游戏展中，开发者 Phil Fish 则推出了众人翘首以盼的画了四年制作的游戏 FEZ “费兹”。Jonathan Blow 则在考虑继 Braid “时空幻境” 之后的新游戏。而时空幻境曾一度是历史上平均最高的游戏之一。Lisanne Pajot 和 James Swirsky 第一次共同制作了这部电影，他们精心捕捉独立游戏艺术家们奋斗历程的点点滴滴，以及其艺术表现过程中的情感历程。四个开发者，三款游戏，一个终极目标 —— 通过这部纪录片共同表达了出来。</p><p><strong>精彩影评：</strong></p><blockquote><p>有一些人，他们也希望赚钱，但他们更多的是凭着理想工作。我们这个社会叫他们理想主义者。他们希望作品能被人认可、被人接受、被人喜欢，但不是这样也没关系，他们会按照自己的理念创作，不会因此改变一分一毫。他们脱离社会，离群索居，只是一心一意沉浸在自己做出的世界中。</p></blockquote><h1 id="三、代码奔腾（Code-Rush）"><a href="#三、代码奔腾（Code-Rush）" class="headerlink" title="三、代码奔腾（Code Rush）"></a>三、代码奔腾（Code Rush）</h1><p><strong>影片介绍：</strong></p><p>这是一部讲述Netscape和Mozilla的故事的纪录片。Netscape是一家伟大的公司，它发明了img标签、cookie、ssl安全协议，当然还有如今HTML5时代的明星语言Javascript！但是由于众所周知的原因，它失败了。Netscape最终将浏览器代码开源，这个新项目就是Mozilla！摄制团队横跨了期间重要的几个时间点，整整跟踪了程序员们一年的时间，最终制成这部纪录片。</p><p>独立制片人从1998年3月到1999年4月跟随Mozilla的团队，他们曾经曾开发了网景浏览器的源代码，并走向世界，如今在尽最后的努力来挽救公司。其结果是计算机历史上一个了不起的瞬间，拍摄做这工作的，是第一个内部测试版的人，此刻杰米Zawinski撰写上传的第一个建立公开的应用程序，通过集体会议宣布AOL的收购。它开启了了全国性的PBS在2000年3月，也是互联网泡沫崩溃的开始。</p><p><strong>精彩影评：</strong></p><blockquote><p>随着互联网企业如百度，腾讯等的兴起，越来越多的人投身于这一充满神秘感的行业。这里有一夜致富的神话，这里的人年轻而又新潮，这里的人在做着世界上最酷的事情。这就是互联网创业。</p><p>硅谷无异是此道中执牛耳的地方。google，facebook等公司和斯坦福大学一起让这里成为世界上计算机互联网技术最高点。人们惊讶，羡慕，甚至嫉妒于这些如梦幻般的生活和故事，于是找到了一部并不算新的纪录片：Code Rush。（IT纪录片很少，也许是这个行业太年轻以至于忘记了拍摄周年写真）。</p><p>少数真正点开这部电影并花费一小时看完的人都会为结局感到迷茫：不为屏幕中人，而为自己。因为自己正是其中的一员。在摄像头打开的瞬间中，网景公司和她的员工们正在避免被微软击败后一蹶不振。（关于网景公司和微软的浏览器之争请百度）接下来，镜头随着一个个程序员的角度讲述着这个世界上最高富帅最吸引人的行业是如何运行的：发福的胖子；不做作业却编代码的小孩；吃住在电脑前的狂人…种种努力，拼搏，协作，永不言弃精神短短的几十分钟里体现的淋漓尽致。”我们没有被打败，我们在做改变世界的事。历史会见证的。”</p><p>可是电影的最后却转向华尔街，点出了一切的一切：他们（程序员）所有的致富梦都在我们这里。而华尔街的贪婪和无情众所周知。出于对网景公司战胜微软前景的不看好（背景：当时创业者找投资时都会被问到”微软会不会感兴趣？”），大家的努力，mozilla开源社区的建立，最终也没有挽回资金链断裂不得不卖给AOL的事实。当大家真正放下手头的工作，回首自顾：自己已经习惯不在家的日子，孩子很久没见过了，妻子已经分居甚至（离婚）。自己的健康不再，心也疲惫。曾经的伙伴各奔前途。繁华散尽，原来他们也是最普通的人。</p><p>相对于媒体给大家宣传的种种，这部纪录片更多的讲述了IT行业的残酷。有得必有失，也许光鲜如马克•扎克伯格现实中却缺少很多常人的快乐。男人因孤独而优秀。通宵面对计算机屏幕是一种方式，但不是唯一的一种。</p><p>这里所说的程序员并不等同当下敲代码的”打字员”。</p></blockquote><h1 id="四、现代生活的秘密规则：算法（The-Secret-Rules-of-Modern-Living-Algorithms）"><a href="#四、现代生活的秘密规则：算法（The-Secret-Rules-of-Modern-Living-Algorithms）" class="headerlink" title="四、现代生活的秘密规则：算法（The Secret Rules of Modern Living: Algorithms）"></a>四、现代生活的秘密规则：算法（The Secret Rules of Modern Living: Algorithms）</h1><p><strong>影片介绍（我就不翻译了）：</strong></p><p>Without us noticing, modern life has been taken over. Algorithms run everything from search engines on the internet, to sat navs and credit card data security - they even help us travel the world, find love and save lives.</p><p>Mathematician Professor Marcus du Sautoy demystifies the hidden world of algorithms. By showing us some of the algorithms most essential to our lives, he reveals where these 2,000-year-old problem solvers came from - how they work, what they have achieved and how they are now so advanced they can even programme themselves.</p><p><strong>精彩影评：</strong></p><blockquote><p>原来算法在我们的生活中早已无处不在，从排序，搜索引擎，飞机起飞顺序，路程选择，游戏，大型自动仓库……最后部分是机器学习，由机器自己来发现算法。</p></blockquote><h1 id="五、密码破译者：布莱切利庄园的幕后英雄（Timewatch-Code-Breakers-Bletchley-Park’s-Lost-Heroes）"><a href="#五、密码破译者：布莱切利庄园的幕后英雄（Timewatch-Code-Breakers-Bletchley-Park’s-Lost-Heroes）" class="headerlink" title="五、密码破译者：布莱切利庄园的幕后英雄（Timewatch - Code-Breakers: Bletchley Park’s Lost Heroes）"></a>五、密码破译者：布莱切利庄园的幕后英雄（Timewatch - Code-Breakers: Bletchley Park’s Lost Heroes）</h1><p><strong>影片介绍：</strong></p><p>你是否知道，二战时期英国的破译中心—-布莱切利庄园。庄园位于伦敦以北50英里的BLETCHLEY PARK，由于最高军事机密，这个地名从未出现在任何地图上。布莱切利庄园默默无语，但它改变了整个世界。</p><p>纪录片 [密码破译中心—-布莱切利庄园]，介绍二战期间为破译纳粹德国顶级密码”金枪鱼密码”，英国在布莱切利庄园设立了监听站。因为德军一次小小疏忽，英国破译者成功破译了密码。情报人员截获了纳粹德国元首希特勒与其数名高级将领的密电，由此二战库尔斯克战役成为转折点，苏军一路攻克柏林。 布莱切利庄园的英雄们使二战缩短了至少两年时间，挽救无数生命免遭涂炭，取得了伟大胜利。</p><p>影片介绍了庄园里三位天才的丰功伟绩。阿兰•图灵破译了德国的 Enigma 密码。2014年3月25日，布莱切利庄园当年那支破译小组的最后一位成员，二战密码破译界里程碑式的人物雷蒙德•罗伯特上尉与世长辞，享年93岁。历史上第一台计算机，也并非出自美国人之手。对世界计算机发展做出卓越贡献的两位伟人BILL TUTTE和 TOMMY FLOWERS，直到上世界七八十年代解密后，才开始给世界一个真相。其中BILL TUTTE后来移民加拿大，并一直在UNIVERSITYOF WATERLOO工作，这也是为什么滑铁卢大学的计算机专业是世界文明的一个原因吧。</p><p><strong>精彩影评：</strong></p><blockquote><p>1、德军的密报员偷懒疏忽，导致一系列的溃败，真是一着不慎满盘皆输；</p><p>2、一群天才抓住一个小疏忽从而改变时局，机会永远只留给有准备且专业知识过硬的人；</p><p>3、唯才是举，众生平等，把合适的人用到合适的岗位上才是正道，一切搞血统论、阶级成分论的人最终都会被历史证明是愚蠢透顶的。</p></blockquote><h1 id="六、谷歌与世界头脑（Google-and-the-World-Brain）"><a href="#六、谷歌与世界头脑（Google-and-the-World-Brain）" class="headerlink" title="六、谷歌与世界头脑（Google and the World Brain）"></a>六、谷歌与世界头脑（Google and the World Brain）</h1><p><strong>影片介绍：</strong></p><p>都说人类从未放弃巴别塔之梦。20 世纪30 年代着名科幻作家威尔斯的《世界大脑》预言，70 年后由智能先锋谷歌变相实现。一个要把全世界书籍扫描贮藏，旷古绝今的智库建设计划，其实已在我们半知不晓下火速进行。12 年来，数以百万计被收藏的书籍被侵犯版权，计划背后隐约浮现的超级人工智能图像，都令人惊惧交集，疑怒不休。一场紧繫知识意义和人类文化前途的划时代官司，如尖刀剖开文明之梦想两难。「待我谷歌一下」的日常琐语从此显得曲折而沉重。</p><p><strong>精彩影评：</strong></p><blockquote><p>1938年，科幻小说家赫伯特•乔治•威尔斯（发表过《世界大战》等作品）出版了《世界脑》一书。在这本书中，他着重介绍了世界脑概念，与构建一个世界规模的知识库有关。世界脑汇聚了全人类的知识，以便任何人都能够在需要的时候查询。</p><p>如今，谷歌图书计划正好符合了威尔斯的世界脑构想。这个计划希望把全世界的书籍都数字化，以便用户搜索。</p><p>正当谷歌的计划初具规模时，作者们因版权问题开始奋起反击。于是，谷歌只好缩减这项计划，仅收录没有版权的书籍。</p><p>然而，在某些科技人士眼里，版权却不是他们最关心的问题。在谷歌创业初期，《失控》的作者KK曾向该公司的创始人提出一个疑问，既然当时互联网已经有比较好的搜索引擎，为什么谷歌还要开展这项业务？谷歌创始人回答说：他们是在做人工智能。</p><p>现在看来，谷歌做的正是全球规模的人工智能。它依靠庞大的服务器群（计算能力），先进的软件（算法），以及来自互联网的海量数据（同时也是海量信息与海量知识），将人工智能提升到了前所未有的高度。</p></blockquote><h1 id="七、极速下载的命运（Downloaded）"><a href="#七、极速下载的命运（Downloaded）" class="headerlink" title="七、极速下载的命运（Downloaded）"></a>七、极速下载的命运（Downloaded）</h1><p><strong>影片介绍：</strong></p><p>纪录P2P传输始祖Napster音乐分享网站的兴起与没落，导演亚历士温特藉此一窥网路科技对于音乐产业的巨大影响。虽然整个网站后台随着与唱片公司版权诉讼的争议而宣告终止，但新兴网路自由的圣战，才正要掀起一股时代的浪潮。</p><p><strong>精彩影评：</strong></p><blockquote><p>这是一部关于Napster的纪录片。这个软件有多牛逼呢？你现在用的p2p技术，都有它的雏形。就连早期iTunes界面都那么像它。通过这个软件的兴衰经历，反应了网络共享文化对传统产业，尤其是唱片业的冲击。而且这也是唱片工业史上第一次，科技没有帮助这个产业赚钱，而是让这个产业产生了恐惧。</p></blockquote><h1 id="八、第四公民（Citizenfour）"><a href="#八、第四公民（Citizenfour）" class="headerlink" title="八、第四公民（Citizenfour）"></a>八、第四公民（Citizenfour）</h1><p><strong>影片介绍：</strong></p><p>《第四公民》高度还原”棱镜门”事件始末，为观众真实揭秘身处漩涡中心的爱德华•斯诺登。</p><p>纪录片导演柏翠丝本人也是”棱镜门”事件的核心人物，正是在她和《卫报》记者格仑•格林沃德的协助下，斯诺登才得以将美国国家安全局的监控丑闻公之于众。而柏翠丝与格林沃德也因此荣获普利策奖。片名”第四公民”（citizen four）正是斯诺登早期与柏翠丝邮件沟通时使用的匿名代号。2013年6月，当柏翠丝第一次飞往香港与斯诺登见面的时候，她随身携带的摄像机也真实记录了当时的场景。《第四公民》将能高度还原”棱镜门”事件始末，为观众真实揭秘身处漩涡中心的爱德华•斯诺登。</p><p>原来斯诺登在身份没有公开之前就一直和本片导演劳拉•波特拉斯以及卫报的记者匿名联系，所以片子从第一封邮件，到第一篇新闻，再到公开身份，他为了更多的声音，其实做了一个天大的决定，没有人知道明天甚至下一个小时会怎样，电影却举重若轻地，似乎只是展示他几天的日常生活。太勇敢了。</p><p><strong>精彩影评：</strong></p><blockquote><p>原来斯诺登在身份没有公开之前就一直和本片导演劳拉•波特拉斯以及卫报的记者匿名联系，所以片子从第一封邮件，到第一篇新闻，再到公开身份，他为了更多的声音，其实做了一个天大的决定，没有人知道明天甚至下一个小时会怎样，电影却举重若轻地，似乎只是展示他几天的日常生活。太勇敢了。</p></blockquote><h1 id="九、我们窃取秘密：维基解密的故事（We-Steal-Secrets-The-Story-of-WikiLeaks）"><a href="#九、我们窃取秘密：维基解密的故事（We-Steal-Secrets-The-Story-of-WikiLeaks）" class="headerlink" title="九、我们窃取秘密：维基解密的故事（We Steal Secrets: The Story of WikiLeaks）"></a>九、我们窃取秘密：维基解密的故事（We Steal Secrets: The Story of WikiLeaks）</h1><p><strong>影片介绍：</strong></p><p>纪录片饶有兴趣地从多种层面描写了信息时代的透明度和我们对真相的永远不依不饶的探寻。影片详述了朱利安•阿桑奇(Julian Assange)维基解密网站(WikiLeaks)的诞生，这个网站助长了美国有史以来最大的安全缺口。影片描述了这一神秘网站的兴衰，其中穿插着美国陆军士兵布拉德利•曼宁(Bradley Manning)泄密事件，这个令人不安的高智商士兵从美国军事和外交服务器上下载了几十万个文档。</p><p><strong>精彩影评：</strong></p><blockquote><p>2013最佳纪录片剧本。提供多方面的阐述，让观者自己判断。阿桑奇作为一个理想主义的黑客的多面与复杂性是人性在一个特殊新奇的载体上的有趣的呈现。</p></blockquote><h1 id="十、现实生活中的海盗湾（TPB-AFK-The-Pirate-Bay-Away-from-Keyboard）"><a href="#十、现实生活中的海盗湾（TPB-AFK-The-Pirate-Bay-Away-from-Keyboard）" class="headerlink" title="十、现实生活中的海盗湾（TPB AFK: The Pirate Bay Away from Keyboard）"></a>十、现实生活中的海盗湾（TPB AFK: The Pirate Bay Away from Keyboard）</h1><p><strong>影片介绍：</strong></p><p>21世纪初，一个标榜着”实现真正的言论和文化传播自由”的网站横空出世。它就是日后大名鼎鼎并惹来无数争议的最大的档案分享网站海盗湾（Pirate Bay）。该网站由高特弗里德•萨特霍姆•瓦格、弗雷德里克•内伊以及彼得•桑德三个瑞典人创立，他们的精神和魄力得到来自全世界复制派（海盗党）的热烈支持，与此同时也遭到号称损失高达61亿美金的版权方的嫉恨。2008年，以好莱坞为首的巨头向海盗湾提起诉讼，三位创始人不得不”离开键盘”，与检方展开一连串的周旋。</p><p>一方以法律为手段，一方以技术为武器。这不仅是一场来自不同价值观阵营的战争。</p><p><strong>精彩影评：</strong></p><blockquote><p>一直认为海盗湾就是个奇迹，居然在老美和瑞典政府如此的重压之下，依然屹立不倒，至今仍然可以访问，下载。</p><p>电影以记录片的形式讲述海盗湾三位创始人被告的始末，虽然此片的视点基本上站在被告的立场，但依然可以看出版权之争在现代社会中的影响。</p><p>片名AFK是Geek术语，电影也带着观众一窥真实世界中的Geek生活。最后众人入狱的结局令人扼腕。</p></blockquote><p><em>来自：简书</em><br><em>作者：Jaky_Zhan</em><br><em>链接：<a href="http://www.jianshu.com/p/2dd54ec0bb43">http://www.jianshu.com/p/2dd54ec0bb43</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】为什么计算机程序的结构和解释很重要</title>
      <link href="/posts/2024-07-14-why-sicp-matters.html"/>
      <url>/posts/2024-07-14-why-sicp-matters.html</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://people.eecs.berkeley.edu/~bh/sicp.html">https://people.eecs.berkeley.edu/~bh/sicp.html</a></p><p>2011年，为庆祝麻省理工学院建校150周年，《波士顿环球报》列出了在 MIT 那里开发的最重要的创新。他们希望我能解释一下 SICP 的重要性，这是我发给他们的：</p><p>SICP 在许多方面都是革命性的。最重要的是，它极大地提高了介绍性知识内容的标准计算机科学。在 SICP 之前，第一门 CS 课程几乎都是完全充满了学习某种编程语言的细节。 SICP 是关于从细节中退一步来学习大局的方法思考编程过程。它将注意力集中在抽象的中心思想——从具体中发现一般模式问题并构建体现每种模式的软件工具。它使大量使用函数作为数据的想法，这是一个很难学习的想法最初，但一旦学会就会非常强大。（这也是同样的想法，以不同的形式，这使得新生微积分变得非常困难，甚至对于在早期数学课程中表现良好的学生。）它符合第一门计算机科学课程三种不同的编程范例（函数式、面向对象和声明性），而大多数其他课程甚至没有真正讨论哪怕是一种范式。</p><p>另一项革命是选择Scheme作为编程语言。直到今天，大多数计算机科学的介绍都使用当下的“热门”语言：从 Pascal 到 C 到 C++ 到 Java 到 Python。该方案从未在工业界得到广泛应用，但它是完美的 CS 简介语言。一方面，它有一个非常简单的，一切事物的统一符号。其他语言有一种表示法变量赋值，条件执行的另一种表示法，两个或另外三个用于循环，还有一个用于函数调用。课程教这些语言至少要花一半的时间来学习符号。在我在伯克利的基于 SICP 的课程中，我们花了第一个小时关于符号，这就是我们所需要的；在这个学期剩下的时间里，我们学习思想，而不是语法。此外，尽管（或由于）其简单性， Scheme是一种非常通用的语言，使我们能够检查这三种编程范式，特别是让我们看看如何 实现了面向对象编程，所以OOP语言似乎没有对我们的学生来说就像魔法一样。 Scheme 是 Lisp 的一种方言，所以它很棒将函数作为数据处理，但相比之下它是一个精简版本到更常用于专业编程的那些，最少的花哨的东西。阿贝尔森和萨斯曼非常勇敢以尽可能最好的教学语言教授他们的入门课程，而不注意所有工作都在进行中的抱怨其他一些语言。他们认为，一旦你了解了伟大的想法，这也是我的经验，学习另一种编程语言不是一件大事；这是周末的一件苦差事。我告诉我的学生，“语言你将在其中度过大部分工作生涯的方式尚未发明，所以我们无法教你。相反，我们必须为您提供您所需要的技能需要学习新语言的出现。</p><p>最后，SICP对大学新生的未来充满信心预期完成。 SICP 学生编写编程解释器语言，通常被认为更适合大三或大四的学生。文本本身并不容易阅读；它没有侧边栏并且是彩色的盒子和有趣的图片代表了现代教科书的目标注意力持续时间低的学生。没有多余的练习；每个锻炼教会了一个重要的新观念。它使用大词。但它回报了细读；每句话都很重要。</p><p>据统计，基于 SICP 的课程只占少数。但这本书其影响力超出了少数人。给后来的很多人带来了启发作者有意识地努力达到 SICP 标准的教科书。这方案作为学习者语言的使用已被其他人扩展了超过范围从中学到研究生。即使是比较主流的课程尽管大多数人对编程范式的想法变得敏感他们专注于面向对象的编程。计算机的想法科学应该是关于思想，而不是完全关于编程实践，此后扩大到包括有关背景和社会的非技术想法计算的影响。</p><p>SICP 本身拥有悠久的历史，这对于入门 CS 来说是非常不寻常的教科书。通常，一本书的寿命取决于它所采用的语言的流行程度。被附上。 SICP 已强劲发展超过 25 年，且没有任何迹象绝版。在那段时间里，计算发生了巨大的变化，从巨型大型计算机到个人计算机到移动互联网电话。然而这些变化背后的重要理念仍然是一样的，而且 SICP 很好地捕获了这些信息。</p><p>自 1987 年以来，我一直在教授基于 SICP 的课程。该课程已发生变化在此期间逐渐增加；我们添加了有关并行性、并发性的部分控制、用户界面设计和客户端&#x2F;服务器范例。但它是本质上仍然是相同的课程。每隔五年左右，就会有人教师建议我们的第一门课程应该使用 X 语言；每个那时，我说“当有人写出世界上最好的计算机科学书籍时使用 X 语言，那就没问题了”，到目前为止，教员们总是投票支持继续学习 SICP 课程。我们很快就会知道该课程是否可以度过我自己的退休生活。</p><blockquote><p>（脚注：不。伯克利大学新开设的第一门专业课程使用 Python，以及试图保留 SICP 的思想（和一些文本）的讲义。）</p></blockquote><p>最近的讨论更加激烈，因为麻省理工学院经历了一场重大的变革重新设计低年级 EECS 课程。麻省理工学院以外的人倾向于将重新设计总结为“麻省理工学院决定切换到 Python”，但这不是一个感性的描述。麻省理工学院决定放弃课程围绕主题组织（编程范例，然后是电路，然后是信号处理，然后是架构）到围绕应用程序组织的课程（让我们构建一个机器人并对其进行编程；让我们构建一个手机并对其进行编程）。他们课程的一切都必须重新组织；的选择编程语言是这些决定中最不重要的。他们的新方法是更难教；一方面，每门课程都需要合作伙伴电气工程学院和计算机科学学院。也许及时应用优先的方法将引发一场意义深远的革命这是 SICP 之后的事情，但还没有发生。</p><p>根据我的经验，很少有学生意识到他们在我的课程中学到了多少有价值的内容。但是在调查所有的计算机科学专业的学生，SICP成为了最受欢迎的课程之一。回想起来，我经常收到早已离开的学生的邮件，告诉我他们是如何在工作中使用他们的想法的是学生时代不切实际的象牙塔观念。基于函数式编程里面发明的 MapReduce 软件在 Google 上用于数据并行处理帮助消除了象牙塔的声誉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Lisp </tag>
            
            <tag> Computer Sciense </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】2024 年真实世界加密主题</title>
      <link href="/posts/2024-07-14-themes-from-real-world-crypto-2024.html"/>
      <url>/posts/2024-07-14-themes-from-real-world-crypto-2024.html</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://blog.trailofbits.com/2024/06/18/themes-from-real-world-crypto-2024/">https://blog.trailofbits.com/2024/06/18/themes-from-real-world-crypto-2024/</a></p><p>三月，Trail of Bits 的工程师们前往了充满活力 (而且稍微有点冷) 的多伦多市，参加了为期三天的 Real World Crypto 2024 大会，该大会汇集了数百位密码学领域的杰出人才。 我们还参加了三个相关活动：Real World 后量子密码 (RWPQC) 研讨会、全同态加密 (FHE) 研讨会和开源密码学研讨会 (OSCW)。 经过回顾活动中的演讲和专家讨论，我们总结了一些突出的主题：</p><ol><li>政府、标准化组织和业界在推进后量子密码 (PQC) 标准化和落地方面取得了重大进展。</li><li>在后量子密码标准之外，我们看到了利用基于格的结构进行更先进的后量子密码的创新。</li><li>对端到端加密（E2EE）和密钥透明度的投资在多个组织中正变得越来越重要。</li></ol><p>还有一些值得一提的领域：</p><ol><li>全同态加密（FHE）是一个活跃的研究领域，并且变得越来越实用。</li><li>带有关联数据的认证加密方案（AEAD）也是一个活跃的研究领域，并且正在进行许多改进。</li></ol><p>请继续阅读我们的完整想法！</p><h1 id="行业和政府如何落地PQC"><a href="#行业和政府如何落地PQC" class="headerlink" title="行业和政府如何落地PQC"></a>行业和政府如何落地PQC</h1><p>自 25 年前开始（持续）努力用椭圆曲线加密取代 RSA 和 DSA 以来，社区正在为最大规模的加密迁移做准备。 PQ 专用 RWPQC 研讨会和 RWC 主要活动的讨论重点是标准化工作和大规模实际部署。谷歌、亚马逊和 Meta 报告称内部部署取得了初步成功。</p><p>会谈的核心要点包括：</p><ul><li>国际社会已广泛接受 NIST 后量子算法作为标准。 Signal 等更高级别的协议正忙于整合新算法。</li><li>先存储后解密攻击需要尽快转向后量子密钥交换协议。对于遵循良好密钥轮换实践的应用程序来说，后量子身份验证（签名方案）并不那么紧迫。</li><li>后量子安全只是加密敏捷性的一方面。良好的加密库存和密钥轮换实践使 PQ 迁移更加顺利。</li></ul><p>RWPQC 收录了四个标准机构的演讲。这些会谈表明采用 PQC 的努力正在顺利进行。达斯汀·穆迪 (NIST) 强调，美国政府和美国工业界的目标是到 2035 年做好量子准备，而马修·坎帕尼亚 (ETSI) 则讨论了 60 多个国家的 850 多个组织之间的协调工作。 Stephanie Reinhardt (BSI) 警告称，与加密相关的量子计算机可能会在 2030 年代初上线，并分享了 BSI 的<a href="https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.html">加密机制技术指南</a>。 Reinhardt 还警告不要依赖量子密钥分发，并列举了近 200 起针对 QKD 实施的已发布攻击。与更常见和谨慎的混合方法相比，NCSC 提倡单独使用 ML-KEM 和 ML-DSA。</p><p>虽然所有标准机构都支持 FIPS 算法，但 BSI 还支持使用 NIST 竞赛决赛入围者 FrodoKEM 和 McEliece。</p><p>Deidre Connelly 代表 IETF 的多个工作组，谈到了她一直在编写的 KEM 组合器指导文件以及围绕 <a href="https://durumcrustulum.com/2024/02/24/how-to-hold-kems/">KEM 绑定属性</a>正在进行的讨论（来自 CFRG 工作组）。她还提到了 TLS 工作组的进展：PQC 将仅在 TLS v1.3 中进行，主要重点是完善各种关键协议规范。 LAMPS 工作组正在致力于将 PQC 算法纳入加密消息语法和互联网 X.509 PKI。最后，PQUIP 正在致力于在更多协议中引入 PQC 的操作和工程方面，MLS 工作组正在致力于在 MLS 中引入 PQC.</p><p>行业视角同样富有洞察力，来自主要科技公司的代表分享了一些关键见解：</p><ul><li><strong>Signal</strong>：Rolfe Schmidt 介绍了 Signal 融合后量子密码学的幕后工作，例如他们最近开发后量子密钥协商协议 <a href="https://signal.org/docs/specifications/pqxdh/">PQXDH</a> 的工作。他们前进的重点领域包括针对量子攻击者提供前向保密和妥协后的安全性，实现完全后量子安全的信号协议和匿名凭证。</li><li><strong>Meta&#x2F;Facebook</strong>：Meta 通过宣布加入 PQC 联盟来展示其对 PQC 的承诺。他们的代表 Rafael Misoczki 还讨论了成功 PQC 迁移的先决条件：密码学库和应用程序必须支持 PQ 算法的轻松使用，明确阻止创建新的量子不安全密钥，并提供针对已知量子攻击的保护。此外，迁移必须是高性能且经济高效的。</li><li><strong>谷歌</strong>：谷歌的 Sophie Schmieg 阐述了他们管理密钥轮换和加密敏捷性的方法，强调后量子迁移实际上是一个密钥轮换问题。如果您有一个良好的密钥轮换机制，并且您正确地将密钥指定为加密配置和原始密钥字节，而不仅仅是原始字节，那么您基本上就可以迁移到后量子。</li><li>**Amazon&#x2F;Amazon Web Services (AWS)**：Matthew Campagna 总结了行业最新动态，并介绍了 AWS (AWS) 在保护其加密技术免受量子对手攻击方面所取得的进展。与大多数其他人一样，他们最关心的是“现在存储，稍后解密”攻击。</li></ul><h1 id="更多-PQC：先进的晶格技术"><a href="#更多-PQC：先进的晶格技术" class="headerlink" title="更多 PQC：先进的晶格技术"></a>更多 PQC：先进的晶格技术</h1><p>除了政府和行业团体都承诺采用最新的 PQC NIST 标准外，今年的 RWC 还展示了在 PQC 其他领域正在开展的大量工作。特别是，我们参加了两次关于使用格构建的新密码原语的有趣演讲：</p><ul><li>LaZer：LaZer 是一个有趣的库，它使用格来促进高效的零知识证明（ZKP）。对于某些指标，该证明系统比当前一些最先进的证明系统实现了更好的性能。然而，由于LaZer使用格，其算术与现有的R1CS和Plonkish证明系统完全不同。这意味着它无法与现有的开箱即用的电路编译器一起使用，因此将其推进到现实系统将需要额外的努力。</li><li>Swoosh：另一个讨论集中在 Swoosh，这是一种为高效的基于格子的非交互式密钥交换而设计的协议。在我们必须依赖后量子密钥封装机制 (KEM) 而不是后量子 Diffie-Hellman 方案的时代，开发具有后量子质量的鲁棒密钥交换协议是向前迈出的一大步，也是一个有前途的研究领域。</li></ul><h1 id="端到端加密和密钥透明度"><a href="#端到端加密和密钥透明度" class="headerlink" title="端到端加密和密钥透明度"></a>端到端加密和密钥透明度</h1><p>端到端（E2E）加密和密钥透明度是会议的一个重要主题。几个亮点：</p><ul><li>关键透明度总体情况：Melissa Chase 对关键透明度的未决问题和最新进展进行了精彩的概述介绍。密钥透明度在端到端加密中发挥着至关重要的作用，允许用户在不依赖带外通信的情况下检测中间人攻击。</li><li>确保 Zoom 的 E2EE 安全：研究员 Mang Zhu 分享了他们提高 Zoom E2EE 安全性的方法，特别是防止来自恶意服务器的窃听或假冒攻击。他们的策略在很大程度上依赖于密码验证密钥交换（PAKE）和关联数据验证加密（AEAD），为用户提供更安全的通信层。然后他们使用正式方法来证明他们的方法达到了目标。</li><li>Meta 上的 E2EE 采用：Meta&#x2F;Facebook 逐步记录了他们在 Messenger 上推出 E2EE 的历程。用户在升级到 E2EE 时会遇到很大的阻力，因为他们突然需要采取行动，以确保在丢失设备时能够恢复数据。在某些情况下，例如贴纸搜索，Meta 决定优先考虑功能和隐私，因为在客户端存储整个贴纸库是令人望而却步的。</li></ul><h1 id="荣誉奖"><a href="#荣誉奖" class="headerlink" title="荣誉奖"></a>荣誉奖</h1><p><strong>AEAD</strong>：在对称密码学中，带有关联数据的身份验证加密方案 (AEAD) 是今年讨论的核心。围绕 Poly1305 和 AES-GCM 的深入对话表明了对改进这些加密工具的持续致力于。我们正在准备一篇专门的文章来介绍这些令人兴奋的进步，敬请期待！</p><p><strong>FHE</strong>：FHE的突破证明了全同态加密的持续进步。研究人员提出了创新的理论进展，例如基于带舍入的环学习的新同态方案，该方案显示出在某些指标下相对于当前方案实现更好性能的迹象。另一场突破性的演讲重点介绍了 HEIR 编译器，这是一个加速 FHE 研究的工具链，有可能简化从理论到实际实现的过渡。</p><h1 id="2024-年-Levchin-奖获得者"><a href="#2024-年-Levchin-奖获得者" class="headerlink" title="2024 年 Levchin 奖获得者"></a>2024 年 Levchin 奖获得者</h1><p>每年都有两个团队在 RWC 上获得 Levchin 奖，以表彰其对密码学及其实际应用的重大贡献。</p><p>Al Cutter、Emilia Käsper、Adam Langley 和 Ben Laurie 因大规模创建和部署证书透明度而获得 Levchin 奖。证书透明度建立在相对简单的加密操作之上，但对互联网安全和隐私具有巨大的积极影响。</p><p>Anna Lysyanskaya 和 Jan Camenisch 因开发高效的匿名凭证而获得了另一项 2024 年 Levchin 奖。随着越来越多的应用程序使用它们，他们 20 年前的开创性工作变得越来越重要。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>Real World Crypto 2024 会议以及 FHE、RWPQC 和 OSCW 活动为密码学的最新技术和未来方向提供了丰富的见解。随着该领域的不断发展，随着政府、标准机构和行业参与者的合作，进一步了解加密世界的细微差别，我们期待在 PQC、E2EE、FHE 和许多其他令人兴奋的领域不断取得进步。这些进展反映了我们的集体使命，即确保安全的未来，并强调整个密码学界正在进行的研究、合作和参与的重要性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fix docker-ce GPG error in apt update on ubuntu</title>
      <link href="/posts/2024-06-22-docker-ce-gpg-error-in-apt-update-on-ubuntu.html"/>
      <url>/posts/2024-06-22-docker-ce-gpg-error-in-apt-update-on-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>Problem shown as in <code>$ sudo apt update</code></p><pre><code>$ sudo apt updateHit:1 https://mirrors.ustc.edu.cn/ubuntu focal InReleaseHit:2 https://mirrors.ustc.edu.cn/ubuntu focal-updates InReleaseHit:3 https://mirrors.ustc.edu.cn/ubuntu focal-backports InReleaseHit:4 https://mirrors.ustc.edu.cn/ubuntu focal-security InReleaseGet:5 https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu focal InRelease [57.7 kB]Ign:5 https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu focal InReleaseHit:8 https://esm.ubuntu.com/apps/ubuntu focal-apps-security InReleaseHit:9 https://esm.ubuntu.com/apps/ubuntu focal-apps-updates InReleaseHit:10 https://esm.ubuntu.com/infra/ubuntu focal-infra-security InReleaseHit:11 https://esm.ubuntu.com/infra/ubuntu focal-infra-updates InReleaseFetched 57.7 kB in 2s (24.4 kB/s)Reading package lists... DoneBuilding dependency treeReading state information... DoneAll packages are up to date.W: GPG error: https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu focal InRelease: The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY 7EA0A9C3F273FCD8</code></pre><p>Solve with:</p><pre><code>$ sudo mkdir -p /etc/apt/keyrings$ sudo curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg$ sudo chmod a+r /etc/apt/keyrings/docker.gpg</code></pre><p>Edit <code>/etc/apt/sources.list.d/docker.list</code> as:</p><pre><code>deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu focal stable</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Docker </tag>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins Environment Variables</title>
      <link href="/posts/2024-06-14-jenkins-environment-variables.html"/>
      <url>/posts/2024-06-14-jenkins-environment-variables.html</url>
      
        <content type="html"><![CDATA[<pre><code>BRANCH_NAME=develop/snipeBUILD_DISPLAY_NAME=#3BUILD_ID=3BUILD_NUMBER=3BUILD_TAG=jenkins-hello-world-develop%2Fsnipe-3BUILD_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/3/CI=trueDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/0/busDOCKER_CLI_EXPERIMENTAL=enabledEXECUTOR_NUMBER=1GIT_BRANCH=develop/snipeGIT_COMMIT=fb060e3833b2d5db61b15fca806489b626a89418GIT_PREVIOUS_COMMIT=e8b2fdcdc39aadca2c4b0991fa1a00564447a0f0GIT_PREVIOUS_SUCCESSFUL_COMMIT=7771ab2ab9f82f49d3dc691a99129e0a5c4b1877GIT_URL=https://gitlabwh.uniontech.com/wuhan/web/adp/deploy/hello-world.gitHUDSON_COOKIE=4e6c6e79-cd1b-4486-9aff-c17eac8c636dHUDSON_HOME=/var/jenkins_homeHUDSON_SERVER_COOKIE=35002450c7ddd0e1HUDSON_URL=http://10.20.30.40:8080/JENKINS_HOME=/var/jenkins_homeJENKINS_NODE_COOKIE=f6922b98-89e8-49cf-b18d-89e2daa0da96JENKINS_SERVER_COOKIE=durable-b97afb9a3dcb4f29b70420af66d83169bbf7a090e119ae1ec795572fce2fd846JENKINS_URL=http://10.20.30.40:8080/JOB_BASE_NAME=develop%2FsnipeJOB_DISPLAY_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/display/redirectJOB_NAME=hello-world/develop%2FsnipeJOB_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/LANGUAGE=zh_CNLANG=zh_CN.UTF-8NODE_LABELS=anunnaki3NODE_NAME=anunnaki3OLDPWD=/data/jenkins-workspace/workspace/hello-world_develop_snipePATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPWD=/data/jenkins-workspace/workspace/hello-world_develop_snipeRUN_ARTIFACTS_DISPLAY_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/3/display/redirect?page=artifactsRUN_CHANGES_DISPLAY_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/3/display/redirect?page=changesRUN_DISPLAY_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/3/display/redirectRUN_TESTS_DISPLAY_URL=http://10.20.30.40:8080/job/hello-world/job/develop%252Fsnipe/3/display/redirect?page=testsWORKSPACE=/data/jenkins-workspace/workspace/hello-world_develop_snipeWORKSPACE_TMP=/data/jenkins-workspace/workspace/hello-world_develop_snipe@tmp</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】全同态加密的高级技术概述</title>
      <link href="/posts/2024-05-23-a-high-level-technical-overview-of-fully-homomorphic-encryption.html"/>
      <url>/posts/2024-05-23-a-high-level-technical-overview-of-fully-homomorphic-encryption.html</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://www.jeremykun.com/2024/05/04/fhe-overview/">https://www.jeremykun.com/2024/05/04/fhe-overview/</a></p><p>大约两年前，我在谷歌换了团队，开始专注于全同态加密（简称FHE，有时也称为HE）。从那时起，我参与了许多有趣的项目，并在此过程中学习了后量子密码学、编译器设计以及全同态加密的方方面面。</p><p>如果你听说过全同态加密（FHE）并且是软件行业的人，你可能听说过两点：它允许在不解密的情况下直接对加密数据运行程序；但它仍然太慢，无法用于任何实际用途。除此之外，很少有资源能比40页的研究论文更易于理解地对这一领域进行概述（如果你想要这样的资源，<a href="https://eprint.iacr.org/2022/1602">这里有一篇2022年的论文</a>）。本文将提供这样一个概述——技术性但仍然足够高层次，使你能够更好地了解这一技术的工作原理以及该领域的发展方向。另外，FHE.org上还有一篇不错的<a href="https://fhe.org/history/">FHE研究简史</a>。</p><p><strong>免责声明</strong>：由于我在这个领域只有两年的经验，我觉得有必要提醒你，我并不是专家。我没有在全同态加密（FHE）方面发表过任何原创研究，并且我的知识中存在相当大的空白。然而，我进入这个领域的目的是将尽可能多的有用技术整合到我目前的主要项目中： <a href="https://heir.dev/">HEIR 编译器工具链</a>。因此，我对任何特定的FHE方法都没有偏见。我也不会包括出版物的时间线或增量改进的引用图。相反，我将专注于从我的角度来看处于该领域前沿的一部分技术。</p><h1 id="最高层次的视角"><a href="#最高层次的视角" class="headerlink" title="最高层次的视角"></a>最高层次的视角</h1><p>我在午餐时间向我的软件工程师同事们解释同态加密的说法。</p><p>同态加密让你可以以一种特殊的方式加密数据，使得你可以在不解密数据的情况下运行程序。这意味着运行程序的计算机在运行程序时无法访问底层数据——无论是通过中间计算值，还是通过最终结果。特别是，如果一个不法分子能够访问计算机的原始内存，他们仍然无法获取任何关于底层数据的信息（前提是密码学没有被破解）。用户向程序发送加密输入，当程序完成后，加密结果会被发送回用户，由用户进行解密。</p><p>在加密数据上运行程序听起来像是魔法。它的实现是通过选择一种加密方案，使其在以下意义上与加法和乘法“兼容”：</p><ul><li>对密文进行加法运算会得到底层明文之和的加密。</li><li>将两个密文相乘会得到底层明文之积的加密。</li></ul><p>有了这种能力，你可以逐位加密你的数据，将你的程序表示为一个布尔电路——XOR门是加法，AND门是乘法——然后模拟这个电路。由于XOR和AND形成了布尔逻辑的通用基础，你总是可以这样分解一个电路。<a href="https://www.jeremykun.com/2024/05/04/fhe-overview/?continueFlag=fcaae36dd48c80ea2eea4df19d1409c2#fn:1">1</a></p><p>为了进一步阐述FHE理论上如何处理通用计算的观点，人们已经在FHE中实现了<a href="https://medium.com/optalysys/fully-homomorphic-encryption-and-the-game-of-life-d7c37d74bbaf">康威的生命游戏</a>以及<a href="https://www.usenix.org/system/files/sec21summer_matsuoka.pdf">完整的处理器架构</a>。</p><p>这其中有四个主要的注意事项。首先，仅仅使用布尔电路并不足以完成计算机能够完成的所有任务。电路总是会终止，因此如果不采取其他措施，你无法编写无限循环的程序。像正弦和指数函数这样的超越函数也有它们自己的挑战，因为用位运算模拟它们通常是不可行的，原因如下所述。</p><p>第二，模拟电路很慢，特别是考虑到为每个门进行加密解密的开销。慷慨地说，一个现代布尔门FHE实现需要大约1毫秒的时间来评估单个门，而没有任何特殊的硬件加速。将其与运行频率为2 GHz且每个（32位！）指令需要4个时钟周期的老式CPU进行比较，这相当于每个操作约1纳秒。如果你只是简单地将电路分解，运行FHE在CPU上至少比相应的未加密程序慢一百万倍。<a href="https://www.jeremykun.com/2024/05/04/fhe-overview/?continueFlag=fcaae36dd48c80ea2eea4df19d1409c2#fn:2">2</a></p><p>第三，加密保证意味着对可以使用的优化方法有所限制（即使你没有使用布尔电路方法），因为实现该优化必然会破坏加密。例如，不可能编写一个FHE程序，其使用的指令数量少于程序的最坏情况输入。这样做会暴露出输入不是最坏情况的信息，这与加密的安全性相矛盾。相反，一个FHE程序必须急切地计算所有if语句的分支，然后使用select语句决定应该使用哪个结果。相同的推理适用于循环：所有循环必须执行其最大迭代次数，实际上这意味着所有循环必须具有静态已知的上界。</p><p>第四，存在带宽问题。FHE加密方案通常会增加被加密数据的大小，用户还必须向服务器发送一组特殊的加密密钥来启用计算，这些密钥也相对较大。这些特殊密钥只需要生成和发送一次，就可以用于所有未来的计算，但它们的大小可能轻松达到几十GB。在一个具有轻量级密钥的FHE方案中的一个例子中，加密单个整数的密文大约为25 KB，而特殊密钥大约为0.5 GB。在其他方案中，可以将16000个或更多的整数打包到一个大小相似的单个密文中，但密钥可能会达到数十GB。</p><p>在后面的部分，我将描述FHE方案如何与或克服这些限制。</p><h1 id="FHE方案的共同点"><a href="#FHE方案的共同点" class="headerlink" title="FHE方案的共同点"></a>FHE方案的共同点</h1><p>本节将对支撑FHE的加密方案的工作原理进行稍微技术性的概述。下一节将提供更具体的细节，介绍特定的FHE方案及其不同的功能。</p><h2 id="LWE-和-RLWE"><a href="#LWE-和-RLWE" class="headerlink" title="LWE 和 RLWE"></a>LWE 和 RLWE</h2><p>所有现代的FHE方案都使用了实质上相同的加密基础：一个带有噪声的点积。在FHE方案中实际使用的最简单版本称为<a href="https://en.wikipedia.org/wiki/Learning_with_errors">学习有误差问题</a>，或LWE。</p><p>LWE加密支持通过将这些位放置在机器字的最高有效位来加密小位宽的整数。为了简单起见，假设它是一个4位整数，位于32位整数的最高位，其他所有位初始化为零，并将整个编码的明文称为 𝑚。秘密密钥 𝑠 是一个随机的长度为 𝑛 的二进制向量，选择的目的是实现一定的安全性——假设 𝑛&#x3D;800。然后进行加密，采样一个长度为 𝑛 的32位整数向量 𝑎，与秘密密钥 𝑠 做点积，加上消息 𝑚，然后加上来自与方案安全性密切相关的精心选择的分布的一些随机噪声。加密值既是随机选择的样本，也是噪声掩盖的结果，即 (𝑎, 𝑎⋅𝑠+𝑚+noise)。更准确地说，代码中表现为:</p><pre><code class="python">def encrypt(m, s, a, noise):  # the 28 below would realistically  # come from a config  clean_product = np.dot(a, s) + (m &lt;&lt; 28)  obfuscated_product = clean_product + noise  return np.append(a, obfuscated_product)</code></pre><p>噪声分布是最神秘的部分，我在这里不会详细介绍，但在大多数情况下，它被视为对称的整数值高斯分布，以零为中心，具有可调的方差。较大的方差意味着更高的安全性，但正如我稍后将讨论的那样，它会减少可以应用的同态操作的数量，直到底层消息被损坏，这反过来会影响性能，因为需要进行昂贵的清理操作来从高噪声密文中恢复。<a href="https://www.jeremykun.com/2024/05/04/fhe-overview/?continueFlag=fcaae36dd48c80ea2eea4df19d1409c2#fn:3">3</a></p><p>LWE解密然后将这个过程反转：重新计算点积，并从加密输出中减去它。但最后需要应用一个舍入步骤来移除加密过程中添加的噪声。因为消息位于消息的最高有效位中（假设是位28-31），而且添加的噪声并不是很大，所以将其舍入到最接近的 2^28 的倍数就可以移除它。</p><pre><code class="python">def decrypt(ciphertext, secret_key):  obfuscated_plaintext = \    ciphertext[-1] - np.dot(        ciphertext[:-1],        secret_key)  return round_to_power_of_2(      obfuscated_plaintext, 28)</code></pre><p>加密保证的是，对于使用相同的秘密密钥进行大量消息加密的样本，不存在任何非平凡概率高于随机猜测的情况下能够推断出秘密密钥或底层消息。这实际上是一个困难的机器学习问题：尝试从由 𝑠 和 𝑚 参数化的可能函数族中学习一个固定函数 𝑓(𝑎)&#x3D;𝑎⋅𝑠+𝑚。学习者可以均匀地采样输入-输出对，但输出值与其真实值略有偏差。如果没有这种偏差，这个问题等同于解一个线性系统，而且会很容易。但是由于这种偏差，没有人知道如何在多项式时间内解决它。关于为什么LWE（或<a href="https://link.springer.com/chapter/10.1007/978-3-642-27660-6_9">甚至更简单的问题</a>）很难解决，有着广泛的文献。<a href="https://eprint.iacr.org/2015/046">这里是关于已知最佳攻击的调查报告</a>。</p><p>LWE是CGGI密码系统所使用的前端加密，稍后会更详细地描述，但大多数其他FHE方案使用的是对LWE进行泛化到多项式算术的一种称为<a href="https://en.wikipedia.org/wiki/Ring_learning_with_errors">环形学习有误差</a>（RLWE）的方法。</p><p>在RLWE中，LWE中的标量乘法和加法被升级为多项式乘法和加法。操作不再是模机器字大小，而是模“多项式模数”进行的，并且该模数对方案的安全性至关重要。</p><p>更详细地说，我们首先选择一个多项式环。我们选择一个多项式的次数作为最大次数（比如，$N &#x3D; 1024$），系数始终是某个选定模数 𝑞 的整数（它可以是机器字大小或某个大素数），最后我们选择一个多项式，通常是 $x^N+1$，并将每个操作的结果表示为除以该多项式的余数。在数学符号中，这组多项式将被表示为 𝑍&#x2F;𝑞𝑍[𝑥]&#x2F;(𝑥^𝑁+1)。规范要求的 𝑞、𝑁 和多项式模数的选择因方案而异。模数 $x^N+1$ 是标准的，因为它通过离散傅里叶变换（DFT）或数论变换（NTT）实现了高效的多项式乘法。参见我的<a href="https://jeremykun.com/2022/12/09/negacyclic-polynomial-multiplication/">早期文章</a>，了解如何实现这些特殊的多项式乘法，尽管我还没有写过关于NTT的文章。</p><p>为了加密，一个或多个小整数消息会以某种与方案相关的方式编码成多项式（我写了一篇<a href="https://jeremykun.com/2023/09/18/encoding-schemes-in-fhe/">关于这个的整篇文章</a>）。秘密密钥是一个具有二进制系数的随机多项式列表，样本是具有均匀随机模 $𝑞$ 系数的随机多项式。然后进行点积运算，加上消息，并添加一个类似的“噪声多项式”以掩盖结果。</p><p>因为多项式比整数更“困难”（有关更多细节，请参阅<a href="https://jeremykun.com/2022/12/28/estimating-the-security-of-ring-learning-with-errors-rlwe/">这篇文章</a>），在RLWE中，向量大小 𝑛，即我在LWE示例中设定为800的值，通常被设置为1。换句话说，LWE中的“点积”被替换为单个多项式乘积。如果你考虑一下，多项式乘积很像<a href="https://jeremykun.com/2022/12/09/negacyclic-polynomial-multiplication/">卷积</a>，它是更简单的点积的变体。多项式的次数取代了LWE向量的维度，用于扩展安全性。尽管如此，一些方案使用两个或更多多项式来获得安全性和性能的不同权衡。</p><p>使用RLWE而不是LWE的主要优势在于，你可以将许多消息打包到单个多项式中，并且你所应用的同态操作适用于所有消息。这与<a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a>的优势类似，但对于这些打包消息可用的SIMD操作存在更多限制，我将在后面的部分讨论。</p><p>最后，许多人已经观察到整数只是一个次数为0的多项式。由于RLWE始终将向量维度设置为1，你可以将这两个参数（向量维度和多项式次数）结合起来，得到一个单一的母问题，其中两个参数都可以是可变的。这个母问题称为“模LWE”，它超出了本文的范围。</p><h2 id="基本操作和处理噪声"><a href="#基本操作和处理噪声" class="headerlink" title="基本操作和处理噪声"></a>基本操作和处理噪声</h2><p>在LWE和RLWE加密中，两个密文的加法自然对应于底层消息的加法。获得同态乘法更加困难，而且方法通常依赖于方案，但是是可能的。你可能已经注意到，LWE和RLWE支持“小位宽整数”，而不是我之前提到的单个位。实际上，现代FHE从业者利用了这一点，并根据低位宽算术操作来表示他们的电路，或者利用固定宽度的表示来支持十进制计算。根据计算的不同，这可能比纯布尔电路的表示方式具有显著的优势。</p><p>除了对底层消息进行操作外，同态加法还将两个操作数中的加密噪声添加到结果密文中。同样，同态乘积大致上会将两个密文中的噪声相乘。这显然是不可持续的。一旦噪声超过分配给它的约 28 位空间，解密将失败，并且程序的结果实际上变成了随机噪声。</p><p>举例来说，在我最近参与的一个FHE程序中，我在32位LWE明文的顶部使用了3位消息。我设置的密码参数使得我的初始程序具有大约12位噪声的有效限制（这可能对于实际应用来说不够安全）。一次加法会增加一位噪声，而乘法会使噪声翻倍。因此，我们最多可以进行一次乘法，然后进行大约五次或更多次加法，否则噪声太大而无法继续进行下去。</p><p>几乎所有FHE的复杂性都基于如何避免噪声增长或在程序中间如何减少噪声。后者被称为<em>引导</em>，它值得特别关注。引导的概念有点神奇。它的技术细节超出了本文的范围，但我可以总结其主要思想：您可以<em>在不看到底层消息的情况下对FHE密文进行同态解密，并在新的秘密密钥下重新加密</em>。这样做，导致的密文的噪声被“重置”为较小的值。但要使其工作，用户必须向服务器提供用户秘密密钥的特殊加密，这增加了一个额外的安全假设，称为循环安全性，或<a href="https://dl.acm.org/doi/10.1145/1943513.1943516">key-dependent message security</a>。通过引导，您可以无限扩展FHE程序。缺点是引导可能很昂贵，在某些方案中需要几毫秒，在其他方案中可能需要几秒钟到几分钟。</p><p>如果您不想进行引导，则只能对噪声增长设置一个硬限制。这通常被称为<em>分级同态加密</em>，因为噪声增长被离散化为级别，并且程序被禁止超过最大级别。这两种技术大致将FHE社区一分为二。</p><p>其中一方通俗地被称为“布尔FHE”，它代表了一类专注于较小加密和高效引导的FHE实现族群。它擅长于需要随机访问特定位的程序，例如字符串处理或具有大量比较运算符的程序。它在实现大位宽乘法的程序方面表现不佳，因为（在某种程度上）这归结为模拟一个大型电路，在每个门处进行引导。布尔FHE通常是计算密集型的，而在这个领域中的引导方法往往需要顺序累积许多多项式乘法。</p><p>另一方通俗地被称为“算术FHE”。这些方案将程序表示为算术电路（不是解释为位操作的加法和乘法），并且几乎禁止引导操作，因为没有人找出如何使它们快速的方法。相反，它们增加参数，使噪声上限足够高（想象成数百位），并使用技巧减少电路的深度，以便永远不会达到噪声上限。更具体地说，它们希望减少电路的乘法深度——从输入到输出的最长路径上的乘法操作数的数量。乘法引入的噪声比加法多得多，并且由加法引入的噪声可以大部分忽略。因为算术电路只能正式计算多项式，算术FHE用户（或在我这种情况下，编译器）还必须考虑如何将非多项式操作表示为多项式。例如，在神经网络中，ReLU激活函数可能被近似为一个3次多项式。然后，您必须考虑该近似引入的误差，加上密文噪声。但是，尽管有所有这些麻烦，算术FHE在进行大量的SIMD算术方面表现出色（将许多消息打包成一个密文），这对于机器学习应用通常效果很好。为此付出的代价之一是，算术FHE具有更大的密文、更多的“特殊密钥”需要管理，并且除了计算密集型之外，还倾向于受到内存限制。</p><p>在这一部分中我想提及的最后一件事是，类似于LWE的问题通常支持额外的密码学技巧，这些技巧成为FHE方案的关键实现细节。其中最重要的一个是同态地切换加密密钥。也就是说，给定一个特殊的密钥切换密钥，它使用另一个密钥 𝑠2 加密密钥 𝑠1，您可以将使用 𝑠1 的 LWE 或 RLWE 加密的消息 𝑚 转换为使用 𝑠2 的加密，而无需解密和重新加密（噪声也不像引导中那样重置）。这需要用户提供额外的加密密钥。其他构建块包括同态地改变加密方案系数的模数，应用RLWE密文底层环的自同构（例如，旋转密文中编码的消息的位置），以及将LWE和RLWE之间的密文进行打包或解包。</p><h2 id="残余数系统"><a href="#残余数系统" class="headerlink" title="残余数系统"></a>残余数系统</h2><p>在所有这些方案中，都会遇到一个问题，即希望使用比加密系统限制更大的数字。这可能是因为您希望加密的消息（例如，32位整数）比加密函数的输入限制（例如，对于您选择的参数，它是8位整数）要大，或者因为加密消息的系数不适合机器字并且您不想产生多精度整数运算的开销。后一种情况在算术FHE中很常见，其中一个会放大方案的参数以避免引导。</p><p>在这种情况下，FHE方案通常转向残余数系统的概念。这基于中国剩余定理（CRT，也称为孙子定理），它大致说明一个大数 $x$ 可以表示为一个数字元组 $(x_1,\dots,x_k)$ ，其中每个 𝑥𝑖≡𝑥mod𝑛𝑖，对于一些 𝑛𝑖 的选择（它们必须互质，并且它们的乘积必须大于 $x$ ）。您可以从元组中重构出原始的 $x$ ，并且残余数系统以其“剩余”（模元组）的形式表示数字。这类似地适用于多项式商环，这些环分解为更小的商环的直积形式。</p><p>残余数系统的惊人之处在于您仍然可以对它们进行计算。逐个对元组进行加法或乘法（然后在每个条目中进行相关的模归约）等效于对原始数字进行加法或乘法。</p><p>在FHE中，这意味着我们可以将一个大密文分解为RNS，并在RNS中进行所有后续的计算。当您的硬件具有大量的SIMD并行性可用时，这是一个很好的折衷方案，而另一种选择将涉及多精度数字，就像前面提到的算术FHE中的800位数字一样。</p><p>RNS 最突出地用于具有 RLWE 的算术 FHE 方案中，因为算术 FHE 方案已经施加了类似 SIMD 的计算模型，我稍后将在本文中更详细地讨论。然而，它也用于布尔方案，以整洁地表示高精度算术和低精度基础消息。</p><h2 id="双重CRT-Double-CRT"><a href="#双重CRT-Double-CRT" class="headerlink" title="双重CRT(Double-CRT)"></a>双重CRT(Double-CRT)</h2><p>RNS&#x2F;CRT在编码过程中的另一种方式是在编码过程中出现。两个多项式的加法自然对应于它们系数的和，但两个多项式的乘法对应于它们系数的<em>卷积</em>。在上述RLWE编码中，消息可以在加密前编码在多项式的系数中。然而，最常见的RLWE编码将消息编码为多项式在某些点上的<em>评估</em>。这可以被视为DFT&#x2F;NTT反演，多项式插值或底层多项式环的CRT分解的几种等效方式之一。所有这些方式都涉及从“评估域”转换到“系数域”。</p><p>当将此技巧与算术FHE方案结合使用以支持大型输入消息时，编码通常称为<em>双重CRT</em>。有关更多详细信息，请参阅我的<a href="https://jeremykun.com/2023/09/18/encoding-schemes-in-fhe/">深入研究编码</a>。</p><h2 id="装置分解法"><a href="#装置分解法" class="headerlink" title="装置分解法"></a>装置分解法</h2><p>另一种管理增长的常规方法是所谓的 <em>装置分解</em> 想法（我讨厌这个名字，因为它毫无意义）。这经常作为特定方案的实现细节出现，对方案的用户来说是不可见的，但对确保 FHE 构建模块操作（如密钥切换）可以在不超出噪声预算的情况下实现至关重要。我写了一篇<a href="https://www.jeremykun.com/2021/12/11/the-gadget-decomposition-in-fhe/">文章</a>描述了它的工作原理，但主要思想是，当您可能要将两个数字 𝑎,𝑏 相乘时，实际上您将 𝑎 乘以 𝑏 的各个位，然后将它们相加并适当地缩放。当两个参数的噪声增长不对称时，这是非常有用的，因此基本上您会将噪声重的部分尽可能地减小，并将2的幂移动到另一侧。</p><h1 id="几个FHE方案"><a href="#几个FHE方案" class="headerlink" title="几个FHE方案"></a>几个FHE方案</h1><p>现在我将对当前研究前沿的主要FHE方案进行广泛概述。它们通过作者的缩写命名：BFV、BGV、CKKS和CGGI。</p><h2 id="BFV-和-BGV-（整数-定点算术）"><a href="#BFV-和-BGV-（整数-定点算术）" class="headerlink" title="BFV 和 BGV （整数&#x2F;定点算术）"></a>BFV 和 BGV （整数&#x2F;定点算术）</h2><p><a href="https://eprint.iacr.org/2011/277.pdf">BGV</a> 和 BFV（两篇论文 <a href="https://eprint.iacr.org/2012/078">B</a> 和 <a href="https://eprint.iacr.org/2012/144">FV</a>）是“算术FHE”系列中的两种方案。自2011年&#x2F;2012年首次发表以来的十年里，BGV和BFV已经进行了调整和重新分析，并被确定为基本上是等效的，其在实现、效率和噪声传播方面存在细微差异，因不同参数选择而异。这个方案的许多高级技巧和考虑也被用于CKKS，因此本节将更长以解释这一点。</p><p>这两种方案都使用RLWE的一种版本来加密消息向量，都使用RLWE的一种类型，其中仅涉及两个多项式的点积（当我讨论下一个关键基础概念时，这将是相关的）。尽管如此，它们的首个显而易见的差异在于，BGV将明文编码为多项式系数的<em>最</em>低有效位中存储消息，而BFV将其存储在<em>最</em>高有效位中。BGV&#x2F;BFV可能通常使用16位消息。在这16位中，可以表示16位整数，或者各种适合同样位数的固定点数。</p><p>BGV和BFV都使用标准的RLWE加法，尽管它们在处理乘法方面有所不同，但它们的乘法例程都依赖于密钥切换，原因如下。它们将密文视为在密钥 𝑠 中的“一次多项式”。也就是说，一个密文是一对 $(c_0,c_1)$，其解密的第一步是计算 𝑐0⋅1+𝑐1⋅𝑠。𝑐𝑖 是这个线性多项式的系数，但当我们看到密文之间的乘法 (𝑐0,𝑐1) 和 (𝑏0,𝑏1) 被定义为：</p><p>(𝑐0,𝑐1)⋅(𝑏0,𝑏1)&#x3D;(𝑐0𝑏0,𝑐0𝑏1+𝑐1𝑏0,𝑐1𝑏1)</p><p>这是一个有效的密文，但仅当您将其视为关于 𝑠 的二次多项式时，即， 𝑐0𝑏0⋅1+(𝑐0𝑏1+𝑐1𝑏0)𝑠+𝑐1𝑏1𝑠2。另一种表述方式是，我们谈论的不是关于 𝑠 的多项式，而是存在一个“密钥基础”，其起始为 (1,𝑠)，而乘法将基础更改为 (1,𝑠,𝑠2)（然后我们不是计算多项式，而是与基础进行点积）。</p><p>请注意，上面的乘法公式是一个简化。BGV和BFV在如何确保上述操作保持在适当的系数模内方面存在差异，调整这些细节是少数学术论文的主要目标。我主要想强调的是密钥基础的变化，因为它造成了一些障碍。你可以继续在这个二次密钥基础上进行FHE操作，但这会更加计算昂贵，并且再次进行乘法运算会使基础变为三次或更高次。</p><p>因此，BGV&#x2F;BFV方案使用一种称为<em>重新线性化</em>的技术将从二次基础转换回一次基础。这需要将密钥交换作为子程序，并额外加密 𝑠2 以支持它。重新线性化是乘法的瓶颈，对于BGV和BFV来说是相同的子程序，而且还会略微增加密文的噪声。</p><p>BGV还使用一种称为“模切换”的技术来减少电路评估过程中的噪声增长。作为提醒，BGV和BFV都采取了“算术FHE”方法，通过增加参数大小来避免引导。这种模切换技术是通过具有大参数可以让人们以这种方式欺骗性能死亡的具体方法：模切换的行为使参数变小同时减少噪声，因此参数越大，减少噪声的空间就越大。</p><p>具体而言，BGV的参数包括一组称为“模数”𝑄0,𝑄1,…,𝑄𝐿的数字集，其中每个𝑄𝑖都可以整除𝑄𝑖+1。通常，它们是通过取𝑄𝑖+1&#x3D;𝑝𝑖+1𝑄𝑖构造的，其中𝑝𝑖是一些32位或64位素数。这些模数实际上是RLWE密文的多项式环的系数模，但在抽象上，它们被认为是“级别”。一个密文从顶级𝑄&#x3D;𝑄𝐿开始，一旦到达𝑄0，就不能再进行更多的乘法运算。每次乘法后，输出密文的系数都会通过模切换操作进行重新缩放，将其系数从mod 𝑄𝑖+1转换为mod 𝑄𝑖。这涉及将密文的系数按𝑄𝑖&#x2F;𝑄𝑖+1进行重新缩放，但需要一些细节上的处理才能正确实现。这会导致噪声以相同的因子进行重新缩放。特别是，如果没有这个技巧，密文的噪声会随着乘法操作的数量呈二次增长，这意味着您只能评估log2(𝐿)次乘法。有了这个技巧，你可以做𝐿次乘法。𝐿通常高达128并不罕见。</p><p>BFV也使用模数切换，但它隐藏在乘法操作内部，并将“尺度不变性”作为其公共API的一部分（在乘法操作之外），而BGV则暴露了模数，用户必须确保仅对具有相同模数的密文进行组合操作。</p><p>模数切换问题很重要，因为它影响了你如何设置方案的参数。对于BGV，参数取决于您想要评估的电路。当人们谈论“分级”同态加密时，这就是他们的意思：选择更大的参数，以便您拥有足够的级别来避免引导。有乘法深度吗？您需要更多的质数。一位FHE工程师向我提到，由于需要将它们用于RNS分解和模数切换，他们实际上已经“用完了”32位质数（根据<a href="https://homes.cerias.purdue.edu/~ssw/shortage.pdf">这篇论文</a> ，大约有6000万个，或0.25 GiB），因此不得不将其基础类型切换为64位。与此同时，BFV的类似参数与电路无关。作为对这种复杂性的交换，对于更大的模数 𝑄（即，更深的电路），BGV比BFV快20-50％，尽管这取决于应用的特定其他技巧的子集。</p><p>BGV和BFV在更大的计算范式中的位置是我想提及的最后一点。虽然人们关注改善微基准测试（如重新线性化、密钥切换或来自单个乘法的噪声增长），但还有一个挑战是在BGV&#x2F;BFV计算模型中表达程序。因为虽然你可以进行诸如添加和乘以密文之类的SIMD操作，但其他与SIMD架构（如AVX）常见的操作却不存在。忘记密文是一个多项式，只把它当作底层消息的向量。AVX等工具允许你对向量元素应用任意排列，将它们重新排列以便后续的SIMD操作更好地对齐。在FHE中，我们受到了更大的限制。有一种有限的支持排列的子集，对应于向量的循环旋转。在多项式领域，这些是通过底层环的<a href="https://en.wikipedia.org/wiki/Frobenius_endomorphism">Frobenius自同构</a>实现的，这些自同构将 𝑥 ↦ 𝑥𝑘，其中 𝑘 是某个数。</p><p>将这个扩展到任意排列需要构造一个对数深度的<em>置换网络</em>。我不知道在实际的FHE方面是否有人真正这样做，他们转而进行了一些可以用现有旋转表达的计算，比如简单的循环和矩阵-向量乘积。然而，这些自同构需要它们自己的特殊密钥材料，每个支持的旋转移位都需要一个，而且相对于它们所做的事情来说，它们的代价是昂贵的。因此，自然而然地，人们希望尽量减少它们的使用，在表达一个不是手工定制为适应算术FHE模型的程序时，这可能是一个挑战。</p><p>旋转之所以昂贵，部分原因是它们需要一个密钥切换操作，这既需要额外的加密密钥材料，又与BGV&#x2F;BFV中的其他（非引导）操作相比计算密集。有关BGV、BFV及其差异和优化技巧的更深入的学术讨论，请参阅Kim、Polyakov和Zucca的论文。</p><p>最近有一些关于优化BFV&#x2F;BGV方案的引导技术的工作，但据我所知，这些方案中最好的引导运行时仍需要几分钟才能完成，或者如果摊销，每条消息需要几秒钟。</p><h2 id="CKKS（近似算术）"><a href="#CKKS（近似算术）" class="headerlink" title="CKKS（近似算术）"></a>CKKS（近似算术）</h2><p>CKKS是同态加密中最新发明的方案之一，它的核心观察是，注入到同态加密密文中的误差可以被吸收到浮点运算的误差中。CKKS利用了这一点，既可以扩展允许的输入空间，又可以在方案中更积极地降低噪声。具体来说，CKKS使用一种称为<em>重新缩放</em>的操作，类似于BGV&#x2F;BFV中的模量切换，用于减少乘法引起的噪声增长，但在这个过程中，会从消息的最低有效位中丢失一些精度。</p><p>与BGV和BFV相似，CKKS也使用RLWE来加密消息，并且擅长SIMD风格的编程。它与BGV和BFV一样使用残数系统技巧来加速多项式乘法，强调通过“分层”的方式避免引导，并且类似地使用重新线性化、旋转和密钥切换。</p><p>CKKS方案支持任意实数或复数作为输入消息，前提是需要理解精度会有所损失。它在通过泰勒级数多项式近似计算超越函数方面表现出色。因此，CKKS被认为最适合允许有限精度损失的SIMD风格计算，例如机器学习推断任务，这类任务需要使用某些超越函数但并不频繁。特别是，在找到近似某一局部邻域内函数的小度数多项式方面，CKKS可以比BGV&#x2F;BFV做得更好。这依赖于具有连续的消息空间：如果将消息空间设置为单位区间，则多项式近似可以假定输入在该范围内。</p><p>然而，CKKS的性能提升是以可用性为代价的。除了需要关注同态操作导致的FHE密文噪声增长，还需跟踪多项式近似非多项式函数所引入的近似误差，在CKKS中，还必须跟踪其他操作（例如重新缩放）所导致的精度损失。即使是加密并立即解密消息（没有任何同态操作），也无法还原原始消息。无法组合具有不同缩放比例的两个密文，与BGV类似，这在CKKS的“公共”API中有所体现，但它与CKKS中的正确程序输出关系更密切，因此比BGV的模量切换更难隐藏。</p><p>在所有四种FHE方案中，我个人对CKKS的理解最少，但我越深入研究并与同事讨论，越觉得CKKS与BGV&#x2F;BFV之间的区别越来越小。特别是，CKKS的许多特性很快就被移植到BGV&#x2F;BFV，反之亦然。</p><h2 id="CGGI（布尔-短整数运算）"><a href="#CGGI（布尔-短整数运算）" class="headerlink" title="CGGI（布尔&#x2F;短整数运算）"></a>CGGI（布尔&#x2F;短整数运算）</h2><p>CGGI方案支持使用LWE加密方式对小位宽整数（1到约6位）进行加密。它利用LWE的天然加法操作，但不像BGV&#x2F;BFV那样有明显的乘法操作。相反，CGGI专注于两个关键组件：<strong>快速</strong>引导（每个密文的引导时间小于10毫秒），并通过一种称为<strong>可编程引导</strong>的技术在引导期间对密文进行额外的（免费）计算。</p><p>普通的引导操作将加密消息 $m$ 的密文作为输入，并生成另一个具有较低噪声的 $m$ 加密密文。可编程引导允许在降低噪声的同时计算基础消息的任意（单变量）函数。由于消息是 $m$ 位整数，“任意函数”以一个具有 $2^m$ 项的查找表形式呈现。基于函数引导的工作原理，随着 $m$ 的增加，引导效率会迅速下降（你需要指数级增长的数据大小参数）。因此，查找表通常是硬编码的。</p><p>借助这种能力，可以实现平方函数 $x \mapsto x^2$ ，并结合加法和密文-常量乘法，可以实现密文-密文乘法：</p><p>$$x \cdot y &#x3D; \frac{(x + y)^2 - (x - y)^2}{4}$$</p><p>通过这种方式，即使没有明显的乘法操作，也可以利用平方函数和其他基本运算实现密文间的乘法操作。</p><p>一旦你有了可编程的引导，乘法就不再是核心功能了。你可以直接实现任意布尔门、比较操作、位运算、最大&#x2F;最小值，以及你想要的（非常低精度的）定点运算。然后，你可以通过找到巧妙的方式将逻辑表达为低精度查找表来优化你的程序。你也可以通过将两个输入的位并排放置来挤入双变量函数，前提是你有足够的精度。</p><p>在CGGI中，一次引导操作相对于BGV&#x2F;BFV&#x2F;CKKS来说是比较便宜的。领先的CPU实现可以在大约8毫秒内运行引导操作，并且可以并行运行许多引导操作，具有将相同查找表同时应用于许多密文的特殊版本。这使得频繁运行引导操作变得更加可行，以至于一些实现在FHE程序中的每个非加法门后都盲目地运行引导操作，这被称为“门引导”。但是，引导操作仍然是CGGI中的主要瓶颈，占据了总计算量的90%以上。</p><p>可编程引导的实现可以被视为一个黑匣子，但是稍微看一下内部，它是通过在一个RLWE密文中表示查找表，并通过加密的消息进行“盲旋转”（在加密时进行同态评估，对自同构𝑥↦𝑥𝑚）。这实际上涉及大量（~800）的顺序矩阵-向量多项式乘法。然后，它必须跟随一个RLWE到LWE的转换和一个密钥交换，相比于盲旋转步骤，这两个步骤都是次要的。</p><p>一些CGGI的扩展（比如<a href="https://eprint.iacr.org/2021/729">这个</a>）包括了BFV式的乘法和重线性化，将更大的函数分解成查找表树，并向CGGI添加了其他功能。</p><p>因此，由于这种灵活性，CGGI可以被认为更适合具有大量分支评估和相对低宽度电路的程序。不过，请参阅下面的“超越方案”部分以获取更多信息。但无论如何，其组件较算术方案要少。</p><p>有时你会看到CGGI被称为其他几个名称，比如“TFHE”（“Torus” FHE，CGGI的作者给它的名称），<a href="https://www.jeremykun.com/2024/05/04/fhe-overview/?continueFlag=fcaae36dd48c80ea2eea4df19d1409c2#fn:5">5</a>“FHEW”代表“Fastest HE in the West”（向其使用“Fastest Fourier Transform in the West”算法致敬；FHEW是CGGI方案的重要前身），或者“DM”代表FHEW的两位作者的首字母缩写。</p><p>最近的工作已经在<a href="https://eprint.iacr.org/2024/181">BFV</a>中展示了对功能性引导的支持。CKKS也有引导操作，尽管其初始版本需要几秒钟（每个消息摊销）才能运行。针对CKKS设计了某些特殊化的引导程序，它们运行速度更快，但假设输入的密文是单个比特。</p><p>要深入了解CGGI，请参阅Daniel Lowengrub的<a href="https://www.daniellowengrub.com/blog/2024/01/03/fully-homomorphic-encryption">这篇实现文章</a>，或者Marc Joye的<a href="https://eprint.iacr.org/2021/1402">这篇论文长度解释</a>。</p><h1 id="超越方案"><a href="#超越方案" class="headerlink" title="超越方案"></a>超越方案</h1><p>在本文的前面，我描述了一种将算术方案和布尔方案之间的墙壁，将研究社区划分开来的情况。近年来的一个有趣的发展是能够将一个FHE方案的密文转换为另一个的能力。这被称为“方案切换”。它始于CHIMERA论文，该论文证明了在CGGI、BFV和CKKS之间进行切换是可能的。后续的一篇名为PEGASUS的论文改进了从CKKS到CGGI的转换。最近的一个研究编译器证明，可以静态分析一个程序来决定哪些部分应该用CKKS实现，哪些部分应该用CGGI实现，而得到的混合方案比任何一个方案单独实现的速度都要快。</p><p>这是一个很有趣的发展！自定义的CKKS启动程序针对CKKS加密单比特消息的特殊情况进行了设计，该研究声称，如果同时有超过150个密文需要启动，那么CKKS的启动速度（摊销）比CGGI的启动速度更快。因此，您可以将这个与方案切换结合起来，将大批量的CGGI密文转换为CKKS，进行启动，然后再转换回来，以实现更快的启动。</p><p>这强调了我在过去两年里看到的FHE的主要研究趋势：FHE方案之间的区别变得不那么明显了。CKKS、BGV和BFV正在合并成一个原始方案，其细节主要在于明文编码以及它们在高层次上共享的各个操作的变化。如果最近的研究结果持续下去，可编程启动将在BFV中可用，并且很可能很快也会在CKKS和BGV中实现。而方案切换意味着最初选择的FHE方案可能并不那么具有约束力。</p><h1 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h1><p>FHE研究的一个重要方面是设计定制硬件来加速FHE操作。有许多项目，但让我简要总结一下我比较熟悉的几个。</p><p>最突出的项目群体是一个名为DPRIVE的DARPA计划的一部分。简而言之，DARPA正在资助FHE硬件设计者，挑战他们尽快在FHE中执行逻辑回归、CNN推断和CNN训练。目前有四个参与者：</p><ul><li>英特尔，其加速器被称为 <a href="https://dl.acm.org/doi/abs/10.1145/3560810.3565290">HERACLES</a>.</li><li><a href="https://dualitytech.com/">Duality</a>，其加速器被称为 <a href="https://eprint.iacr.org/2023/521">TREBUCHET</a>.</li><li><a href="https://www.sri.com/press/story/sri-dprive-teams-fhe-accelerator-design-strengthens-security-of-outsourced-data-processing/">SRI International</a>，其加速器称为为 <a href="https://dl.acm.org/doi/10.1145/3470496.3527393">CraterLake</a>.</li><li><a href="https://niobiummicrosystems.com/">Niobium Microsystems</a>，其加速器被称为 <a href="https://eprint.iacr.org/2022/657">BASALISC</a>.</li></ul><p>DPRIVE的所有参与者都在研发能加速算术全同态加密方案（如BFV&#x2F;BGV和CKKS）的ASIC芯片，并且它们在通向制造的过程中处于不同的阶段。它们的初始性能声明基于仿真，但为了赞扬这些参与者中的佼佼者，Niobium的<a href="https://tches.iacr.org/index.php/TCHES/article/view/11157">初始论文</a>声称，在处理1024个样本、10个特征的数据集的逻辑回归时，估计只需40秒，而在CPU上则需要60小时。对我来说，这是硬件加速的一个下限。在这些加速器的核心是对相关多项式环中的数论变换（NTT）和其他多项式运算的加速。据我所知，这些加速器的难点在于将足够的RAM集成到其中，以便它们可以存储所有的密文和辅助密钥材料，并获得良好的内存局部性。</p><p>我熟悉的另一个项目是基于FPGA的CGGI加速方法，名为<a href="https://eprint.iacr.org/2022/1635">FPT</a>，来自<a href="https://www.esat.kuleuven.be/cosic/">比利时鲁汶大学KU Leuven的COSIC研究实验室</a>。他们使用<a href="https://www.xilinx.com/products/boards-and-kits/alveo/u280.html">Alveo U280</a>，并且通过对16个密文进行功能性引导，以实现每35微秒1个引导的吞吐量。我见过他们的实时演示，在演示中，他们在CGGI中运行康威生命游戏，动画效果几乎是实时的。与DPRIVE计划中的NTT运算机不同，FPT是一个FFT运算机。当然，该项目从TFHE-rs API开始，用于CGGI。</p><p>有一些方法我了解较少。英特尔的团队有一个名为<a href="https://github.com/intel/hexl">HEXL项目</a>的项目，专注于使用AVX和类似的现代CPU技术来针对英特尔CPU。此外，<a href="https://developer.nvidia.com/blog/accelerated-encrypted-execution-of-general-purpose-applications/">NVIDIA的团队</a>正在研究GPU加速，而<a href="https://heaan.it/">HEaaN库</a>（CKKS）也支持GPU加速。还有一家名为<a href="https://optalysys.com/">Optalysys</a>的公司正在为FHE构建一款光学计算芯片。其想法是通过使用通过透过透镜（或者说纳米级等效物）的光的干涉模式，可以“以光速”计算傅里叶变换，并通过这种方式加速引导。</p><p>最后，我正在研究自己的硬件加速方法：在<a href="https://en.wikipedia.org/wiki/Tensor_Processing_Unit">TPU</a>上运行CGGI。这是一个名为<a href="https://github.com/google/jaxite">jaxite</a>的开源库（因为它是用<a href="https://github.com/google/jax">JAX</a>编写的）。目前性能还不值得太过夸耀，但我希望如果我能将性能提高到比CPU快10-100倍，那么我就可以利用谷歌已经大规模部署了TPU的事实，在更强大的硬件加速规模准备好之前推出一些FHE产品。</p><p>关于这些以及我了解较少的其他加速器的更多细节，请参阅这篇<a href="https://arxiv.org/abs/2212.01713">论文，“SoK: Fully Homomorphic Encryption Accelerators”</a>。</p><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>FHE有很多软件支持，从核心加密的实现到编译器和更高级别的框架。要获取详尽的列表，请查看Jonathan Schneider的<a href="https://github.com/jonaschn/awesome-he">Awesome FHE</a>。我将在这里介绍一些我喜欢的。</p><p>OpenFHE是所有主要FHE方案的实现，包括方案切换，主要由<a href="https://dualitytech.com/">Duality</a>维护。它取代了之前的<a href="https://palisade-crypto.org/">PALISADE</a>项目，该项目已不再维护。据我所知，这是唯一支持方案切换的库，也是DPRIVE参与者作为硬件入口的主要API。</p><p><a href="https://github.com/snucrypto/HEAAN">HEaaN</a> 是 CKKS 的经典实现，当作者们开始了以盈利为目的的研究实验室 <a href="https://www.cryptolab.co.kr/en/about-us-en/company-history/">CryptoLab</a> 后，它被收回了闭源。<a href="https://github.com/snucrypto/HEAAN">最后的开源版本仍然在 GitHub 上</a>。</p><p><a href="https://github.com/zama-ai/tfhe-rs">TFHE-rs</a> 是领先的 CGGI 实现，用 Rust 编写，由营利性公司 <a href="https://www.zama.ai/">Zama</a> 开发&#x2F;维护。它基于 <a href="https://github.com/tfhe/tfhe">原始的 CGGI 实现</a>（也称为 TFHE），后者是用 C++ 编写的，已不再维护。Zama 还在 TFHE-rs 上构建了各种高级库，包括一个名为 <a href="https://github.com/zama-ai/concrete">concrete</a> 的编译器和一个名为 <a href="https://github.com/zama-ai/concrete-ml">concrete-ml</a> 的 scikit-learn API 镜像。</p><p><a href="https://github.com/tuneinsight/lattigo">Lattigo</a> 是 CKKS 的纯 Go 实现，同时还包括 BGV&#x2F;BFV&#x2F;CGGI 实现，最初由 <a href="https://jeanphilippebossuat.ch/">Jean-Philippe Bossuat</a> 开发，现由 <a href="https://tuneinsight.com/">Tune Insight</a> 维护。</p><p>据我所知，其他所有的FHE实现库要么没有得到广泛使用，要么已不再积极开发。其中两个值得注意的例子包括：</p><ul><li>微软的SEAL支持BGV&#x2F;BFV以及一些CKKS，附带有关联的EVA编译器（也不再积极开发）。</li><li>HELib是IBM开发的BGV和CKKS实现。</li></ul><p>有几个正在积极开发的其他FHE工具值得一提。</p><ul><li><a href="https://ibm.github.io/helayers/">HELayers</a> 是IBM的FHE编译器，专门用于找到良好的打包方案。</li><li><a href="https://dl.acm.org/doi/10.1145/3591228">HEaaN.mlir</a> 是CryptoLab的编译器，针对HEaaN，但据我所知，它并不是开源的。</li><li>正如上文所提到的，<a href="https://github.com/zama-ai/concrete">Concrete</a> 和 <a href="https://github.com/zama-ai/concrete-ml">Concrete-ML</a> 是一对通过TFHE-rs为CGGI进行机器学习编译器&#x2F;前端。</li><li><a href="https://heir.dev/">HEIR</a> 是一个FHE编译器，也是我的主要项目，旨在支持所有主要的FHE方案和硬件后端。截至目前，它支持将CGGI导出到TFHE-rs，以用于CPU和FPT FPGA，以及将BGV导出到OpenFHE（并准备用于DPRIVE加速器）。</li></ul><p>还有<a href="https://arxiv.org/abs/2101.07078">各种其他研究级别的编译器</a>，虽然它们没有得到维护，但它们在当前FHE编译器中使用了许多创新的想法。</p><h1 id="编写-FHE-程序"><a href="#编写-FHE-程序" class="headerlink" title="编写 FHE 程序"></a>编写 FHE 程序</h1><p>在所有的加密算法和软件工具都准备就绪之后，编写同态加密程序实际是什么样子的？这是一个非常有趣的话题，未来我也很想写更多关于它的内容。</p><p>然而，简单来说，编写同态加密程序目前仍然突显出算术&#x2F;布尔运算的分界线。虽然有一些专门的库（如 <a href="https://github.com/zama-ai/concrete-ml">Concrete-ML</a>）在特定任务中表现出色，但通用的FHE编程仍然是一个高度手动的过程，有点类似于编写自定义图形内核，你需要非常清楚如何在“硬件”中正确实现某个功能。而在我们的情况下，这个“硬件”就是FHE受限的计算模型。</p><p>对于算术同态加密（FHE）而言，这意味着你必须避免使用非多项式运算或者无法通过低阶多项式轻松逼近的运算。这排除了即使是简单的比较、最大值&#x2F;最小值和分支操作。大量的研究专注于寻找精确的符号函数（<code>1 if x &gt; 0 else -1</code>）的多项式近似。而选择“正确”的多项式近似方案在很大程度上取决于程序的语义。因此，大多数算术FHE领域的研究都集中在神经网络推理上，因为神经网络的主要工作在于计算矩阵乘法，而在FHE中实现这一点的难点主要在于处理超越激活函数。一个包含太多不连续函数且对误差容忍度低的程序在算术FHE中将会非常慢，因为它需要不断进行引导操作。例如，我见过的最令人印象深刻的算术FHE程序是<a href="https://proceedings.mlr.press/v162/lee22e.html">在CKKS中实现的ResNet</a>，这是一种深度神经网络架构，堆叠了带有ReLU激活的卷积层。ReLU需要高阶多项式近似，这消耗了所有可用的乘法深度，因此在每个卷积层之后都需要进行一次CKKS引导操作。</p><p>据我所知，目前最先进的实现是上面链接的论文，该论文报告了一次推理（在包含50张图像的打包密文上）大约需要一小时（每张图像大约一分钟，摊销）。[6] 那篇论文还实现了ResNet-110，推理延迟为每次6小时。与此同时，ResNet-50 CPU 推理的摊销延迟约为每毫秒处理一张图像，这是几乎慢了100,000倍的数量级。</p><p>根据我的了解，除了使用特定技巧编译预训练的神经网络外，所有实际的算术全同态加密程序都是由专家手工编写的，他们手动选择逼近方法和批处理方案。</p><p>对于布尔全同态加密，非多项式操作要便宜得多，但你会遇到与位宽相关的其他问题。具体来说，大位宽的加法和乘法操作变得非常昂贵，因为布尔全同态加密方案只支持相对较小的位宽消息，必须通过大型功能性启动操作树来有效地模拟大型加法器&#x2F;乘法器电路。因此，布尔全同态加密在<em>量化</em>上付出了很多努力，即尽可能减少位宽。对于神经网络，像Brevitas和TFLite这样的库非常有用，Zama公司充分利用了这一点，结合其他剪枝技巧，在CPU上实现了像VGG这样的网络，每张图像的<a href="https://github.com/zama-ai/concrete-ml/issues/658#issuecomment-2082088997">推断时间约为40秒</a>。它比上面的ResNet示例慢（而且VGG是一个更小的网络），但这种方法的好处是你也可以做决策树等在算术全同态加密中可能不太实用的事情，并且其中很少有手工制作的部分，正如Zama的concrete-ml库所示，它隐藏了许多细节。布尔全同态加密模型的另一个好处是你可以针对这个问题投入更多的现成硬件优化工具，因为布尔全同态加密电路看起来更像传统的组合电路，而不像算术全同态加密那样。</p><h1 id="参与"><a href="#参与" class="headerlink" title="参与"></a>参与</h1><p>如果你对FHE感兴趣并希望参与其中，有几种不错的方式可以开始。由Zama牵头的<a href="https://fhe.org/">FHE.org</a>组织每周举办<a href="https://fhe.org/meetups/">FHE研究研讨会系列</a>，并且有一个活跃的<a href="https://fhe.org/community">Discord社区</a>（披露：我是管理员，HEIR项目有一个频道）。FHE.org还主办每年三月举办的<a href="https://fhe.org/conferences/conference-2024/">年度会议</a>。</p><p>OpenFHE项目拥有一个活跃的<a href="https://openfhe.discourse.group/">Discourse论坛</a>，维护者们会在这里回答关于OpenFHE和FHE的相关问题。</p><p><a href="https://homomorphicencryption.org/">FHE标准化联盟</a>正在积极组织FHE的ISO标准化工作，并且还举办了<a href="https://homomorphicencryption.org/workshops/">研究研讨会</a>。</p><p>最后，我们的HEIR项目每月两次举办<a href="https://heir.dev/community/">开放设计会议</a>，欢迎任何有兴趣做出贡献的人参加。</p><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢Seonhong Min、Johannes Mono、<a href="https://github.com/inbelic">Finn Plummer</a>和<a href="https://www.linkedin.com/in/jeffrey-sorensen-8a2b15191/">Jeffrey Sorensen</a>对本文提供的反馈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comparison of Ed25519 and RSA</title>
      <link href="/posts/2024-05-10-ed25519-vs-rsa.html"/>
      <url>/posts/2024-05-10-ed25519-vs-rsa.html</url>
      
        <content type="html"><![CDATA[<p>Ed25519 and RSA are two different public-key cryptographic algorithms, each with notable differences in terms of security and performance.</p><h1 id="Key-Length"><a href="#Key-Length" class="headerlink" title="Key Length"></a>Key Length</h1><ul><li>RSA relies on the multiplication of large prime numbers and typically uses key lengths of 2048 bits or longer. Ed25519, on the other hand, uses a key length of 256 bits.</li><li>While Ed25519 has a shorter key length, its key space is more evenly distributed, making key generation easier and providing higher security.</li></ul><h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h1><ul><li>Ed25519 is generally faster than RSA. This is because Ed25519 uses Elliptic Curve Cryptography (ECC) instead of modular exponentiation used in RSA, which tends to be more efficient.</li><li>RSA can be computationally intensive, especially for key generation and encryption&#x2F;decryption processes, particularly with longer key lengths.</li></ul><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><ul><li>RSA has been around for a long time and has undergone extensive research and application. It is considered quite secure with appropriate key lengths (e.g., 2048 bits and above).</li><li>Ed25519 is a newer algorithm, but it is based on elliptic curve cryptography and provides high security with relatively short key lengths, avoiding certain specific attacks present in RSA.</li></ul><h1 id="Resistance-to-Quantum-Attacks"><a href="#Resistance-to-Quantum-Attacks" class="headerlink" title="Resistance to Quantum Attacks"></a>Resistance to Quantum Attacks</h1><ul><li>RSA is particularly vulnerable to attacks from quantum algorithms like Shor’s algorithm, which could compromise its long-term security in the era of quantum computing.</li><li>Ed25519 is currently considered to have higher resistance against known quantum computing attacks.</li></ul><p>In summary, Ed25519 is generally regarded as a more secure and efficient choice, especially in resource-constrained environments like mobile or IoT devices. However, RSA remains one of the widely used traditional encryption algorithms in many systems, with its security and performance largely dependent on the chosen key length and implementation.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deploy IPFS with Nginx in Docker</title>
      <link href="/posts/2024-03-19-deploy-ipfs-with-nginx-in-docker.html"/>
      <url>/posts/2024-03-19-deploy-ipfs-with-nginx-in-docker.html</url>
      
        <content type="html"><![CDATA[<p>This post is mainly to help reader to deploy an IPFS service with nginx proxy which provides basic authorizations.</p><p>A quick start is the following steps.</p><p>Some basic requirements:</p><ul><li>Docker should already be installed on your computer.</li><li>Basic Linux terminal skills.</li></ul><h1 id="Create-files"><a href="#Create-files" class="headerlink" title="Create files"></a>Create files</h1><ol><li><p>Create folder</p><pre><code>$ mkdir ipfs$ cd ipfs</code></pre></li><li><p>Create <code>docker-compose.yaml</code></p><pre><code>version: &#39;3&#39;services:  ipfs:    container_name: ipfs    image: ipfs/kubo:latest    volumes:      - ./data/:/data/ipfs/    ports:      - &#39;8080:8080&#39;    restart: always  nginx:    container_name: nginx    image: nginx:latest    ports:      - &#39;5001:5001&#39;    volumes:      - &#39;./default.conf:/etc/nginx/conf.d/default.conf:ro&#39;      - &#39;./htpasswd:/htpasswd:ro&#39;    restart: always</code></pre></li><li><p>Create <code>htpasswd</code></p><pre><code>ljiang:$apr1$nShUpvO7$hizri44cnQwto/zQ0y3Ka0</code></pre></li><li><p>Create <code>default.conf</code></p><pre><code>server &#123;    listen 5001;    server_name _;    client_max_body_size 2048000m;    location / &#123;        proxy_pass http://ipfs:5001;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        auth_basic           &quot;Administrator’s Area&quot;;        auth_basic_user_file /htpasswd;    &#125;&#125;</code></pre></li></ol><h1 id="Init-IPFS-Data"><a href="#Init-IPFS-Data" class="headerlink" title="Init IPFS Data"></a>Init IPFS Data</h1><ol><li><p>Make data folder</p><pre><code>$ mkdir -p ./data/</code></pre></li><li><p>Init data</p><pre><code>$ IPFS_PATH=&quot;$(pwd)/data/&quot; ipfs init</code></pre></li></ol><h1 id="Set-IPFS-config"><a href="#Set-IPFS-config" class="headerlink" title="Set IPFS config"></a>Set IPFS config</h1><ol><li><p>Set Addresses</p><pre><code>$ IPFS_PATH=&quot;$(pwd)/data/&quot; ipfs config --json Addresses.API &#39;&quot;/ip4/0.0.0.0/tcp/5001&quot;&#39;$ IPFS_PATH=&quot;$(pwd)/data/&quot; ipfs config --json Addresses.Gateway &#39;&quot;/ip4/0.0.0.0/tcp/8080&quot;&#39;</code></pre></li><li><p>Set API</p><pre><code>$ IPFS_PATH=&quot;$(pwd)/data/&quot; ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin &#39;[&quot;*&quot;]&#39;$ IPFS_PATH=&quot;$(pwd)/data/&quot; ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods &#39;[&quot;GET&quot;, &quot;PUT&quot;, &quot;POST&quot;]&#39;</code></pre></li></ol><h1 id="Start-IPFS"><a href="#Start-IPFS" class="headerlink" title="Start IPFS"></a>Start IPFS</h1><pre><code>$ docker-compose up -d</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> IPFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sending File via Netcat</title>
      <link href="/posts/2024-03-11-sending-file-via-netcat.html"/>
      <url>/posts/2024-03-11-sending-file-via-netcat.html</url>
      
        <content type="html"><![CDATA[<p>For example, your want send a file named hello.zip from client to server which ip and port are <code>192.168.56.102</code> and <code>8080</code></p><p>On your server:</p><pre><code>$ nc -l -p 8080 -q 1 &gt; hello.zip &lt; /dev/null</code></pre><p>On your client:</p><pre><code>$ cat hello.zip | nc 192.168.56.102 8080</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Backup Docker Compose Services</title>
      <link href="/posts/2024-03-01-backup-docker-compose-services.html"/>
      <url>/posts/2024-03-01-backup-docker-compose-services.html</url>
      
        <content type="html"><![CDATA[<p>See: <a href="https://gist.github.com/ismdeep/34eda2fac762f2fdcabc3f6de2df7884">https://gist.github.com/ismdeep/34eda2fac762f2fdcabc3f6de2df7884</a></p><script src="https://gist.github.com/ismdeep/34eda2fac762f2fdcabc3f6de2df7884.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Create Linux OS Rootfs for Build Docker Images</title>
      <link href="/posts/2024-03-01-create-linux-os-rootfs-for-build-docker-images.html"/>
      <url>/posts/2024-03-01-create-linux-os-rootfs-for-build-docker-images.html</url>
      
        <content type="html"><![CDATA[<h1 id="Create-Linux-OS-ROOTFS"><a href="#Create-Linux-OS-ROOTFS" class="headerlink" title="Create Linux OS ROOTFS"></a>Create Linux OS ROOTFS</h1><ol><li><p>Create an output folder</p><pre><code># mkdir -p /output/</code></pre></li><li><p>Create rootfs.tar</p><pre><code># cd /# tar cf /output/rootfs.tar --exclude=/proc --exclude=/dev --exclude=/boot --exclude=/run --exclude=/sys --exclude=/output /</code></pre></li><li><p>Compress tar file with xz</p><pre><code># xz -v -T 0 /output/rootfs.tar</code></pre></li></ol><h1 id="Build-Docker-Image"><a href="#Build-Docker-Image" class="headerlink" title="Build Docker Image"></a>Build Docker Image</h1><p>Build docker image from scratch with rootfs.tar.xz</p><pre><code>FROM scratchADD ./rootfs.tar.xz /</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tips for Writing Bash Script</title>
      <link href="/posts/2024-02-24-tips-for-writing-bash-script.html"/>
      <url>/posts/2024-02-24-tips-for-writing-bash-script.html</url>
      
        <content type="html"><![CDATA[<p>Bash (Bourne Again SHell) is a popular command-line shell and scripting language. It is commonly used on Unix-like operating systems, including Linux.</p><h1 id="1-Writing-functions"><a href="#1-Writing-functions" class="headerlink" title="1. Writing functions"></a>1. Writing functions</h1><p>Bash functions are a way to group a set of commands and logic into a reusable block in a Bash script. They allow you to encapsulate common tasks or complex sequences of commands into a single callable entity. Here’s an example of how to define and use a Bash function:</p><pre><code class="bash">function hello() &#123;  ...&#125;</code></pre><p>or</p><pre><code class="bash">hello() &#123;  ...&#125;</code></pre><p><strong>Note: bash function will only return the return code of the last command that run in function.</strong></p><p>For example: the <code>hello</code> function will not catch the return code of <code>command1</code></p><pre><code class="bash">hello() &#123;  command1  command2&#125;</code></pre><p>If you care about the execution results of all instructions throughout the entire function process, you need to use the “&amp;&amp;” symbol to chain all the commands together. Such as:</p><pre><code class="bash">hello() &#123;  command1 &amp;&amp; \  command2&#125;</code></pre><h1 id="2-set-e"><a href="#2-set-e" class="headerlink" title="2. set -e"></a>2. set -e</h1><p><code>set -e</code> is a common command used in Bash scripts. It sets an error handling flag that causes the script to exit immediately if any command within the script fails.</p><pre><code class="bash">#!/bin/bashset -e# Some commands here...command1command2#...# If any command fails, the script will exit here</code></pre><h1 id="3-realpath"><a href="#3-realpath" class="headerlink" title="3. realpath"></a>3. realpath</h1><p><code>realpath</code> is a command in bash that is used to get the absolute path of a file or directory. </p><h1 id="4-dirname"><a href="#4-dirname" class="headerlink" title="4. dirname"></a>4. dirname</h1><p><code>dirname</code> is a built-in command in Bash scripts that returns the directory name part of a given path or the directory path of a given file path.</p><h1 id="5-BASH-SOURCE"><a href="#5-BASH-SOURCE" class="headerlink" title="5. BASH_SOURCE"></a>5. BASH_SOURCE</h1><p><code>BASH_SOURCE</code> is an internal variable in the Bash shell. It holds the path of the script or function that is currently being executed.</p><p>You can get absolute path of the bash script file you are running.</p><pre><code class="bash">#!/usr/bin/env bashset -ebash_script=&quot;$(realpath &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot;</code></pre><p>And set the dirctory where bash script in as working directory.</p><pre><code class="bash">#!/usr/bin/env bashset -eworkdir=&quot;$(realpath &quot;$(dirname &quot;$(realpath &quot;$&#123;BASH_SOURCE[0]&#125;&quot;)&quot;)&quot;)&quot;cd &quot;$&#123;workdir&#125;&quot;</code></pre><h1 id="6-confirm-via-read"><a href="#6-confirm-via-read" class="headerlink" title="6. confirm via read"></a>6. confirm via read</h1><p>In Bash, you can use the <code>read</code> command to prompt for confirm input from the user. Here’s an example of how to write a confirm input in Bash:</p><pre><code class="bash">read -p &quot;Are you sure [y/n]? &quot; -r nameif [[ ! $name =~ ^[Yy]$ ]]then  echo &quot;==&gt; Aborted&quot;  exit 0fi</code></pre><h1 id="7-variable-requirement"><a href="#7-variable-requirement" class="headerlink" title="7. variable requirement"></a>7. variable requirement</h1><p>The naive way to check if a variable is empty.</p><pre><code class="bash">if [ &quot;$&#123;variable&#125;&quot; == &quot;&quot; ]; then  ...fi</code></pre><p>The tidy code could be like:</p><pre><code class="bash">a=&quot;$&#123;variable:?&#125;&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Development </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List all credentials from jenkins</title>
      <link href="/posts/2024-02-22-list-all-credentials-from-jenkins.html"/>
      <url>/posts/2024-02-22-list-all-credentials-from-jenkins.html</url>
      
        <content type="html"><![CDATA[<p>This post is mainly to help your list all credentials from Jenkins.</p><p>Run the following code in <code>Dashboard -&gt; Manage Jenkins -&gt; Tools and Actions -&gt; Script Console</code></p><pre><code class="groovy">import com.cloudbees.plugins.credentials.Credentialsimport com.cloudbees.plugins.credentials.CredentialsProviderCredentialsProvider.lookupCredentials(Credentials.class, Jenkins.instance, null, null).each &#123; c -&gt;    def className = c.properties.class.toString()    def p = c.properties    println(&quot;ID: $&#123;c.id&#125;&quot;)    println(&quot;Scope: $&#123;c.scope&#125;&quot;)    println(&quot;Description: $&#123;c.description&#125;&quot;)    println(&quot;Type: $&#123;className.substring(className.lastIndexOf(&#39;.&#39;) + 1)&#125;&quot;)    switch (c.properties.class.toString()) &#123;        case &#39;class com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl&#39;:            println(&quot;Username: $&#123;p.username&#125;&quot;)            println(&quot;Password: $&#123;p.password&#125;&quot;)            break        case &#39;class com.cloudbees.jenkins.plugins.sshcredentials.impl.BasicSSHUserPrivateKey&#39;:            println(&quot;Username: $&#123;p.username&#125;&quot;)            println(&quot;Private Key: |&quot;)            println(&quot;$&#123;p.privateKey&#125;&quot;)            break        case &#39;class org.jenkinsci.plugins.plaincredentials.impl.FileCredentialsImpl&#39;:            println(&quot;Filename: $&#123;p.fileName&#125;&quot;)            println(&quot;File Content: |&quot;)            println(&quot;$&#123;new String(c.getSecretBytes().getPlainData())&#125;&quot;)            break        case &#39;class org.jenkinsci.plugins.plaincredentials.impl.StringCredentialsImpl&#39;:            println(&quot;Secret: $&#123;p.secret&#125;&quot;)            break        default:            println(&quot;WARN: unknown credential type&quot;)            println(&quot;credential properties: $&#123;p.toString()&#125;&quot;)    &#125;    println(&quot;------------------------------------------------------------------------------&quot;)&#125;</code></pre><p>Or use the more tidy code</p><pre><code class="groovy">com.cloudbees.plugins.credentials.SystemCredentialsProvider.getInstance().getCredentials().forEach&#123;  it.properties.each &#123; prop, val -&gt;    println(prop + &quot; = &quot; + val)  &#125;  println(&quot;----------------------------------------------------&quot;)&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DevOps </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First things you should do after install jetbrains IDE</title>
      <link href="/posts/2024-02-07-first-things-you-should-do-after-install-jetbrains-ides.html"/>
      <url>/posts/2024-02-07-first-things-you-should-do-after-install-jetbrains-ides.html</url>
      
        <content type="html"><![CDATA[<p>JetBrains produces a suite of integrated development environments (IDEs) that are highly regarded by developers for their productivity-boosting features and user-friendly interfaces. Some of the most popular JetBrains IDEs include IntelliJ IDEA, PyCharm, WebStorm, PhpStorm, RubyMine, GoLand and etc.</p><p>Here are some things you need to prepare in advance before using them formally.</p><h1 id="Disable-IDE-await"><a href="#Disable-IDE-await" class="headerlink" title="Disable IDE await"></a>Disable IDE await</h1><p>“ide.await.scope.completion” to be a registry option that can be toggled to alter the behavior of JetBrains IDEs during shutdown. Sometimes when you close the IDE, it gets stuck at the ‘Closing Project’ dialog.</p><p>Here’s a breakdown of the steps outlined in the workaround:</p><ol><li>Select “Help” from the main menu of IDE.</li><li>Choose “Find Action.”</li><li>Type “Registry…” and select it from the search results.</li><li>In the opened list of registry options, find and disable the “ide.await.scope.completion” option.</li></ol><h1 id="Shortcut-for-Open-in-Terminal"><a href="#Shortcut-for-Open-in-Terminal" class="headerlink" title="Shortcut for Open in Terminal"></a>Shortcut for Open in Terminal</h1><ol><li>Select “File” from the main menu of IDE.</li><li>Choose “Setting”</li><li>Select “Keymap” in the open dialog.</li><li>Go to “Plugin” - “Terminal” - “Open in Terminal”</li><li>Set a shortcut for “Open in Terminal”, “Ctrl + T” is recommended.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> JetBrains </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Install Docker CE on UOS Server 1050e</title>
      <link href="/posts/2024-01-27-install-docker-ce-on-uos-server-1050e.html"/>
      <url>/posts/2024-01-27-install-docker-ce-on-uos-server-1050e.html</url>
      
        <content type="html"><![CDATA[<p>Let’s quick start.</p><h1 id="Prepare-docker-ce-repo"><a href="#Prepare-docker-ce-repo" class="headerlink" title="Prepare docker-ce.repo"></a>Prepare docker-ce.repo</h1><pre><code>$ curl -L https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo$ sed -i &#39;s+https://download.docker.com+https://mirrors.ustc.edu.cn/docker-ce+&#39; /etc/yum.repos.d/docker-ce.repo$ sed -i &#39;s+$releasever+8+&#39; /etc/yum.repos.d/docker-ce.repo</code></pre><h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><pre><code>$ yum install -y docker-ce</code></pre><h1 id="Enable-system-service"><a href="#Enable-system-service" class="headerlink" title="Enable system service"></a>Enable system service</h1><pre><code>$ systemctl enable docker$ systemctl start docker</code></pre><h1 id="Check-service-status"><a href="#Check-service-status" class="headerlink" title="Check service status"></a>Check service status</h1><pre><code>$ systemctl status docker</code></pre><p>The result should show like below. Active status should be <code>running</code>.</p><pre><code>[root@localhost ~]# systemctl status docker● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)   Active: active (running) since Sat 2024-01-27 16:52:24 CST; 10s ago     Docs: https://docs.docker.com Main PID: 12132 (dockerd)    Tasks: 7   Memory: 32.7M   CGroup: /system.slice/docker.service           └─12132 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> UOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Open files with system-associated editor in JetBrains IDE</title>
      <link href="/posts/2023-07-26-jetbrains-ide-open-file-with-system-associated-applications.html"/>
      <url>/posts/2023-07-26-jetbrains-ide-open-file-with-system-associated-applications.html</url>
      
        <content type="html"><![CDATA[<p>The JetBrains series of IDEs are obviously very powerful and have become essential development tools for many developers.</p><p>However, I encountered a minor issue while using them: I prefer to edit certain files using the system-associated editor rather than the built-in Markdown editor in JetBrains IDE. For instance, Markdown files.</p><p>When you want to use a system-associated editor instead of the built-in editor in JetBrains IDE for certain files, you can follow these steps:</p><ol><li>Open your JetBrains IDE (e.g., IntelliJ IDEA, PyCharm, etc.).</li><li>Go to “File” -&gt; “Settings” (or “IntelliJ IDEA” -&gt; “Preferences” on macOS) from the menu bar.</li><li>In the Settings window, navigate to the “Editor” section and select “File Types”.</li><li>In the “File Types” tab, locate the file type for which you want to use the system-associated editor, such as Markdown files.</li><li>After selecting the file type, you will see the file extensions for that file type listed in the “Registered patterns” text box below the “Registered patterns” list.</li><li>Enter or edit the file extensions for the system-associated editor in the text box, separating each extension with a semicolon. For example, if you want the system-associated editor to handle Markdown files, you can enter *.md.</li><li>Click the “Apply” or “OK” button to save your settings.</li></ol><p>After completing these steps, the system will use the associated editor to open the specified file types instead of the built-in editor in JetBrains IDE.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> JetBrains </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lightweight Deepin Linux</title>
      <link href="/posts/2023-07-04-lightweight-deepin.html"/>
      <url>/posts/2023-07-04-lightweight-deepin.html</url>
      
        <content type="html"><![CDATA[<p>Deepin Linux is a Debian-based Linux distribution known for its visually appealing desktop environment and user-friendly interface. It’s developed by Chinese software company Deepin Technology Co., Ltd. Deepin features the Deepin Desktop Environment (DDE), which offers a sleek and intuitive interface similar to macOS, with a dock at the bottom, a global menu bar at the top, and various animations and effects.</p><p>Aside from its aesthetics, Deepin also provides a range of built-in applications, including a file manager, music player, video player, and more, all designed to integrate seamlessly with the desktop environment. It’s known for its simplicity and elegance, making it a popular choice for users who prefer a polished and modern Linux experience.</p><p>Deepin Linux also includes its own software center, which provides users with access to a wide range of applications for installation and updates. It’s available in multiple languages and is used by people around the world who appreciate its user-friendly approach and attractive design.</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>After system startup, it will consume 1.2GB of memory by default.</p><pre><code>root@deepin:~# free -mh              total        used        free      shared  buff/cache   availableMem:          7.7Gi       1.2Gi       4.7Gi        22Mi       1.9Gi       6.3GiSwap:            0B          0B          0B</code></pre><h1 id="Disable-services"><a href="#Disable-services" class="headerlink" title="Disable services"></a>Disable services</h1><pre><code>systemctl disable lightdm --nowsystemctl disable dde-filemanager-daemon --nowsystemctl disable deepin-accounts-daemon --nowsystemctl disable deepin-devicemanager-server --now</code></pre><h1 id="Effectiveness"><a href="#Effectiveness" class="headerlink" title="Effectiveness"></a>Effectiveness</h1><p>After disabling some unnecessary services using the above methods, the system now only consumes 347MB of memory.</p><pre><code>root@server:~# free -mh              total        used        free      shared  buff/cache   availableMem:          7.7Gi       347Mi       7.2Gi       2.0Mi       183Mi       7.1GiSwap:            0B          0B          0B</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>To solve Terminator split screen divider transparent background problem</title>
      <link href="/posts/2023-07-03-terminator-transparent-problem-solved.html"/>
      <url>/posts/2023-07-03-terminator-transparent-problem-solved.html</url>
      
        <content type="html"><![CDATA[<p>To solve the issue of Terminator terminal emulator’s split screen divider having a transparent background, you can try the following steps:</p><p>In the Linux desktop environment, Terminator is a highly versatile terminal tool that allows for multiple horizontal and vertical splits of the current page. However, there is an issue where the divider between splits is transparent, <strong>which can sometimes make it difficult to distinguish between the split blocks</strong>.</p><p>If you want to use a solid color as the background for the split line, you can use the following method:</p><h2 id="Edit-terminator-py"><a href="#Edit-terminator-py" class="headerlink" title="Edit terminator.py"></a>Edit terminator.py</h2><p>Edit Terminator source code file <code>/usr/share/terminator/terminatorlib/terminator.py</code>. Please note that modifying this file requires <code>root</code> permissions.</p><p>Search <code>background_type</code>, this should be in about line 495。</p><pre><code>            if profiles[profile][&#39;background_type&#39;] == &#39;transparent&#39;:                bgalpha = profiles[profile][&#39;background_darkness&#39;]</code></pre><p>Replace these two lines with:</p><pre><code>            if profiles[profile][&#39;background_type&#39;] == &#39;image&#39;:                backgound_image = profiles[profile][&#39;background_image&#39;]            if profiles[profile][&#39;background_type&#39;] == &#39;transparent&#39; or profiles[profile][&#39;background_type&#39;] == &#39;image&#39;:                bgalpha = profiles[profile][&#39;background_darkness&#39;]</code></pre><h2 id="Add-a-css-file"><a href="#Add-a-css-file" class="headerlink" title="Add a css file"></a>Add a css file</h2><p>Add a <code>~/.config/gtk-3.0/gtk.css</code> file in the user’s home directory with the following content:</p><pre><code>.terminator-terminal-window separator &#123;  background: #303030;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】现代软件工程 - 第二部分：测试</title>
      <link href="/posts/2023-07-02-modern-software-engineering-part-2-testing.html"/>
      <url>/posts/2023-07-02-modern-software-engineering-part-2-testing.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>“如果调试是清除软件缺陷的过程，那么编程一定是把它们放进去的行为”。—— Edsger Djikstra</p></blockquote><p>编写自动化软件测试就像和自己玩电话游戏–当你误解了信息是什么时，你是唯一可以责备的人。如果你为自己的代码写测试，这已经够难的了，但是考虑到你为别人写的代码写测试，而这些代码本来就没有被测试。现在，这就像试图理解一张在蓝色牛仔裤口袋里洗过的纸上的信息是什么……三次!</p><p>这是在被测试的代码已经写完之后才写的测试。现在考虑一下先写测试的做法–这就像和自己玩高手过招，先写一些看似合理的规范或测试，以确保你要写的解决方案会 “做正确的事”。但是，如果你学过计算机科学，那么这听起来非常像解决停止问题–只是更糟糕，因为现在你不仅需要向自己证明，还需要向编译器&#x2F;解释器证明你希望它做的事情是正确的。</p><p>那么，为什么在过去的20年里，测试一直是现代软件工程实践中不可或缺的一部分–无论是测试优先还是测试最后，我们专业的软件工程师仍然需要考虑如何测试和验证软件以满足需求。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>又到了故事时间。</p><p>上次在第一部分中，我写到我是如何艰难地学会了如何设计系统以适应现代的扩展性、可靠性、可用性、可维护性和安全性要求。设计一个解决方案只能到此为止，因为到了最后，这个解决方案需要被实施–有时，它必须由一个团队或多个团队来完成。</p><p>你可以想象，跨团队的协调工作将是问题的主要来源，但我们是否可以做些什么来减少这种负担？自动测试来了–特别是那种指定行为而不是测试实现的测试。</p><p>当我在Friendster工作的时候，我可以知道我所从事的服务的客户端到底期望什么。然而，这并不是完全明确的–我们有一个我们所遵循的协议（这是在协议缓冲区流行之前）和一些被这些客户端调用的URI。语义并没有完全阐明，但我们有一个忠实的听众–我可以阅读客户端的代码，并从当前的实现中找出期望。</p><p>这一点很重要–我们不是创建一个全新的协议或创建一个新的合同，而是从已知的需求开始，我们可以把这些需求写成自动测试。我首先要做的几件事之一是把这些测试变成我可以编程的规范，并逐步把实现带到满足要求的地步。这项工作产生了两个产品：</p><ul><li>C++网络库–一个性能相当好的HTTP客户端和服务器的C++实现，我正在重写的服务将在此基础上集成。</li><li>memcache++库 - 一个性能合理的C++实现的memcache客户端，支持分片和虚拟节点池。</li></ul><p>这两个开源解决方案都是内部定义的技术要求的结果。我们从一个现有的系统开始，将其分解成各个组成部分，然后逐步实施这些解决方案，直到我们可以将非业务关键部分作为开源软件共享。</p><p>你可能会问，为什么我需要从测试开始？因为测试允许我以一种渐进和可预测的方式来填充解决方案以满足需求。有了测试，我和审查我所写的代码的人就能理解需求是什么，并通过运行测试自动验证它们。这使我们能够逐步获得我们所需要的信心，我们得到了一个满足我们需求的解决方案。</p><p>有了测试，我就可以专注于什么是必要的和足够的功能，同时让我有信心重构和改进解决方案，并快速验证我是否破坏了编码需求的测试。通过让测试涵盖需求，我已经能够捕捉到许多错误，并快速地交付功能，在此过程中无畏地进行重构。</p><p>那是在2007-2008年左右，很多这些概念（如测试驱动开发和行为驱动开发）刚刚开始流行，但通常是在企业软件行业。在这里，我把其中一些好的想法应用到了微服务和水平可扩展的系统中!</p><p>快进了几年，我们现在到了2023年，测试在某些圈子里已经变成了一个肮脏的词（TDD和BDD往往烧毁了很多人，主要是由于对原则的误解），并且已经成为一种事后的想法，我们要求我们的副驾驶为我们写的代码做单元测试。这有点可惜，因为采用正确测试的高性能软件工程团队在适应不断变化的需求和改进解决方案的实施方面的自由度是非常有价值的，那些没有及早投资的团队往往会在很晚的时候才意识到，测试本来可以拯救他们的重大故障，由于错误爬到生产中而导致的不眠之夜，或者由于解决方案质量差和速度低而失去业务。</p><p>在这篇文章中，我将写更多关于测试在现代软件工程中的作用，以及如何正确地进行测试使你和你的团队在行业中取得成功。</p><h1 id="测试水平"><a href="#测试水平" class="headerlink" title="测试水平"></a>测试水平</h1><p>在我们进一步讨论之前，最好先了解测试的不同级别或类别。如果你以前没有写过测试，知道有一个相当健全的测试术语分类法可能会有好处，这样你至少可以跟上围绕它们发生的讨论。</p><ul><li>用户验收测试 —— 通常是自动测试，确保软件系统符合终端用户的要求。模拟终端用户通常包括驱动软件的用户界面（基于浏览器的网络用户界面的自动测试，本地应用程序用户界面的应用程序驱动程序，API服务客户端等），以执行用户会做的事情，并观察这些行动的结果，看它是否符合软件的验收标准。这通常是最高级别的测试，涵盖了整个软件系统的所有内容。</li><li>系统测试 —— 通常是对系统的功能和非功能属性进行测试的自动化测试。在这里，一个系统可以是一个完全集成的应用，也可以是一个带有相关组件的子系统。系统测试通常比用户验收测试（UATs）更全面。</li><li>集成测试 —— 典型的自动化测试，测试在集成环境中作为子系统工作的多个组件的相互作用（通常是测试线束或应用程序支架），这有利于集成组件的布线和测试。集成测试通常是对一个完整解决方案的逻辑子系统进行测试，这些子系统一起工作以提供一组特定的功能。</li><li>单元测试 —— 典型的自动化测试，对单个组件（不一定是单个类）的功能进行隔离测试。依赖关系可以由功能相当的实现来代替，以便于以受控的方式（有时是故意的）来模拟这些依赖关系。</li></ul><p>在某些情况下，你可能会遇到需要有人工或人类驱动的测试来覆盖一些不可预测的或组合巨大的可能性空间（考虑计算机游戏，人工智能模型，控制系统等）。这些在软件工程行业中仍然有很好的地位，但在这篇文章中，我将专注于自动化测试案例。</p><p>现在我们有了一些定义，让我们深入了解一些现代软件工程的测试方法以及它是如何改变我们解决问题的方式的。</p><h1 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h1><p>测试驱动开发或TDD是一种实现软件的方法论，首先将测试（或规范）写成可执行代码，看到测试失败（先是红色），实现一个解决方案以满足需求，看到测试成功（绿色），重构解决方案的可读性和灵活性，同时保持测试成功运行（保持绿色），并进行迭代。下面是对这个方法论中每个步骤的更多解释：</p><ul><li><strong>写一个失败的测试来代表一个需求。</strong> 这可能使用一个还不存在的类，或一个还没有实现的方法，或一个还没有被现有实现处理的情况，或一些系统还没有执行的新行为–不管新的需求是什么，写一个测试来代表这个需求，作为可执行的东西，并且最初失败。这一步让我们思考缺失的功能，以及它在任何层次上的使用方式–测试可以是UAT，系统测试，集成测试，或单元测试。</li><li>实施解决方案以满足需求（绿色）。满足需求的初始实现可能是最简单的工作，或者是一个简单的 “返回测试期望的东西”（我知道，这感觉像是作弊，但相信这个过程……），只是为了让你看到测试 “变绿”。这一步迫使我们思考解决这个问题的最直接的方法，这样我们就可以进入下一步，重新做这个循环。</li><li>无情地重构，同时保持测试的绿色（保持绿色）。不要在这里通过第2步，因为软件工程的肉发生在这一步，在这里我们可以看一下测试和实现中使用的接口，看看我们是否正在接近一个更可维护和灵活的解决方案，或者我们是否需要更多的测试来找到模式。你拥有的覆盖系统功能的测试越多，你就越需要重构，不仅是实现，还有测试–如果你也遵循领域驱动设计，这可以让你细化系统中的模型，这样你对解决方案的理解就会随着模型的变化而不断发展。</li><li>迭代。当你在不同的层次（UATs，系统测试，集成测试，单元测试）覆盖了越来越多的系统功能和非功能需求时，你将不可避免地发现一些需求不再是需求，现有的需求由于新的业务需求而略有变化，你可能不得不从某些子系统重新开始。认识到什么时候去增加测试，删除测试，优化性能或效率，或者只是叫它完成并继续前进，是整个过程的一个重要部分。只要你还没有完成，就回到第1步。</li></ul><p>请注意，即使你已经有了一个没有测试的代码库，你也可以开始遵循TDD。你可以自上而下（从UATs到单元测试）或自下而上（从单元测试到UATs），并在此过程中开始重构你的接口，让你觉得更有信心代表逻辑组件或领域模型。</p><p>从一开始就遵循TDD有很多好处：</p><ul><li>你在写测试的时候不得不考虑需求和设计。难以测试的代码通常意味着它没有遵循良好的设计实践。如果你发现你不能很好地表达测试，意味着你没有很好地理解需求，这迫使你在写测试之前首先要理解需求是什么。</li><li>你有更多的信心，你所拥有的解决方案甚至在到达生产之前就能满足要求。提前发现问题可以使你免受生产中可预见的麻烦。它还允许你专注于解决已经存在的指导问题，而不是等了很久才知道你是否满足了需求，当它上线时。与其把时间花在调试上，不如把时间花在解决其他问题上，并自信地逐步交付价值。</li><li>你有时间去整理，使之变得漂亮。TDD明确地将重构的时间作为开发过程的一部分–而不是推迟到以后的事情。如果你时间紧迫，需要推迟重构，那么它也可以在以后再进行，因为你的测试代表了需求的状态，而且实施质量可以作为过程的一部分得到改善。</li></ul><p>这也很好，但我们也需要承认TDD的成本和一些缺点。</p><ul><li>编写和运行自动化测试并不便宜。有些种类的测试比其他的更难写，而且它们也不是都能产生同样的价值。编写UATs可能需要特定测试框架的专业知识，或者在模拟生产部署时，需要使用不容易获得的特殊硬件（例如强大的GPU或FPGA）。有些需要全面部署多个服务，为测试目的而建立这些服务可能不符合成本效益，因此可能会走一些弯路。</li><li>要显示测试代码的价值是很难的，特别是当它被看作是一种机会成本时。很多人仍然认为测试是浪费时间，因为重要的是运送工作的东西–如果他们在生产中失败了，我们就黑掉它，因为我们需要赚足够的钱，这样资金就不会用完。不幸的是，用运送代码到生产中来代替测试，意味着你每次部署代码和新功能时，都在为你的解决方案和业务的有效性冒险。尽管TDD是一个很好的做法，而且有大量的成功案例表明为什么遵循TDD是一个好主意，除非有效的测试覆盖率被看作是对未来故障和需求变化的保险政策，那么它将是一个难点。</li><li>当你把有效的测试和100%的测试覆盖率混为一谈时，你会有一个糟糕的时间。TDD并不是要达到100%的测试覆盖率，而是专注于将需求表现为可执行的测试。只要你想，你可以有很多测试，只要它们能代表你正在构建的系统的重要内容。拥有100%的测试覆盖率并不代表你的测试在代表解决方案的重要内容方面有多有效。它可能是一个较小的测试集在确保你要解决的问题被解决方面得到了最好的价值。</li></ul><p>TDD并不是我们在这个世界上遇到的所有软件质量问题的万能药。然而，它是一种实践，可以帮助保持重要的焦点，以便我们可以有信心地设计满足需求的系统。</p><h1 id="自动测试"><a href="#自动测试" class="headerlink" title="自动测试"></a>自动测试</h1><p>如果你已经遵循TDD，那很好。但如果你不这样做，你有可以在以下情况下自动运行的测试仍然很重要：</p><ul><li>在开发时，在 “内部开发者循环 “中。如果你不能在你的集成开发环境或你的工作站中运行测试，以快速验证你的解决方案正在做他们应该做的事情，那么你会有一个糟糕的时间。确保自动化测试能够快速构建&#x2F;运行，并且能够代表重要的需求，这是一个重要的生产力提升器，值得投资。如果你除了写自动化测试，开发人员可以在他们的工作站上运行，你已经达到了自动化测试的80%的好处。</li><li>维护一个回归测试套件。每当提出或发现bug时，首先应该做的是用失败的测试来重现它。这样你就可以把修复错误的过程当作另一个需求来管理，把它表达为一个捕捉回归的测试（这意味着，软件不会表现出一个在过去已经被修复的错误）。你把越多的bug变成回归测试，你就越能更广泛地表达系统上的实际需求，并防止它们在未来反复出现。</li><li>也要测试系统的非功能方面。非功能需求指的是与功能没有严格联系的系统质量–如吞吐量、延迟、资源消耗、最低负载要求，以及其他可观察的属性。自动化这些需求可以让你把它们变成设计和实现需求的一部分，这样在对系统进行修改的时候，它们总是被考虑在内。</li></ul><p>自动化测试正在成为提供具有竞争力和更高质量的软件系统的关键工具，特别是在我们今天看到的现代软件工程实践中。鉴于我们正在构建和部署的系统的复杂性和关键性，很难看到我们如何能够在没有自动化测试的情况下向前管理。</p><h1 id="现代测试技术"><a href="#现代测试技术" class="headerlink" title="现代测试技术"></a>现代测试技术</h1><p>假设你已经实现了自动化测试，你有UATs、系统测试、集成测试和单元测试，你可以运行。你也有一个回归测试套件和非功能需求表达为自动化测试。你如何将你的测试实践带到现代软件工程时代？</p><p>特别是对于那些在云中作为分布式系统开发和部署的软件，在像Kubernetes这样的环境中协调，控制平面分别管理工作负载和资源的放置和管理，公共云供应商为网络存在和地理多样性提供管理资源，应用程序的架构变得越来越复杂。测试这些应用程序变得非常困难和昂贵。</p><p>以下是管理这种复杂性需要考虑的几件事，并确保你能跟上现代大规模全球可用服务的需求：</p><ul><li>投资于持续集成和持续交付。在你的软件投入生产之前进行测试，只能让你的测试达到一定程度，但生产的现实情况在开发中很少被预料到。有一种方法可以将在集成环境中测试过的代码以可控和安全的方式持续地运送到生产中，这是能够使你的解决方案适应生产的现实的关键。因为你已经投资了测试，你在生产中发现的错误可以被表述为失败的测试，并自动通过你的持续集成（CI）和持续部署（CD）管道运行。这减少了上市时间，缩短了工程团队的反馈周期。</li><li>投资于模糊测试和自动故障查找。有大量的解决方案可以在你依赖的系统中自动注入故障，无论是远程API服务还是内部组件。Fuzzing是一种测试方法，它使用随机生成的输入来发现潜在的安全漏洞或意外问题。虽然不能取代手写的测试，但这些测试可以增强你为你的系统编写的需求驱动的测试，以便在开发过程的早期发现潜在的故障。</li><li>使用尽可能多的生产暴露来测试你的系统。在生产中进行小规模的测试（也被称为金丝雀测试），可以让你的系统得到最真实的测试。将生产中的测试作为应用程序交付和部署管道中的一个关键环节。</li><li>利用人工智能和LLMs来增加你的测试覆盖率。如果你能获得GitHub Copilot或类似的技术，考虑使用它们（在咨询了法律顾问关于这对你的公司和代码的影响后）来填补你现有系统的单元、集成和系统测试。或者，如果你开始使用TDD，考虑用AI自动化来减少内循环中开发这些测试的时间。毕竟，如果开发人员花在编码测试上的时间是一个问题，那么AI应该是减少这种成本的一个好方法。）</li></ul><p>随着系统变得越来越复杂，因为它们是分布式的，处理的规模也越来越大，自动化测试对于确保我们正在开发的各种交互式系统的质量和正确性只会更加重要。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>编写和维护有效的自动化测试，代表软件系统的关键要求，正成为今天软件工程专业人员的追求和重要技能。拥有测试专家的日子已经一去不复返了，就像现在每个人都是开发人员和运营工程师一样。现代软件工程要求每个软件工程从业者都知道并理解自动化测试的价值，它如何影响我们交付给客户的软件系统的稳健性、质量和有效性。</p><p>在一天结束时，软件工程是关于建立正确的东西来解决正确的问题。知道解决这个问题的要求是什么，是能够有效解决这个问题的关键。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Repost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】现代软件工程 - 第一部分：系统设计</title>
      <link href="/posts/2023-06-21-modern-software-engineering-a-series-part-1-system-design.html"/>
      <url>/posts/2023-06-21-modern-software-engineering-a-series-part-1-system-design.html</url>
      
        <content type="html"><![CDATA[<p>在80年代末90年代初长大的我，对电脑的接触几乎仅限于游戏机（我认为是Atari 800和Commodore 64游戏机，因为我只看到过在它们上面运行的游戏）或早期的x86系统。直到2000年我上了大学，我才掌握了一台Sun Microsystems SPARC工作站、UNIX和我可以在家里Intel 486机器上安装的Slackware Linux.</p><p>那时，软件开发主要是指在你的机器上本地运行的软件，或者，如果你有机会的话，在时间共享的计算机上运行的软件，其处理能力明显高于你，可以做商业相关的事情。我记得，在大学里听说过一个计算机科学家使用的程序，它需要一个多核处理器来生成数千个学生的课程表；生成和打印课程表需要数周时间。直到今天，我仍然不确定程序运行时间还是打印到纸上时间哪个更长。</p><p>今天，大多数正在开发的软件要么在云上运行，要么在需要访问云的设备上运行，要么为同样在云上运行的其他软件提供动力。在密闭空间内工作的软件系统（如嵌入式软件系统），如果不能在其他地方获得更强大的计算平台，那是非常罕见的。会计系统现在压缩了大量的数据，这些数据被托管在公司内部或外部的数据仓库的服务器群中。销售系统现在由第三方管理客户关系，并由更多的第三方或内部开发人员开发插件。</p><p>但是，今天这些软件系统是如何建立的，以服务数百到数百万的用户，同时还能保持我们对今天使用的软件所期望的性能和响应性？</p><p>作为一个有20年之久的软件工程师，我见过许多系统从堆栈的每个层面被开发出来。从DOS时代的中断处理程序到JavaScript驱动的动画，甚至是无代码的报告生成。几周前，我甚至让ChatGPT-4根据我给它的一些描述来生成一些我想要的Python代码！但这是另一个故事！但这是另一个故事了。</p><p>在这篇文章中，我写的是系统设计，它如何成为现代软件工程实践的一个关键部分，以及它将是人类软件工程师在中短期内仍能提供价值的关键领域之一。</p><h1 id="系统设计的重要性"><a href="#系统设计的重要性" class="headerlink" title="系统设计的重要性"></a>系统设计的重要性</h1><p>很久以前，我是一家公司的软件工程师，这家公司在处理他们自己带来的成功的负荷方面存在问题。我把这家公司称为Friendster。当我加入这家公司时，我所负责的项目已经很晚了，而且有许多与内存管理有关的错误。他们的核心服务（是的，在2007年我们这样称呼它之前，它是一个微服务）是用C++编写的，但有内存泄漏，处理请求的时间太长，而且被设计为在自己的内存中缓存和提供数据。它需要是无状态的，但最后却变成了有状态的。</p><p>在项目进行了几周后，我恳求高级工程领导层放弃这个服务的迭代，而是从头开始写一些符合要求的东西；这将是对现有实施的一个直接替换。我们有一个最后期限，因为该服务只能再处理几个月的增长，然后它就不能再以重新水化的方式处理缓存的大小。</p><p>重新启动服务所花的时间比它能保持的时间还要长，直到内存泄漏使它瘫痪。这是一个 “赌上我的职业生涯 “的时刻，但我几乎没有这个时间。我们必须让它运转起来。</p><p>系统设计开始了。我们做的第一件事是列出系统必须满足的要求，依赖服务（PHP前端代码）和这个核心服务之间的合同是什么，以及一个关于我们如何满足三个关键的非技术要求的计划：性能、效率和弹性。</p><p>系统设计涉及到了解系统必须执行其功能的约束条件，所需的功能是什么，以及相对于所有其他属性而言，系统的哪些属性是重要的。一旦你有了这些定义，你就可以开始设计一个符合要求的系统，并系统地规划出解决方案的交付。</p><h1 id="系统设计的组成部分"><a href="#系统设计的组成部分" class="headerlink" title="系统设计的组成部分"></a>系统设计的组成部分</h1><p>当我们谈及系统设计时，通常有几个组成部分：</p><ul><li>架构 —— 整体解决方案是什么样子的？它是否涉及多个子系统？是否有单独的组件组成一个整体？它们是如何相互作用的，以及它们之间的关系如何？</li><li>拓扑结构 —— 解决方案是否有分层？如果这是一个分布式系统，组件服务在物理上或逻辑上的位置是什么？</li><li>底层设计 —— 你定义了哪些接口，系统的不同部分通过这些接口进行交互？你是否有具体的算法来处理解决方案的关键部分（性能、效率、吞吐量、复原力等）？</li></ul><p>首先要了解一些事情，比如：系统是自成一体的（即：不会访问外部资源）还是分布式的？它是否会有一个用户界面，或者是非交互式的（例如，它是否会生成一份打印出来的报告，或者它在运行过程中是否需要来自人为或其他系统的输入？）它是否需要处理大量的流量？它是在任何时候只有十个人使用，还是在任何时候有千万个用户使用它？</p><p>一旦你对其中一些问题有了答案，通过系统设计原则做出决定就会更容易。</p><h1 id="系统设计的原则"><a href="#系统设计的原则" class="headerlink" title="系统设计的原则"></a>系统设计的原则</h1><p>在这个现代社会中，设计软件系统的几个关键原则直到系统需要扩展时才完全出现——从一个单用户系统到一个应该能够同时处理成千上万甚至数百万用户的系统。以下是我们将在本文中介绍的一些内容：</p><ul><li>可扩展性</li><li>可靠性</li><li>可维护性</li><li>可利用性</li><li>安全性</li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>当一个系统可以在资源成比例增长的情况下被部署来处理负载的增长时，它就是可扩展的。一个系统的扩展系数被定义为服务于系统负载增长所需的资源量的增长。我们在软件系统中会遇到两种典型的扩展情况：垂直扩展和水平扩展。</p><p>垂直扩展是指为软件系统提供更多的空间或单机资源以处理需求的增长。考虑一下网络附加存储设备的情况。你通过设备提供的存储越多，它能存储的数据就越多。如果你需要它处理更多的并发连接和I&#x2F;O操作（IOPs），你通常需要增加计算能力和网络接口来处理增加的负载。</p><p>横向扩展是指用软件的副本复制一个系统或多台机器，以处理需求的增长。考虑一下隐藏在负载均衡器后面的静态网络内容服务器的情况。添加更多的服务器可以让更多的客户连接并从网络服务器上下载内容，当负载减弱后，网络服务器的数量可以缩减到适合当前需求的规模。</p><p>有些系统可以处理混合或对角线的扩展。例如，一些分布式数据库架构允许分割计算和存储节点，这样，计算重的工作负载可以使用具有更多计算资源的节点。相反，IOPs的重度工作负载可以在存储+计算节点上运行。例如，流处理应用程序可能会分离出需要更多内存和计算的工作负载（例如，事件源或分析工作负载），并适当地扩展这些工作负载，并独立于IOPs的重型工作负载（例如，压缩和归档）。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>当一个系统能够容忍部分故障和恢复而不严重降低服务质量时，它就是可靠的。一个系统的可靠性的一部分包括其在延迟、吞吐量和遵守商定的操作范围方面的可预测性。</p><p>确保系统可靠性的通常方法包括以下内容：</p><ul><li>设置系统冗余以支持透明或最小中断的故障切换。</li><li>在内部错误或输入引起的故障的情况下，建立容错机制。</li><li>明确界定延迟、吞吐量和可用性的合同和目标。</li><li>设置足够的备用容量，以满足负荷的突发和有机增长。</li><li>服务质量保障措施，强制执行费率限制和客户&#x2F;业务隔离。</li><li>在过载或灾难性故障的情况下，实施优雅的服务退化。</li></ul><p>构建可靠系统需要记住的关键一点是，以一种定义明确的方式处理潜在的故障，使依赖系统能够做出反应。这意味着如果有输入可能导致系统对所有人都可用，那么它就不是一个可靠的系统。同样地，如果系统依赖于另一个可能不可靠的系统，那么它应该用策略来处理不可靠的问题，以确保可靠性。</p><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>当以相应的努力来改变一个系统，并以最小的用户干扰来部署时，这个系统是可维护的。这就要求在实施系统的时候，假定需求会发生变化，并且系统有足够的灵活性来处理可预见的方向变化。这也意味着要确保代码的可读性，以便下一组维护者（可能是同一个团队，但在未来用新的眼光来看待它）能够维护软件，并使其进化以满足未来的需求。</p><p>没有人愿意被困在维护那些僵化的、难以改变的、没有良好组织的、文件化程度低的、设计不良的、未经测试的、胡乱拼凑的软件。</p><p>确保代码质量高是卓越工程的一部分，体现了专业精神和优秀的工艺。这不仅是一件好事，而且众所周知，它可以让高功能和高性能的工程团队提供可以改变和扩展的软件，以持续提供价值。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>如果你的服务不可用，它可能不存在。</p><p>系统设计应该解决一个系统应该如何保持可用性，以保持与客户和系统用户的相关性。这意味着：</p><ul><li>引入冗余机制处理基础系统故障。</li><li>拥有备份和恢复方案和操作指南，使系统从硬故障中恢复过来。</li><li>从系统中去除尽可能多的单点故障。</li><li>除了横向可扩展性，还要有区域性的复制，并建立内容交付网络（在适当的地方），使你的数据可用。</li><li>从客户的角度监测你的系统的可用性，以更好地了解你的系统是如何为客户服务的。</li></ul><p>在我职业生涯的早期，我了解到，一个不稳定和不可用的系统有时会成为失去客户信任的最大原因。一旦你失去了客户的信任，就很难重新获得信任。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>系统设计应该把安全作为一个关键环节来解决，特别是在互联网连接系统的时代，安全威胁和漏洞会对我们的客户和系统的使用者造成实际伤害。构建安全软件的目标并不是要达到完美，而是要了解漏洞和攻击所涉及的风险。拥有一个适当的安全威胁模型和一个系统的方法来理解风险所在，以及哪些类型的威胁值得优先考虑和设计缓解措施，是安全设计和工程实践的开始。</p><p>今天，随着我们的软件系统成为现代社会更多部分的关键任务服务的一部分，安全不再是可有可无的了。在我们设计的系统中，从一开始就认真对待安全问题，使我们更接近于能够更好地依赖我们所建立和部署的软件，以满足我们用户的需求。赢得客户的信任已经很不容易了，只需要一个漏洞就可以失去很好的一部分信任。</p><h1 id="现代设计模式"><a href="#现代设计模式" class="headerlink" title="现代设计模式"></a>现代设计模式</h1><p>鉴于以上几个方面，现代分布式系统的一些模式已经出现，以不同的方式解决了这些方面的一些问题。让我们来探讨一下我们今天看到的关于系统设计的五个方面的一些比较流行的设计模式。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>随着分布式系统的兴起，其重点是通过冗余建立可靠性和规模，通过横向扩展建立效率和性能，以及通过将系统的部分解耦为独立运行的服务来建立弹性，”微服务 “一词通过实现以下几点而得到普及：</p><ul><li>将独立服务的开发、部署、操作和维护与在更大的商业运作中拥有这些服务的团队联系起来。我们可以通过直接为外部客户提供服务或通过API间接为内部客户提供服务来做到这一点。</li><li>允许微服务根据需求独立扩展。</li><li>通过一个定义明确的合同提供服务，允许实施者发展成为一个独立的服务或一个服务系统。</li></ul><p>通过我们的方面来看，微服务有吸引人的特性，如果适用于用例的话，这使它成为一个好的模式：</p><ul><li>可扩展性：无状态的微服务通常被设计成可横向扩展的，也可以从纵向扩展中受益。在容器化协调环境（如Kubernetes集群）中部署微服务的情况下，微服务甚至可以在相同的节点上运行，从而更好地利用现有的硬件，并根据需求扩展可用的容量。一个缺点是，当一个微服务的规模和关键性在一个微服务图中增长时，部署的复杂性。</li><li>可靠性：无状态的微服务通常被托管在负载平衡器后面，并在地理上分布，以避免区域性故障占用所有系统的容量。用无状态微服务建立可靠性的一个缺点是，存储系统通常需要和微服务的实现&#x2F;部署一样可靠，甚至比它更可靠。有状态的微服务就会受到两种方法中最糟糕的影响，可靠性的成本通常是以过度配置的形式来处理潜在的中断。</li><li>可维护性：实现通过API提供的定义明确且稳定的合同的微服务，允许客户针对该API进行编程，并且实现可以独立发展。然而，协调API的变化涉及潜在的昂贵的客户端迁移和跨团队协调，引入了一个微服务拥有多个积极支持的版本的时期，直到最后的客户端从旧的实现中迁移出来。随着越来越多的客户开始与微服务互动，这种情况只会变得更糟。</li><li>可用性：微服务通常依靠部署环境和外部基础设施来满足客户的可用性要求。这样做的坏处是依赖部署微服务的特定基础设施来提供高可用性解决方案。像服务网和软件负载平衡器这样的系统成为基础设施的关键部分，不再由实施者控制。这可能是一件好事，但也可能是一个持续的维护来源，因为这些系统也有更新周期和运营成本。</li><li>安全性：认证、授权、身份管理和凭证管理可以委托给中间件或通过外部机制（如Kubernetes中的工作负载身份），微服务实施可以专注于整合相关的业务逻辑。与可用性一样，缺点是解决方案的这些外部部分成为基础设施的关键部分，在微服务实施的基础上带来自己的运营成本。</li></ul><p>微服务是分解大型应用的一个好方法，在这里可以确定需要自己的扩展和可靠性域的逻辑分区。不过，当从头开始时，从一开始就设计微服务是不太理想的，因为有可能将服务分解成太小的碎片。微服务之间的通信成本–通常为HTTP或gRPC请求–是很重要的，只有在必要时才应该产生。确定功能是否适合于一个服务的一个好方法是遵循领域驱动设计或功能分解这样的做法。</p><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>如同在基于微服务的解决方案中，使用无服务器实现进一步将服务请求的关键功能部分委托给底层基础设施。如果在微服务中，服务是由一个持久化进程提供的，那么无服务器解决方案通常只实现一个入口点，以处理对一个端点的请求（通常是通过HTTP或gRPC的URI）。在无服务器部署中，没有配置实际的服务器，而是由部署环境根据需要启动资源来处理进来的请求。有时，这些资源会停留一段时间，以摊销启动它们的成本，但这只是一个实施细节。</p><p>让我们通过系统设计的各个方面来看看无服务器解决方案是如何叠加的：</p><ul><li>可扩展性：无服务器解决方案与微服务一样具有横向可扩展性，甚至更强，因为它们被设计为可按需调整规模。这种方法的缺点是需要更多的控制，并将扩展功能完全委托给底层无服务器基础设施。</li><li>可靠性：无服务器的可靠性取决于水平扩展和网络流量路由的能力。这与微服务解决方案有相同的缺点。</li><li>可维护性：无服务器的实现比微服务更易维护，因为它专注于处理请求的业务逻辑，并尽量减少模板。这与微服务所存在的API进化问题相同。</li><li>可用性：无服务器部署的可用性与它们所部署的环境一样。这也有同样的问题，底层基础设施变得比解决方案本身更重要。</li><li>安全性：无服务器的实现完全依赖于底层基础设施的安全配置。这也有同样的问题，底层基础设施变得比实际解决方案本身更关键。</li></ul><p>无服务器解决方案，或功能即服务，是一种非常有吸引力的方式，通过关注业务逻辑和价值，让底层基础设施处理服务的可扩展性、可靠性和可用性，来进行原型设计甚至部署生产级解决方案。这是一个典型的起点，可以让一个具有最小运营负担的解决方案启动和运行，对于大多数原型来说，这是一个证明我们假设的好方法。这也是一个典型的经验，一旦这些解决方案达到了扩展的极限，与运行这些相关的成本就变得足够高。这些都变成了根据所需规模调整的更优化的微服务实现。</p><h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><p>然而，有些问题领域不需要在线交易处理，而微服务和无服务器的实现并不完全符合要求。考虑到可以在后台或在有资源的情况下处理事务的情况。另一种情况是后台处理活动，其结果不一定是互动的。</p><p>事件驱动的系统遵循的模式是有一个事件源和事件汇，事件（消息）分别来自和被发送。处理是由订阅者和发布者分别对这些源和汇进行的。事件驱动系统的一个例子是一个聊天机器人，它可以参与许多对话（事件源和汇），并在它们进来时处理消息。</p><p>分布式事件驱动系统可以有多个并发的消息处理程序在相同的源上等待，可能会发布太多的汇，作为其他消息处理程序的源。这种通过汇和源将处理器连锁起来的模式被称为事件管道。通常情况下，汇和源有一个单一的实现，提供一个消息队列接口，并根据通过系统的消息需求来进行扩展。许多分布式队列管理系统也可以有效地从对角线扩展中获益，比如Apache Kafka、RabbitMQ等。</p><p>让我们通过我们的五个方面来研究分布式事件驱动系统：</p><ul><li>可扩展性：消息&#x2F;事件代理实现和消息处理程序都可以独立扩展。当处理太多的消息&#x2F;事件时，一些缺点就会出现，对事件代理的需求增长远远超过系统的可用容量。</li><li>可靠性：好的消息代理实现提供高水平的可靠性，不创建自己的消息代理实现是个好主意。缺点是对满足可靠性需求的解决方案的依赖性（例如，处理金融交易与处理聊天室的即时信息路由有很大不同）。</li><li>可维护性：如果你使用像协议缓冲区这样灵活的消息交换格式，那么在使用相同的数据描述语言的同时进化消息的写入者和读取者也是合理的。这仍然需要协调，但不像在实时交易处理系统中演变API合同那样繁琐（如在微服务和无服务器实现中）。</li><li>可用性：由于消息通常存储在耐用介质中，事件驱动的系统通常更容易实现可用性，特别是由于它们通常是非交互式应用。可用性的代价可能来自陈旧的消息和无限制的队列处理延迟。</li><li>安全性：事件驱动的系统必须管理独立于身份和证书的数据可用性。确保只有某些服务或消息处理器可以访问特定的消息队列或日志，这成为一项全职工作，因为更多不同的数据会通过系统被挖掘出来。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现代软件工程需要设计可扩展、可靠、可维护、可用和安全的系统。设计分布式系统需要非常严格的要求，因为现代系统的现实复杂性随着社会对更好的软件服务的需求而增长。我们回顾了分布式系统的三种现代设计模式，并研究了设计良好的系统的五个方面。</p><p>作为软件工程师，我们负责设计系统，解决现代分布式系统的关键问题。</p><p>在该系列的下一篇文章中，我将会写到测试及其在现代软件工程中的作用。</p><p>【转自】 <a href="https://betterprogramming.pub/modern-software-engineering-a-series-part-1-system-design-d689fabae772">https://betterprogramming.pub/modern-software-engineering-a-series-part-1-system-design-d689fabae772</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Repost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux通用802.1x认证方法</title>
      <link href="/posts/2023-03-13-linux-802-1x-authorization.html"/>
      <url>/posts/2023-03-13-linux-802-1x-authorization.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-802-1X"><a href="#什么是-802-1X" class="headerlink" title="什么是 802.1X ?"></a>什么是 802.1X ?</h1><p>IEEE 802.1X是一种网络访问控制（NAC）协议，它定义了一种在网络交换机或接入点上进行认证的标准方式。它是一个端口级别的访问控制协议，通过端口的身份验证来控制网络上的主机是否有权访问资源。IEEE 802.1X提供了一种允许网络管理员验证用户的身份、检查设备是否满足最低安全标准并允许或拒绝访问网络的方法。 </p><p>使用IEEE 802.1X，网络管理员可以防止未经授权的设备、病毒或其他恶意软件进入网络并对网络进行攻击。此外，它也提供了一种机制来保护网络免受暴力破解、ARP欺骗和MAC地址欺骗等攻击形式。因此，IEEE 802.1X可以增加网络的安全性以确保网络的保密性和数据完整性。</p><h1 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h1><p>Linux下网络配置工具不同的发行版之间略有不同，而且有些发行版默认的网络工具存在问题，会导致认证失败的问题。</p><p>本文提供一种基于Docker的认证方法。</p><p>首先当然需要安装 Docker 和 docker-compose</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="docker-compose-配置"><a href="#docker-compose-配置" class="headerlink" title="docker-compose 配置"></a>docker-compose 配置</h2><p>Dockerfile</p><pre><code>FROM debian:11RUN set -e; \    apt-get update; \    apt-get upgrade -y; \    apt-get install -y net-tools wpasupplicant</code></pre><p>docker-compose.yaml</p><pre><code>version: &#39;3&#39;services:  uniteos:    build:      context: ./      dockerfile: Dockerfile    command: wpa_supplicant -D wired -i enp3s0 -c /wpa.conf -dd -t    network_mode: host    volumes:      - ./wpa.conf:/wpa.conf:ro    restart: always</code></pre><h2 id="wpa-配置文件"><a href="#wpa-配置文件" class="headerlink" title="wpa 配置文件"></a>wpa 配置文件</h2><p>wpa.conf</p><pre><code>ctrl_interface=/var/run/wpa_supplicantctrl_interface_group=rootap_scan=0network=&#123;  key_mgmt=IEEE8021X  eap=PEAP  phase2=&quot;autheap=GTC&quot;  identity=&quot;&lt;username&gt;&quot;  password=&quot;&lt;password&gt;&quot;  priority=2&#125;</code></pre><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><pre><code>docker-compose up -d</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 802.1x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 godepgraph 优化Go项目代码结构</title>
      <link href="/posts/2023-02-15-optimize-golang-project-code-structure-with-godepgraph.html"/>
      <url>/posts/2023-02-15-optimize-golang-project-code-structure-with-godepgraph.html</url>
      
        <content type="html"><![CDATA[<p>最近在Golang项目开发过程中，发现一些启动依赖关系搞不清楚的问题。项目中会使用 <code>init()</code> 函数进行初始化，然而一个项目会有多个可执行程序，比如： </p><ul><li>A 程序仅调用 A 应用应该调用的 init 代码，结果在开发过程中，却使得 A 应用调用了其他应用程序的 init 代码。然而这种问题，在构建阶段是无法发现的。</li><li>原本规划好了调用层级，比如大致调用层级关系如： app层 -&gt; internal层 -&gt; pkg层</li></ul><p>本文将介绍如何使用 godepgraph 工具解决 Golang 项目开发过程中优化代码结构。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="bash">go install github.com/kisielk/godepgraph@latest</code></pre><h1 id="基础运行"><a href="#基础运行" class="headerlink" title="基础运行"></a>基础运行</h1><pre><code class="bash">godepgraph github.com/ismdeep/station/cmd/server</code></pre><p>输出如下：</p><pre><code>digraph godep &#123;splines=orthonodesep=0.4ranksep=0.8node [shape=&quot;box&quot;,style=&quot;rounded,filled&quot;]edge [arrowsize=&quot;0.5&quot;]&quot;bufio&quot; [label=&quot;bufio&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/bufio&quot; target=&quot;_blank&quot;];&quot;bytes&quot; [label=&quot;bytes&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/bytes&quot; target=&quot;_blank&quot;];&quot;compress/bzip2&quot; [label=&quot;compress/bzip2&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/compress/bzip2&quot; target=&quot;_blank&quot;];&quot;compress/flate&quot; [label=&quot;compress/flate&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/compress/flate&quot; target=&quot;_blank&quot;];&quot;compress/gzip&quot; [label=&quot;compress/gzip&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/compress/gzip&quot; target=&quot;_blank&quot;];&quot;compress/zlib&quot; [label=&quot;compress/zlib&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/compress/zlib&quot; target=&quot;_blank&quot;];&quot;container/list&quot; [label=&quot;container/list&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/container/list&quot; target=&quot;_blank&quot;];&quot;unicode&quot; [label=&quot;unicode&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/unicode&quot; target=&quot;_blank&quot;];&quot;unicode/utf16&quot; [label=&quot;unicode/utf16&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/unicode/utf16&quot; target=&quot;_blank&quot;];&quot;unicode/utf8&quot; [label=&quot;unicode/utf8&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/unicode/utf8&quot; target=&quot;_blank&quot;];&quot;unsafe&quot; [label=&quot;unsafe&quot; color=&quot;palegreen&quot; URL=&quot;https://godoc.org/unsafe&quot; target=&quot;_blank&quot;];&#125;</code></pre><p>但是这样的输出显示是有太多是我们不想去关心的。可以通过以下参数进行筛选。</p><h1 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h1><p>通过 <code>-onlyprefixes</code> 可以筛选仅以某个包名为前缀的包。</p><pre><code>godepgraph -onlyprefixes github.com/ismdeep/station github.com/ismdeep/station/cmd/server</code></pre><h1 id="结合-graphviz-可视化依赖树"><a href="#结合-graphviz-可视化依赖树" class="headerlink" title="结合 graphviz 可视化依赖树"></a>结合 graphviz 可视化依赖树</h1><p>首先安装 graphviz 包</p><pre><code>sudo apt updatesudo apt install -y graphviz</code></pre><p>产生依赖关系树并输出svg图片</p><pre><code>godepgraph -onlyprefixes github.com/ismdeep/station github.com/ismdeep/station/cmd/server | dot -Tsvg -o server.svg</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2023/02/16/8a02a3a4014094adbd2ddd1e283c5ec6-86bbd4.svg" alt="server"></p><h1 id="小技巧-sed"><a href="#小技巧-sed" class="headerlink" title="小技巧 sed"></a>小技巧 sed</h1><p>从上图来看，包名前缀也是比较多余，可以通过 sed 命令清理掉。</p><pre><code>godepgraph -onlyprefixes github.com/ismdeep/station github.com/ismdeep/station/cmd/server | sed &#39;s/github\.com\/ismdeep\/station\///g&#39; | dot -Tsvg -o server.svg</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2023/02/16/a7e48b23290bd455f8ba6b356d548874-5625ac.svg" alt="server"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux</title>
      <link href="/posts/2022-11-06-tmux.html"/>
      <url>/posts/2022-11-06-tmux.html</url>
      
        <content type="html"><![CDATA[<p>Easy way to use tmux.</p><span id="more"></span><h2 id="Show-session-list"><a href="#Show-session-list" class="headerlink" title="Show session list"></a>Show session list</h2><pre><code class="bash">tmux ls</code></pre><h2 id="Create-a-new-session"><a href="#Create-a-new-session" class="headerlink" title="Create a new session"></a>Create a new session</h2><pre><code class="bash">tmux new -s &lt;session-name&gt;</code></pre><h2 id="Attach-a-session"><a href="#Attach-a-session" class="headerlink" title="Attach a session"></a>Attach a session</h2><pre><code class="bash">tmux attach -t &lt;session-name&gt;</code></pre><p>or</p><pre><code class="bash">tmux a -t &lt;session-name&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30道常见Vue面试题</title>
      <link href="/posts/2022-06-16-30-vue-interview-questions.html"/>
      <url>/posts/2022-06-16-30-vue-interview-questions.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-说说你对SPA单页面的理解，它的优缺点分别是什么？"><a href="#1-说说你对SPA单页面的理解，它的优缺点分别是什么？" class="headerlink" title="1. 说说你对SPA单页面的理解，它的优缺点分别是什么？"></a>1. 说说你对SPA单页面的理解，它的优缺点分别是什么？</h1><p>SPA ( single-page application ）仅在Web 页面初始化时加载相应的 HTML、JavaScript和CSS.一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI与用户的交互避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li></ul><p>基于上面一点，SPA 相对对服务器压力小；前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将JavaScript、css 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h1 id="2-v-show与v-if有什么区别？"><a href="#2-v-show与v-if有什么区别？" class="headerlink" title="2. v-show与v-if有什么区别？"></a>2. v-show与v-if有什么区别？</h1><p><strong>v-if</strong> 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>情性</strong>的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p><strong>v-show</strong> 就简单得多 ——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的“display” 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h1 id="3-class与style如何动态绑定？"><a href="#3-class与style如何动态绑定？" class="headerlink" title="3. class与style如何动态绑定？"></a>3. class与style如何动态绑定？</h1><p>class可以通过对象语法和数组语法进行动态绑定：</p><ul><li><p>对象语法：</p><pre><code>&lt;div v-bind:class=&quot;&#123; &#39;active&#39;: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;/div&gt;data: &#123;  isActive: true,  hasError: false&#125;</code></pre></li><li><p>数组语法：</p><pre><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;data: &#123;  activeClass: &#39;active&#39;,  errorClass: &#39;text-danger&#39;&#125;</code></pre></li></ul><p>style也可以通过对象语法和数组语法进行动态绑定：</p><ul><li><p>对象语法：</p><pre><code>&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;data: &#123;  activeColor: &#39;red&#39;,  fontSize: 30&#125;</code></pre></li><li><p>数组语法： </p><pre><code>&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;data: &#123;  styleColor: &#123;  color: &#39;red&#39;  styleSize:&#123;    fontSize:&quot;&#39;23px&#39;  &#125;&#125;</code></pre></li></ul><h1 id="4-怎样理解Vue的单向数据流？"><a href="#4-怎样理解Vue的单向数据流？" class="headerlink" title="4. 怎样理解Vue的单向数据流？"></a>4. 怎样理解Vue的单向数据流？</h1><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行鄉定：父级prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><p>有两种常见的试图改变一个prop 的情形：</p><ul><li><p><strong>这个prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop数据来使用。</strong>在这种情况下，最好定义一个本地的data 属性并将这个 prop 用作其初始值：</p><pre><code>props: [&#39;initialCounter&#39;],data: function() &#123;  return &#123;    counter: this.initialCounter  &#125;&#125;</code></pre></li><li><p><strong>这个prop 以一种原始的值传入且需要进行转换</strong>。在这种情况下，最好使用这个prop 的值来定义一个计算属性</p><pre><code>props: [&#39;size&#39;]computed: &#123;  normalizedSize: function() &#123;    return this.size.trim().toLowerCase()  &#125;&#125;</code></pre></li></ul><h1 id="5-computed和watch的区别和运用的场景？"><a href="#5-computed和watch的区别和运用的场景？" class="headerlink" title="5. computed和watch的区别和运用的场景？"></a>5. computed和watch的区别和运用的场景？</h1><p><strong>computed</strong>：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p><p><strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；</p><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed， 因为可以利用computed 的缓存特性，避免每次获取值时，都要重新计算;</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch 选项允许我们执行异步操作（访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h1 id="6-直接给一个数组项赋值，Vue能检测到变化吗？"><a href="#6-直接给一个数组项赋值，Vue能检测到变化吗？" class="headerlink" title="6. 直接给一个数组项赋值，Vue能检测到变化吗？"></a>6. 直接给一个数组项赋值，Vue能检测到变化吗？</h1><p>由于JavaScript 的限制，vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfltem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ul><p>为了解决第一个问题，Vue 提供了以下操作方法：</p><pre><code class="javascript">// Vue.setVue.set(vm.items, indexOfItem, newValue)// vm.$set, Vue.set的一个别名vm.$set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)</code></pre><p>为了解决第二个问题，Vue提供了一下操作方法：</p><pre><code class="javascript">// Array.prototype.splicevm.items.splice(newLength)</code></pre><h1 id="7-谈谈你对Vue生命周期的理解？"><a href="#7-谈谈你对Vue生命周期的理解？" class="headerlink" title="7. 谈谈你对Vue生命周期的理解？"></a>7. 谈谈你对Vue生命周期的理解？</h1><p>(1) 生命周期是什么？</p><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom-＞渲染、更新-＞渲染、卸载等一系列过程，我们称这是 vue 的生命周期。</p><p>(2) 各个生命周期的作用</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的render 函数首次被调用</td></tr><tr><td>mounted</td><td>el被新创建的 vm.$el替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activated</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestroy</td><td>组件销毁前调用</td></tr><tr><td>destroyed</td><td>组件销毁后调用</td></tr></tbody></table><h1 id="8-Vue的父组件和子组件生命周期钩子函数执行顺序？"><a href="#8-Vue的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="8. Vue的父组件和子组件生命周期钩子函数执行顺序？"></a>8. Vue的父组件和子组件生命周期钩子函数执行顺序？</h1><p>Vue的父组件和子组件生命周期钩子函数执行顺序可以归类为以下4部分：</p><ul><li>加载渲染过程</li><li>子组件更新过程</li><li>父组件更新过程</li><li>销毁过程</li></ul><h1 id="9-在哪个生命周期内调用异步请求？"><a href="#9-在哪个生命周期内调用异步请求？" class="headerlink" title="9. 在哪个生命周期内调用异步请求？"></a>9. 在哪个生命周期内调用异步请求？</h1><p>可以在钩子西数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 己经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在created 钩子西数中调用异步请求，因为在 created 钩子西数中调用异步请求有以下优点：</p><ul><li>能更怏获取到服务端数据，减少页面 loading 时间；</li><li>ssr 不支持 beforeMount、mounted 钩子函数，所以放在created 中有助于一致性；</li></ul><h1 id="10-在什么阶段才能访问操作DOM？"><a href="#10-在什么阶段才能访问操作DOM？" class="headerlink" title="10. 在什么阶段才能访问操作DOM？"></a>10. 在什么阶段才能访问操作DOM？</h1><p>在钩子函数 mounted 被调用前，vue 已经将编译好的模板挂载到页面上，所以在mounted 中可以访问操作 DOM。 vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p><h1 id="11-父组件可以监听到子组件的生命周期吗？"><a href="#11-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11. 父组件可以监听到子组件的生命周期吗？"></a>11. 父组件可以监听到子组件的生命周期吗？</h1><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p><pre><code>/ Parent.vue&lt;Child @mounted= &quot;doSomething&quot; /&gt;// Child.vuemounted()&#123;  this.$emit(&quot;mounted&quot;);&#125;</code></pre><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p><pre><code>// Parent.vue&lt;Child @hook:mounted= &quot;doSomething&quot;&gt;&lt;/Child&gt;doSomething()&#123;  console.log(&#39;父组件监听到 mounted 钩子函数...&#39;)&#125;// Child.vuemounted()&#123;  console.log(&#39;子组件触发mounted 钩子函数...&#39;)&#125;// 以上输出顺序为：// 子组件触发mounted钩子函数.// 父组件监听到mounted钩子函数.当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created, updated 等都可以监听。</code></pre><h1 id="12-谈谈你对keep-alive的了解？"><a href="#12-谈谈你对keep-alive的了解？" class="headerlink" title="12. 谈谈你对keep-alive的了解？"></a>12. 谈谈你对keep-alive的了解？</h1><p>keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和exclude 属性，两者都支持宇符串或正则表达式，include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated，当组件被激活时，触发钩子函数activated， 当组件被移除时，触发钩子函数 deactivated.</li></ul><h1 id="13-组件中-data-为什么是一个函数？"><a href="#13-组件中-data-为什么是一个函数？" class="headerlink" title="13. 组件中 data 为什么是一个函数？"></a>13. 组件中 data 为什么是一个函数？</h1><p>为什么组件中的 data 必须是一个函数，然后return 一个对象，而new vue 实例里，data 可以直接是一个对象？</p><pre><code class="javascript">// datadata() &#123;  return &#123;    message:&quot;子组件&quot;,    childName:this.name  &#125;&#125;// new Vuenew Vue(&#123;  el: &#39;#app&#39;,  router,  template: &#39;&lt;App/&gt;,  components: &#123;App&#125;&#125;)</code></pre><p>因为组件是用来复用的，且JS里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的data 属性值会相互影响，如果组件中 data 选项是一个西数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data 属性值不会互相影响；而new vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h1 id="14-v-model-的原理？"><a href="#14-v-model-的原理？" class="headerlink" title="14. v-model 的原理？"></a>14. v-model 的原理？</h1><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和textarea 元素使用 value 属性和input 事件；</li><li>checkbox 和radio 使用 checked 属性和change 事件；</li><li>select 字段将value 作为 prop并将change 作为事件。</li></ul><p>以input 表单元素为例：</p><pre><code class="javascript">&lt;input v-model=&#39;something&#39;&gt;</code></pre><p>相当于</p><pre><code>&lt;input v-bind:value =&quot;something&quot; v-on:input=&quot;something = Sevent.target.value&quot;&gt;</code></pre><p>如果在自定义组件中，v-model 默认会利用名为 value 的prop 和名为 input 的事件，<br>如下所示：<br>父组件：</p><pre><code>&lt;ModelChild -model= &quot;message&quot;&gt;&lt;/ModelChild&gt;</code></pre><p>子组件：</p><pre><code class="javascript">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;props:&#123;  value: String&#125;,methods: &#123;  test()&#123;    this. $emit (&#39;input&#39;, &quot;小红&quot;)  &#125;,&#125;,</code></pre><h1 id="15-vue-组件间通信有哪几种方式？"><a href="#15-vue-组件间通信有哪几种方式？" class="headerlink" title="15. vue 组件间通信有哪几种方式？"></a>15. vue 组件间通信有哪几种方式？</h1><p>Vue组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 vue 掌握的越熟练。vue 组件问通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。<br>(1)  props &#x2F; $emit 适用 父子组件通信</p><p>这种方法是 vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p><p>(2) ref 与 $parent &#x2F; $children 适用 父子组件通信</p><ul><li>ref：如果在普通的 DOM 元素上使用，引1用指向的就是DOM 元素；如果用在子组件上，引用就指向组件实例；</li><li>$parent &#x2F; $children：访问父&#x2F; 子实例</li></ul><p>(3) EventBus($emit &#x2F; $on）适用于 父子、隔代、兄弟组件通信</p><p>这种方法通过一个空的 vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p><p>(4) $attrs&#x2F;$listeners 适用于 隔代组件通信</p><ul><li>$attrs：包含了父作用域中不被 prop 所识别(且获取）的特性绑定（class 和stvle除外）。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定（class 和style 除外），并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件。通常配合inheritAttrs 选项一起使用。</li><li>$listeners：包含了父作用域中的(不含 native 修饰器的）v-on 事件监听器。它可以通过 v-On&#x3D;”$listeners” 传入内部组件。</li></ul><p>(5) provide &#x2F; inject 适用于隔代组件通信</p><p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p>(6) Vuex 适用于 父子、隔代、兄弟组件通信</p><p>Vuex 是一个专为 vuejs 应用程序开发的状态管理模式。每一个vuex 应用的核心就是store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态（ state ）。</p><ul><li>Vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><h1 id="16-你使用过-vuex-吗？"><a href="#16-你使用过-vuex-吗？" class="headerlink" title="16. 你使用过 vuex 吗？"></a>16. 你使用过 vuex 吗？</h1><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store(仓库)。“store”基本上就是一个容器，它包含着你的应用中大部分的状态（ state ）。</p><p>(1) vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>(2) 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的getter 映射到局部计算属性。</li><li>Mutation：是唯一更改store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交mutation， 而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的Store 拆分为多个store 且同时保存在单一的状态树中。</li></ul><h1 id="17-使用过-Vue-SSR-吗？说说SSR？"><a href="#17-使用过-Vue-SSR-吗？说说SSR？" class="headerlink" title="17. 使用过 Vue SSR 吗？说说SSR？"></a>17. 使用过 Vue SSR 吗？说说SSR？</h1><p>Vue.js是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出Vue组件进行生成DOM 和操作DOM。然而，也可以将同一个组件渲染为服务端的 HTML字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p><p><strong>服务端渲染 SSR 的优缺点如下：</strong><br>(1) 服务端渲染的优点：</p><ul><li>更好的SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜素引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过Ajax 荻取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有vue 编译后的 is 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间;SSR 直接由服务端渲染好页 面直接返回显示，无需等待下载 is 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul><p>(2) 服务端渲染的缺点：</p><ul><li>更多的开发条件限制：例如服务端渲染只支持 beforcreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node js server 运行环境；</li><li>更多的服务器负载：在Node js 中渲染完整的应用程序，显然会比仅仅提供静态文件的server 更加大量占用CPU 资源 (CPU-intensive-CPU 密集)，因此如果你预料在高流量环境（high traffic）下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><h1 id="18-vue-router-路由模式有几种？"><a href="#18-vue-router-路由模式有几种？" class="headerlink" title="18. vue-router 路由模式有几种？"></a>18. vue-router 路由模式有几种？</h1><p>vue-router 有3种路由模式：hash、history、abstract，对应的源码如下所示：</p><pre><code class="javascript">switch(mode) &#123;  case &#39;history&#39;:    this.history = new HTML5History(this, options.base)    break  case &#39;hash&#39;:    this.history = new HashHistory(this, options.base, this.fallback)    break  case &#39;abstract&#39;:    this. history = new AbstractHistory(this, options.base)    break  default:    if (process.env.NODE ENV!== &#39;production&#39;) &#123;      assert(false, &quot;invalid mode: $&#123;mode&#125;&quot;)    &#125;&#125;</code></pre><p>其中，3种路由模式的说明如下：</p><ul><li>hash: 使用 URLhash 值来作路由。支持所有浏览器，包括不支持 HTML5 History API 的浏览器；</li><li>history: 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract: 支持所有 Javascript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 APl，路由会自动强制进入这个模式。</li></ul><h1 id="19-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#19-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h1><p>(1) hash 模式的实现原理</p><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是URL 中＃后面的内容。比如下面这个网站，它的location.hash 的值为”#search’：</p><p><a href="https://www.word.com/#search">https://www.word.com#search</a></p><p>hash 路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过a标签，并设置href 属性，当用户点击这个标签后，URL的hash 值会发生改变；或者使用 Javascript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染)。</li></ul><p>(2) history 模式的实现原理</p><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：<code>history.pushState()</code> 和 <code>history.repalceState()</code> 。这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p><pre><code>window.history.pushState(null, null, path);window.history.replaceState(null, null, path);</code></pre><p>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染)；</li><li><code>history.pushState()</code> 或 <code>history.replaceState()</code> 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><h1 id="20-什么是-MVVM"><a href="#20-什么是-MVVM" class="headerlink" title="20. 什么是 MVVM?"></a>20. 什么是 MVVM?</h1><p>ModelView-ViewModel (MvvM)是一个软件架构设计模式，由微软 WPF 和Silverlight 的架构师 Ken Cooper 和Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表MVVM 源自于经典的 Model-View-Controller (MVC)模式，MvVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是ViewModel 层，它就像是一个中转站 (value converter)，负责转换Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model 层通过接口请求进行数据交互，起呈上启下作用。</p><p>(1) View 层<br>View 是视图层，也就是用户界面。前端主要由 HTML 和CSS 来构建。<br>(2) Model 层<br>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p><h1 id="21-Vue-是如何实现数据双向绑定的？"><a href="#21-Vue-是如何实现数据双向绑定的？" class="headerlink" title="21. Vue 是如何实现数据双向绑定的？"></a>21. Vue 是如何实现数据双向绑定的？</h1><p>Vue 数据双向鄉定主要是指：数据变化更新视图，视图变化更新数据。</p><p>即：</p><ul><li>输入框内容变化时，Data 中的数据同步 变化。即 View&#x3D;＞Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即Data &#x3D;＞ View 的变化。其中，View 变化更新 Data，可以通过事件监听的方式来实现，所以 vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</li></ul><p>vue 主要通过以下 4个步骤来实现数据双向绑定的</p><ul><li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty()对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter， 那么就能监听到了数据变化。</li><li>实现个解析器 Compile：解析 vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li><li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher ，对监听器 Observer 和订阅者 Watcher 进行统一管理。</li></ul><h1 id="22-vue-框架怎么实现对象和数组的监听？"><a href="#22-vue-框架怎么实现对象和数组的监听？" class="headerlink" title="22. vue 框架怎么实现对象和数组的监听？"></a>22. vue 框架怎么实现对象和数组的监听？</h1><p>如果被问到 vue 怎么实现数据双向绑定，大家肯定都会回答通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 vue框架中都知道，vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p><pre><code class="javascript">/*** Observe a list of Array items.*/observeArray(items: Array&lt;any&gt;) &#123;  for (let i = 0, | = items.length; i &lt; I; i++) &#123;    observe(items[i]) // observe 功能为监测数据的变化  &#125;&#125;/*** 对属性进行递归遍历*/let childob = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化</code></pre><p>通过以上 vue 源码部分 查看，我们就能知道 vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty( 也能对对象和数组（部分方法的操作）进行监听。</p><h1 id="23-Proxy-与-Object-defineProperty-优劣对比"><a href="#23-Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="23. Proxy 与 Object.defineProperty 优劣对比"></a>23. Proxy 与 Object.defineProperty 优劣对比</h1><p><strong>Proxy 的优势如下：</strong></p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达13种拦截方法，不限于 apply、ownkeys、delete Property、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p>Object.defineProperty 的优势如下：</p><ul><li>兼容性好，支持 1E9，而Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此vue 的作者才声明需要等到下个大版本（3.0）才能用 Proxy 重写。</li></ul><h1 id="24-Vue-怎么用vm-set-）-解决对象新增属性不能响应的问题？"><a href="#24-Vue-怎么用vm-set-）-解决对象新增属性不能响应的问题？" class="headerlink" title="24. Vue 怎么用vm.$set(） 解决对象新增属性不能响应的问题？"></a>24. Vue 怎么用vm.$set(） 解决对象新增属性不能响应的问题？</h1><p>受现代 JavaScript 的限制，vue 无法检测到对象属性的添加或删除。由于 vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化，所以属性必须在 data 对象上存在才能让vue 将它转换为响应式的。但是vue 提供了 Vue.set (object, propertyName, value) &#x2F; vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？<br>我们查看对应的 vue 源码：vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p><pre><code class="javascript">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;  // target 为数组  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;    // 修改数组的长度，避免索引&gt;数组长度导致splcie()执行有误    target.length = Math.max(target.length, key)    //利用数组的splice变异方法触发响应式    target.splice(key, 1, val)    return val  &#125;  // key 已经存在，直接修改属性值  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;    target[key] = val    return val  &#125;    const ob = (target: any)._ob_    // target 本身就不是响应式数据,直接赋值  if (!ob) &#123;    target[key] = val    return val  &#125;  // 对属性进行响应式处理  defineReactive(ob.value, key, val)  ob.dep.notify()  return val&#125;</code></pre><p>我们阅读以上源码可知，vm.$set 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 define Reactive 方法进行响应式处理。</li></ul><h1 id="25-虛拟-DOM-的优缺点？"><a href="#25-虛拟-DOM-的优缺点？" class="headerlink" title="25. 虛拟 DOM 的优缺点？"></a>25. 虛拟 DOM 的优缺点？</h1><p><strong>优点：</strong></p><ul><li>保证性能下限：框架的虛拟 DOM 需要适配任何上层 API 可能产生的操作，它的些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情況下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM：我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虛拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台：虚拟 DOM 本质上是Javascript 对象,而 DOM 与平台强相关，相比之下虛拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p><strong>缺点：</strong></p><ul><li>无法进行极致优化：虽然虛拟 DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虛拟 DOM 无法进行针对性的极致优化。</li></ul><h1 id="26-虚拟-DOM-实现原理？"><a href="#26-虚拟-DOM-实现原理？" class="headerlink" title="26. 虚拟 DOM 实现原理？"></a>26. 虚拟 DOM 实现原理？</h1><p>虛拟 DOM 的实现原理主要包括以下3部分：</p><ul><li>用Javascript 对象模拟真实 DOM 树，对真实DOM 进行抽象；</li><li>diff 算法一比较两棵虚拟 DOM树的差异；</li><li>pach 算法 一将两个虚拟 DOM 对象的差异应用到真正的 DOM树。</li></ul><h1 id="27-Vue中的key有什么作用？"><a href="#27-Vue中的key有什么作用？" class="headerlink" title="27. Vue中的key有什么作用？"></a>27. Vue中的key有什么作用？</h1><p>key 是为 Vue 中 Vnode 的唯一标记，通过这个key，我们的diff 操作可以更准确、更快速。vue 的 diff 过程可以概括为：oldCh 和newCh 各有两个头尾的变量 oldStartindex、oldEndindex 和 newStartindex、newEndlindex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartindex 和 oldStartindex 、newEndIndex 和 oldEndindex、newStartIndex 和 oldEndIndex , newEndIndex 和oldStartindex， 如果以上 4种比较都没匹配，如果设置了key，就会用key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIndex＞EndIndex 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。</p><p>所以 vue 中 key 的作用是：key是为vue 中 vnode 的唯一标记，通过这个key，我们的 diff 操作可以更准确、更快速。</p><p>更准确：因为带 key 就不是就地复用了，在sameNode 函数 a.key &#x3D;&#x3D;&#x3D; b.key 对比中可以避免就地复用的情况。所以会更加准确。</p><p>更快速：利用key 的唯一性生成map 对象来获取对应节点，比遍历方式更快，源码如下：</p><pre><code class="javascript">function createKeyToOldIdx (children, beginIdx, endIdx)&#123;  let i, key  const map = 0  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;    key = children[i].key    if (isDef(key)) map[key] = i  &#125;  return map&#125;</code></pre><h1 id="28-你有对Vue项目进行哪些优化？"><a href="#28-你有对Vue项目进行哪些优化？" class="headerlink" title="28. 你有对Vue项目进行哪些优化？"></a>28. 你有对Vue项目进行哪些优化？</h1><p>(1) 代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><p>(2) Webpack 层面的优化</p><ul><li>webpack 对图片进行压缩</li><li>减少ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 cSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>vue 项目的编译优化</li></ul><p>(3) 基础的Web技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h1 id="29-对于的Vue3-0特性你有什么了解的吗？"><a href="#29-对于的Vue3-0特性你有什么了解的吗？" class="headerlink" title="29. 对于的Vue3.0特性你有什么了解的吗？"></a>29. 对于的Vue3.0特性你有什么了解的吗？</h1><p>Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p><p>(1) 监测机制的改变</p><p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><ul><li>只能监测属性，不能监测对象</li><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 Weak Seto</li></ul><p>新的 observer 还提供了以下特性：</p><ul><li>用于创建observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li>默认采用惰性观察。在2.x 中，不管反应式数据有多大，都会在启动时被观察到，如果你的数据集很大，这可能会在应用启动时带来明显的开销。在3.x中，只观察用于渲染应用程序最初可见部分的数据。</li><li>更精确的变更通知。在2.x中，通过 vue.set 强制添加新属性将导致依赖于该对象的watcher 收到变更通知。在3.x中，只有依赖于特定属性的watcher 才会收到通知。</li><li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 vuex 状态树以外的变化。</li><li>更好的调试功能：我们可以使用新的renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul><p>(2) 模板</p><p>模板方面没有大的变更，只改了作用域插槽，2.× 的机制导致作用域插槽变了，父组件会重新渲染，而3.0把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于render 西数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom.</p><p>(3) 对象式的组件声明方式</p><p>Vue2.x 中的组件是通过声明的方式传入一系列 option，和Type Script 的结合需要通过一 些装饰器的方式来做，量然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 Type Script 的结合变得很容易。</p><p>此外，Vue 的源码也改用了 Type Script 来写。其实当代码的功能复杂之后，必须有。个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p><p>(4) 其它方面的更改</p><p>Vue 3.0 的改变是全面的，上面只涉及到主要的 3个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接fork 源码来改的方式。</li><li>支持 Fragment （多个根节点） 和Protal（在dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul><h1 id="30-说说你使用-vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#30-说说你使用-vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="30. 说说你使用 vue 框架踩过最大的坑是什么？怎么解决的？"></a>30. 说说你使用 vue 框架踩过最大的坑是什么？怎么解决的？</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《技术的本质》读书分享</title>
      <link href="/posts/2022-04-16-the-nature-of-technology.html"/>
      <url>/posts/2022-04-16-the-nature-of-technology.html</url>
      
        <content type="html"><![CDATA[<p>人类技术发展史向我们展示了一个这样的趋势：那就是重大创新发生的时间间隔正在不断的缩短。从农业革命到工业革命用了8000年。从工业革命到电灯泡的产生，只花了120年。之后的90年，人类就登上了月球。再往后20里年互联网就出现了，紧接着仅仅过了九年，在21世纪初，人类基因组测序就完成了。技术正在不动声色地创造着这个时代所有的重大议题和惊人的巨变。技术决定者我们将关注什么，为什么新的东西兴奋不已。</p><p>《技术的本质》这本书讲述的并不是一项一项具体的技术，或者是某些将要出炉的新技术。作者最想告诉我们的是<strong>技术是什么</strong>，以及<strong>技术是如何进化的</strong>。</p><p>《技术的本质》这本书作者是著名的技术思想家、经济学家布莱恩·阿瑟教授，他涉猎了非常多的领域，包括电子工程、数学、经济学等等。但是，半个世纪以来，他一直在研究和追踪唯一一个重要的课题，那就是<strong>路径依赖性</strong>。也就是研究人的行为如何依赖于过去的全部行为。由此，他把这个研究应用到了很多的领域，其中就包括技术的进化和发展。可以说，阿瑟是少有的可以称为既是狐狸型通才又是刺猬型专才的人。阿瑟教授曾经担任过斯坦福大学人口研究与经济学系的主任。也正是在那一年，他成为了斯坦福大学历史上最年轻的终身教授。随后，他在经济学泰斗、诺贝尔奖获得者阿罗教授的邀请之下，加入了圣塔菲研究所。他这一待，就是20多年，成为了这座跨科学研究圣殿当中当之无愧的元老级人物。阿瑟教授的研究，对于深入了解创新贡献很大。在1990年的时候，他就获得了专门颁给那些研究创新问题的顶尖学者的熊彼特奖。阿瑟教授对于技术本质的探寻，为技术创新的发展带来了很多重要的洞见，比如 Java 语言的开发就用到了他的思想。在高科技投资领域，阿瑟教授的很多观点都是决策者必须要掌握的风向标。在《技术的本质》这本书里，阿塞教授就告诉我们，技术并不是死的，而是活生生的，它有自己的进化方向，也有自己的行事逻辑。他在写作这本书的时候，讲了很多引人入胜的例子，从人类最初是怎么打造粗陋的石器，到怎么完成了复杂的石油冶炼，怎么从简易的莱特兄弟的飞行器到火箭和航天飞机的发明，还有基因编辑、水力发电、养殖蜜蜂等等。</p><p>通过这些林林总总技术进化和创新的例子色也提出了不少新的概念，比如说自创生、垫脚石、技术活跃、技术体等等。同时，他也提出了很多新的见解，比如说科学和经济是技术的副产品，又比如新技术先是对精神的建构，之后才是对物质的建构。接下来，我将通过三个部分来讲述《技术的本质》这本书中最重要的内容，分别是：</p><ul><li>第一部分，技术是什么？技术在本质上具有什么样的特性。</li><li>第二部分，技术是如何进化的？即新技术它是怎么产生的。</li><li>第三部分，技术的进化怎么推动了经济的进化？也就是活生生的技术是怎么让经济自身生生不息的繁衍。</li></ul><h1 id="技术是什么"><a href="#技术是什么" class="headerlink" title="技术是什么"></a>技术是什么</h1><p>首先，技术是什么，换句话说，技术从本质上来讲具有什么特性？技术从本质上来讲是自创生的，也就是说记述自己，创造了自己。如果我们去仔细观察任何一项新技术，就会发现所有新技术都不是无中生有被发明出来的，新技术都是从现存技术当中组合出来的。一组新的要素技术可以无限构成新的组合。比如黏合剂，既可以把它涂在玻璃纸的背面，成为透明胶带；也可以把它用在波音飞机的消音版上来抵抗声波的震动。你还可以把它用在高尔夫球杆上，在强烈的撞击之下，碳素纤维和碳依然能够牢牢的粘在一起。甚至，还可以把它涂在带电的玻璃表面，装到显示器上，这就成了智能手机的触摸屏。再比如全球定位系统，可以把它安装在飞机、轮船、汽车上进行导航，还可以用它来辅助土地勘探、规划土地耕种等等。某一项技术，就像是化学反应当中一个高度活跃的成分，虽然只是参与了各种技术组合当中的一项功能，但是却主导着这些不同的组合，它可以在无限的组合当中和其他的技术匹配在一起，为不同的目的进一步组合成各种各样的可能性。</p><p>书中，作者就给出了有关技术的三层定义，第一层定义也是最基础的一个定义，那就是<strong>技术是实现人的目的的一种手段</strong>，从这个角度来看，技术是单数的。它可以是一种方法，比如语音识别算法，也可以是一个过程，比如说化学工程当中的过滤法，还可以是一项装置，比如一个柴油发动机。从这个层面来说，技术可以是简单的，也可以是复杂的，可以是物质的，也可以是非物质的。当我们在强调技术是一种软件的时候，我们看到的就是过程和方法，而当我们强调技术是一种硬件的时候，我们看到的就是具体的物理设备。技术的第二层定义，指的是<strong>它是实践和元器件的集成</strong>。从这个视角上来看，技术常常是复数的是技术的集合，或者叫做技术的工具箱。那当我们提到电子技术或者是生物技术的时候，就是指技术的这第二层定义。那技术的第三层定义指的是，<strong>它可以是运用在某种文化当中的装置和工程实践的结合</strong>。换句话说，这层定义是指技术是人类所有过去和现存技术的总和，是产生于对各种各样的自然现象的应用。从这个角度上来看，技术具有更普遍的意义。比如当凯文凯利在他的演讲当中说，技术就是和硅谷相关的一切，那这个时候他指的就是技术的这第三层定义。</p><p>本书中，作者谈论的技术更多是基于第二层和第三层定义，而他谈论的重点尤其在于技术是如何进化的。</p><h1 id="技术的进化"><a href="#技术的进化" class="headerlink" title="技术的进化"></a>技术的进化</h1><p>技术是如何进化的，即新技术是怎么产生的。关于技术的进化，这样的讨论和观点其实从很早以前就开始了。1859年，达尔文出版了有关生物进化的《物种起源》，仅仅四年之后英国著名的作家塞缪尔·巴特勒，就提出了机械王国的理论，他写了一篇影响广泛的文章——《机械中的达尔文》。巴特勒，他提出的观点就是在努力的把技术塞进一个类似达尔文生物进化论的理论框架里面去。如今大家都知道，达尔文提出的生物进化两个最主要的机制就是变异和选择。如果我们来分析一些特定技术的时候，确实能够看到跟生物进化机制相类似的一些情况。比如说像火车的进化，就是通过变异和选择逐渐发展出了蒸汽机车，电力机车，磁悬浮列车等等。但是，用达尔文的进化理论来解释技术，有些地方就很难解释得通。比如说，很多新技术实现的是飞跃式的创新，也就是说在面对同样一个要实现的目标的时候，新技术会用完全不同的原理来实现它，一点儿都看不到前任技术的痕迹。比如说，就拿书籍出版来举例吧，人类先是发明了用笔和纸来抄写书籍，接着活字印刷术出现了，而发展到现代，出现了数码印刷机，每一次的进化都完全颠覆了以往技术。这样的例子还有很多，比如说像是激光喷气式飞机、雷达等等。这些技术，他们在刚刚出现的时候，跟以前解决同样问题的技术，使用的原理也是完全不一样的。也就是说很多新技术不是任何其他先前技术的变种，也不是在以往技术的基础上稳步积累形成的。这些情况，用变异和选择的机制完全解释不通。所以如果想要解释这种完全颠覆的新技术是怎么来的，那么就一定存在一套其他的新理论。作者就认为技术进化的机制就是组合进化。最初很简单的技术通过组合成一个一个的技术模块，发展出了越来越多的复杂技术形式。如果我们把进化的机制比喻成人。那么它更像是一个喜欢古代小玩意儿的人，而不是一个天才的发明家。这个人，并不是在从无到有地发明出一些东西，而是把现有的一些部件进行连接组合，推陈出新，制造出一个新的东西。古腾堡发明印刷机，就是一个经典的技术组合进化，它更像是一种拼装，而不是无中生有的全新突破。在印刷机这项独立发明出现之前，已经具备了很多的关键元素。比如说活字印刷术，是在公元前四世纪由毕升发明的。又比如螺旋压榨技术，最初它使用于葡萄酒压榨机的。还有油墨和纸张的生产技术，这些也都被发明出来了。</p><p>另外，古腾堡还曾经做过金匠，凭借着对这一行的了解，他又对活字印刷系统整体进行了一些改进。所以，古腾堡发明印刷机并不是突如其来的一种全新技术，而是把各个不同领域的现存成熟技术拼装在了一起。这些拼装在一起的技术模块，每一个都可以实现不同的功能，这些功能相互联系，共同服务于一个核心目标。然而，这种模块化的组合并不是技术进化的唯一机制。比如说激光技术，它的用途非常多，在农业生产当中，激光可以用在育种、除草、灭虫、检验作物基因等等方面儿，在日常生活当中，激光唱片、激光录像都是最常见的。在医疗当中，激光可以用作钻头、手术刀、焊枪等等，而在军事当中，激光可以用在坦克、舰艇、飞机等等武器装备上，还可以用在雷达上和激光制导炸弹上。机关的应用，是如此的广泛，但是当你追溯它的发展进程的时候，就会发现它并不是从某些特定的技术，比如说在农业当中，他不是从化学农药进化而来的，在武器当中，他也不是由弓箭制造技术发展而来的，在医疗当中，也并不是从制陶工艺而来的。所以一定有另外的超出组合进化的机制在起着作用。作者就认为，这第二个重要的机制就是捕捉现象。它指的是技术能够持续发现新的自然现象，并且带着特定的目的去驾驭这些现象。比如瑞士发明家维斯特劳注意到宠物狗身上沾满了带刺的苍耳之后，他就发明了尼龙搭扣。又比如，谷歌的创始人拉里佩奇和谢尔盖布林他们就观察到，人们在日常检索内容的时候，会利用文章之间的交叉引用，他们就根据这个现象开发出了谷歌后台的超链接搜索算法。作者在这本书当中用一句话给出了很精辟的概括，那就是技术的本质就是对现象的有目的的编程。我给你讲一个故事，你就能很好的理解这句话了。高露洁公司，曾经被一个难题困扰了几十年。你肯定听说过含氟牙膏，据说，可以帮助孩子预防龋齿，那制造这种牙膏的时候，就需要把氟化物的粉末加到牙膏管里去。可是，这道工序常常会把氟化物的粉尘弄得到处都是。高露洁的专家们就研究了几十年，但是都不能有效解决这个问题。最后，他们决定向社会广泛求助，提供高额奖金来悬赏解决方案。最后，一位粒子物理学专家提供了一种方法解决了这个难题。他捕捉到的现象非常的简单，那就是带电的粉尘可以被塑料吸附。所以他就想办法让这些氟化物粉末带电，同时，把一个塑料管接地，这样带电的粉尘就会自动进到塑料管里，不会弄的到处都是了。这个解决方法实在是太简单了，但是却完美解决了困扰高露洁工程师长达几十年之久的大难题。</p><p>自然现象是新技术赖以产生的必不可少的源泉。所有的技术，不论是多么简单，或者是多么复杂，实际上，都应用了一种或者是几种现象。比如说，实际上，它用到了两个自然现象，一个是化学物质燃烧带来的热能可以转化为动能，这个现象，带来了发动机，让卡车可以实现自动推进。另一个是圆的东西滚动起来，比方的东西摩擦力小，这个现象带来了轮子，让卡车更容易移动。如此看来，一辆卡车的实质其实就是一个平台加上一个车厢，这个平台能够自动推进儿，车厢装载着人或者是货物，平台能够让车厢更容易的移动。卡车就是把两个现象结合在一起的，但最近日本某家汽车公司，他们真的把这两个现象分开进行设计，再组合起来使用，产生了新的创意。你可以看到这种新型的概念车，它分成了平台和车厢两部分，可以根据需要随意组合，你可以为平台匹配上不同功能和尺寸的车厢，这样就可以实现更多的装载移动的功能。平台匹配上封闭的带座位的车厢就成为了一个旅游大巴，平台匹配上一个大翻斗，就变成了一辆工程用车。所以，今后你要购买汽车的时候，可以变成分开购买底部的可移动平台和各种不同功能的车厢，这样的话你就相当于可以通过不同的组合拥有了很多量不同功能的汽车。</p><p>技术的进化机制，就是组合进化。作者告诉我们，每个技术都是通过对一组固定的现象用不同的方式进行编程创造出来的。随着时间的推移，新的现象、核心的技术会不断的加入进化。所有的技术归根到底都来自自然现象，所有的技术最终都是这些现象的奏鸣曲。</p><h1 id="技术进化推动经济进化"><a href="#技术进化推动经济进化" class="headerlink" title="技术进化推动经济进化"></a>技术进化推动经济进化</h1><p>技术的进化怎么推动了经济的进化，也就是说活生生的技术，它是怎么让经济启动了自身生生不息的繁衍。作者认为，众多的技术结合在一起，就创造出了我们称之为经济的东西，他把经济定义为一套安排和活动。社会，可以借助这套系统来满足所有的需求，构成经济的整套安排，包括所有的制度、方法和与它对应的技术，比如说诊所和外科手术，市场和定价系统，金融系统和监管体系等等，这些安排都是实现人类各种需求的手段。经济从技术当中浮现，新技术带来新的解决方案，但同时也会带来新的问题和新的需求。而经济就是技术的一种表达，技术进化会引发经济的进化。作者就认为，在理解新技术带动新经济的过程当中有两个概念非常的重要，一个是<strong>重新域定</strong>，域是领域的域，定是定位的定。另一个是<strong>标准工程</strong>。这两个概念都和创新密切相关，我先来说说什么是重新域定。所谓的玉，通常指的是一个范畴，比如时间的范畴就可以叫做时间域，空间的范畴就可以叫做空间域。那么同样的道理，我们可以把一组技术组成的工具箱和它相应的应用规范叫做这种技术的范畴，也就是技术域。这组技术，他们有共同的能力，捕捉了共同的自然现象，可以完成共同的目标。</p><p>比如说无线电工程就是一个域，数字技术也是一个域。这样，域定这个词的意思也就好理解了，那就是说，我们在开展一项任务之前，要确定具体使用哪些技术范畴。比如，一位建筑师要开始设计一个新的办公大楼，他可能会选择玻璃钢架结构，也可能会选择花岗岩。那么这个过程，就叫做域定，也就是要确定使用哪套技术工具箱和对应的规范。说到这里，重新域定的含义也就非常明确了，他指的是，你为了实现某个需求，放弃了原来使用的技术规范，</p><p>重新选择了一套新的规范。这个过程非常重要，会产生新的技术，带来颠覆性的改变，甚至你可以说重新域定这个概念，它会重新定义一个时代和它的边界。通常这会是一个伟大创意的诞生，也是一次改变世界的创举。比如说，人类运输史的发展，就是不断进行重新域定的过程。最开始，人类运输使用的是陆地域，学会开凿运河之后，运输就进入了由驳船、船夫、船闸等等构成的运河域。当发明飞机以后，运输就进入了航空域。陆地运输、水路运输和航空运输这三次重新域定，就是对人类运输史的创新。又比如，以前我们听音乐的时候，使用的是黑胶唱片，处理信息的方式是模拟，后来，我们听音乐用CD，处理信息的方式是数据。这也是一次重新域定。还比如，你可以从这个视角来看待零售出现，互联网之前，日常购物行为发生在线下实体商店，当电子商务时代来临的时候，日常购物行为发生在线上的网络商店，而现在的新零售时代，日常购物行为同时发生在线上和线下。这里日常购物行为是一项贯穿始终的就任务，而这项任务被我们在线上线下进行不断的重新表达，这就是零售业的重新域定，也是零售业的不断创新。说到这里，我们得出的结论就很重要了，那就是所有的创新都是在新的可能的世界当中，把旧的任务不断进行重新表达的过程。用这个思路来看待问题，会让你在技术急剧的变化当中更好地把握变与不变的本质。</p><p>接下来，作者又提到了标准工程。如果你看过任何一本工程手册就会发现，里面有许多的标准问题的解决方案，比如说耦合旋转轴的19种方法，15种不同的凸轮结构，或者是五种振荡器的使用方法等等。这一类的手册，提供了标准的解决方案来解决那些重复性的问题。他也可以是对特定的技术用途提供特定的改进方案，那这套标准问题解决方案经过反复使用和验证之后，就会成为通用模式，这个时候它就变成了一个新的技术架构，我们就把它叫做标准工程。</p><p>标准工程对创新带来的贡献是非常大的，他和重新域定带来创新的方式却又是非常不一样的。标准工程是对现有技术带来的标准问题提供标准的解决方案，然后，随着经验的累积产生一些微小的进步。这些微小的进步聚集在一起，被反复使用。那通过这个过程促使技术随着时间变化和进步。所以说标准工程也可以说是由微小进步的聚集所带来的缓慢创新。在20世纪初的时候，瑞士的工程师吗雅尔他就用标准工程这个创新方法创造了一系列的大桥。</p><p>这些桥采用的都是通用技术，根本不新鲜。比如说她用的材料就是常见的钢筋混凝土，而它采用的结构是当时被广为接受的形式，也就是由固定在桥拱上的构建来支撑桥面。马雅尔所做的创新，仅仅是在普通的材料和普通的结构形式之上，进行了一个微小的改进。他在桥面上加了一个平板，放在了桥拱顶部，然后，把平板的两端固定在桥墩上。这样一来，整个桥所承担的重量就被更均匀地分散在了整个结构上。这个解决方案同时也让桥拱和桥面的重量很轻，但是却有足够的强度。马雅尔的这个创新性的方案就让整个设计变得既有效又经济。就是这些普通的技术要素组合在一起却能够使得整体上呈现出了一种流动和和谐。建筑评论家就说，马雅尔建造的大桥是有史以来最美丽的混凝土大桥。这座大桥不仅是一个技术产品，更是一件艺术品。标准工程这个创新机制，最重要的不在于天才的创想，而是来自于知识和技能经年累月的积累。这里，又产生了一个非常重要的结论，那就是创新就是关于解决方案的微小改进。即使是最日常性的项目，也是能够通过微小改进发现其中值得创新的部分的。标准工程就是一个对知识深度理解和认识的过程，正是这种深层的知识储备带来了崭新的创想。</p><p>小结，技术的进化怎么推动了经济的进化？作者认为，技术和经济的发展并不是完全由之前的发展决定，但是也不是完全不依赖之前的发展。当技术的发展选择的路径是重新域定的时候，那他就更倾向于在新的世界当中把旧的任务不断进行重新表达，以此来完成创新，而当技术的发展选择的路径是标准工程的时候，那他就更倾向于在微小的改进当中发现值得创新的部分。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>《技术的本质》这本书的主要内容分为三个部分：第一部分，技术是什么？技术从本质上来讲具有什么特性。第二部分，技术是如何进化的，即新技术是怎么产生的。第三部分，技术的进化是怎么推动经济的进化的，也就是说活生生的技术怎么让经济也启动了自身生生不息的繁衍。其实，不论是认为技术控制了人类的生活，还是认为技术服务了人类的生活，这两种观点都是对的。没有技术就没有人类，反之，没有人类技术的存在也就没有了意义。人类需要的不只是经济上的舒适；人类，更需要的是挑战，是目的，是意义，需要和自然融为一体。如果技术把人类与自然分离，就消灭了人性，如果技术加强了人类和自然的联系，那就更好地确立了人性。有句话是这么说的：佛陀与上帝居住在计算机的电路里，或者是周期转动的齿轮当中，就和他们居住在群山之巅或者是盘坐在莲花上同样舒服。可以说，技术是自然的拓展，是人性的拓展，是更深的宇宙法则的一部分。了解技术的本质，你才能掌握未来。自然带给人类的天性和无穷的奥秘，正是我们创意的源头，也是我们赖以生存的本源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【译】 Go 泛型编程介绍</title>
      <link href="/posts/2022-03-24-an-introduction-to-go-generic-programming.html"/>
      <url>/posts/2022-03-24-an-introduction-to-go-generic-programming.html</url>
      
        <content type="html"><![CDATA[<p>原文： <a href="https://go.dev/blog/intro-generics">https://go.dev/blog/intro-generics</a></p><p>作者： Robert Griesemer，Ian Lance Taylor</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文基于我们在 GopherCon 2021 上的讲话（视频地址：<a href="https://www.youtube.com/watch?v=Pa_e9EeCdy8">https://www.youtube.com/watch?v=Pa_e9EeCdy8</a> ， B站： <a href="https://www.bilibili.com/video/BV1V34y1q7wP%EF%BC%89%EF%BC%9A">https://www.bilibili.com/video/BV1V34y1q7wP）：</a></p><p>Go 1.18版本增加了对泛型的支持。泛型是我们自 Go 第一个开源版本以来做出的最大改变。在本文中，我们将介绍新的语言特性。这将不会试图涵盖所有的细节，但我们会点出所有重要的点。更详细的内容，以及许多例子，请参见<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md">提案文件</a>。关于语言变化的详细描述，请看更新的<a href="https://go.dev/ref/spec">语言规范</a>。(请注意，实际上 Go 1.18 的实现对提案文件所允许的内容施加了一些限制，该规范应该是描述准确的。未来的版本可能会取消这部分限制）。</p><p>泛型是一种编写独立于正在使用的特定类型的代码的方式。那么，现在可以编写用于任何类型的函数或类型。</p><p>泛型为语言增加了三个新的重要内容：</p><ol><li>函数和类型的类型参数。</li><li>将接口类型定义为类型的集合，包括没有方法的类型。</li><li>类型推导，允许在许多情况下调用函数时省略类型参数。</li></ol><h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>目前，函数和类型已支持类型参数。一个参数类型列表看起来就像一个普通的参数列表，只是它用方括号代替了小括号。</p><p>为了方便说明这一点，让我们从一个基本的非泛型的浮点值 <code>Min</code> 函数开始吧。</p><pre><code class="go">func Min(x, y float64) float64 &#123;    if x &lt; y &#123;        return x    &#125;    return y&#125;</code></pre><p>我们可以通过添加一个类型参数列表来使这个函数泛型化 —— 使其适用于不同的类型。在这个例子中，我们增加了一个由一个类型参数 <code>T</code> 构成的参数列表，并用 <code>T</code> 替换 <code>float64</code> 的使用。</p><pre><code class="go">func GMin[T constraints.Ordered](x, y T) T &#123;    if x &lt; y &#123;        return x    &#125;    return y&#125;</code></pre><p>那么，现在可以用一个类型参数来调用这个函数了，调用方式如</p><pre><code class="go">x := GMin[int](2, 3)</code></pre><p>向 <code>GMin</code> 传入类型参数，在本例中是 <code>int</code> ，称为实例化。实例化分为两个步骤。首先，编译器在整个泛型函数或类型中把所有的类型参数替换成它们各自的类型参数。第二，编译器验证每个类型参数是否满足各自的约束条件。我们很快就会知道这意味着什么，但是如果第二步失败，实例化就会失败，程序就会无效。</p><p>实例化成功后，我们将有一个非泛型函数，可以像其他函数一样被调用。例如，在代码中就是这样</p><pre><code class="go">fmin := GMin[float64]m := fmin(2.71, 3.14)</code></pre><p><code>GMin[float64]</code> 的实例化产生了一个有效的原始浮点 <code>Min</code> 函数，我们可以在函数调用中使用它。</p><p>类型参数也可用于类型。</p><pre><code class="go">type Tree[T interface&#123;&#125;] struct &#123;    left, right *Tree[T]    value       T&#125;func (t *Tree[T]) Lookup(x T) *Tree[T] &#123; ... &#125;var stringTree Tree[string]</code></pre><p>在这里，泛型类型 <code>Tree</code> 存储的是类型参数 <code>T</code> 的值。泛型类型可以有方法，比如本例中的 <code>Lookup</code> 方法。为了使用一个泛型，它必须被实例化；<code>Tree[string]</code> 是一个用类型参数 <code>string</code> 来实例化 <code>Tree</code> 的例子。</p><h2 id="类型集合"><a href="#类型集合" class="headerlink" title="类型集合"></a>类型集合</h2><p>让我们深入了解一下可以用来实例化一个类型参数的类型参数。</p><p>一个普通的函数对每个值参数都有一个类型；该类型定义了一组值。例如，如果我们有一个 <code>float64</code> 类型，就像上面非泛型函数 <code>Min</code> 那样，允许的参数值集合是可以用 <code>float64</code> 类型表示的浮点值集合。</p><p>同样地，类型参数列表中的每个类型参数都有一个类型。因为一个类型参数本身就是一个类型，所以类型参数的类型定义了类型的集合。这种元类型被称为<em>类型约束</em>。</p><p>在泛型函数 <code>GMin</code> 中，类型约束是从<a href="https://golang.org/x/exp/constraints">约束包</a>中导入的。<code>Ordered</code> 约束描述了所有具有可排序值的类型的集合。换句话说，也就是用 &lt; 操作符（或 &lt;&#x3D; , &gt; , 等）进行比较。该约束确保只有具有可排序值的类型才能被传递给 <code>GMin</code> 。这也意味着在 <code>GMin</code> 函数体中，该类型参数的值可以被用于比较操作符  &lt; 的运算。</p><p>在 Go 中，类型约束必须是接口。也就是说，一个接口类型可以作为一个值类型，也可以作为一个元类型。接口定义了方法，所以显然我们可以描述方法存在的类型约束。但是 <code>constraints.Ordered</code> 也是一个接口类型，而且 &lt; 操作符不是一个方法。</p><p>为了实现这个，我们以一种新的方式来看待接口。</p><p>直到最近，Go 规范描述：一个接口定义了一个方法集，大概就是接口中列举的方法集。任何实现了所有这些方法的类型都实现了该接口。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2022/03/24/2eff57257302a26c6d975be8303b035b-32915d.png" alt="img"></p><p>但另一种看法是，接口定义了一个类型集，即实现这些方法的类型。从这个角度来看，任何属于接口类型集的元素的类型都实现了接口。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2022/03/24/1504376fe6b7fbae91bf85f0e0f57e50-ba8f90.png" alt="img"></p><p>这两种观点达到了一样的结果。对于每一组方法，我们可以想象出实现这些方法的相应类型集，这就是接口所定义的类型集。</p><p>不过对于我们的目的来说，类型集视角比方法集视角有一个优势：我们可以明确地将类型添加到集合中，从而以新的方式控制类型集。</p><p>为了发挥作用，我们对接口类型的语法进行了扩展。例如，<code>interface&#123; int|string|bool &#125;</code> 定义了包含 <code>int</code> 、<code>string</code> 和 <code>bool</code> 的类型集。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2022/03/24/3fd88fd47a4e8e489287cea402fa7a99-f5ae4a.png" alt="img"></p><p>另一种说法是，这个接口只被 <code>int</code> 、<code>string</code> 或 <code>bool</code> 所满足。</p><p>我们来看一下 <code>contraints.Ordered</code> 的实际定义：</p><pre><code class="go">type Ordered interface &#123;    Integer|Float|~string&#125;</code></pre><p>这个声明表示，<code>Ordered</code> 接口是所有整数、浮点数和字符串类型的集合。<code>|</code> 表示的是类型的联合（或者是类型的集合）。 <code>Integer</code> 和 <code>Float</code> 是接口类型，在 <code>constraints</code> 中也有类似的定义。注意，<code>Ordered</code> 接口没有定义任何方法。</p><p>对于类型约束，我们通常不关心一个特定的类型，比如 <code>string</code> ；我们对所有的字符串类型感兴趣。这就是 <code>~</code> 标记的作用。表达式 <code>~string</code> 意味着所有基础类型为 <code>string</code> 的类型的集合 —— 这包括 <code>string</code> 类型本身，以及所有用定义声明的类型，如 <code>type MyString string</code> 。</p><p>当然，我们仍然希望在接口中指定方法，而且我们希望能向后兼容。在 Go 1.18 中，一个接口可以像以前一样包含方法和嵌入接口，但它也可以嵌入非接口类型、联合体和底层类型的集合。</p><p>当作为类型约束使用时，由接口定义的类型集准确地指定了允许作为相应类型参数的类型参数的类型。在一个泛型函数体中，如果操作数的类型是带有约束 <code>C</code> 的类型参数 <code>P</code> ，那么如果操作被 <code>C</code> 的类型集中的所有类型所允许，那么操作就是被允许的（目前这里实现上有一些限制，但是普通代码不太可能遇到这些限制）。</p><p>用作约束条件的接口可以被赋予名称（比如 <code>Ordered</code> ），或者它们可以是类型参数列表中的字面接口。比如说：</p><pre><code class="go">[S interface&#123;~[]E&#125;, E interface&#123;&#125;]</code></pre><p>这里 <code>S</code> 必须是一个切片类型，其元素类型可以是任何类型。</p><p>因为这是一种常见的情况，对于处于约束位置的 <code>interface&#123;&#125;</code> ，可以省略。可以简单如下编写：</p><pre><code class="go">[S ~[]E, E interface&#123;&#125;]</code></pre><p>因为空接口在类型参数列表中很常见，在普通 Go 代码中也是如此，Go 1.18 引入了一个新的预先声明的标识符 <code>any</code> 作为空接口类型的别名。这样一来，我们就得到了这个惯用代码：</p><pre><code class="go">[S ~[]E, E any]</code></pre><p>接口用于类型集是一个强大的新机制，也是使类型约束在 Go 中发挥作用的关键。目前，使用新语法形式的接口只能作为约束使用。但不难想象，具有明确的类型约束的接口将会非常有用。</p><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>最后一个新的主要语言特性是类型推导。在某些方面，这是最复杂的变化，但它很重要，因为它让人们可以通过一种自然的风格来编写调用泛型函数的代码。</p><h3 id="函数参数类型推导"><a href="#函数参数类型推导" class="headerlink" title="函数参数类型推导"></a>函数参数类型推导</h3><p>有了类型参数，就需要传递类型参数，这就使代码变得冗长。回到我们的泛型函数 <code>GMin</code> 。</p><pre><code class="go">func GMin[T constraints.Ordered](x, y T) T &#123; ... &#125;</code></pre><p>类型参数 <code>T</code> 用于指定普通泛型参数 <code>x</code> 和 <code>y</code> 的类型。正如我们前面所看到的，可以用一个显式类型参数来调用它</p><pre><code class="go">var a, b, m float64m = GMin[float64](a, b) // 显式类型参数</code></pre><p>在许多情况下，编译器可以从普通参数中推断出 <code>T</code> 的类型参数。这使得代码更简短。</p><pre><code class="go">var a, b, m float64m = GMin(a, b) // 没有 类型参数</code></pre><p>其工作原理是将参数 <code>a</code> 和 <code>b</code> 的类型与参数 <code>x</code> 和 <code>y</code> 的类型相匹配。</p><p>这种从函数的参数类型中推断出参数类型的推导，被称为<em>函数参数类型推导</em>。</p><p>函数参数类型推导只适用于在函数参数中使用的类型参数，不适用于只在函数结果中使用的类型参数或只在函数主体中使用的类型参数。例如，它不适用于像 <code>MakeT[T any]() T</code> 这样的函数，它只在结果中使用 <code>T</code> 。</p><h3 id="约束类型推导"><a href="#约束类型推导" class="headerlink" title="约束类型推导"></a>约束类型推导</h3><p>Go 还支持另一种类型推导，即<em>约束类型推理</em>。为了描述这个，让我们从这个缩放整数切片的例子开始：</p><pre><code class="go">// Scale 返回s中每个元素都乘以c的副本。// 这种实现方式有一个问题，后面将会看到。func Scale[E constraints.Integer](s []E, c E) []E &#123;    r := make([]E, len(s)    for i, v := range s &#123;        r[i] = v * c    &#125;    return r&#125;</code></pre><p>这是一个适用于任何整数类型切片的泛型函数。</p><p>现在假设我们有一个多维的 <code>Point</code> 类型，其中每个 <code>Point</code> 都是一个给出了点的坐标的简单整数列表。当然，这个类型有一些方法。</p><pre><code class="go">type Point []int32func (p Point) String() string &#123;    // Details not important.&#125;</code></pre><p>有时候，我们想对一个 <code>Point</code> 进行缩放。因为一个 <code>Point</code> 只是一个整数切片，我们可以使用我们之前写的 <code>Scale</code> 函数：</p><pre><code class="go">// ScaleAndPrint 将一个 Point 翻倍，并且打印。func ScaleAndPrint(p Point) &#123;    r := Scale(p, 2)    fmt.Println(r.String()) // 无法编译&#125;</code></pre><p>然而，这并没有被编译，而是出现了这样的错误 <code>r.String undefined (type []int32 has no field or method String)</code>.</p><p>问题是 <code>Scale</code> 函数返回了一个 <code>[]E</code> 类型的值，其中 <code>E</code> 是参数切片的元素类型。当我们用一个 <code>Point</code> 类型的值调用 <code>Scale</code> 时，其底层类型是 <code>[]int32</code> ，我们得到的是 <code>[]int32</code> 类型的值，而不是 <code>Point</code> 类型。这是由泛型编程的写法决定的，但这不是我们想要的。</p><p>为了解决这个问题，我们必须改变 <code>Scale</code> 函数，使用一个类型参数来表示分片类型。</p><pre><code class="go">// Scale 返回s中每个元素都乘以c的副本。func Scale[S ~[]E, E constraints.Integer](s S, c E) S &#123;    r := make(S, len(s)    for i, v := range s &#123;        r[i] = v * c    &#125;    return r&#125;</code></pre><p>我们引入了一个新的类型参数 <code>S</code> ，它是分片参数的类型。我们对它进行了约束，使其底层类型是 <code>S</code> 而不是 <code>[]E</code> ，结果类型现在是 <code>S</code> 。由于 <code>E</code> 被限制为整数，其效果与之前相同：第一个参数必须是某个整数类型的片断。函数主体的唯一变化是，现在我们在调用 <code>make</code> 时传递 <code>S</code> ，而不是 <code>[]E</code> 。</p><p>如果我们用一个普通的片断来调用它，新函数的作用和以前一样，但是如果我们用 <code>Point</code> 类型来调用它，我们现在得到一个 <code>Point</code> 类型的值。这就是我们想要的。有了这个版本的 <code>Scale</code> ，先前的 <code>ScaleAndPrint</code> 函数就会像我们期望的那样编译和运行。</p><p>但是我们可以问：为什么写对 <code>Scale</code> 的调用可以不传递明确的类型参数？也就是说，为什么我们可以写 <code>Scale(p, 2)</code> ，没有类型参数，而不是必须写 <code>Scale[Point, int32](p, 2)</code> ？我们的新 <code>Scale</code> 函数有两个类型参数， <code>S</code> 和 <code>E</code> 。在调用 <code>Scale</code> 时没有传递任何类型参数，上面描述的函数参数类型推理让编译器推断出 <code>S</code> 的类型参数是 <code>Point</code> 。但是该函数也有一个类型参数 <code>E</code> 。编译器推断出 <code>E</code> 的类型参数是切片的元素类型的过程被称为<em>约束类型推理</em>。</p><p>约束类型推理从类型参数约束中推断出类型参数。当一个类型参数有一个定义在另一个类型参数上的约束时，它就会被使用。当这些类型参数中的一个的类型参数是已知的，该约束被用来推断另一个的类型参数。</p><p>通常适用的情况是，当一个约束对某些类型使用 <code>~ type</code> 的形式时，该类型是用其他类型参数写的。我们在 <code>Scale</code> 这个例子中看到了这一点。<code>S</code> 是 <code>~[]E</code> ，它是 <code>~</code> 后面有一个用另一个类型参数写的 <code>[]E</code> 类型。如果我们知道 <code>S</code> 的类型参数，我们可以推断出 <code>E</code> 的类型参数。<code>S</code> 是一个切片类型，<code>E</code> 是该切片的元素类型。</p><p>这只是对约束类型推导的一个介绍。完整的细节请参见<a href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md">提案文档</a>文件或<a href="https://go.dev/ref/spec">语言规范</a>。</p><h3 id="类型推导实践"><a href="#类型推导实践" class="headerlink" title="类型推导实践"></a>类型推导实践</h3><p>类型推理的详细过程很复杂，但使用并不复杂：类型推理要么成功要么失败。如果它成功了，类型参数可以被省略，调用泛型函数看起来与调用普通函数没有什么不同。如果类型推理失败，编译器则会给出一个错误信息，在这种情况下，我们直接提供必要的类型参数就可以。</p><p>在向语言添加类型推理时，我们在试图平衡推理能力和复杂性。我们希望确保当编译器推断出类型时，这些类型永远不会令人困惑。我们试图小心翼翼地站在未能推断出类型的一边，而不是站在推断出错误类型的一边。我们可能没有完全做到这一点，可能会在后续版本中继续完善它。其效果是，更多的代码可以在没有显式类型参数的情况下编写。当然，今天不需要类型参数的代码，明天也不会需要。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>泛型是 1.18 中一个很大的新语言特性。这些新的语言变化需要大量的新代码，这些代码还没有在生产环境中进行过大量的测试。这只会随着越来越多的人编写和使用泛型代码来进行。我们相信这个功能实现得很好，质量很高。然而，与 Go 的大多数方面不同，我们无法用现实的经验来支持这一信念。因此，虽然我们鼓励在有意义的地方使用泛型，但在生产中部署泛型代码时，请使用适当的谨慎措施。</p><p>以外，我们也也很高兴能提供泛型，并希望能使 Go 程序员的工作更高效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Generic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五分钟启动 Kubernetes 服务</title>
      <link href="/posts/2021-10-28-start-a-kubernetes-server-in-5-minutes.html"/>
      <url>/posts/2021-10-28-start-a-kubernetes-server-in-5-minutes.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述一种快速部署Kubernetes服务器的方法。</p><p>准备工具：</p><ul><li>VirtualBox</li><li>Vagrant</li></ul><h1 id="1-Vagrant配置文件"><a href="#1-Vagrant配置文件" class="headerlink" title="1.  Vagrant配置文件"></a>1.  Vagrant配置文件</h1><ol><li><p>创建一个空目录，并通过命令行进入此空目录。</p></li><li><p>执行以下命令</p><pre><code class="bash">vagrant init alvistack/kubernetes-1.22</code></pre></li><li><p>打开自动创建的 Vagrantfile 文件。增加 <code>config.vm.network &quot;public_network&quot;, bridge: &quot;enp3s0&quot;</code> 配置。其中 <code>enp3s0</code> 为本机网卡。此配置用于桥接 <code>enp3s0</code> 网卡。<em>如果需要使用 hostonly 模式的网卡，可修改 <code>config.vm.network &quot;private_network&quot;</code> 对应的配置。</em></p></li></ol><h1 id="2-启动虚拟机"><a href="#2-启动虚拟机" class="headerlink" title="2.  启动虚拟机"></a>2.  启动虚拟机</h1><ol><li><p>在此目录下执行</p><pre><code class="bash">vagrant up</code></pre></li></ol><h1 id="3-重新生成密钥"><a href="#3-重新生成密钥" class="headerlink" title="3.  重新生成密钥"></a>3.  重新生成密钥</h1><ol><li><p>替换以下脚本中 <code>NEW_IP</code> 参数为本机IP地址，并在 root 账号下执行该脚本。</p><pre><code class="bash">export NEW_IP=192.168.16.101cd /etc/kubernetes/pkiopenssl x509 -noout -text -in apiserver.crtopenssl genrsa -out apiserver.key 2048openssl req -new -key apiserver.key -subj &quot;/CN=kube-apiserver&quot; -out apiserver.csrcat &gt; apiserver.ext &lt;&lt; EOFsubjectAltName = DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:ubuntu, IP:10.233.0.1, IP:10.0.2.15, IP:$&#123;NEW_IP&#125;EOFopenssl x509 -req -in apiserver.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out apiserver.crt -days 3650 -extfile apiserver.extopenssl x509 -noout -text -in apiserver.crt</code></pre></li><li><p>重启服务器</p></li></ol><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.  总结"></a>4.  总结</h1><p>本文使用Vagrant和VirtualBox组合，能够快速启动K8s服务供应用中心开发者或其他需要使用到K8s服务的同学们使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> VirtualBox </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> Vagrant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密货币——一场彻头彻尾的灾难</title>
      <link href="/posts/2021-09-03-cryptocurrency-yet-another-disaster.html"/>
      <url>/posts/2021-09-03-cryptocurrency-yet-another-disaster.html</url>
      
        <content type="html"><![CDATA[<p>其实早就想写这样一篇文章了，这篇文章也早该发出来了。<strong>就让一切都结束吧。</strong></p><p><strong>注：</strong>如果你要评论这篇文章的话，请你附上持有加密货币的数量。</p><p>从今年的5月1日开始，soucehut 的 CI 服务开始收费，这一改变影响了大约一半的 <a href="http://builds.sr.ht/">builds.sr.ht</a> 的用户。在过去的几个月里，业内所有提供任何形式的 CPU 计算资源的服务商都在处理大规模爆发的滥用加密货币挖矿行为。行业服务商们还专门一起成立了非正式的工作组，互相交流，避免在应对这种 CPU 计算资源滥用事情上浪费太多的时间。</p><p>加密货币发明了一个全新的互联网资源滥用类别。而且资源滥用的形式也是非常之多：JavaScript挖矿程序、僵尸网络以及各种各样用以解决一些无意义的运算问题的非法循环。有人会说，对于任何一个提供免费的公共服务来说滥用是不可避免的。但是，在加密货币出现以前，有一些什么样的滥用行为呢？比如：垃圾邮件亦或是在一些虚拟机上挂载站点。然而在加密货币出现以后，就有人找到了将免费CPU计算资源转化成利益的方式，导致大家就不能正常使用这些算力进行正常的服务了，比如自动构建应用等。如果不是因为加密货币的出现，这些服务仍然可用。</p><p>你可别以为这些人都是一些“脚本小子”。他们有一个人数众多的高智商团队，有各种各样的滥用资源策略，比如就我所知的有：</p><ul><li>使用 CPU 限制器来操纵监控工具。</li><li>在自由软件项目的构建系统中安装挖矿程序，使构建看起来合法。</li><li>使用密码转储来窃取合法用户的登录凭证，然后利用他们的账户进行采矿。</li></ul><p>其实还有着很多很多的骚操作来滥用这些资源的，但是我得为一些服务商保密这其中的细节，甚至是大概都不能说，这些黑客脑动太大了，稍微提示一下他们就能想出各种各样的法子。</p><p>而加密货币本身的问题则比资源滥用更加严重。正是因为加密货币的出现，整个软件行业的诚信和信任度急剧下降。加密货币给新项目设立了不正当的奖励机制，太多的公司打着加密货币的幌子出来招摇撞骗。到了现在，一项新的有前途的技术出现时候，我不免有一种越来越强烈的恐惧感，总会想：“这会不会又是一个扯淡的加密货币项目？” 加密货币是一种科技界的多层营销模式。“嘿！好久不见啊。我一直在研究一种很酷的分布式数据存储技术，我们下周要做一个ICO。” 然后我就径直走开了。其实很多项目不使用区块链技术就能够运行得很好。</p><p>有数以百计甚至是数以千计得加密货币骗局和庞氏骗局伪装得跟个合法产品一样。即使是你正在做的项目相当的不错，但是可能就有上百个项目正在抄袭你的项目，然后通过各种各样的方式设法把用户的钱搞到创始人那里去。你觉得投资者更有可能投资哪一个呢？很明显是那个更有利可图的项目。</p><p>这就是加密货币的全部内容：不是新技术，不是赋权，而是赚钱。除了在一些落败的经济体独立的国家之外，加密货币作为实际货币显然是已经失败了。不，加密货币根本就不是一种货币：它是一种投资工具。一个让富人更富有的工具。在现实中，加密货币与庞氏骗局有着很多共同点，而不是真正的投资。加密货币所谓的解决数学问题（一些无意义的数学问题），而实际上为谁提供了什么 “价值”呢？简直就是个扯淡的事。</p><p>还有那几个失败的经济体，他们的人民拼命使用加密货币来维持他们命运之轮的转动？这倒是一个非常不错的标题，而在那些落后的农村，他们的税收补贴政策正好吸引了矿工们蜂拥而至，真好补贴了矿工们建发电厂。那里的人们正在遭受停电的事，因为他们的电力都被矿工们的矿场吸走了。同时还排放大量的二氧化碳。</p><p>即使是世界最大的经济体也难逃加密货币带来的影响。在过去的几个月里，显卡价格急剧上升。顺便说一下，显卡的用途是什么？循环计算SHA-256，速度越快越好。然而不仅仅是显卡的价格，CPU的价格，甚至是硬盘的价格都受到了影响。</p><p>或许你会说你的加密货币是不同的。但是你看，你就这么一个小破公司。就好比你身处一个只有你一个人诚实守信的环境中，那你就得换个环境了。网上那些对加密货币的评论大多来自于一些对加密货币有大量投资的人，他们喜欢通过他们的言论来改变大众对加密货币的看法并且引诱你们去入坑，其本质目的在于投资加入这场庞氏骗局，然后骗你们从中捞取钱财。更不用说任何改革的尝试，如股权证明，都会被那些当权者（即那些有钱的人）恶狠狠地阻止，因为这对减少他们的底线有风险。于是，你的区块链并没有什么不同。</p><p>可以说，加密货币是21世纪最糟糕的发明之一。我为与这种剥削性的骗局共处一个行业而感到羞耻。加密货币并没有称为一种有用的货币，然而却发明了一种新的互联网资源滥用行为，进一步加剧了贫富差距，浪费大量的电力，还加速了气候变化，也毁掉了大量非常有前途的项目，也为很多骗局项目提供了蓬勃发展的环境，造成了硬件供货短缺和价格上涨。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptocurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows的现状：Windows 10用了多少个不一致的UI层？</title>
      <link href="/posts/2021-06-22-state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10.html"/>
      <url>/posts/2021-06-22-state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10.html</url>
      
        <content type="html"><![CDATA[<p>我们可能都听说过这个梗：如果你在Windows 10中挖掘得足够深，你会发现可以追溯到Windows 3.x时代的元素。但这实际上是真的吗？在这篇文章中，我们将来探寻Windows中到底有多少个UI层，以及它们是何时被首次引入的。</p><p>为了这个实验的目的，我选择了最新的Windows 10 Insider Build（截至2021年2月6日），即Windows 10 build 21301。</p><p>所以，来不及解释了，赶紧上车。</p><h1 id="第一层：Fluent-Design"><a href="#第一层：Fluent-Design" class="headerlink" title="第一层：Fluent Design"></a>第一层：Fluent Design</h1><p>首先，我们从最新和最伟大的，流畅设计开始。流利设计于2017年宣布，并与Windows 10 1803更新一起推出，是现代设计语言2（MDL2）的重大重新设计，旨在带来光、深度、运动、材料和规模等元素。它还引入了揭幕效果和亚克力半透明背景。</p><p>截至目前，大多数收件箱（UWP）应用程序已经升级，以利用Fluent元素，以及一些更面向前台的元素，如开始菜单、活动中心和登录屏幕。</p><p>尽管”Fluent Design”得到了好评，但大多数爱好者认为此举太少、太晚了，因为只有一小部分功能通过这种新的设计风格得到了加强。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/18b4f09d05fdbcb468dc3d4e1550bc2e-8595be.png" alt="windows-10-x64-2021-02-06-19-26-06"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/c349f7de56319c657b1c9a06cbfe37a8-973814.png" alt="windows-10-x64-2021-02-06-18-37-21-2"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/9f1dabf457c499c1c52563ff59d97c90-454575.png" alt="windows-10-x64-2021-02-06-18-37-43-2"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/3b0778764921af25ab0fd70f88e1a2e4-ec9cc9.png" alt="windows-10-x64-2021-02-06-18-38-23"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/a00bfeacf059ab33b3b0f9979e2280b9-382164.png" alt="windows-10-x64-2021-02-06-18-38-28"></p><h1 id="第二层：Metro"><a href="#第二层：Metro" class="headerlink" title="第二层：Metro"></a>第二层：Metro</h1><p>就在我们深入挖掘操作系统的时候，我们可以看到自Windows 8&#x2F;8.1以来没有升级过的元素。</p><p>其中一些是明显的遗漏，如音量、USB弹出以及登录屏幕的一些元素。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/6c5721f7e75103296c415c288e03f78e-969e36.png" alt="vlcsnap-2021-02-06-19h42m58s859"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/57e6ab78f4b1227890627ce513bd2b9d-6fb9d8.png" alt="windows-10-x64-2021-02-06-18-39-08-2"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/2556f2411ce57a4750478da863f4b2d9-728320.png" alt="windows-10-x64-2021-02-06-18-39-24"></p><p>其他Metro元素，虽然没有那么突出，但有开机画面（很快将被更新的画面取代）和WinRE。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/5795778a09466b14ae57c462b19e0a74-6c1a3e.png" alt="windows-10-x64-2021-02-06-18-42-32"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/63c97e33b250639787b84a5775f94c6d-507335.png" alt="windows-10-x64-2021-02-06-18-42-47"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/befbad0586effc5e035fbd95540111a8-63a980.png" alt="7989boot"></p><p>你知道吗：第一次引入旋转圆点是在Windows 8 build 7989。</p><h1 id="第三层：Windows-8-Win32-elements"><a href="#第三层：Windows-8-Win32-elements" class="headerlink" title="第三层：Windows 8 Win32 elements."></a>第三层：Windows 8 Win32 elements.</h1><p>就像Windows 10一样，Windows 8也被不一致的问题所困扰（无论好坏）。然而，Windows 8为主要的用户元素增加了有意义的改进，如Windows Explorer或任务管理器。虽然它们在随后的Windows 10更新中会得到一些生活质量的改善，但变化是最小的。</p><p>此外，Windows 8带来的一个重要变化是重新设计了文件传输对话框。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/2d0fe5991b9564bf78b1191a87d27298-cf2302.png" alt="q"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/b1a9c7702aeeda83f8d98780e0b5cf3b-bd4474.png" alt="windows-10-x64-2021-02-06-18-41-42"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/758ae4acba59731d07a408a283e70bf4-deee77.png" alt="windows-10-x64-2021-02-06-18-44-45"></p><p>其中一些变化从Windows 7开始，这使我们来到了第四层。</p><h1 id="第四层：Windows-7-UI-elements"><a href="#第四层：Windows-7-UI-elements" class="headerlink" title="第四层：Windows 7 UI elements"></a>第四层：Windows 7 UI elements</h1><p>毫无疑问，Windows 7是有史以来最受喜爱的Windows版本之一，因其在Windows Vista基础上的巨大提升而受到称赞。它带来了许多新功能，虽然没有Vista引入的那些功能那么重要，但使Windows 7成为一个非常坚实的操作系统，是Windows XP的真正继承者。然而，Windows 7带来的最臭名昭著的变化之一是Ribbon UI，这是一个从Office 2007移植的功能。用新的Ribbon UI更新的一些应用程序是Paint和Wordpad。</p><p>虽然在某些时候，微软决定废弃经典的画图，而采用新的画图3D（与Windows 10创意者更新一起推出），但在重大的反响之后，他们推翻了自己的决定。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/299ab0007aad2b98141e5dbb1408097a-88b238.png" alt="windows-10-x64-2021-02-06-18-45-38"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/1a6da87b67f96b57b7e42550aa7eda40-73063f.png" alt="windows-10-x64-2021-02-06-18-45-17"></p><p>其他在Windows 7中更新并一直保持不变的功能有：Windows Media Player 12、远程桌面连接和一些文件对话框。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/f3eb6efc2c8b7f3776950d213651939d-5daf11.png" alt="windows-10-x64-2021-02-06-18-46-33"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/98dd430364d5842b6f5dae098c081624-fc9cbd.png" alt="windows-10-x64-2021-02-06-18-47-00"></p><h1 id="第五层：Windows-Vista"><a href="#第五层：Windows-Vista" class="headerlink" title="第五层：Windows Vista."></a>第五层：Windows Vista.</h1><p>Windows Vista是一个具有纪念意义的Windows版本，它给平台带来了急需的现代化。几乎所有操作系统的基本要素都以某种方式得到了改进，从启动器到驱动模型。然而，正如我们现在都知道的，Windows Vista将成为有史以来最糟糕的Windows版本之一，从一开始就被各种问题所困扰。不过，为数不多的被称赞的功能之一是用户界面。它重新设计了一些自Windows 95以来没有更新过的基本要素。这一变化的主要推动者之一是引入了所谓的Aero Wizards，取代了以前的Wizard标准，即Wizard97。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/9cf476c00df551b984a143ed89868c00-3ff4fe.png" alt="windows-10-x64-2021-02-06-18-56-42"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/deda1aacc564130b5c1e09376b1a14db-6cf242.png" alt="windows-10-x64-2021-02-06-18-54-58"></p><p>在Windows Vista中重新设计的其他功能，在Windows 10中基本相同：控制面板、搜索程序、Windows传真和扫描。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/10230818e81267a0ff424976aaa48b32-139912.png" alt="windows-10-x64-2021-02-06-20-38-06"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/78c980312e88bb5de70c876486642cd2-8df5d8.png" alt="windows-10-x64-2021-02-06-18-51-54"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/29f220b3c58e6c6086a47a71b2649822-107af5.png" alt="windows-10-x64-2021-02-06-18-54-37"></p><p>说到 Windows Vista：你知道在某些特殊情况下，Windows 10会退回到Vista的启动画面吗？比如当你的显卡不支持标准启动屏幕使用的视频模式时，就会发生这种情况。</p><h1 id="第六层：Windows-XP"><a href="#第六层：Windows-XP" class="headerlink" title="第六层：Windows XP"></a>第六层：Windows XP</h1><p>信不信由你，没有那么多XP元素嵌入到Windows 10中。这可能是因为大多数基本要素已经被更新到Windows 2000中。然而，Windows 10包含一些来自XP的文件对话框，在安装驱动程序时可以看到这些对话框。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/ceaa88a2d38271b753af4166aed27fd5-e63af8.png" alt="dri"></p><h1 id="第七层：Windows-2000"><a href="#第七层：Windows-2000" class="headerlink" title="第七层：Windows 2000"></a>第七层：Windows 2000</h1><p>Windows 2000是微软NT系列操作系统的一个重要里程碑。它也是一块垫脚石，标志着开始向新的、统一的Windows愿景过渡。然而，Windows 2000仍然是一个面向商业的操作系统，这意味着它带来了许多为专家设计的新功能。</p><p>最重要的一个新增功能就是管理控制台（MMC），其UI元素自那时起，至今几乎没变。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/2af794583f3c4e3dc0e91272cd0f8e26-774ab5.png" alt="windows-10-x64-2021-02-06-19-05-34"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/50896409dfbcb900718ea78f8f66471e-86c085.png" alt="windows-10-x64-2021-02-06-19-04-39"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/82387a21f10004d96f0d211858733b85-8150a2.png" alt="windows-10-x64-2021-02-06-19-04-54"></p><p>在Windows 2000中引入的另一个功能是Windows安装程序，它的图标仍然与最初时一样。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/97155d138f355227e238fa8a7f279dd6-4dd4d4.png" alt="wi"></p><p>还有另一个没有变化过的UI元素（当然除了品牌效应）是winver，它的设计是在Windows 2000 build 1946中被引入的。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/f36f0655b6790b625e29ab80cc43d9eb-32f6e9.png" alt="windows2000-5.0.1946-about"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/9a11782dd1ca5d6fb0087baa3bb59f15-bba104.png" alt="windows-10-x64-2021-02-06-19-04-04"></p><p>虽然Windows 2000引入了许多针对高级用户的功能，但Windows 95可能是迄今为止最重要的Windows版本。它所引入的基本范式至今仍然有效。它引入了诸如开始菜单、上下文菜单、任务栏和回收站等功能。虽然这些功能经过多年的更新，但有些功能几乎完全保持不变。</p><h1 id="第八层：Windows-95-NT-4-0-中的元素"><a href="#第八层：Windows-95-NT-4-0-中的元素" class="headerlink" title="第八层：Windows 95&#x2F;NT 4.0 中的元素"></a>第八层：Windows 95&#x2F;NT 4.0 中的元素</h1><p>一个基本上是老式计算习惯的遗留物的元素，即人们必须保护他们宝贵的CRT屏幕，这就是屏保设置。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/cae1e6e40863f7c5c27c9d8429bd0b2f-d10bf0.png" alt="windows-95-2021-02-06-21-34-46-2"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/953573c4521a3423a32201cdaf786657-3919f0.png" alt="windows-10-x64-2021-02-06-19-10-29-1"></p><p>另一个惊人相似的元素是“运行”对话框。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/efc0d1fc4749f03a1e14d826fd8033bd-c52a6a.png" alt="windows-95-2021-02-06-21-34-55-3"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/d0b92b3c032f15fb9eb60410e9799063-76f214.png" alt="windows-10-x64-2021-02-06-19-10-53-1"></p><p>还有一个通过时间考验的常见UI元素是文件夹属性窗口。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/1986fa9346bdb225187a05d38b2ad05e-1fbd5d.png" alt="wi2-1"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/189f12d27b85176bb324d65628648f39-74f606.png" alt="nf"></p><p>还有很多UI元素自Windows 95以来就没有被碰过。这是一个永恒的设计的案例吗？</p><h1 id="第九层：像-Windows-3-1-和-DOS"><a href="#第九层：像-Windows-3-1-和-DOS" class="headerlink" title="第九层：像 Windows 3.1 和 DOS"></a>第九层：像 Windows 3.1 和 DOS</h1><p>好吧，这其实算不上真正的“UI层”，因为我还没在Windows 10中发现Windows 95以前的任何界面元素（尽管我感觉肯定有）。然而，在Windows 10中有一个奇特的文件，叫做 moricons.dll，它包含了很多DOS时代的老图标。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2021/06/22/3e17843443b9c99c79124e433af3280f-1df35e.png" alt="mori-1"></p><p>嗯，这么多就是这样。可能你也知道了，微软正计划用他们的“太阳谷”更新来彻底重构Windows系统的用户界面，目的是统一操作系统的设计。然而，正如我们今天所看到的，Windows是一个庞大的操作系统。他们为最终形成一个统一的用户体验所做的努力会成功吗？让我们拭目以待吧。</p><p>谢谢您的关注。</p><hr><p>翻译自：<a href="https://ntdotdev.wordpress.com/2021/02/06/state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10/">https://ntdotdev.wordpress.com/2021/02/06/state-of-the-windows-how-many-layers-of-ui-inconsistencies-are-in-windows-10/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Generate SSH Keys with Docker</title>
      <link href="/posts/2021-05-08-generate-ssh-keys-with-docker.html"/>
      <url>/posts/2021-05-08-generate-ssh-keys-with-docker.html</url>
      
        <content type="html"><![CDATA[<p>An easy and clean way to generate ssh keys with docker.</p><span id="more"></span><h1 id="1-Create-a-Folder-to-Store-SSH-Key"><a href="#1-Create-a-Folder-to-Store-SSH-Key" class="headerlink" title="1. Create a Folder to Store SSH Key"></a>1. Create a Folder to Store SSH Key</h1><pre><code class="bash"># ismdeep @ NSA in ~/Desktop [15:08:46]$ mkdir keys-data# ismdeep @ NSA in ~/Desktop [15:08:57]$ cd keys-data# ismdeep @ NSA in ~/Desktop/keys-data [15:09:00]$ pwd/Users/ismdeep/Desktop/keys-data</code></pre><h1 id="2-Generate-SSH-key"><a href="#2-Generate-SSH-key" class="headerlink" title="2. Generate SSH key"></a>2. Generate SSH key</h1><pre><code class="bash">docker run --rm \    -v /Users/ismdeep/Desktop/keys-data:/keys \    -it ismdeep/ssh-keygen \    /usr/bin/ssh-keygen -t rsa -C &quot;L. Jiang&quot; -f /keys/ljiang1024 -q -N &quot;&quot;</code></pre><h1 id="3-Generate-More-Secure-Keys"><a href="#3-Generate-More-Secure-Keys" class="headerlink" title="3. Generate More Secure Keys"></a>3. Generate More Secure Keys</h1><pre><code class="bash">docker run --rm \    -v /Users/ismdeep/Desktop/keys-data:/keys \    -it ismdeep/ssh-keygen \    /usr/bin/ssh-keygen -t rsa -b 4096 -C &quot;L. Jiang&quot; -f /keys/ljiang1024 -q -N &quot;&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据库设计规范</title>
      <link href="/posts/2021-03-05-mysql-db-design-guide.html"/>
      <url>/posts/2021-03-05-mysql-db-design-guide.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述使用MySQL数据库进行开发时，数据库设计的相关规范。</p><span id="more"></span><h1 id="1-规范背景与目的"><a href="#1-规范背景与目的" class="headerlink" title="1. 规范背景与目的"></a>1. 规范背景与目的</h1><p>MySQL数据库与 Oracle、 SQL Server 等数据库相比，有其内核上的优势与劣势。我们在使用MySQL数据库的时候需要遵循一定规范，扬长避短。本规范旨在帮助或指导RD、QA、OP等技术人员做出适合线上业务的数据库设计。在数据库变更和处理流程、数据库表设计、SQL编写等方面予以规范，从而为公司业务系统稳定、健康地运行提供保障。</p><h1 id="2-设计规范"><a href="#2-设计规范" class="headerlink" title="2. 设计规范"></a>2. 设计规范</h1><h2 id="2-1-数据库设计"><a href="#2-1-数据库设计" class="headerlink" title="2.1 数据库设计"></a>2.1 数据库设计</h2><p>以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注，遵守优先级从高到低。</p><p>对于不满足【高危】和【强制】两个级别的设计，DBA会强制打回要求修改。</p><h3 id="2-1-1-库名"><a href="#2-1-1-库名" class="headerlink" title="2.1.1 库名"></a>2.1.1 库名</h3><ol><li>【强制】库的名称必须控制在32个字符以内，相关模块的表名与表名之间尽量提现join的关系，如user表和user_login表。</li><li>【强制】库的名称格式：业务系统名称_子系统名，同一模块使用的表名尽量使用统一前缀。</li><li>【强制】一般分库名称命名格式是<code>库通配名_编号</code>，编号从0开始递增，比如<code>wenda_001</code>以时间进行分库的名称格式是“库通配名_时间”</li><li>【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：<code>create database db1 default character set utf8;</code>。</li></ol><h3 id="2-1-2-表结构"><a href="#2-1-2-表结构" class="headerlink" title="2.1.2 表结构"></a>2.1.2 表结构</h3><ol><li>【强制】表和列的名称必须控制在32个字符以内，表名只能使用字母、数字和下划线，一律小写。</li><li>【强制】表名要求模块名强相关，如师资系统采用”sz”作为前缀，渠道系统采用”qd”作为前缀等。</li><li>【强制】创建表时必须显式指定字符集为utf8或utf8mb4。</li><li>【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为InnoDB。当需要使用除InnoDB&#x2F;MyISAM&#x2F;Memory以外的存储引擎时，必须通过DBA审核才能在生产环境中使用。因为Innodb表支持事务、行锁、宕机恢复、MVCC等关系型数据库重要特性，为业界使用最多的MySQL存储引擎。而这是其他大多数存储引擎不具备的，因此首推InnoDB。</li><li>【强制】建表必须有comment</li><li>【建议】建表时关于主键：(1)强制要求主键为id，类型为int或bigint，且为<code>auto_increment(2)</code>标识表里每一行主体的字段不要设为主键，建议设为其他字段如<code>user_id</code>，<code>order_id</code>等，并建立unique key索引（可参考<code>cdb.teacher</code>表设计）。因为如果设为主键且主键值为随机插入，则会导致innodb内部page分裂和大量随机I&#x2F;O，性能下降。</li><li>【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段<code>create_time</code>和最后更新时间字段<code>update_time</code>，便于查问题。</li><li>【建议】表中所有字段必须都是<code>NOT NULL</code>属性，业务可以根据需要定义<code>DEFAULT</code>值。因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题。</li><li>【建议】建议对表里的<code>blob</code>、<code>text</code>等大字段，垂直拆分到其他表里，仅在需要读这些对象的时候才去select。</li><li>【建议】反范式设计：把经常需要join查询的字段，在其他表里冗余一份。如<code>user_name</code>属性在<code>user_account</code>，<code>user_login_log</code>等表里冗余一份，减少join查询。</li><li>【强制】中间表用于保留中间结果集，名称必须以<code>tmp_</code>开头。备份表用于备份或抓取源表快照，名称必须以<code>bak_</code>开头。中间表和备份表定期清理。</li><li>【强制】对于超过100W行的大表进行<code>alter table</code>，必须经过DBA审核，并在业务低峰期执行。因为<code>alter table</code>会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li></ol><h3 id="2-1-3-列数据类型优化"><a href="#2-1-3-列数据类型优化" class="headerlink" title="2.1.3 列数据类型优化"></a>2.1.3 列数据类型优化</h3><ol><li>【建议】表中的自增列（<code>auto_increment</code>属性），推荐使用<code>bigint</code>类型。因为无符号<code>int</code>存储范围为<code>-2147483648~2147483647</code>（大约21亿左右），溢出后会导致报错。</li><li>【建议】业务中选择性很少的状态<code>status</code>、类型<code>type</code>等字段推荐使用<code>tinytint</code>或者<code>smallint</code>类型节省存储空间。</li><li>【建议】业务中IP地址字段推荐使用<code>int</code>类型，不推荐用<code>char(15)</code>。因为<code>int</code>只占4字节，可以用如下函数相互转换，而<code>char(15)</code>占用至少15字节。一旦表数据行数到了1亿，那么要多用1.1G存储空间。 SQL：<code>select inet_aton(&#39;192.168.2.12&#39;); select inet_ntoa(3232236044);</code> PHP: <code>ip2long(‘192.168.2.12’); long2ip(3530427185);</code></li><li>【建议】不推荐使用<code>enum</code>，<code>set</code>。 因为它们浪费空间，且枚举值写死了，变更不方便。推荐使用<code>tinyint</code>或<code>smallint</code>。</li><li>【建议】不推荐使用<code>blob</code>，<code>text</code>等类型。它们都比较浪费硬盘和内存空间。在加载表数据时，会读取大字段到内存里从而浪费内存空间，影响系统性能。建议和PM、RD沟通，是否真的需要这么大字段。Innodb中当一行记录超过8098字节时，会将该记录中选取最长的一个字段将其768字节放在原始page里，该字段余下内容放在<code>overflow-page</code>里。不幸的是在<code>compact</code>行格式下，原始<code>page</code>和<code>overflow-page</code>都会加载。</li><li>【建议】存储金钱的字段，建议用<code>int</code>，程序端乘以100和除以100进行存取。因为<code>int</code>占用4字节，而<code>double</code>占用8字节，空间浪费。</li><li>【建议】文本数据尽量用<code>varchar</code>存储。因为<code>varchar</code>是变长存储，比<code>char</code>更省空间。MySQL server层规定一行所有文本最多存65535字节，因此在utf8字符集下最多存21844个字符，超过会自动转换为<code>mediumtext</code>字段。而<code>text</code>在utf8字符集下最多存21844个字符，<code>mediumtext</code>最多存2^24&#x2F;3个字符，<code>longtext</code>最多存2^32个字符。一般建议用<code>varchar</code>类型，字符数不要超过2700。</li><li>【建议】时间类型尽量选取<code>timestamp</code>。因为<code>datetime</code>占用8字节，<code>timestamp</code>仅占用4字节，但是范围为<code>1970-01-01 00:00:01</code>到<code>2038-01-01 00:00:00</code>。更为高阶的方法，选用<code>int</code>来存储时间，使用SQL函数<code>unix_timestamp()</code>和<code>from_unixtime()</code>来进行转换。</li></ol><p>详细存储大小参加下图：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2025/05/23/689d87ca1eeba2db1def68d8f454e3cc-434259.png" alt="MySQL数据类型存储大小"></p><h3 id="2-1-4-索引设计"><a href="#2-1-4-索引设计" class="headerlink" title="2.1.4 索引设计"></a>2.1.4 索引设计</h3><ol><li>【强制】InnoDB表必须主键为<code>id int/bigint auto_increment</code>,且主键值禁止被更新。</li><li>【建议】主键的名称以“<code>pk_</code>”开头，唯一键以“<code>uk_</code>”或“<code>uq_</code>”开头，普通索引以“<code>idx_</code>”开头，一律使用小写格式，以表名&#x2F;字段的名称或缩写作为后缀。</li><li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为<code>BTREE</code>；MEMORY表可以根据需要选择<code>HASH</code>或者<code>BTREE</code>类型索引。</li><li>【强制】单个索引中每个索引记录的长度不能超过64KB。</li><li>【建议】单个表上的索引个数不能超过7个。</li><li>【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。如列<code>userid</code>的区分度可由<code>select count(distinct userid)</code>计算出来。</li><li>【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，这样join执行效率最高。</li><li>【建议】建表或加索引时，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在<code>key(a,b)</code>，则<code>key(a)</code>为冗余索引，需要删除。</li></ol><h3 id="2-1-5-分库分表、分区表"><a href="#2-1-5-分库分表、分区表" class="headerlink" title="2.1.5 分库分表、分区表"></a>2.1.5 分库分表、分区表</h3><ol><li>【强制】分区表的分区字段（<code>partition-key</code>）必须有索引，或者是组合索引的首列。</li><li>【强制】单个分区表中的分区（包括子分区）个数不能超过1024。</li><li>【强制】上线前RD或者DBA必须指定分区表的创建、清理策略。</li><li>【强制】访问分区表的SQL必须包含分区键。</li><li>【建议】单个分区文件不超过2G，总大小不超过50G。建议总分区数不超过20个。</li><li>【强制】对于分区表执行<code>alter table</code>操作，必须在业务低峰期执行。</li><li>【强制】采用分库策略的，库的数量不能超过1024</li><li>【强制】采用分表策略的，表的数量不能超过4096</li><li>【建议】单个分表不超过500W行，ibd文件大小不超过2G，这样才能让数据分布式变得性能更佳。</li><li>【建议】水平分表尽量用取模方式，日志、报表类数据建议采用日期进行分表。</li></ol><h3 id="2-1-6-字符集"><a href="#2-1-6-字符集" class="headerlink" title="2.1.6 字符集"></a>2.1.6 字符集</h3><ol><li>【强制】数据库本身库、表、列所有字符集必须保持一致，为<code>utf8</code>或<code>utf8mb4</code>。</li><li>【强制】前端程序字符集或者环境变量中的字符集，与数据库、表的字符集必须一致，统一为<code>utf8</code>。</li></ol><h3 id="2-1-7-程序层DAO设计建议"><a href="#2-1-7-程序层DAO设计建议" class="headerlink" title="2.1.7 程序层DAO设计建议"></a>2.1.7 程序层DAO设计建议</h3><ol><li>【建议】新的代码不要用model，推荐使用手动拼SQL+绑定变量传入参数的方式。因为model虽然可以使用面向对象的方式操作db，但是其使用不当很容易造成生成的SQL非常复杂，且model层自己做的强制类型转换性能较差，最终导致数据库性能下降。</li><li>【建议】前端程序连接MySQL或者redis，必须要有连接超时和失败重连机制，且失败重试必须有间隔时间。</li><li>【建议】前端程序报错里尽量能够提示MySQL或redis原生态的报错信息，便于排查错误。</li><li>【建议】对于有连接池的前端程序，必须根据业务需要配置初始、最小、最大连接数，超时时间以及连接回收机制，否则会耗尽数据库连接资源，造成线上事故。</li><li>【建议】对于log或history类型的表，随时间增长容易越来越大，因此上线前RD或者DBA必须建立表数据清理或归档方案。</li><li>【建议】在应用程序设计阶段，RD必须考虑并规避数据库中主从延迟对于业务的影响。尽量避免从库短时延迟（20秒以内）对业务造成影响，建议强制一致性的读开启事务走主库，或更新后过一段时间再去读从库。</li><li>【建议】多个并发业务逻辑访问同一块数据（innodb表）时，会在数据库端产生行锁甚至表锁导致并发下降，因此建议更新类SQL尽量基于主键去更新。</li><li>【建议】业务逻辑之间加锁顺序尽量保持一致，否则会导致死锁。</li><li>【建议】对于单表读写比大于10:1的数据行或单个列，可以将热点数据放在缓存里（如mecache或redis），加快访问速度，降低MySQL压力。</li></ol><h3 id="2-1-8-一个规范的建表语句示例"><a href="#2-1-8-一个规范的建表语句示例" class="headerlink" title="2.1.8 一个规范的建表语句示例"></a>2.1.8 一个规范的建表语句示例</h3><p>一个较为规范的建表语句为：</p><pre><code>CREATE TABLE user (  `id` bigint(11) NOT NULL AUTO_INCREMENT,  `user_id` bigint(11) NOT NULL COMMENT ‘用户id’  `username` varchar(45) NOT NULL COMMENT &#39;真实姓名&#39;,  `email` varchar(30) NOT NULL COMMENT ‘用户邮箱’,  `nickname` varchar(45) NOT NULL COMMENT &#39;昵称&#39;,  `avatar` int(11) NOT NULL COMMENT &#39;头像&#39;,  `birthday` date NOT NULL COMMENT &#39;生日&#39;,  `sex` tinyint(4) DEFAULT &#39;0&#39; COMMENT &#39;性别&#39;,  `short_introduce` varchar(150) DEFAULT NULL COMMENT &#39;一句话介绍自己，最多50个汉字&#39;,  `user_resume` varchar(300) NOT NULL COMMENT &#39;用户提交的简历存放地址&#39;,  `user_register_ip` int NOT NULL COMMENT ‘用户注册时的源ip’,  `create_time` timestamp NOT NULL COMMENT ‘用户记录创建的时间’,  `update_time` timestamp NOT NULL COMMENT ‘用户资料修改的时间’,  `user_review_status` tinyint NOT NULL COMMENT ‘用户资料审核状态，1为通过，2为审核中，3为未通过，4为还未提交审核’,  PRIMARY KEY (`id`),  UNIQUE KEY `idx_user_id` (`user_id`),  KEY `idx_username`(`username`),  KEY `idx_create_time`(`create_time`,`user_review_status`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#39;网站用户基本信息&#39;;</code></pre><h2 id="2-2-SQL编写"><a href="#2-2-SQL编写" class="headerlink" title="2.2 SQL编写"></a>2.2 SQL编写</h2><h3 id="2-2-1-DML语句"><a href="#2-2-1-DML语句" class="headerlink" title="2.2.1 DML语句"></a>2.2.1 DML语句</h3><ol><li>【强制】SELECT语句必须指定具体字段名称，禁止写成<code>*</code>。因为<code>select *</code>会将不该读的数据也从MySQL里读出来，造成网卡压力。且表字段一旦更新，但model层没有来得及更新的话，系统会报错。</li><li>【强制】insert语句指定具体字段名称，不要写成<code>insert into t1 values(…)</code>，道理同上。</li><li>【建议】<code>insert into…values(XX),(XX),(XX)…</code>。这里XX的值不要超过5000个。值过多虽然上线很很快，但会引起主从同步延迟。</li><li>【建议】SELECT语句不要使用<code>UNION</code>，推荐使用<code>UNION ALL</code>，并且<code>UNION</code>子句个数限制在5个以内。因为<code>union all</code>不需要去重，节省数据库资源，提高性能。</li><li>【建议】in值列表限制在500以内。例如<code>select… where userid in(….500个以内…)</code>，这么做是为了减少底层扫描，减轻数据库压力从而加速查询。</li><li>【建议】事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。</li><li>【强制】事务涉及的表必须全部是innodb表。否则一旦失败不会全部回滚，且易造成主从库同步终端。</li><li>【强制】写入和事务发往主库，只读SQL发往从库。</li><li>【强制】除静态表或小表（100行以内），DML语句必须有where条件，且使用索引查找。</li><li>【强制】生产环境禁止使用<code>hint</code>，如<code>sql_no_cache</code>，<code>force index</code>，<code>ignore key</code>，<code>straight join</code>等。因为<code>hint</code>是用来强制SQL按照某个执行计划来执行，但随着数据量变化我们无法保证自己当初的预判是正确的，因此我们要相信MySQL优化器！</li><li>【强制】where条件里等号左右字段类型必须一致，否则无法利用索引。</li><li>【建议】<code>SELECT|UPDATE|DELETE|REPLACE</code>要有WHERE子句，且WHERE子句的条件必需使用索引查找。</li><li>【强制】生产数据库中强烈不推荐大表上发生全表扫描，但对于100行以下的静态表可以全表扫描。查询数据量不要超过表行数的25%，否则不会利用索引。</li><li>【强制】WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。</li><li>【建议】索引列不要使用函数或表达式，否则无法利用索引。如<code>where length(name)=&#39;Admin&#39;</code>或<code>where user_id+2=10023</code>。</li><li>【建议】减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如<code>where a=1 or b=2</code>优化为<code>where a=1… union …where b=2, key(a),key(b)</code>。</li><li>【建议】分页查询，当limit起点较高时，可先用过滤条件进行过滤。如<code>select a,b,c from t1 limit 10000,20;</code>优化为: <code>select a,b,c from t1 where id&gt;10000 limit 20;</code>。</li></ol><h3 id="2-2-2-多表连接"><a href="#2-2-2-多表连接" class="headerlink" title="2.2.2 多表连接"></a>2.2.2 多表连接</h3><ol><li>【强制】禁止跨db的join语句。因为这样可以减少模块间耦合，为数据库拆分奠定坚实基础。</li><li>【强制】禁止在业务的更新类SQL语句中使用join，比如<code>update t1 join t2…</code>。</li><li>【建议】不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用join来代替子查询。</li><li>【建议】线上环境，多表join不要超过3个表。</li><li>【建议】多表连接查询推荐使用别名，且SELECT列表中要用别名引用字段，数据库.表格式，如<code>select a from db1.table1 alias1 where …</code>。</li><li>【建议】在多表join中，尽量选取结果集较小的表作为驱动表，来join其他表。</li></ol><h3 id="2-2-3-事务"><a href="#2-2-3-事务" class="headerlink" title="2.2.3 事务"></a>2.2.3 事务</h3><ol><li>【建议】事务中<code>INSERT|UPDATE|DELETE|REPLACE</code>语句操作的行数控制在2000以内，以及WHERE子句中IN列表的传参个数控制在500以内。</li><li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep，一般建议值5-10秒。</li><li>【建议】对于有<code>auto_increment</code>属性字段的表的插入操作，并发需要控制在200以内。</li><li>【强制】程序设计必须考虑“数据库事务隔离级别”带来的影响，包括脏读、不可重复读和幻读。线上建议事务隔离级别为<code>repeatable-read</code>。</li><li>【建议】事务里包含SQL不超过5个（支付业务除外）。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等雪崩问题。</li><li>【建议】事务里更新语句尽量基于主键或<code>unique key</code>，如<code>update … where id=XX</code>; 否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li><li>【建议】尽量把一些典型外部调用移出事务，如调用webservice，访问文件存储等，从而避免事务过长。</li><li>【建议】对于MySQL主从延迟严格敏感的select语句，请开启事务强制访问主库。</li></ol><h3 id="2-2-4-排序和分组"><a href="#2-2-4-排序和分组" class="headerlink" title="2.2.4 排序和分组"></a>2.2.4 排序和分组</h3><ol><li>【建议】减少使用<code>order by</code>，和业务沟通能不排序就不排序，或将排序放到程序端去做。<code>order by</code>、<code>group by</code>、<code>distinct</code>这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li><li>【建议】<code>order by</code>、<code>group by</code>、<code>distinct</code>这些SQL尽量利用索引直接检索出排序好的数据。如<code>where a=1 order by</code>可以利用<code>key(a,b)</code>。</li><li>【建议】包含了<code>order by</code>、<code>group by</code>、<code>distinct</code>这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li></ol><h3 id="2-2-5-线上禁止使用的SQL语句"><a href="#2-2-5-线上禁止使用的SQL语句" class="headerlink" title="2.2.5 线上禁止使用的SQL语句"></a>2.2.5 线上禁止使用的SQL语句</h3><ol><li>【高危】禁用<code>update|delete t1 … where a=XX limit XX;</code> 这种带limit的更新语句。因为会导致主从不一致，导致数据错乱。建议加上<code>order by PK</code>。</li><li>【高危】禁止使用关联子查询，如<code>update t1 set … where name in(select name from user where…);</code>效率极其低下。</li><li>【强制】禁用procedure、function、trigger、views、event、外键约束。因为他们消耗数据库资源，降低数据库实例可扩展性。推荐都在程序端实现。</li><li>【强制】禁用<code>insert into …on duplicate key update…</code>在高并发环境下，会造成主从不一致。</li><li>【强制】禁止联表更新语句，如<code>update t1,t2 where t1.id=t2.id…</code>。</li></ol><p>转载自：<a href="https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md">https://github.com/jly8866/archer/blob/master/src/docs/mysql_db_design_guide.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打开 Word 文档后，电脑就特别卡</title>
      <link href="/posts/2021-02-25-after-open-word-cpu-burning.html"/>
      <url>/posts/2021-02-25-after-open-word-cpu-burning.html</url>
      
        <content type="html"><![CDATA[<p>打开Word文档后，电脑就变得特别卡，文档根本没法编辑，CPU占用率居高不下，有时候虽然现实只有50%或者25%，这是因为占用了某个单核，而如果CPU是4核的，那占用率就是25%了。</p><p>那么出现这样的问题的原因是什么呢？大致上就是因为以下两种情况：</p><ul><li>启用了单词拼写检查功能。</li><li>启用了智能标记功能。</li></ul><p>Word是默认启用这两项功能的。在设置里面关闭即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Office </tag>
            
            <tag> Word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件开发经验之谈</title>
      <link href="/posts/2021-02-19-software-development-rules-of-thumb.html"/>
      <url>/posts/2021-02-19-software-development-rules-of-thumb.html</url>
      
        <content type="html"><![CDATA[<p>在我的软件开发生涯中，我形成了一些个人的经验法则，这些经验法则可以帮助我更好地编写代码，写出可读性和可维护更强的代码。</p><p>但首先，什么是经验法则？对我来说，它是我采用的一个原则，当我一次又一次地应用它时，它积极地帮助我实现我的目标。这些目标可能不同：从代码质量，到软件架构，但每次都是与代码的可维护性有关。</p><p>让我们直接开始吧。</p><h1 id="1-命名：传达意图（而非实现细节）"><a href="#1-命名：传达意图（而非实现细节）" class="headerlink" title="1. 命名：传达意图（而非实现细节）"></a>1. 命名：传达意图（而非实现细节）</h1><p>这是我遵循的一个核心经验法则，它总是会带来更好的代码。几乎在所有情况下，当我们写代码时，我们都会处理业务逻辑。这个业务逻辑处理的是我们要实现的核心问题，所以代码应该始终反映这一点。</p><p>当我们给一个变量命名时，应该反映出它所代表的内容，而不是说它是一个列表或者是其中有一些什么数据类型。</p><p>在写一个业务逻辑块的时候，你希望下一个最终从事这个工作的人能够弄清楚问题的核心。当一个需求进来的时候，它肯定会要求一些业务逻辑的实现或变更，使用的是其数据域的特定术语。</p><p>当我们写出这个逻辑的时候，用同样的语言进行转写和改编，就会容易很多。</p><p>对于一个在同一个项目（或项目的一部分）上工作的团队来说，领域语言是所有成员共享的，而具体的实现术语可能会有所不同，并造成混乱。有的人会喜欢<em>array</em>，有的人会喜欢<em>list</em>，有的人会喜欢<em>vector</em>，有的人会喜欢<em>iterable</em>。但是当你谈到业务逻辑时，一组集合对大家的意义是一样的。</p><p>所以，这样写</p><pre><code>collection_ids = [1, 2, 3, 4]</code></pre><p>总是比这样写更好</p><pre><code>list_of_ints = [1, 2, 3, 4]</code></pre><p>同样的原则也适用于类、方法和函数的命名。一个类的目的应该尽可能的明显，应该不惜一切代价避免包含数据或处理器的命名。</p><h1 id="2-类和函数应该只做一件事情，而且只做一件事情。"><a href="#2-类和函数应该只做一件事情，而且只做一件事情。" class="headerlink" title="2. 类和函数应该只做一件事情，而且只做一件事情。"></a>2. 类和函数应该只做一件事情，而且只做一件事情。</h1><p>虽然这是一个从大学一年级就开始思考的面向对象编程的流行概念，但我看到外面有太多的课，什么都做。这还是比有一个巨大的文件，里面只有互相调用的函数，而且每次都互相传递同样的3-4个参数要好，但这不是一个足够好的方法。</p><p>当一个类&#x2F;函数只有一个责任时，它的可测试性更强，可以更容易重构，在某些情况下，还可以重用。这些都会提高代码库的整体代码质量，进而提高开发速度。</p><p>举个简单的例子，像下面这样的类就做得太多了。</p><pre><code class="python">class FileExporter:  def to_xml(self, ...):    ...  def to_json(self, ...):    ...  def to_xlsx(self, ...):    ...</code></pre><p>最好为我们要做的每一个操作以单独的类。</p><pre><code class="python">class XmlExporter:    def export(self):        passclass JsonExporter:    def export(self):        passclass XlsxExporter:    def export(self):        pass</code></pre><p>This way, we can test each functionality independently, and we can differentiate easier between them. Some the exporter will require&#x2F;support extra configuration the others will not: the <code>ExcelExporter</code> would allow formatting, exporting to multiple sheets, data validation, etc… while the <code>XmlExporter</code> would allow specifying the <code>xmlns</code>, a thing that is very specific to the implemented file format.</p><p>这样一来，我们就可以独立地测试每一个功能，而且我们可以更容易地区分它们。有些导出器需要&#x2F;支持额外的配置，而其他的则不需要：<code>ExcelExporter</code> 允许格式化，导出到多个工作表，数据验证等……而 <code>XmlExporter</code> 允许指定 <code>xmlns</code> ，这是一个非常具体的实现文件格式的东西。</p><h1 id="3-K-I-S-S-你不需要它"><a href="#3-K-I-S-S-你不需要它" class="headerlink" title="3. K.I.S.S &#x2F; 你不需要它"></a>3. K.I.S.S &#x2F; 你不需要它</h1><p>另外两个非常流行的 OOP 原则，我喜欢为了简单而合并成一个规则，就是 K.I.S.S. 和 Y.A.G.N.I.</p><p>归根结底就是避免过早的优化，一次次重构，直到你得到完美的抽象（提示：完美的抽象并不存在），实现功能只是为了以防将来需要。</p><p>每次写代码的时候，你的首要任务是用足够好的代码实现功能。完美的代码是不存在的，所以你必须满足于下一个最好的东西：足够好。你仍然必须生产出质量好的代码，但纠结于变量和类的命名不应该是你的主要优先事项。</p><p>代码总是可以在以后进行重构，但功能才是最重要的，因为代码是用来解决问题的。</p><h1 id="4-解耦，解耦，解耦"><a href="#4-解耦，解耦，解耦" class="headerlink" title="4. 解耦，解耦，解耦"></a>4. 解耦，解耦，解耦</h1><p>让事情尽可能的解耦，是一个人能做出的最好的实现决策。这将使你更容易重构，在需要的时候可以换掉不同的功能，测试所有的东西，而不需要过多的嘲讽和头疼。</p><p>我发现，一个好的设计模式可以帮助你解耦组件，就是适配器模式。虽然它不应该被滥用，但它对于并行开发两个独立的组件，然后用一个额外的轻量级层与适配器集成它们，使它们的输入&#x2F;输出兼容是很有用的。</p><h1 id="5-单一代码库，多种环境"><a href="#5-单一代码库，多种环境" class="headerlink" title="5. 单一代码库，多种环境"></a>5. 单一代码库，多种环境</h1><p>虽然这是现在的常识，但一些老的架构和部署策略仍然在代码库层面对环境进行了区分。</p><p>每个环境的代码库应该始终是相同的，因为这样可以更容易地将生产错误复制到开发环境的本地。环境负责为每个环境提供配置，并对生产、暂存和开发进行区分。</p><p>我个人比较喜欢通过环境变量来配置项目，但也有其他方法可以达到同样的效果：配置文件、集中参数存储等。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>我不认为有什么结论可以拿来总结的，因为毕竟这篇文章只是我个人的一些原则。希望你能喜欢！</p><p>Repost from: <a href="https://vladcalin.ro/blog/2021-01-30-software-development-rules-of-thumb">https://vladcalin.ro/blog/2021-01-30-software-development-rules-of-thumb</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过实践来学习编程</title>
      <link href="/posts/2021-02-18-learn-to-code-by-doing.html"/>
      <url>/posts/2021-02-18-learn-to-code-by-doing.html</url>
      
        <content type="html"><![CDATA[<p>即使认为这基本上是大家在成长过程中最常说的一句话，但我看到大多数人还是没有“学会”。当他们开始学习新的东西时，他们的第一直觉就是抓一大堆教程和书籍，仅此而已。这篇文章主要是针对软件开发工程师的，我见过太多人太多次迷失在教程的炼狱里，花了太多时间和精力去“学习”。</p><p>那么，实际问题是什么呢？当你在学习一门新的技术或者完全开始技术生涯的时候，看一些教程没什么问题。但教程只会耗费你更多的时间，会教给你一套非常有限的指令，而这些指令在实际的场景中可能并不会有任何意义。</p><p>从零开始构建一个应用程序会涉及到很多部件，这些部件通常并不会出现在这些教程中。教程往往只涉及表面。</p><h2 id="教程炼狱"><a href="#教程炼狱" class="headerlink" title="教程炼狱"></a>教程炼狱</h2><p>我见过很多初学者都掉进了教程炼狱这个陷阱。一开始，他们不知道该学什么，因为要成为一名软件开发人员，你需要掌握很多学科的知识。</p><p>于是，他们就在谷歌上搜索“随机编程语言教程”来开始学习一些东西。他们就会挑选一些基础知识来看。然后他们搜索更多的教程。然后就跟着教程做。通过完成每一个教程感受到了多巴胺的刺激。觉得自己也蛮聪明的，感觉自己进步了。</p><p>但是在完成了一些教程之后，实际的学习就停止了。然而他们还是继续去搜教程，不断从不同的学习平台去购买教程，并陷入不断的一个又一个的教程中。</p><p>这就是<strong>教程炼狱</strong>。新手很容易掉入的心理陷阱。他们从教程中反复学习同样的东西，殊不知他们缺失了该有的成长。同样的概念以不同的形式出现，给人以进步的错觉。</p><p>教程是不够的。这些教程足以让你跟着开始并构建一些非常具体的作者想要的东西，给你一个明确的步骤清单，你跟着做就行。在最后，你也完成了课程，并且构建出了作者希望你构建的东西。然而实际上，并没有真正构建起任何的东西。</p><p>要想挣脱束缚，该怎么做呢？在我看来，软件工程远不止写代码这么简单。当然，对很多人来说，写代码这个职业已经是一个不错的选择，但如果你只知道写代码，那么一段时间后就会停止发展。</p><p>软件开发是建立问题的解决方案、分析问题、将其分解成步骤、建立算法、给出所需的结果并交付可用的东西。</p><h2 id="软件开发者需要知道什么？"><a href="#软件开发者需要知道什么？" class="headerlink" title="软件开发者需要知道什么？"></a>软件开发者需要知道什么？</h2><p>这还真不好说，这与每个人的看法有关。每个人的经历不同，对这个问题的看法也就会不一样。有时候也会产生关于数学是否有用的分歧。在我看来，一个成功的软件工程师，应该对大多数与计算机相关的领域都有一个大概的了解，这样才能看清和了解全局，并围绕全局展开工作。</p><p>最关键的领域有：</p><ul><li><p><strong>数学</strong> —— 是的，一个有点不受欢迎的观点，但是我认为数学是软件开发中的一个关键部分。并不是因为公式和微积分可能会帮你构建 web 应用，而是你在学数学时培养的批判性思维和结构性思维对你如何处理问题至关重要。从某种程序上来看，数学就是将需要解决更大的问题，分解成更小的更容易解决的问题，并将结果结合起来。这基本上就是：发明、遵循并结合算法。</p><p><em>如何学习？</em></p><p>嗯，答案可能不会让你感到惊讶：做数学题。还记得那些你没有做或者试图逃避做的数学作业吗？当你的大脑大部分时间都设置在学习模式时，所有这些都会有助于建立你的算法思维。现在应该还是这样，但现在你的时间和精力比较有限。</p><p>软件工程最难接受的是，其实你必须在一定程度上喜欢数学，才能在工作中取得成功，或者对解决问题充满热情。如果不是这样，软件工程可能不是最好的职业选择，你最终要么会被炒掉，要么就会讨厌你的工作。</p></li><li><p><strong>低级编程语言</strong> —— 基本上就是对 C&#x2F;C++ 的了解。什么是编译，什么是内存管理，什么是文件描述符管理，甚至是一些汇编的知识都会很有用。掌握这方面的一些知识，当你看到你正在构建的代码时，肯定会帮助你调试和发现问题。例如，如果你不知道要找什么，内存泄漏就很难修复。如果你有一些低级编程的知识，你就会知道，你必须四处寻找未释放的内存，陈旧的引用，防止一些数据结构从内存中删除，或者未关闭的文件描述符。</p><p><em>如何学习？</em></p><p>实际学习和用 C&#x2F;C++ 构建小程序。必须处理分配内存的实际案例场景，并注意非法内存访问和与指针的工作，肯定会让你学到很多东西。潜心研究一下汇编也许是值得的，因为你会看到处理器看到的代码，而不是你写的代码，你最终会明白，你写的所有东西对处理器来说都变成了一堆的指令（比如移动数据，管理执行指针，以及一直从堆栈中推送和弹出东西）。</p></li><li><p><strong>操作系统</strong> —— 因为每一段代码都是在操作系统上运行的，你在电脑上度过的每一刻，基本上都是在使用操作系统，所以了解你所处理的东西至关重要。磁盘、文件、目录是如何工作的？什么是用户，程序突然关闭是什么意思，突然风扇开始吹热风，发出很大的噪音是什么意思？你会从哪里收集更多的信息？</p><p><em>如何学习？</em></p><p>这里就比较棘手了。没有正确的方法来解决，它，但有一些选择，肯定会让你更容易。学习操作系统最有影响的方法是上 Linux，开始用C语言实现你在Linux中找到的基本命令：cd、ls、mkdir、ps等。重新发明轮子是比打造原创性的东西更好的学习体验。</p></li><li><p><strong>网络</strong> —— 虽然是一个很难的话题，但在当前的软件开发环境下，了解进程如何通信是至关重要的。单一服务器上的单一应用的时代已经结束，云计算的时代已经到来。你需要知道这些移动的部件是如何结合在一起的，最重要的是，它们之间是如何沟通的？经常有人问我，即使是全新的路由器，如何通过内存知道它的地址？联网。在一个软件项目中，你会遇到的很多错误都与网络有关，比如连接一直被关闭，定时出错，被拒绝，搞清楚数据库连接需要什么配置才能工作等等。这些都在于网络领域。</p><p><em>如何学习？</em></p><p>简单的答案和操作系统要点的答案是一样的。构建一些流行的开源应用的客户端，如数据库，电子邮件服务器，甚至SSH，如果你觉得冒险的话。这将提供一个很好的学习经验。</p></li><li><p><strong>设计模式</strong> —— 这是一个你真的不需要学习的话题，因为你会从构建中，随着你的经验越来越多，逐渐学会。学习这种东西最有力的方法就是用错误的方式构建一些东西，完全不使用任何设计模式，然后重构（或从头开始重新构建）来整合它们。看到第一手的例子，了解它们是如何帮助你的代码变得更容易管理的，这将保证对 “为什么 “的深刻理解。而这才是最重要的事情：弄清楚为什么要使用某些设计模式，并认识到它们所解决的问题，这样你就能在问题真正成为问题之前就能得到 “感觉”。</p><p><em>如何学习？</em></p><p>靠经验和耐心。你会犯错误。每个人都会犯错。而且这很好。代码不一定要从迭代一开始就完美。一个应用程序&#x2F;项目永远不会完成，它的代码库会不断变化。每一次变化都应该努力增加功能，或者减少技术债。</p><p>另一种学习设计模式的方法是使用框架和探索开源代码：它们已经融入了良好的实践和设计模式。这对体验这些设计模式的优点和缺点会很有用。</p></li></ul><p>是不是觉得奇怪，怎么这个列表中并没有编程语言？我并不认为懂得一门编程语言是一个软件开发者的关键技能。毕竟，编程语言是我们用来解决问题的工具，而工具是可以切换的。当然，随着时间的推移，我们会对一种工具的使用比其他工具更加熟练，并且会在大部分时间内更喜欢使用某一种语言，并在此基础上建立自己的职业生涯，但它不应该成为定义你职业生涯的东西。最终你需要成长起来，把语言仅仅看作是工具，真正的挑战是整个应用。用任何语言（甚至是PHP）都可以建立伟大的东西。</p><h3 id="在实践中学习"><a href="#在实践中学习" class="headerlink" title="在实践中学习"></a>在实践中学习</h3><p>回到最开始的想法：在实践中学习。从零开始构建一些东西，体验真实开发中会出现的全部问题和挑战，这一点很重要。当你在软件开发行业工作时，你的工作就是在解决真实应用&#x2F;系统中的实际问题。</p><p>只在工作中学习也有一些非常大的弊端：学习率和探索解决方案的灵活性非常有限，因为有真实的利益关系在里面，人们会监督你的工作，你会被限制在一些有限的资源内，更大的重构环节需要大量的规划，并且会被多人分担，所以知识的获得也是会被分割的。</p><p>要想真正让你的软件开发能力突飞猛进，你应该有一些你自己热衷的个人项目。你应噶在工作时间之外建立一些东西，并把它作为一个允许任何错误并且没有风险的竞争场。你唯一需要投入的资源就是时间，与其把时间浪费在社交媒体上，不如每天花上至少一个小时时间来构建你自己的项目。</p><p>一开始，会很乏味，大多数人放弃这样的学习方法转而拿起教程进行学习的原因就在于此：你从一无所知开始，你需要弄清楚步骤是什么。</p><p>那么，假设你想构建一个 Twitter. 你应该怎么开始？用户？推文？提及？</p><p>这是一个艰难的决定，但这肯定是任何项目开始时都需要作出的决定。在企业环境中，有一整套专门的流程，需要花费大量的时间和人力。</p><p>但作为一个独立开发者，一开始就一头扎进去，边干边想也是可以的。犯错可以创造学习的机会。</p><p>比如，我目前正在构建 <a href="https://amethystplatform.com/">Amethyst Platform</a> ，我五次重新开始此项目。每一次，我的起点都比之前知道得更多。最终，每一次迭代，都会有更多的进步。</p><p>构建个人项目给了你尝试任何事物的土壤：新技术、新工艺、新设计模式、新架构、新方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我对任何想让自己的职业生涯保持在上升轨道上的软件开发人员的建议就是：拥抱软件开发行业的广阔天地，专注于构建个人项目。</p><p>通过构建自己的东西，我们可以获得新的技能，我们能够无风险地进行试验并犯很多错误，而且没有老板和最后期限的压力。</p><p>为了了解更多的东西，有必要掌握互联网的构件，从运行我们的代码的机器，数据在世界各地的移动方式到我们代码的架构和结构，这样我们就能更容易地驾驭它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于区块链（比特币），我想说的其实是……</title>
      <link href="/posts/2021-02-18-my-opinion-on-blockchain.html"/>
      <url>/posts/2021-02-18-my-opinion-on-blockchain.html</url>
      
        <content type="html"><![CDATA[<p>这篇博客的灵感来自于 Reddit 上的一个问题：你的投资中有多少是加密货币？</p><p>好吧，我的回答是 0% 并且以后也依然是 0%.</p><p>我看不到其价值所在，一堆人鼓吹它，然而这些人都是些伪君子：他们说他们使用加密货币是为了对抗目前被政府控制的 FIAT 系统，同时又白日做梦，想把它卖掉，获得巨大利润（转化成 FIAT 系统中的货币）。每一个拥护者都提倡人们持有加密货币，然而这并不是货币的目的。货币的目的在于：成为交换的媒介与手段。</p><p>另外，我还看到主张基本经济学的人对基本经济学一通胡说：</p><ul><li>他们说通货紧缩而看不到通货膨胀这是一件好事，而实际上却是一件坏事。有理由将几乎所有地方的目标通货膨胀率定在 2% 左右。然而，我们需要通货膨胀来保持经济发展。</li><li>他们说这是一种货币，然而并不是。它并不是每个人都可以接触到的（并不是每个人无时无刻都可以访问互联网的）。</li><li>如果你丢失了密钥，你将永远失去对钱包的访问权限，而这是没有任何人可以帮助你的。然而人们并不太明白这是多么严重的事情。想象一下人们因为一个愚蠢的行为而失去他的一切。</li><li>波动性是任何经济市场的敌人：我们需要稳定的和可预测的货币系统来避免混乱。企业需要可预测性来准备股票；工厂需要可预测性来准备商品；人们需要可预测性来做预算和定制长期计划。当然，长期计划通常跟预期不太一样，但是你应该不想因为一些疯狂的波动（你今一辆车的价格是 0.5 BTC，而明天可能就是 5 BTC 了）而每周重新思考你的整个策略。因为波动，你甚至无法为未来存钱。</li></ul><p>另外，作为一项技术，区块链本身并没有那么厉害。它的核心是一个去中心化的慢速只读数据库，它需要尽可能多的电力来运行，这些都没有多少现实生活中的有用的应用。是的，有人会说，有一个去中心化的零信任数据库会是一个优势，但我还没有看到一个使用区块链的系统，仅仅只是一个普通的数据库是不够的。</p><p>现实生活中的应用我只看到了审计跟踪，去中心化的部分是没有用的（只有通过哈希的区块链在那里有用，以避免篡改过去的记录）。但这种用例与区块链倡导者推广它的原因无关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在我看来，比特币是一种时尚，它的价值是两件事所赋予的：</p><ol><li>人们对一种资产有太多的信心，而这种资产并不是真正的资产，除了提供一个投机的机会外，没有任何用处；</li><li>还有就是人们的 FOMO，当朋友告诉他们应该买，或者大众媒体极少数月一次将它带到公众面前时，他们就会被一时的热度所吸引而买入。</li></ol><p>本文仅代表个人观点，不代表理财建议。我并不是在说“买”或“卖”。请自行思考。</p><p>Repost from: <a href="https://vladcalin.ro/blog/2021-02-07-about-blockchain">https://vladcalin.ro/blog/2021-02-07-about-blockchain</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
            <tag> BitCoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 大文件存储</title>
      <link href="/posts/2021-01-27-git-lfs.html"/>
      <url>/posts/2021-01-27-git-lfs.html</url>
      
        <content type="html"><![CDATA[<p>Git Large File Storage (<code>git-lfs</code>) 是针对 Git 大文件存储的解决方案，开发者在 git 仓库中有时会有一些大型文件，比如：机器学习的数据集，音频文件，视频文件等等。</p><h1 id="1-安装-git-lfs-扩展"><a href="#1-安装-git-lfs-扩展" class="headerlink" title="1. 安装 git-lfs 扩展"></a>1. 安装 git-lfs 扩展</h1><p>macOS 下直接使用下面命令即可安装。</p><pre><code class="bash">brew install git-lfs</code></pre><h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h1><p>在 git repo 中指明哪些文件需要使用 <code>git-lfs</code> 来进行大文件存储。</p><pre><code class="bash">git lfs track &quot;data/*&quot;</code></pre><p>以上命令表示 <code>data</code> 目录下所有文件都需要通过 <code>git-lfs</code> 来进行管理。</p><p>而且在 git repo 根目录会有一个 <code>.gitattributes</code> 文件，这个也是需要 <code>git add .gitattributes</code> 的。</p><p>注：上述命令中 <code>&quot;data/*&quot;</code> 需要加上引号，不然会被 bash shell 当成正则处理了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件推荐之 Ventoy</title>
      <link href="/posts/2021-01-19-software-recommendation-ventoy.html"/>
      <url>/posts/2021-01-19-software-recommendation-ventoy.html</url>
      
        <content type="html"><![CDATA[<p>Ventoy （ 官网地址：<a href="https://www.ventoy.net/">https://www.ventoy.net/</a> ） 是一个制作可启动U盘的开源工具。有了Ventoy你就无需反复地格式化U盘，你只需要把 ISO&#x2F;WIM&#x2F;IMG&#x2F;VHD(x)&#x2F;EFI 等类型的文件拷贝到U盘里面就可以启动了，无需其他操作。<br>你可以一次性拷贝很多个不同类型的镜像文件，Ventoy 会在启动时显示一个菜单来供你进行选择 (参见 <a href="https://www.ventoy.net/cn/screenshot.html">截图</a>)。<br>Ventoy 同时支持 x86 Legacy BIOS、IA32 UEFI、x86_64 UEFI 和 ARM64 UEFI 模式。支持大部分常见类型的操作系统 （Windows&#x2F;WinPE&#x2F;Linux&#x2F;Unix&#x2F;VMware&#x2F;Xen …）<br>目前已经测试了各类超过 <strong>600+</strong> 个ISO文件(<a href="https://www.ventoy.net/cn/isolist.html">列表</a>)。 支持 <a href="https://distrowatch.com/dwres.php?resource=popularity">distrowatch.com</a> 网站上收录的 <strong>90%+</strong> 的操作系统(<a href="https://www.ventoy.net/cn/distrowatch.html">列表</a>)。</p><p><strong>特点：</strong></p><ul><li>可以安装在 U盘&#x2F;本地硬盘&#x2F;SSD&#x2F;NVMe&#x2F;SD卡等设备上</li><li>直接从 ISO&#x2F;WIM&#x2F;IMG&#x2F;VHD(x)&#x2F;EFI 文件启动，无需解开</li><li>ISO&#x2F;WIM&#x2F;IMG&#x2F;VHD(x)&#x2F;EFI 文件在磁盘上无需连续</li><li>支持MBR和GPT分区格式</li><li>同时支持 x86 Legacy BIOS、IA32 UEFI、x86_64 UEFI、ARM64 UEFI</li><li>UEFI 模式支持安全启动 (Secure Boot) <a href="https://www.ventoy.net/cn/doc_secure.html">说明</a></li><li>支持数据持久化 <a href="https://www.ventoy.net/cn/plugin_persistence.html">说明</a></li><li>支持Windows系统的自动安装部署 <a href="https://www.ventoy.net/cn/plugin_autoinstall.html">说明</a></li><li>支持 RHEL7&#x2F;8&#x2F;CentOS7&#x2F;8&#x2F;SUSE&#x2F;Ubuntu Server&#x2F;Debian 等Linux系统的自动安装部署 <a href="https://www.ventoy.net/cn/plugin_autoinstall.html">说明</a></li><li>镜像分区支持 FAT32&#x2F;exFAT&#x2F;NTFS&#x2F;UDF&#x2F;XFS&#x2F;Ext2(3)(4) 文件系统</li><li>支持超过4GB的ISO文件</li><li>保留ISO原始的启动菜单风格(Legacy &amp; UEFI)</li><li>支持大部分常见操作系统, 已测试600+ 个ISO文件</li><li>不仅仅是启动，而是完整的安装过程</li><li>菜单可以在列表模式和目录树模式之间实时、动态切换 <a href="https://www.ventoy.net/cn/doc_treeview.html">说明</a></li><li>提出 “Ventoy Compatible” 概念</li><li>支持插件扩展</li><li>Linux vDisk(vhd&#x2F;vdi&#x2F;raw…) 启动解决方案</li><li>支持向运行环境中插入文件</li><li>动态替换ISO文件中的原始启动配置文件</li><li>高度可定制化的主题风格和菜单</li><li>启动过程中支持U盘设置写保护</li><li>不影响U盘日常普通使用</li><li>版本升级时数据不会丢失</li><li>无需跟随操作系统升级而升级Ventoy</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> Software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Markdown 来进行 LaTeX 写作</title>
      <link href="/posts/2021-01-11-write-your-latex-document-with-markdown.html"/>
      <url>/posts/2021-01-11-write-your-latex-document-with-markdown.html</url>
      
        <content type="html"><![CDATA[<p>一直以来 Markdown 和 LaTeX 都在吸引着我，各自有着各自的优缺点。Markdown 很简单，但是在论文排版、书籍排版等方面不够专业，只能用做简单的博客方面。LaTeX 有非常强大的排版系统，但是书写起来不够优雅，目前还没有见到有什么所见即所得的 LaTeX 编辑器。于是本文主要讲述目前笔者摸索出来的一套将 Markdown 与 LaTeX 结合起来进行文章混合写作的方法。</p><h1 id="1-什么是-Markdown-？"><a href="#1-什么是-Markdown-？" class="headerlink" title="1. 什么是 Markdown ？"></a>1. 什么是 Markdown ？</h1><p>Markdown 是一种轻量级的标记语言，允许人们使用简单易读的纯文本格式编写文档。编写出来的文档能够很轻松的转换成 HTML、Word、epub 等文档。得益于其简单易读的语法格式，Markdown 成为了程序员们编写文档的主要工具。不仅如此，越来越多的人开始使用 Markdown 来进行写作。Markdown 是一种文档标记语言，而针对 Markdown 的文档编辑器也非常多。主流使用的有：Typora、MWeb、MarkdownPad、Mou等。除了这些 Markdown 的文档编辑器，甚至有很多笔记软件也内置了 Markdown 语法支持，比如我们熟悉的印象笔记、有道云笔记、为知笔记、Notion等等。</p><h1 id="2-什么是-LaTeX-？"><a href="#2-什么是-LaTeX-？" class="headerlink" title="2. 什么是 $\LaTeX$ ？"></a>2. 什么是 $\LaTeX$ ？</h1><p>$\LaTeX$ 是一种基于 $\TeX$ 的排版系统。利用这种格式系统进行处理，即使使用者没有排版和程序设计的知识也可以充分发挥由 $\TeX$ 所提供的强大功能，使用者不需要一一亲自去设计或校对就能在几天甚至是几小时内生成很多具有书籍品质的印刷品。$\LaTeX$ 在生成复杂的表格和数学公式方面尤为突出。因此它非常适用于生成高质量的科技和数学、物理文档。</p><h1 id="3-文件组织方式"><a href="#3-文件组织方式" class="headerlink" title="3. 文件组织方式"></a>3. 文件组织方式</h1><p>Markdown 文件不宜过大，所以写的文件按章存放：<code>chapter01.md</code>, <code>chapter02.md</code> 等等。</p><p>如 <code>chapter01.md</code> ：</p><pre><code class="markdown"># 简介路径规划 \cite&#123;Zafar2018&#125; 在很多领域都具有广泛的应用，在高新科技领域的应用有：机器人的自主无碰撞行为；无人机的避障突防飞行等。</code></pre><p>通过 <code>pandoc -r markdown-auto_identifiers -w latex chapter01.md -o chapter01.tex</code> 可以生成对应的 <code>.tex</code> 文件。有了 <code>.tex</code> 文件，则可以在主文件中进行引用了。</p><p><code>main.tex</code> 如下：</p><pre><code class="tex">\documentclass[UTF8]&#123;ctexart&#125;\usepackage&#123;url&#125;\usepackage&#123;hyperref&#125;\title&#123;路径规划算法研究&#125;\author&#123;L. Jiang&#125;\date&#123;\today&#125;\begin&#123;document&#125;\maketitle\tableofcontents\input&#123;chapter01&#125;\bibliographystyle&#123;IEEEtran&#125;\bibliography&#123;IEEEabrv,my&#125;\end&#123;document&#125;</code></pre><p>而参考文献只需要新建一个 <code>my.bib</code> 文件，然后将文献管理器（如：Mendeley，EndNote等）导出的 BibTeX 格式的内容复制进去即可。而本人在使用 Mendeley 作为文献管理器时，最后直接将整个 Mendeley 所有文献全部导出或者将某个分类目录下的全部导出到 <code>my.bib</code> 文件即可，非常地银杏。</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f0d7d378-231b-4d5f-a3a2-50b80f3b973d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20210111/us-west-2/s3/aws4_request&X-Amz-Date=20210111T062612Z&X-Amz-Expires=86400&X-Amz-Signature=6acd0d3964858640df336f40743541177da0b69b9bdf8481f7079ca41085ef3b&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/posts/2020-12-29-quick-sort.html"/>
      <url>/posts/2020-12-29-quick-sort.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>（英文：Quick Sort），也称为<strong>分区交换排序</strong>（Partition Exchange Sort），是一种排序算法。快速排序最早由 <strong>Tony Hoare</strong> 于 1961 年提出。其平均算法复杂度为 $O(n \log{n})$，然而最坏情况下算法复杂度为 $O(n^2)$，当然这种情况是非常极端的，大部分时候是不会发生这种事情的。</p><p>快速排序的主要排序思想在于：<strong>选出一个基准值，然后将所有比这个值小的值放置在左边，比这个值大的放在右边。接下来对左右两边的数值继续执行这个过程。</strong></p><p>比如：[5, 4, 2, 7, 3] 这组数字，假设我们选择基准为数字3，那么第一趟下来大致是这样的：[2, 3, 5, 4, 7]。那么在以 3 作为基准数字的一趟排序后，数组被分为了三个部分，[2], 3, 和 [5,4,7]. 3已经被确定下来位置了，那么接下来就继续使用以上操作分别对 [2] 和 [5,4,7] 进行排序即可。</p><p>在快速排序算法中有两个核心函数：<code>sort()</code> 和 <code>partition()</code></p><ul><li><code>sort()</code> 从上述能看出，快速排序是一个具有递归结构的算法，我们在设计的时候可以设计成 <code>void sort(int a[], size_t n);</code> 表示对数组 <code>a[]</code> 进行排序，那么为什么还要 <code>size_t n</code> 这个参数呢？我们都知道，在 C 语言中，传递的一个数组变量那只是传递了这个数组的首地址，所以还需要传递数组的大小。这里有同学可能会说，那分区之后如何对分区后的左右两个部分进行排序呢？并不是所有的分区都是从 <code>a[]</code> 的首地址开始的呀。技巧就是：我们只需要进行地址偏移就可以了。</li><li><code>partition()</code> 函数，对数组进行分区交换操作。设计的时候可以设计成 <code>size_t partition(int a[], size_t n);</code> 注意：这个函数是有返回值的。因为我们要告诉调用者分区最后基准值落在哪个位置，有了这个位置，就可以定位到分区之后被分成的左右两个部分，进而继续调用 <code>sort()</code> 函数进行排序了。</li></ul><h1 id="1-sort-函数"><a href="#1-sort-函数" class="headerlink" title="1. sort() 函数"></a>1. <code>sort()</code> 函数</h1><p> 实现上，首先判断一下 $n$ 的大小，没必要排序的情况下直接结束。然后接下来三个步骤：</p><ol><li>调用 <code>partition()</code> 函数进行分区，并获取基准值最后停下来的位置。</li><li>对分区后左部分进行排序。</li><li>对分区后右部分进行排序。</li></ol><p>这里需要注意的就是分区后左部分和右部分各自的起始地址和大小。</p><pre><code class="c">void sort(int a[], size_t n) &#123;    if (n &lt;= 1) &#123;        return;    &#125;    size_t mid = partition(a, n);    sort(a, mid);    sort(a + mid + 1, n - mid - 1);&#125;</code></pre><h1 id="2-partition-函数"><a href="#2-partition-函数" class="headerlink" title="2. partition() 函数"></a>2. <code>partition()</code> 函数</h1><p>分区函数，其实这才是快速排序最最核心的部分了。分区操作基准值选择需要分区的数组段最后一个值。首先将除去最后一个值的剩余部分分成左右两部分（左部分所有值小于基准值，右部分所有值大于基准值），然后将分区后右半部分的第一个与分区的数组段最后一个值（基准值）进行互换。这里其实有一个小操作，就是我们并不要着急去规定基准值最后的位置，毕竟咋也不知道具体多少个值是小于基准值的，多少个值是大于基准值的。而是我们直接将除了基准值剩下的分成两个部分，然后将右部分第一个与基准值换个地址就好了，反正这个值往右放并没有改变右边所有值都大于基准值的事实。</p><pre><code class="c">size_t partition(int a[], size_t n) &#123;    if (n &lt;= 1) &#123;        return 0;    &#125;    size_t cursor_bottom = -1;    for (size_t i = 0; i &lt; n - 1; i++) &#123;        if (a[i] &lt; a[n - 1]) &#123;            cursor_bottom++;            swap(&amp;a[cursor_bottom], &amp;a[i]);        &#125;    &#125;    cursor_bottom++;    swap(&amp;a[cursor_bottom], &amp;a[n-1]);    return cursor_bottom;&#125;</code></pre><h1 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h1><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void print_arr(int a[], size_t n) &#123;    for (size_t i = 0; i &lt; n; i++) &#123;        printf(&quot;%2d &quot;, a[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swap(int *a, int *b) &#123;    int tmp;    tmp = *a;    *a = *b;    *b = tmp;&#125;size_t partition(int a[], size_t n) &#123;    if (n &lt;= 1) &#123;        return 0;    &#125;    size_t cursor_bottom = -1;    for (size_t i = 0; i &lt; n - 1; i++) &#123;        if (a[i] &lt; a[n - 1]) &#123;            cursor_bottom++;            swap(&amp;a[cursor_bottom], &amp;a[i]);        &#125;    &#125;    cursor_bottom++;    swap(&amp;a[cursor_bottom], &amp;a[n - 1]);    return cursor_bottom;&#125;void sort(int a[], size_t n) &#123;    if (n &lt;= 1) &#123;        return;    &#125;    size_t mid = partition(a, n);    sort(a, mid);    sort(a + mid + 1, n - mid - 1);&#125;int main() &#123;    int a[] = &#123;4, 6, 3, 2, 7, 4, 2, 5, 6, 2&#125;;    print_arr(a, 10);    sort(a, 10);    print_arr(a, 10);    return EXIT_SUCCESS;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>便携式 MySQL</title>
      <link href="/posts/2020-12-15-portable-mysql.html"/>
      <url>/posts/2020-12-15-portable-mysql.html</url>
      
        <content type="html"><![CDATA[<p>开发者日常就是需要面对各种各样的数据库，甚至有的开发者需要面对同样的产品不同版本的数据库，而且希望数据库软件不会影响到系统，如果是通过可执行文件进行安装的数据库软件，在安装多个版本的数据时候可能会出现一些版本冲突的情况，甚至是软件安装覆盖的问题。还有一个困扰就是我可能需要多个数据库实例，而且每个实例互不影响。那么本文的方法都是可以解决以上问题的。</p><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>那么什么是 “便携式 MySQL” 呢？其实本文笔者写笔记的时候用的是 “Portable MySQL” 的标题。但还是更喜欢这个标题吧。便携式的意思就是软件不会与系统有太多的依赖。比如我在A机器上运行了一个 MySQL，但是我现在想把数据库迁移到另一台机器上，那么便携式在这件事情上的优点就是<strong>我们能够直接复制对应的数据目录到新的机器上就可以直接恢复运行了。</strong>而且还有一个优点就是<strong>便携式 MySQL 能够很方便的进行安装、卸载、迁移。</strong>这些优点都是现在软件开发中有关效率与安全性非常重要的。</p><h1 id="2-下载并安装"><a href="#2-下载并安装" class="headerlink" title="2. 下载并安装"></a>2. 下载并安装</h1><p>本文使用到的所有 MySQL 可执行文件都是可以在 MySQL 官网（<a href="https://dev.mysql.com/downloads/mysql/%EF%BC%89%E8%BF%9B%E8%A1%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E3%80%82">https://dev.mysql.com/downloads/mysql/）进行下载的。</a></p><p>那么笔者下载的是 mysql-8.0.22-macos10.15-x86_64.tar.gz ，下载后解压并将其放至 <code>/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64</code></p><h1 id="3-创建存放-MySQL-数据的文件夹"><a href="#3-创建存放-MySQL-数据的文件夹" class="headerlink" title="3. 创建存放 MySQL 数据的文件夹"></a>3. 创建存放 MySQL 数据的文件夹</h1><p>创建一个空文件夹 <code>/Users/ismdeep/Data/rawdata</code></p><p>该文件夹将用来保存 MySQL 数据库的数据，如果需要进行迁移则在数据库关闭之后复制这个文件夹即可。那如果需要启动新的数据库实例，则需要新建另一个数据库文件夹并按照以下步骤进行初始化数据库即可。</p><h1 id="4-初始化数据库"><a href="#4-初始化数据库" class="headerlink" title="4. 初始化数据库"></a>4. 初始化数据库</h1><p>首先对空白的文件夹进行数据库初始化。</p><pre><code class="bash">mysqld --initialize \       --user=mysql \       --basedir=/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64 \       --datadir=/Users/ismdeep/Data/rawdata</code></pre><p>MySQL 8.0 默认使用的数据库密码是由 MySQL 自动随机生成的，这个密码会出现在以上命令执行的输出上。如果没有出现则会保存在数据文件夹中的后缀为 <code>.err</code> 的文件中。</p><h1 id="5-启动数据库"><a href="#5-启动数据库" class="headerlink" title="5. 启动数据库"></a>5. 启动数据库</h1><pre><code>mysqld --basedir=/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64 \       --datadir=/Users/ismdeep/Data/rawdata</code></pre><p><code>mysqld</code> 命令常用参数说明：</p><ul><li><code>--daemonize</code> 后台守护进程模式</li><li><code>--bind-address=&lt;address&gt;</code> 绑定访问地址</li></ul><h1 id="6-修改-root-密码"><a href="#6-修改-root-密码" class="headerlink" title="6. 修改 root 密码"></a>6. 修改 root 密码</h1><p>在以上重新启动数据库之后首先要做的就是修改 root 密码。运行以下命令并输入上述所说随机初始化的密码。</p><pre><code>$ mysql -uroot -p -h127.0.0.1Enter password:</code></pre><p>接下来修改密码，这里为了方便叙述就使用 <code>123456</code> 作为密码，当然笔者非常不建议大家这样用，因为这样的密码太过简单。</p><pre><code>mysql&gt; alter user user() identified by &#39;123456&#39;;Query OK, 0 rows affected (0.00 sec)</code></pre><p>需要开启远程访问则增加以下命令（当然以上 <code>--bind-address</code> 参数也是需要设置的）：</p><pre><code>CREATE USER &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;;</code></pre><h1 id="7-关闭服务器命令"><a href="#7-关闭服务器命令" class="headerlink" title="7. 关闭服务器命令"></a>7. 关闭服务器命令</h1><pre><code>mysqladmin -uroot -p123456 shutdown</code></pre><h1 id="8-alias-小技巧"><a href="#8-alias-小技巧" class="headerlink" title="8. alias 小技巧"></a>8. alias 小技巧</h1><p>笔者觉得以上启动服务器和关闭服务器命令太麻烦了。所以会使用以下两个 alias 来简化。</p><pre><code>alias mysql-start=&quot;mysqld --daemonize --basedir=/Users/ismdeep/Apps/mysql-8.0.22-macos10.15-x86_64 --datadir=/Users/ismdeep/Data/rawdata&quot;alias mysql-stop=&quot;mysqladmin -uroot -pE0Lztvs238 shutdown&quot;</code></pre><p>这样启动服务器则使用 <code>mysql-start</code> ，关闭服务器则使用 <code>mysql-stop</code> 即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Hacker </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> Development </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重置 Downie 4 试用有效期</title>
      <link href="/posts/2020-11-20-reset-downie-4-trial.html"/>
      <url>/posts/2020-11-20-reset-downie-4-trial.html</url>
      
        <content type="html"><![CDATA[<p>Downie 4 是 macOS 上一款优秀的下载工具，不仅能够方便下载 YouTube 视频，还能够高效地下载 HTTP&#x2F;HTTPS 链接资源。当然其实还支持非常多的视频网站下载视频。软件提供 14 天试用时间，试用期之内用户能够使用几乎所有正版购买的功能，这还是非常良心的，那么其实试用版对普通用户来说已经非常够用了。那么这个软件试用期 14 天过了之后，自然就需要用户考虑购买使用了。</p><p>本文所述重置 Downie 4 试用有效期的方法同样适用其他具有试用有效期的软件。</p><p>那么，试用有效期的原理就是：</p><ol><li>读取试用有效期文件</li><li><strong>IF</strong> 文件不存在 <strong>Do</strong></li><li>​    创建文件并写入当前时间</li><li><strong>END</strong> <strong>IF</strong></li><li></li><li><strong>IF</strong> 文件存在 <strong>AND</strong> 超出试用期 <strong>Do</strong></li><li>​    提示购买</li><li>​    <strong>EXIT</strong></li><li><strong>END</strong> <strong>IF</strong></li><li></li><li>显示剩余试用期时长</li></ol><p>针对这样的有效试用期判断方式的破解方式就很简单：找到试用有效期文件，将其删除即可。</p><p>至于怎么找呢，有很多方法，这里主要就是靠经验了。先找到软件存放数据的目录，macOS 下一般都在 <code>~/Library</code> 里面，然后可以通过目录查找的方式找软件的名称，当然还可以配合一些 App 数据清理工具查看 App 存放数据的目录或者是名称。这样能够大大降低搜索的范围。</p><p>至于 Downie 4 嘛，就用以下命令即可：</p><pre><code>rm -rfv &quot;/Users/ismdeep/Library/Containers/com.charliemonroe.Downie-4/Data/Library/Application Support/Downie 4&quot;</code></pre><p>当然，笔者是在 <code>~/.zshrc</code> 中设置了 alias 的</p><pre><code>alias reset-downie-trial=&#39;rm -rfv &quot;/Users/ismdeep/Library/Containers/com.charliemonroe.Downie-4/Data/Library/Application Support/Downie 4&quot;&#39;</code></pre><p>这样以后需要删除试用时间的话就执行 <code>reset-downie-trial</code> 即可。</p><p>好吧，扯了这么多，其实最后才是最重要的部分，就如之前看到一篇文章下的评论一样：一条***命令就行了，非要写这么长。这个嘛，我还是更想让各位明白个所以然啦。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Python 构建漂亮的命令行程序</title>
      <link href="/posts/2020-11-19-building-beautiful-command-line-interfaces-with-python.html"/>
      <url>/posts/2020-11-19-building-beautiful-command-line-interfaces-with-python.html</url>
      
        <content type="html"><![CDATA[<p>在开始构建命令行应用程序之前，让我们来看一下什么是<strong>命令行</strong>。</p><p>自计算机程序创建以来，命令行程序就无处不在了，很多程序都是由命令构建的。命令行程序是一种通过命令行或者是 shell 进行操作的软件。</p><p>命令行界面（Command Line Interface，CLI）是一种可通过终端、shell 或控制台上键入命令来控制（而非使用鼠标）的用户界面。控制台是一种显示模式，其整个屏幕仅显示文本，没有图像和 GUI 控件。</p><p>根据维基百科：</p><blockquote><p>CLI 是 1960 年代中期与计算机终端上的大多数计算机系统进行交互的主要方式，并且在整个 1970 年代和 1980 年代继续在 OpenVMS 、 Unix 系统和包括 MS-DOS ，CP&#x2F;M 和 Apple DOS 在内的个人计算机系统上使用。 该界面通常使用命令行 shell 实现，该命令行 shell 是一个接受命令作为文本输入并将命令转换为对应的操作系统功能。</p></blockquote><h1 id="1-为什么选择-Python-？"><a href="#1-为什么选择-Python-？" class="headerlink" title="1. 为什么选择 Python ？"></a>1. 为什么选择 Python ？</h1><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/6bd5661b7670ac6dbf9d67677d3da7b0-a4764d.jpeg" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/6bd5661b7670ac6dbf9d67677d3da7b0-a4764d.jpeg"></p><p>Python 经常因为其灵活性和与其他语言很好的结合使用的特性而被视作<em>胶水语言。</em>大部分 Python 代码都是用于脚本和命令行界面。</p><p>构建这些命令行界面和工具将变得非常强大，因为它们能够让你将想到的任何事情自动化执行成为可能。</p><p>我们处于一个漂亮且交互式界面的时代，所以 UI  (User Interactive，用户交互) 和 UX (User Experience ，用户体验) 至关重要。我们需要将这些内容添加到命令行中，以让人们能够实现它们。而这些已被 Heroku 等流行公司正式使用。</p><p>大量的 Python 库和模块可以帮助构建命令行应用程序，包括从参数解析和选项标记到完整的 CLI 框架。这些工具可以执行彩色输出，进度条，发送邮件等操作。</p><p>使用这些模块，你可以创建像 Heroku 以及 Node 中 Vue-init 和 NPM-init 这些漂亮的交互式命令行界面程序了。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/28b12eb6a3964bdcb5fb33a6e65d6490-54f1c0.png" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/28b12eb6a3964bdcb5fb33a6e65d6490-54f1c0.png"></p><p>为了方便构建漂亮的 <code>vue init</code> 命令行程序，我建议使用 Python-inquirer ，这是 Inquirer.js 在 Python 的移植版本。</p><p>不幸的是，由于使用了 blessings 模块（一个引入了只有类 UNIX 系统才可以使用的 <code>_curses</code> 和 <code>fcntl</code> 模块的包），Python-inquirer 无法在 Windows 上运行。然而，有一些出色的开发人员能够将 <code>_curses</code> 移植到  Windows 上，但无法移植 <code>fcntl</code>. Windows 中的 <code>fctnl</code> 可替代品是 <code>win32api</code>.</p><p>但是，经过了在 Google 上大量的搜索之后，我碰到了一个 Python 模块，我对其进行全面修复，并将其称为 <a href="https://github.com/CITGuru/PyInquirer">PyInquirer</a> ，它是 python-inquirer 的替代品。而它有一个很大的好处就是：它可以在包括 Windows 在内的所有操作系统平台上使用。<strong>赞！</strong></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/930528e6684ff1da00bf4ce8e447dd53-92bcb5.jpg" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/930528e6684ff1da00bf4ce8e447dd53-92bcb5.jpg"></p><h1 id="2-Python-命令行界面的基础知识"><a href="#2-Python-命令行界面的基础知识" class="headerlink" title="2. Python 命令行界面的基础知识"></a>2. Python 命令行界面的基础知识</h1><p>现在让我们来看看命令行界面，并在 Python 中创建一个。</p><p>命令行界面（CLI）通常以可执行文件的名称开头。你只需要在控制台中输入名称，这就是访问脚本的的主要入口点，例如 <code>pip</code>.</p><p>你需要根据脚本的开发方式将<strong>参数</strong>传递给脚本，它们可以是：</p><ol><li>参数**:** 这是传递给脚本的必需参数。如果不提供，程序就会出错。例如在：<code>pip install django</code> 这个命令中，<code>django</code> 就是命令的参数。</li><li>选项**:** 顾名思义，它是一个可选参数，通常是带有名称和值组成的对，例如：<code>pip install django --cache-dir ./my-cache-dir</code> 中 <code>-cache-dir</code> 是一个选项参数的名称，<code>./my-cache-dir</code> 则是值，这组成了一对，意义表示缓存目录指定为 <code>./my-cache-dir</code> 这个目录。</li><li>标志**:** 这是一个特殊的选项参数，它是用来告诉脚本启用或禁用某些行为，最常见的一种可能就是 <code>-help</code> 了。</li></ol><p>使用 Heroku Toolbelt 等复杂的命令行程序，其实是将访问的所有命令全部归入到主入口点了。它们通常被视为<strong>命令</strong>或者<strong>子命令</strong>。</p><p>现在，让我们看以下如何使用不同的 Python 包构建智能且美观的命令行程序。</p><h1 id="3-Argparse"><a href="#3-Argparse" class="headerlink" title="3. Argparse"></a>3. <strong>Argparse</strong></h1><p><strong>Argparse</strong> 是 Python 中用于构建命令行程序自带的模块。它提供了构建简单的命令行程序的所需的所有功能。</p><pre><code class="python">import argparseparser = argparse.ArgumentParser(description=&#39;Add some integers.&#39;)parser.add_argument(&#39;integers&#39;, metavar=&#39;N&#39;, type=int, nargs=&#39;+&#39;,                    help=&#39;interger list&#39;)parser.add_argument(&#39;--sum&#39;, action=&#39;store_const&#39;,                    const=sum, default=max,                    help=&#39;sum the integers (default: find the max)&#39;)args = parser.parse_args()print(args.sum(args.integers))</code></pre><p>这是一个简单的加法操作。<code>argparse.ArgumentParser</code> 让你能够添加程序描述到其中，而 <code>parser.add_argument</code> 让你添加一个命令。<code>parser.parse_args()</code> 则会返回一组参数，它们通常以 名称-值 对的形式出现。</p><p>例如：你可以通过 <code>args.integers</code> 访问 <code>integers</code> 的参数值。在上述脚本中，<code>-sum</code> 是一个可选参数， <code>N</code> 是位置参数。</p><h1 id="4-Click"><a href="#4-Click" class="headerlink" title="4. Click"></a>4. Click</h1><p>与 Argparse 相比，使用 <a href="https://github.com/pallets/click">Click</a> 能够更简单的创建命令行程序。argparse 能做的，Click 同样能做。但是使用了稍微不一样的方法。它使用了 <em>decorators</em> 的概念，这使命令成为可以使用装饰器包装的函数。</p><pre><code class="python"># cli.pyimport click@click.command()def main():    click.echo(&quot;This is a CLI built with Click ✨&quot;)if __name__ == &quot;__main__&quot;:    main()</code></pre><p>你可以按下面的方式添加参数和选项：</p><pre><code class="python"># cli.pyimport click@click.command()@click.argument(&#39;name&#39;)@click.option(&#39;--greeting&#39;, &#39;-g&#39;)def main(name, greeting):    click.echo(&quot;&#123;&#125;, &#123;&#125;&quot;.format(greeting, name))if __name__ == &quot;__main__&quot;:    main()</code></pre><p>运行上述脚本，则应有：</p><pre><code>$ python cli.py --greeting &lt;greeting&gt; OyetokeHey, Oyetoke</code></pre><p>将以上所有的整合在一起，我能够构建一个简单的命令行（CLI）程序来查询 Google Books 中的图书。</p><pre><code class="python">import clickimport requests__author__ = &quot;Oyetoke Toby&quot;@click.group()def main():    &quot;&quot;&quot;    Simple CLI for querying books on Google Books by Oyetoke Toby    &quot;&quot;&quot;    pass@main.command()@click.argument(&#39;query&#39;)def search(query):    &quot;&quot;&quot;This search and return results corresponding to the given query from Google Books&quot;&quot;&quot;    url_format = &#39;&lt;https://www.googleapis.com/books/v1/volumes&gt;&#39;    query = &quot;+&quot;.join(query.split())    query_params = &#123;        &#39;q&#39;: query    &#125;    response = requests.get(url_format, params=query_params)    click.echo(response.json()[&#39;items&#39;]) @main.command()@click.argument(&#39;id&#39;)def get(id):    &quot;&quot;&quot;This return a particular book from the given id on Google Books&quot;&quot;&quot;    url_format = &#39;&lt;https://www.googleapis.com/books/v1/volumes/&#123;&#125;&gt;&#39;    click.echo(id)    response = requests.get(url_format.format(id))    click.echo(response.json())if __name__ == &quot;__main__&quot;:    main()</code></pre><p>更多有关信息，您可以从<a href="http://click.pocoo.org/">官方文档</a>上深入了解 Click.</p><h1 id="5-Docopt"><a href="#5-Docopt" class="headerlink" title="5. Docopt"></a>5. Docopt</h1><p><a href="http://docopt.org/">Docopt</a> 是一个轻量级的 Python 软件包，可以通过解析 POSIC-样式 或 Markdown 使用说明轻松地创建命令行界面。Docopt 使用多年来用于格式化帮助信息和手册页来描述命令行界面的约定。 <code>*docopt**</code> 中的界面描述就是这样的帮助信息，但是形式化。</p><p>Docopt 非常关心文件顶部格式化所需的文档字符串方式。在工具名称的下一行开始，文档第一部分顶部必需是 “Usage”，并且应列出你期望命令被调用的方式。</p><p>文档的第二部分开始必需是 “Options” ，这应该提供有关在 “Usage” 中标识的选项和参数的更多信息。文档字符串的内容将程序帮助文档的内容。</p><pre><code class="python">&quot;&quot;&quot;HELLO CLIUsage:    hello.py    hello.py &lt;name&gt;    hello.py -h|--help    hello.py -v|--versionOptions:    &lt;name&gt;  Optional name argument.    -h --help  Show this screen.    -v --version  Show version.&quot;&quot;&quot;from docopt import docoptdef say_hello(name):    return(&quot;Hello &#123;&#125;!&quot;.format(name))if __name__ == &#39;__main__&#39;:    arguments = docopt(__doc__, version=&#39;DEMO 1.0&#39;)    if arguments[&#39;&lt;name&gt;&#39;]:        print(say_hello(arguments[&#39;&lt;name&gt;&#39;]))    else:        print(arguments)</code></pre><h1 id="6-PyInquirer"><a href="#6-PyInquirer" class="headerlink" title="6. PyInquirer"></a>6. PyInquirer</h1><p><a href="https://github.com/CITGuru/PyInquirer">PyInquirer</a> 是一个用于交互式命令行用户界面的模块。我们在上面看到的程序包并没有实现我们想要的 “漂亮界面” 的目标。因此，让我们来看以下如何使用 PyInquirer.</p><p>像 Inquirer.js 一样，PyInquirer 分为两个简单的步骤：</p><ol><li>您定义<strong>问题列表</strong>并将其传递给<strong>命令行</strong>。</li><li>命令行返回<strong>答案列表</strong>。</li></ol><pre><code class="python">from __future__ import print_function, unicode_literalsfrom PyInquirer import promptfrom pprint import pprintquestions = [    &#123;        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;first_name&#39;,        &#39;message&#39;: &#39;What\&#39;s your first name&#39;,     &#125;]answers = prompt(questions)pprint(answers)</code></pre><p>一个互动的例子</p><pre><code class="python">from __future__ import print_function, unicode_literalsfrom PyInquirer import style_from_dict, Token, prompt, Separatorfrom pprint import pprintstyle = style_from_dict(&#123;    Token.Separator: &#39;#cc5454&#39;,    Token.QuestionMark: &#39;#673ab7 bold&#39;,    Token.Selected: &#39;#cc5454&#39;,  # default    Token.Pointer: &#39;#673ab7 bold&#39;,    Token.Instruction: &#39;&#39;,  # default    Token.Answer: &#39;#f44336 bold&#39;,    Token.Question: &#39;&#39;,&#125;)questions = [    &#123;        &#39;type&#39;: &#39;checkbox&#39;,        &#39;message&#39;: &#39;Select toppings&#39;,        &#39;name&#39;: &#39;toppings&#39;,        &#39;choices&#39;: [            Separator(&#39;= The Meats =&#39;),            &#123;                &#39;name&#39;: &#39;Ham&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Ground Meat&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Bacon&#39;            &#125;,            Separator(&#39;= The Cheeses =&#39;),            &#123;                &#39;name&#39;: &#39;Mozzarella&#39;,                &#39;checked&#39;: True            &#125;,            &#123;                &#39;name&#39;: &#39;Cheddar&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Parmesan&#39;            &#125;,            Separator(&#39;= The usual =&#39;),            &#123;                &#39;name&#39;: &#39;Mushroom&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Tomato&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Pepperoni&#39;            &#125;,            Separator(&#39;= The extras =&#39;),            &#123;                &#39;name&#39;: &#39;Pineapple&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Olives&#39;,                &#39;disabled&#39;: &#39;out of stock&#39;            &#125;,            &#123;                &#39;name&#39;: &#39;Extra cheese&#39;            &#125;        ],        &#39;validate&#39;: lambda answer: &#39;You must choose at least one topping.&#39; \\            if len(answer) == 0 else True    &#125;]answers = prompt(questions, style=style)pprint(answers)</code></pre><p>结果：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/3dda204e0e32445743d5e8b0aa11d7a6-21b129.png" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/3dda204e0e32445743d5e8b0aa11d7a6-21b129.png"></p><p>让我们来看看脚本的部分内容：</p><pre><code class="python">style = style_from_dict(&#123;Token.Separator: &#39;#cc5454&#39;,Token.QuestionMark: &#39;#673ab7 bold&#39;,Token.Selected: &#39;#cc5454&#39;,  # defaultToken.Pointer: &#39;#673ab7 bold&#39;,Token.Instruction: &#39;&#39;,  # defaultToken.Answer: &#39;#f44336 bold&#39;,Token.Question: &#39;&#39;,&#125;)</code></pre><p><code>style_from_dict</code> 被用来定义让界面自定义样式。 <code>Token</code> 就像一个组件，它下面有其他的组件。</p><p>我们在前面的示例中看到了 <code>questions</code> 列表。并将其传递到<code>prompt</code> 中进行处理。</p><p>你可以按照下面的示例来创建一个交互式命令行程序：</p><pre><code class="python"># -*- coding: utf-8 -*-from __future__ import print_function, unicode_literalsimport regexfrom pprint import pprintfrom PyInquirer import style_from_dict, Token, promptfrom PyInquirer import Validator, ValidationErrorstyle = style_from_dict(&#123;    Token.QuestionMark: &#39;#E91E63 bold&#39;,    Token.Selected: &#39;#673AB7 bold&#39;,    Token.Instruction: &#39;&#39;,  # default    Token.Answer: &#39;#2196f3 bold&#39;,    Token.Question: &#39;&#39;,&#125;)class PhoneNumberValidator(Validator):    def validate(self, document):        ok = regex.match(&#39;^([01]&#123;1&#125;)?[-.\\s]?\\(?(\\d&#123;3&#125;)\\)?[-.\\s]?(\\d&#123;3&#125;)[-.\\s]?(\\d&#123;4&#125;)\\s?((?:#|ext\\.?\\s?|x\\.?\\s?)&#123;1&#125;(?:\\d+)?)?$&#39;, document.text)        if not ok:            raise ValidationError(                message=&#39;Please enter a valid phone number&#39;,                cursor_position=len(document.text))  # Move cursor to endclass NumberValidator(Validator):    def validate(self, document):        try:            int(document.text)        except ValueError:            raise ValidationError(                message=&#39;Please enter a number&#39;,                cursor_position=len(document.text))  # Move cursor to endprint(&#39;Hi, welcome to Python Pizza&#39;)questions = [    &#123;        &#39;type&#39;: &#39;confirm&#39;,        &#39;name&#39;: &#39;toBeDelivered&#39;,        &#39;message&#39;: &#39;Is this for delivery?&#39;,        &#39;default&#39;: False    &#125;,    &#123;        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;phone&#39;,        &#39;message&#39;: &#39;What\&#39;s your phone number?&#39;,        &#39;validate&#39;: PhoneNumberValidator    &#125;,    &#123;        &#39;type&#39;: &#39;list&#39;,        &#39;name&#39;: &#39;size&#39;,        &#39;message&#39;: &#39;What size do you need?&#39;,        &#39;choices&#39;: [&#39;Large&#39;, &#39;Medium&#39;, &#39;Small&#39;],        &#39;filter&#39;: lambda val: val.lower()    &#125;,    &#123;        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;quantity&#39;,        &#39;message&#39;: &#39;How many do you need?&#39;,        &#39;validate&#39;: NumberValidator,        &#39;filter&#39;: lambda val: int(val)    &#125;,    &#123;        &#39;type&#39;: &#39;expand&#39;,        &#39;name&#39;: &#39;toppings&#39;,        &#39;message&#39;: &#39;What about the toppings?&#39;,        &#39;choices&#39;: [            &#123;                &#39;key&#39;: &#39;p&#39;,                &#39;name&#39;: &#39;Pepperoni and cheese&#39;,                &#39;value&#39;: &#39;PepperoniCheese&#39;            &#125;,            &#123;                &#39;key&#39;: &#39;a&#39;,                &#39;name&#39;: &#39;All dressed&#39;,                &#39;value&#39;: &#39;alldressed&#39;            &#125;,            &#123;                &#39;key&#39;: &#39;w&#39;,                &#39;name&#39;: &#39;Hawaiian&#39;,                &#39;value&#39;: &#39;hawaiian&#39;            &#125;        ]    &#125;,    &#123;        &#39;type&#39;: &#39;rawlist&#39;,        &#39;name&#39;: &#39;beverage&#39;,        &#39;message&#39;: &#39;You also get a free 2L beverage&#39;,        &#39;choices&#39;: [&#39;Pepsi&#39;, &#39;7up&#39;, &#39;Coke&#39;]    &#125;,    &#123;        &#39;type&#39;: &#39;input&#39;,        &#39;name&#39;: &#39;comments&#39;,        &#39;message&#39;: &#39;Any comments on your purchase experience?&#39;,        &#39;default&#39;: &#39;Nope, all good!&#39;    &#125;,    &#123;        &#39;type&#39;: &#39;list&#39;,        &#39;name&#39;: &#39;prize&#39;,        &#39;message&#39;: &#39;For leaving a comment, you get a freebie&#39;,        &#39;choices&#39;: [&#39;cake&#39;, &#39;fries&#39;],        &#39;when&#39;: lambda answers: answers[&#39;comments&#39;] != &#39;Nope, all good!&#39;    &#125;]answers = prompt(questions, style=style)print(&#39;Order receipt:&#39;)pprint(answers)</code></pre><p>结果：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/bba36b8ea3673d380414708274d217a8-2bd40f.png" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/bba36b8ea3673d380414708274d217a8-2bd40f.png"></p><h1 id="7-PyFiglet"><a href="#7-PyFiglet" class="headerlink" title="7. PyFiglet"></a>7. PyFiglet</h1><p><a href="https://github.com/pwaller/pyfiglet">Pyfiglet</a>  是一个用于将字符串转换为带有艺术字体的 ASCII 文本的 Python 模块。Pyfiglet 是 FIGlet (<a href="http://www.figlet.org/">http://www.figlet.org/</a>) 在纯 Python 中的完整移植。</p><pre><code class="python">from pyfiglet import Figletf = Figlet(font=&#39;slant&#39;)print f.renderText(&#39;text to render&#39;)</code></pre><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/bfd7023cef9b4d8f735c6239a18508d3-9afe30.png" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/bfd7023cef9b4d8f735c6239a18508d3-9afe30.png"></p><h1 id="8-Clint"><a href="#8-Clint" class="headerlink" title="8. Clint"></a>8. Clint</h1><p><a href="https://pypi.org/project/clint/">Clint</a> 包含了创建命令行程序所需的一切。它支持颜色，超强的可嵌套缩紧上下文管理器，支持自定义邮件样式的引号，超强列打印以及可选的自动扩展列，等等。</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-from __future__ import print_functionimport sysimport ossys.path.insert(0, os.path.abspath(&#39;..&#39;))from clint.arguments import Argsfrom clint.textui import puts, colored, indentargs = Args()with indent(4, quote=&#39;&gt;&gt;&gt;&#39;):    puts(colored.blue(&#39;Aruments passed in: &#39;) + str(args.all))    puts(colored.blue(&#39;Flags detected: &#39;) + str(args.flags))    puts(colored.blue(&#39;Files detected: &#39;) + str(args.files))    puts(colored.blue(&#39;NOT Files detected: &#39;) + str(args.not_files))    puts(colored.blue(&#39;Grouped Arguments: &#39;) + str(dict(args.grouped)))print()</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/5f2a366af561dc6b9ea03a2c186b197f-0857fd.png" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/5f2a366af561dc6b9ea03a2c186b197f-0857fd.png"></p><p>酷吧？我知道。</p><h1 id="9-其他-Python-CLI-工具"><a href="#9-其他-Python-CLI-工具" class="headerlink" title="9. 其他 Python CLI 工具"></a>9. 其他 Python CLI 工具</h1><p><strong><a href="http://builtoncement.com/">Cement</a>:</strong> 它是完整的命令行界面框架。Cement 提供了轻量且功能齐全的基础，可以构建从单个文件脚本到复杂且设计精巧的应用程序。</p><p><strong><a href="https://docs.openstack.org/cliff/latest/">Cliff</a>:</strong> Cliff 是用于构建命令行程序的框架。它使用 setuptools 入口点提供子命令，输出格式化程序和其他扩展。</p><p><strong><a href="https://pypi.python.org/pypi/plac">Plac</a>:</strong> Plac 是 Python 标准库 argparse 的简单封装。该库通过声明性接口隐藏了大多数复杂的东西：推断参数解析器，而不是强制性地写下来。</p><h1 id="10-EmailCLI"><a href="#10-EmailCLI" class="headerlink" title="10. EmailCLI"></a>10. EmailCLI</h1><p>将所有内容加在一起，我编写了一个简单的命令行程序，用于通过 SendGrid 发送邮件。因此，要使用以下脚本，请从 <a href="https://sendgrid.com/">SendGrid</a> 获取你的 API 密钥。</p><h2 id="10-1-安装"><a href="#10-1-安装" class="headerlink" title="10.1 安装"></a>10.1 安装</h2><pre><code>pip install sendgrid click PyInquirer pyfiglet pyconfigstore colorama termcolor six</code></pre><pre><code class="python">import osimport reimport clickimport sendgridimport sixfrom pyconfigstore import ConfigStorefrom PyInquirer import (Token, ValidationError, Validator, print_json, prompt,                        style_from_dict)from sendgrid.helpers.mail import *from pyfiglet import figlet_formattry:    import colorama    colorama.init()except ImportError:    colorama = Nonetry:    from termcolor import coloredexcept ImportError:    colored = Noneconf = ConfigStore(&quot;EmailCLI&quot;)style = style_from_dict(&#123;    Token.QuestionMark: &#39;#fac731 bold&#39;,    Token.Answer: &#39;#4688f1 bold&#39;,    Token.Instruction: &#39;&#39;,  # default    Token.Separator: &#39;#cc5454&#39;,    Token.Selected: &#39;#0abf5b&#39;,  # default    Token.Pointer: &#39;#673ab7 bold&#39;,    Token.Question: &#39;&#39;,&#125;)def getDefaultEmail(answer):    try:        from_email = conf.get(&quot;from_email&quot;)    except KeyError, Exception:        from_email = u&quot;&quot;    return from_emaildef getContentType(answer, conttype):    return answer.get(&quot;content_type&quot;).lower() == conttype.lower()def sendMail(mailinfo):    sg = sendgrid.SendGridAPIClient(api_key=conf.get(&quot;api_key&quot;))    from_email = Email(mailinfo.get(&quot;from_email&quot;))    to_email = Email(mailinfo.get(&quot;to_email&quot;))    subject = mailinfo.get(&quot;subject&quot;).title()    content_type = &quot;text/plain&quot; if mailinfo.get(&quot;content_type&quot;) == &quot;text&quot; else &quot;text/html&quot;    content = Content(content_type, mailinfo.get(&quot;content&quot;))    mail = Mail(from_email, subject, to_email, content)    response = sg.client.mail.send.post(request_body=mail.get())    return responsedef log(string, color, font=&quot;slant&quot;, figlet=False):    if colored:        if not figlet:            six.print_(colored(string, color))        else:            six.print_(colored(figlet_format(                string, font=font), color))    else:        six.print_(string)class EmailValidator(Validator):    pattern = r&quot;\\&quot;?([-a-zA-Z0-9.`?&#123;&#125;]+@\\w+\\.\\w+)\\&quot;?&quot;    def validate(self, email):        if len(email.text):            if re.match(self.pattern, email.text):                return True            else:                raise ValidationError(                    message=&quot;Invalid email&quot;,                    cursor_position=len(email.text))        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(email.text))class EmptyValidator(Validator):    def validate(self, value):        if len(value.text):            return True        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(value.text))class FilePathValidator(Validator):    def validate(self, value):        if len(value.text):            if os.path.isfile(value.text):                return True            else:                raise ValidationError(                    message=&quot;File not found&quot;,                    cursor_position=len(value.text))        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(value.text))class APIKEYValidator(Validator):    def validate(self, value):        if len(value.text):            sg = sendgrid.SendGridAPIClient(                api_key=value.text)            try:                response = sg.client.api_keys._(value.text).get()                if response.status_code == 200:                    return True            except:                raise ValidationError(                    message=&quot;There is an error with the API Key!&quot;,                    cursor_position=len(value.text))        else:            raise ValidationError(                message=&quot;You can&#39;t leave this blank&quot;,                cursor_position=len(value.text))def askAPIKEY():    questions = [        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;api_key&#39;,            &#39;message&#39;: &#39;Enter SendGrid API Key (Only needed to provide once)&#39;,            &#39;validate&#39;: APIKEYValidator,        &#125;,    ]    answers = prompt(questions, style=style)    return answersdef askEmailInformation():       questions = [        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;from_email&#39;,            &#39;message&#39;: &#39;From Email&#39;,            &#39;default&#39;: getDefaultEmail,            &#39;validate&#39;: EmailValidator        &#125;,        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;to_email&#39;,            &#39;message&#39;: &#39;To Email&#39;,            &#39;validate&#39;: EmailValidator        &#125;,        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;subject&#39;,            &#39;message&#39;: &#39;Subject&#39;,            &#39;validate&#39;: EmptyValidator        &#125;,        &#123;            &#39;type&#39;: &#39;list&#39;,            &#39;name&#39;: &#39;content_type&#39;,            &#39;message&#39;: &#39;Content Type:&#39;,            &#39;choices&#39;: [&#39;Text&#39;, &#39;HTML&#39;],            &#39;filter&#39;: lambda val: val.lower()        &#125;,        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;content&#39;,            &#39;message&#39;: &#39;Enter plain text:&#39;,            &#39;when&#39;: lambda answers: getContentType(answers, &quot;text&quot;),            &#39;validate&#39;: EmptyValidator        &#125;,        &#123;            &#39;type&#39;: &#39;confirm&#39;,            &#39;name&#39;: &#39;confirm_content&#39;,            &#39;message&#39;: &#39;Do you want to send an html file&#39;,            &#39;when&#39;: lambda answers: getContentType(answers, &quot;html&quot;)        &#125;,        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;content&#39;,            &#39;message&#39;: &#39;Enter html:&#39;,            &#39;when&#39;: lambda answers: not answers.get(&quot;confirm_content&quot;, True),            &#39;validate&#39;: EmptyValidator        &#125;,        &#123;            &#39;type&#39;: &#39;input&#39;,            &#39;name&#39;: &#39;content&#39;,            &#39;message&#39;: &#39;Enter html path:&#39;,            &#39;validate&#39;: FilePathValidator,            &#39;filter&#39;: lambda val: open(val).read(),            &#39;when&#39;: lambda answers: answers.get(&quot;confirm_content&quot;, False)        &#125;,        &#123;            &#39;type&#39;: &#39;confirm&#39;,            &#39;name&#39;: &#39;send&#39;,            &#39;message&#39;: &#39;Do you want to send now&#39;        &#125;    ]    answers = prompt(questions, style=style)    return answers@click.command()def main():    &quot;&quot;&quot;    Simple CLI for sending emails using SendGrid    &quot;&quot;&quot;    log(&quot;Email CLI&quot;, color=&quot;blue&quot;, figlet=True)    log(&quot;Welcome to Email CLI&quot;, &quot;green&quot;)    try:        api_key = conf.get(&quot;api_key&quot;)    except KeyError:        api_key = askAPIKEY()        conf.set(api_key)        mailinfo = askEmailInformation()    if mailinfo.get(&quot;send&quot;, False):        conf.set(&quot;from_email&quot;, mailinfo.get(&quot;from_email&quot;))        try:            response = sendMail(mailinfo)        except Exception as e:            raise Exception(&quot;An error occured: %s&quot; % (e))                if response.status_code == 202:            log(&quot;Mail sent successfully&quot;, &quot;blue&quot;)        else:            log(&quot;An error while trying to send&quot;, &quot;red&quot;)if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/cf5a82fe55a7ff783b88f86c236349fc-ca9e34.png" alt="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/19/cf5a82fe55a7ff783b88f86c236349fc-ca9e34.png"></p><p>如此而已。</p><p>可以看看这篇文章 <a href="https://www.davidfischer.name/2017/01/python-command-line-apps/">https://www.davidfischer.name/2017/01/python-command-line-apps/</a></p><p>翻译自：<a href="https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df">https://codeburst.io/building-beautiful-command-line-interfaces-with-python-26c7e1bb54df</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年蓝桥杯全国总决赛——皮亚诺曲线</title>
      <link href="/posts/2020-11-17-hilbert-curve.html"/>
      <url>/posts/2020-11-17-hilbert-curve.html</url>
      
        <content type="html"><![CDATA[<p>皮亚诺曲线（英语：Peano Curve，也称：希尔伯特曲线，Hilbert Curve）是一条能够填满正方形的曲线。在传统概念中，曲线的数维是1维，正方形是2维的。详细介绍见：<a href="https://zh.wikipedia.org/zh-cn/%E7%9A%AE%E4%BA%9A%E8%AF%BA%E6%9B%B2%E7%BA%BF">维基百科：皮亚诺曲线</a></p><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>皮亚诺曲线是一条平面内的曲线，下图给出了皮亚诺曲线的 1 阶情形，它是从左下角出发，经过一个 3 × 3 的方格中的每一个格子，最终到达右上角的一条曲线。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/17/3f282b6c64756110753712d0f3cf5e81-f86fc3.png" alt="img"></p><p>下图给出了皮亚诺曲线的 2 阶情形，它是经过一个 32 × 32 的方格中的每一个格子的一条曲线。它是将 1 阶曲线的每个方格由 1 阶曲线替换而成。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/17/e4756f6a8d6f793ea06b2d3e5fd364f1-028733.png" alt="img"></p><p>下图给出了皮亚诺曲线的 3 阶情形，它是经过一个 33 × 33 的方格中的每一个格子的一条曲线。它是将 2 阶曲线的每个方格由 1 阶曲线替换而成。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/17/9f4c990545830ede819aca69522f9cf3-d44c33.png" alt="img"></p><p>皮亚诺曲线总是从左下角开始出发，最终到达右上角。</p><p><strong>问题：求给定阶数的皮亚诺曲线中任意两个相邻点数值差之和。</strong>比如：</p><p>$1$ 阶皮亚诺曲线所有相邻点差值和为 $24$.</p><p>$2$ 阶皮亚诺曲线所有相邻点差值和为 $816$.</p><p>比赛中题目最后要求的是 $n &#x3D; 14$ ，即求 $14$ 阶皮亚诺曲线中任意两个相邻点数值差的和。</p><h1 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h1><p>首先，如果通过暴力打表，然后将所有相邻点差值的和累加起来，当然是不现实的。想想空间复杂度和时间复杂度就明白了。这里我们能够很容易得到空间复杂度是 $O((3^n)^2)$，估算一下当 $n &#x3D; 14$ 时，内存至少需要 $170445$ GB.</p><pre><code>&gt;&gt;&gt; (3 ** 14) ** 2 * 8.0 / 1024.0 / 1024.0 / 1024.0170445.38598478585</code></pre><p>别做梦了，暴力杯并不是所有题都是可以暴力的。</p><p>那这样的题目应该怎么做呢？虽然 $n &#x3D; 14$ 我们做不到，但是 $n$ 比较小的时候还是能够处理的嘛。比如：$n &#x3D; 1$， $n &#x3D; 2$ 这样的。先写一个模拟出来，再找找规律看看。（<em>其实这样的一个解题思路基本上是么得问题的。</em>）</p><p>对于这个东西该怎么模拟呢，请先看下面两张图，分别为 $1$ 阶皮亚诺曲线和 $2$ 阶皮亚诺曲线大致走向示意图。</p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/17/e2568c2d390c3517808ca11a71ff942d-057a40.jpg" alt="MnTOZP18TPSHNIm+aFmeRg_thumb_6b1" style="zoom: 25%;" /><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/17/96a33f5d08d8b33cc722ed9696810538-411135.jpg" alt="yuQ3JrzlSnSezgL+XhF%Ag_thumb_6ae" style="zoom: 25%;" /><p>我们发现在所有的皮亚诺曲线中，大致走向只有四个方向：↗️、↖️、↘️、↙️，依次编号为1，2，3，4.</p><ol><li>↗️</li><li>↖️</li><li>↘️</li><li>↙️</li></ol><p>而皮亚诺曲线升阶（比如1阶变到2阶）过程，就是对基阶皮亚诺曲线进行扩展操作。比如我们看 $1$ 阶升阶为 $2$ 阶就是对↗️走向扩展为 9 个走向↗️↖️↗️ ↘️↙️↘️ ↗️↖️↗️. 到这里如果都能看明白，其他对这个题目解题就很有帮助了。我们接下来要做的就是将四个方向扩展出来的方向列表搞出来，这个可以从二阶扩展到三阶的皮亚诺曲线中得到。</p><ol><li>↗️ 扩展为 ↗️↖️↗️ ↘️↙️↘️ ↗️↖️↗️ 对应编号为 <code>121 343 121</code></li><li>↖️ 扩展为 ↖️↗️↖️ ↙️↘️↙️ ↖️↗️↖️ 对应编号为 <code>212 434 212</code></li><li>↘️ 扩展为 ↘️↙️↘️ ↗️↖️↗️ ↘️↙️↘️ 对应编号为 <code>343 121 343</code></li><li>↙️ 扩展为 ↙️↘️↙️ ↖️↗️↖️ ↙️↘️↙️ 对应编号为 <code>434 212 434</code></li></ol><p>到这里接下来就变得简单了，当然还有一点需要处理，那就是各个大致行走方向怎么接上的问题，比如：先↗️走，接下来需要↖️走，但是我应该怎样让↗️结束后的那个位置接上↖️开始的位置呢？</p><p>那么我们对于所有可能的组合进行的表示（当然并不是所有的方向组合都在这个方向中的，比如↗️接下来就不可能是↙️）：</p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/17/840fb3fcad1124b4846e5eb846c95113-fdd6e7.jpg" alt="J41Ora9ESyuBnG7xh9tvdg_thumb_6b7" style="zoom: 33%;" /><p>那对于大致方向与大致方向之间的连接关系我们也得到了。</p><p>下来就是把大致方向（↗️、↖️、↘️、↙️）表示成详细的行走方向（⬆️、⬇️、⬅️、➡️）即可。</p><h1 id="3-皮亚诺曲线实现"><a href="#3-皮亚诺曲线实现" class="headerlink" title="3. 皮亚诺曲线实现"></a>3. 皮亚诺曲线实现</h1><p><code>Dir.java</code> 详细行走方向类，后面需要用到。</p><pre><code class="java">public class Dir &#123;    public int ic;    public int jc;    public Dir(int _ic_, int _jc_) &#123;        this.ic = _ic_;        this.jc = _jc_;    &#125;&#125;</code></pre><p><code>DirUtil.java</code> 方向处理工具类，<strong>核心部分</strong>，用于升阶扩展操作，以及将大致行走方向表示成详细的行走方向。</p><pre><code class="java">import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class DirUtil &#123;    private static final Dir UP = new Dir(1, 0);    private static final Dir DOWN = new Dir(-1, 0);    private static final Dir RIGHT = new Dir(0, 1);    private static final Dir LEFT = new Dir(0, -1);    public static Dir[] dir1 = new Dir[]&#123;            UP, UP, RIGHT, DOWN, DOWN, RIGHT, UP, UP    &#125;;    public static Dir[] dir2 = new Dir[]&#123;            UP, UP, LEFT, DOWN, DOWN, LEFT, UP, UP    &#125;;    public static Dir[] dir3 = new Dir[]&#123;            DOWN, DOWN, RIGHT, UP, UP, RIGHT, DOWN, DOWN    &#125;;    public static Dir[] dir4 = new Dir[]&#123;            DOWN, DOWN, LEFT, UP, UP, LEFT, DOWN, DOWN    &#125;;    public static Dir[] getDir(DirTester.Point s, DirTester.Point t) &#123;        if (s.x &lt; t.x &amp;&amp; s.y &lt; t.y) return dir1;        if (s.x &lt; t.x &amp;&amp; s.y &gt; t.y) return dir2;        if (s.x &gt; t.x &amp;&amp; s.y &lt; t.y) return dir3;        return dir4;    &#125;    public static Dir[] getDirById(int __id__) &#123;        switch (__id__) &#123;            case 1:                return dir1;            case 2:                return dir2;            case 3:                return dir3;            case 4:                return dir4;        &#125;        return null;    &#125;    // 升阶扩展操作    public static List&lt;Integer&gt; expandDirGroup(List&lt;Integer&gt; list) &#123;        List&lt;Integer&gt; expandedList = new ArrayList&lt;&gt;();        for (int item : list) &#123;            switch (item) &#123;                case 1:                    expandedList.addAll(Arrays.asList(1, 2, 1, 3, 4, 3, 1, 2, 1));                    break;                case 2:                    expandedList.addAll(Arrays.asList(2, 1, 2, 4, 3, 4, 2, 1, 2));                    break;                case 3:                    expandedList.addAll(Arrays.asList(3, 4, 3, 1, 2, 1, 3, 4, 3));                    break;                case 4:                    expandedList.addAll(Arrays.asList(4, 3, 4, 2, 1, 2, 4, 3, 4));                    break;            &#125;        &#125;        return expandedList;    &#125;    // 将大致行走方向展开为完整的行走方向    public static List&lt;Dir&gt; expandAsStepList(List&lt;Integer&gt; dirGroupList) &#123;        List&lt;Dir&gt; dirs = new ArrayList&lt;&gt;();        int prevDirId = 0;        for (int dirGroupId : dirGroupList) &#123;            Dir[] dirsTmp = getDirById(dirGroupId);            switch (prevDirId * 10 + dirGroupId) &#123;                case 12:                case 21:                    dirs.add(UP);                    break;                case 13:                case 31:                    dirs.add(RIGHT);                    break;                case 24:                case 42:                    dirs.add(LEFT);                    break;                case 34:                case 43:                    dirs.add(DOWN);                    break;            &#125;            assert dirsTmp != null;            dirs.addAll(Arrays.asList(dirsTmp));            prevDirId = dirGroupId;        &#125;        return dirs;    &#125;&#125;</code></pre><p><code>HilbertCurveTester.java</code> 则是对曲线结果进行测试了。</p><pre><code class="java">import java.util.*;public class HilbertCurveTester &#123;    static class Point &#123;        public int x, y;        public Point() &#123;        &#125;        public Point(int x, int y) &#123;            this.x = x;            this.y = y;        &#125;    &#125;    public static int[][] genMap(int level) &#123;        if (level &lt; 1) &#123;            return null;        &#125;        int mapSize = pow(3, level);        int[][] a = new int[mapSize][mapSize];        List&lt;Integer&gt; dirGroupList = new ArrayList&lt;&gt;();        dirGroupList.add(1);        for (int i = 2; i &lt;= level; i++) &#123;            dirGroupList = DirUtil.expandDirGroup(dirGroupList);        &#125;        List&lt;Dir&gt; dirList = DirUtil.expandAsStepList(dirGroupList);        int x = 0;        int y = 0;        int val = 1;        a[x][y] = val++;        for (Dir dir : dirList) &#123;            x += dir.ic;            y += dir.jc;            a[x][y] = val++;        &#125;        return a;    &#125;    public static int pow(int a, int n) &#123;        int ans = 1;        for (int i = 0; i &lt; n; i++) &#123;            ans *= a;        &#125;        return ans;    &#125;    public static void display(int[][] a) &#123;        for (int i = a.length - 1; i &gt;= 0; i--) &#123;            for (int j = 0; j &lt; a[i].length; j++) &#123;                System.out.printf(&quot;%2d &quot;, a[i][j]);            &#125;            System.out.println();        &#125;    &#125;    public static void main(String[] args) &#123;        System.out.print(&quot;[n] &gt; &quot;);        Scanner in = new Scanner(System.in);        int n = in.nextInt();        int[][] a = genMap(n);        int sum = 0;        assert a != null;        display(a);    &#125;&#125;</code></pre><pre><code class="text">[n] &gt; 1 3  4  9  2  5  8  1  6  7 </code></pre><pre><code>[n] &gt; 221 22 27 28 33 34 75 76 81 20 23 26 29 32 35 74 77 80 19 24 25 30 31 36 73 78 79 18 13 12 43 42 37 72 67 66 17 14 11 44 41 38 71 68 65 16 15 10 45 40 39 70 69 64  3  4  9 46 51 52 57 58 63  2  5  8 47 50 53 56 59 62  1  6  7 48 49 54 55 60 61 </code></pre><h1 id="4-问题求解过程"><a href="#4-问题求解过程" class="headerlink" title="4. 问题求解过程"></a>4. 问题求解过程</h1><p>接下来我们就可以对生成的皮亚诺曲线进行找规律了，我们可以将所有距离都打了出来，形成一个 $(距离，个数)$ 表示形式。比如：</p><pre><code class="text">[n] &gt; 1(1, 8)(5, 2)(3, 2)</code></pre><p>与给的样例是一样的 $1 \times 8 + 5 \times 2 + 3 \times 2 &#x3D; 24$</p><pre><code>[n] &gt; 2(1, 80)(3, 20)(5, 20)(11, 6)(13, 6)(31, 2)(33, 2)(35, 2)(37, 2)(39, 2)(41, 2)</code></pre><p>这里与给的样例计算结果也是一样的。</p><p>我发现接下去打表就更长了，规律不好找了。于是我突发奇想，我想着直接把同样个数的数值都给加起来看看。</p><p>于是就有了以下关于不同 $n$ 的计算式子：</p><pre><code>1 (24)        =&gt; 1*8      + 8*22 (816)       =&gt; 1*80     + 8*20     + 24*6     + 216*23 (23496)     =&gt; 1*728    + 8*182    + 24*60    + 216*20    + 648*6    + 5832*24 (647520)    =&gt; 1*6560   + 8*1640   + 24*546   + 216*182   + 648*60   + 5832*20   + 17496*6   + 157464*25 (17601144)  =&gt; 1*59048  + 8*14762  + 24*4920  + 216*1640  + 648*546  + 5832*182  + 17496*60  + 157464*20  + 472392*6  + 4251528*26 (476293776) =&gt; 1*531440 + 8*132860 + 24*44286 + 216*14762 + 648*4920 + 5832*1640 + 17496*546 + 157464*182 + 472392*60 + 4251528*20  + 12754584*6 + 114791256*2</code></pre><p>接下来就是快乐的找规律时间了。</p><p>我们将乘法左右给拆分出来，分成两个列表 <code>list1</code> 和 <code>list2</code></p><p><code>list1</code></p><pre><code>1 (24)        =&gt; 1 82 (816)       =&gt; 1 8 24 2163 (23496)     =&gt; 1 8 24 216 648 58324 (647520)    =&gt; 1 8 24 216 648 5832 17496 1574645 (17601144)  =&gt; 1 8 24 216 648 5832 17496 157464 472392 42515286 (476293776) =&gt; 1 8 24 216 648 5832 17496 157464 472392 4251528 12754584 114791256</code></pre><p><code>list2</code></p><pre><code>1 (24)        =&gt; 8      22 (816)       =&gt; 80     20     6     23 (23496)     =&gt; 728    182    60    20    6    24 (647520)    =&gt; 6560   1640   546   182   60   20   6   25 (17601144)  =&gt; 59048  14762  4920  1640  546  182  60  20  6  26 (476293776) =&gt; 531440 132860 44286 14762 4920 1640 546 182 60 20 6 2</code></pre><p>至此，规律就变得很容易找了。</p><p>这里就不去过多赘述了。见下面的代码吧。</p><h1 id="5-解题代码"><a href="#5-解题代码" class="headerlink" title="5. 解题代码"></a>5. 解题代码</h1><pre><code class="java">import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main &#123;    public static long pow(long a, int n) &#123;        long ans = 1;        for (int i = 0; i &lt; n; i++) &#123;            ans *= a;        &#125;        return ans;    &#125;    public static List&lt;Long&gt; genList1(int n) &#123;        if (n &lt; 1) &#123;            return new ArrayList&lt;&gt;();        &#125;        if (n == 1) &#123;            List&lt;Long&gt; result = new ArrayList&lt;&gt;();            result.add(1L);            result.add(8L);            return result;        &#125;        List&lt;Long&gt; prev = genList1(n - 1);        List&lt;Long&gt; result = new ArrayList&lt;&gt;(prev);        result.add(result.get(result.size() - 1) * 3);        result.add(result.get(result.size() - 1) * 9);        return result;    &#125;    public static List&lt;Long&gt; genList2(int n) &#123;        if (n &lt; 1) &#123;            return new ArrayList&lt;&gt;();        &#125;        if (n == 1) &#123;            List&lt;Long&gt; result = new ArrayList&lt;&gt;();            result.add(8L);            result.add(2L);            return result;        &#125;        List&lt;Long&gt; prev = genList2(n - 1);        List&lt;Long&gt; result = new ArrayList&lt;&gt;();        result.add(pow(9, n) - 1);        result.add(result.get(result.size()- 1) / 4L);        result.add(prev.get(1) * 3);        for (int i = 1; i &lt; prev.size(); i++) &#123;            result.add(prev.get(i));        &#125;        return result;    &#125;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        int n = in.nextInt();        List&lt;Long&gt; list1 = genList1(n);        List&lt;Long&gt; list2 = genList2(n);        long ans = 0;        for (int i = 0; i &lt; n * 2; i++) &#123;            ans += list1.get(i) * list2.get(i);        &#125;        System.out.println(ans);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊 HTTP 状态码 301 和 302 的区别</title>
      <link href="/posts/2020-11-12-talk-about-http-status-code-301-and-302.html"/>
      <url>/posts/2020-11-12-talk-about-http-status-code-301-and-302.html</url>
      
        <content type="html"><![CDATA[<p>今天面试了一个厂子，结果又被问到我不熟悉的知识点了，太久没看 HTTP 状态了，也就知道 200 OK，404 NOT FOUND，500，502 系统异常，巴拉巴拉，对于 302 也就是有一点点印象，完全来自于在调试程序从 Chrome 开发者模式的 http response 中看见过。那么，对于 HTTP 状态码的 301 和 302 都有哪些区别呢？</p><p>首先我们先说一下什么是 HTTP 状态码，其实 HTTP 状态码是服务器用来告诉浏览器每一次 HTTP 访问请求的状态的，比如正常的话就返回 200；而如果用户访问了一个不存在的页面，就会返回 404；而当用户访问了一个页面，而这个页面上由于程序员编写的程序不够健壮，或者是后台某个服务停掉了（比如数据库被人删库了）就会出现 500 错误。</p><div style="text-align: center"><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/11/13/76b3ee0a96d45e20982a0244627d2273-37c2cc.png" alt="img" /></div><p>其中 301 和 302 都是用来进行页面重定向的，所以在说起这两个状态码区别之前，我们先说一说页面重定向。在网页重定向中，其实是指当访问了一个网页，启动跳转至新的网页页面。比如：当你在一个网站中反问个人中心页面，然而这时你并没有登录，于是后台作出重定向页面的反应；接下来你在用户登录页面进行登录操作，登录成功后自动跳转至个人中心页面。而这里使用了不同的重定向页面方式，根据不同的需求场景，开发者也会使用不同的重定向技术。</p><p>常用重定向页面方式有：</p><ul><li>301, “Moved Permanently” 永久重定向，推荐用于 SEO 优化</li><li>302, “Found” or “Moved Temporarily”</li><li>307, “Moved Temporarily” (HTTP 1.1 Only)</li><li>Meta Refresh</li></ul><p>下面我们分三个部分对三种页面重定向方式进行说明。</p><h2 id="301-永久重定向"><a href="#301-永久重定向" class="headerlink" title="301 永久重定向"></a>301 永久重定向</h2><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应放回的若干 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><p>301 最简单最常用的一个常见应该就是域名跳转了。比如，我们访问 <a href="http://www.google.com/">http://www.google.com</a> 会自动跳转至 <a href="https://www.google.com/">https://www.google.com</a> ，这一个访问过程是这样的：发送请求之后，服务器给你返回一个 301 状态码，并在 Response Header 中设置 Location 为。<a href="https://www.google.com/">https://www.google.com</a> ，浏览器收到这样的响应自动修改地址栏中的地址，继续访问新的地址。</p><p>注意：301 请求是可以缓存的，也就是说，用户下一次通过浏览器访问 <a href="http://www.google.com/">http://www.google.com</a> 时，浏览器则直接访问 <a href="https://www.google.com/">https://www.google.com</a> 了，而不需要再去访问服务器，然后又一次拿到响应。这就是永久重定向的意思。</p><h2 id="302-Found-临时重定向"><a href="#302-Found-临时重定向" class="headerlink" title="302 Found&#x2F;临时重定向"></a>302 Found&#x2F;临时重定向</h2><p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，除非有 Cache-Control 或者是 Expires 说明情况下才可以进行缓存，否则都是不可以缓存的。在不缓存的情况下（默认情况），下一次访问原地址时，浏览器应该继续访问服务器。</p><p>302 一个例子就是上述说的用户访问用户中心的例子，在未登录的情况下，需要重定向至登录页面，而在已经登录的情况下，则需要直接显示已登录后用户中心的页面。这次每一次访问都需要进行判断，所以只能是临时重定向。</p><h2 id="307-临时重定向（HTTP-1-1）"><a href="#307-临时重定向（HTTP-1-1）" class="headerlink" title="307 临时重定向（HTTP 1.1）"></a>307 临时重定向（HTTP 1.1）</h2><p>307 重定向是 302 重定向的 HTTP 1.1 后续版本。当客户端的 POST 请求收到服务端 307 状态码响应时，需要跟用户询问是否应该在新 URI 上发起 POST 方法，也就是说，307 是不会把 POST 转为 GET 的。</p><h2 id="Meta-Refresh"><a href="#Meta-Refresh" class="headerlink" title="Meta Refresh"></a>Meta Refresh</h2><p>这个写过前端代码的同学肯定用过，就是 JavaScript 里面的 <code>location.href = &quot;/profile&quot;;</code> 这样的语句啦。我们继续来说上面说的用户登录的例子。有的用户交互设计是这样的，用户在页面上输入账号密码，点击登录按钮并不是通过页面 POST 数据到某个页面上，而是通过 Ajax 方式进行异步访问，当异步返回数据显示登录成功之后再通过 <code>location.href</code> 方式进行 Meta Refresh.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能编程语言：C，C++，Rust，汇编语言</title>
      <link href="/posts/2020-11-09-fast-programming-languages-c-cpp-rust-and-assembly.html"/>
      <url>/posts/2020-11-09-fast-programming-languages-c-cpp-rust-and-assembly.html</url>
      
        <content type="html"><![CDATA[<p>本文并不是在讨论哪种编程语言更好，而是讨论用于开发最快的服务器端系统软件（例如数据库引擎和 HTTPS 服务器）的最强大的工具集。这类软件有着以下几个特定的属性：</p><ul><li>相对较大的代码库，超过 100,000 行 C 或 C++ 代码。尽管可以用汇编语言编写特定的最“热门”的函数，但用汇编语言编写整个程序是不切实际的。</li><li>数据库和 Web 服务器是关键性支撑软件。多年以来我们已经习惯了使用有 MySQL 和 Nginx 进程的 Linux 系统。有一些<a href="https://github.com/tempesta-tech/tempesta/wiki/High-availability">简单的高可用</a>最佳实践可以缓解由于可能的奔溃而导致的停机时间，但这是另一篇文章的主题。同时，值得一提的是，如果你真的在乎可用性，那么你应该在假设系统的任何组件随时可能奔溃的前提下构建基础架构，就像 <a href="https://lwn.net/Articles/801871/">Facebook 是这样做的</a>一样，该公司在最新的 Linux 推出之后，就立刻部署使用了。</li></ul><p>多年来，我们一直在开发使用 <a href="http://tempesta-tech.com/c++-services">C，C++ 和汇编语言最快的软件</a>。 既然 Rust 一直<a href="https://en.wikipedia.org/wiki/Rust_(programming_language">“专注于性能”</a>，我们当然对此非常感兴趣。虽然有些怀疑，想想当年 Java 编程语言的兴起：有许多报道表明 JIT 编译产生的代码比 C++ 更快。现在很难出现这种 C++ 比 Java 慢的情况，请参见<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/java.html">基准测试</a>的例子。还值得一题的是，Java 中的内存垃圾回收（GC）会导致较高的尾部等待时间，并且很难甚至根本无法解决该问题。由于 GC，不能将 Go 语言用于高性能编程。</p><h2 id="C-还是-C-？-或者都是？"><a href="#C-还是-C-？-或者都是？" class="headerlink" title="C 还是 C++ ？ 或者都是？"></a>C 还是 C++ ？ 或者都是？</h2><p>C 语言在系统编程中占着主导地位。操作系统内核是最复杂的系统软件之一，不仅因为它直接与硬件打交道，而且还由于严格的性能要求。Linux 和 FreeBSD 内核以及其他 UNIX 和 Windows 内核都是用 C 编写的。让我们从这个高性能系统软件的出色示例开始进行讨论。</p><h3 id="C-开发操作系统内核"><a href="#C-开发操作系统内核" class="headerlink" title="C++ 开发操作系统内核"></a>C++ 开发操作系统内核</h3><p>FreeBSD <a href="https://forums.freebsd.org/threads/driver-building-in-c.35701/">已经支持 C++ 模块</a> 有一段时间了。虽然 Linux 内核从不支持 C++，但是有一个用 C++ 编写并用作 Linux 内核模块的 <a href="https://pdos.csail.mit.edu/papers/click:tocs00/paper.pdf">Click 模块化路由器</a>。如果您对操作系统内核开发的 C++ 适用性感兴趣，那么可以在 <a href="https://wiki.osdev.org/C++">C++</a> 和 <a href="https://wiki.osdev.org/C++_Bare_Bones">Bare bones</a> 文章中找到相当不错的讨论。但是，有一些本质的原因反对使用 C++ 进行操作系统内核开发：</p><ul><li>不需要 <code>libstdc++</code> 和 <a href="https://en.wikipedia.org/wiki/Run-time_type_information">RTTI</a> ，以及内核空间异常处理。事实上，<code>dynamic_cast</code> 并不经常使用，并且有很多 C++ 项目并没有 RTTI 编译。如果需要异常处理，则必须将它们一直到内核中。<code>libstdc++</code> 使用基本的 C 分配，因此必须对内核进行大量修改。</li><li>不能使用 STL 和 Boost 库。实际上，所有内核都已经拥有自己的库。C++ 引入了文件系统，线程和网络库，这在操作系统内核中是毫无意义的。另一方面，现代的操作系统提供了高级同步原语，而这些原语在标准 C++ 中仍然不可用（例如，在 C++ 中仍然没有读写自旋锁）。 </li><li>Linux 内核提供的内存分配的数量（SLAB，页面 <code>vmalloc()</code>, <code>kmalloc()</code> 等），因此你必须使用 <a href="https://en.cppreference.com/w/cpp/language/new"><code>placement new</code></a> 和&#x2F;或 只使用 C 函数的内存分配和释放。对齐内存对于提高性能至关重要，但是你需要编写特殊的包装程序才能对齐使用 <code>new</code>.</li><li>当原始内存指针经常被强制转换为某些数据结构时，强类型安全性对于系统编程而言并不那么舒适。尽管还是有争议的：虽然有些人不习惯用冗长的 <code>reinterpret_cast&lt;Foo *&gt;(ptr)</code> 替代不是简短的 <code>(Foo *)ptr</code>. 但其他人却拥有更多的类型和更多的类型安全性。</li><li>命名空间和函数重载，必须要 C++ 的<a href="https://en.wikipedia.org/wiki/Name_mangling">名称处理</a>。而这使函数很难从汇编调用，因此需要使用 <code>extern &quot;C&quot;</code>. </li><li>你必须为静态对象的构造函数和析构函数 <code>.ctor</code> 以及 <code>.dtor</code> 相应的对象创建特殊的代码段。</li><li>C++ 异常不能跨越<em>上下文</em>边界，即：你不能在一个线程中抛出异常而在另一个线程中捕获它。操作系统内核需要处理更复杂的上下文模型：内核线程，进入内核的用户空间线程，延迟和硬件中断。上下文可以以自愿或合作的方式相互抢占，因此当前上下文的异常处理可以被另一个上下文抢占。还有内存管理和上下文切换代码，它们可能与异常处理代码冲突。就像 RTTI 一样，可以在内核中实现该机制，但是不能使用当前的标准库。</li><li>虽然 Clang 和 G++ 支持 <code>__restrict__</code> 扩展，但是官方的 C++ 标准 <a href="https://www.quora.com/Why-doesnt-C++-have-an-equivalent-of-Cs-restrict-specifier">不支持</a>.</li><li><a href="https://lwn.net/Articles/749064/">不鼓励</a> 在 Linux 内核中使用可变长数组（VLA），在某些情况下它们仍然很方便，但是 <a href="https://groups.google.com/g/comp.std.c++/c/K_4lgA1JYeg?pli=1">在 C++ 中完全不可用</a>。</li></ul><p>因此，在内核空间中使用 C++，基本上只有模版，类继承和一些语法糖（如 lambda 函数）。由于系统代码很少需要复杂的抽象和继承，那么在内核空间中使用 C++ 仍然有意义吗？</p><h3 id="C-异常"><a href="#C-异常" class="headerlink" title="C++ 异常"></a>C++ 异常</h3><p>这是最<a href="https://herbsutter.com/2010/03/13/trip-report-march-2010-iso-c-standards-meeting/">值得争辩</a> 的 C++ 功能之一，值得写上一章。例如：MySQL 的项目，以下为 <a href="https://google.github.io/styleguide/cppguide.html#Exceptions">Google 编码风格</a>， <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_CODING_GUIDELINES.html">不使用异常</a>。Google 编码风格提供了优秀的使用异常的优缺点列表。在这里，我们仅关注性能方面。</p><p>当我们不得不在可能的地方处理错误代码时，异常可以提高性能，例如（让函数内联并且很小）</p><pre><code class="c">if (func_1())    return -EINVAL;if (func_2())    return -EINVAL;....if (func_100())    return -EINVAL;</code></pre><p>该代码的问题是存在额外的条件跳转。现代 CPU 可以很好地进行分支预测，但是仍然会影响性能。在 C++ 中，我们可以编写</p><pre><code class="cpp">try &#123;    func_1();    func_2();    ...    func_100();&#125; catch (...) &#123;    return -EINVAL;&#125;   </code></pre><p>，因此<em>热</em>路径中没有多余的条件。但是，这不是自由的：你的 C++ 代码中的大多数函数都必须带有额外的结尾，这些异常表带有这些函数可以捕获的异常表和适当的清除表。函数结尾没有在正常的工作流中执行，但是它们增加了代码的大小，从而导致 CPU 指令缓存中的额外污染。你可以在 <a href="https://monoinfinito.wordpress.com/series/exception-handling-in-c/">Nico Brailovsky</a> 的博客中找到有关 C++ 异常处理内部的详细信息。</p><h3 id="C-仍然不错？"><a href="#C-仍然不错？" class="headerlink" title="C++ 仍然不错？"></a>C++ 仍然不错？</h3><p>是的。首先，实际上并不是整个代码都必须尽可能快，并且在大多数情况下，我们不需要自定义内存分配，也不在乎异常开销。大多数项目（尤其是新项目）都是在用户空间中开发的，并且受益于相对丰富的 C++ 标准和 Boost 库（虽然不如 Java 丰富）。</p><p>其次，C++ 最大的特点就是：<strong>它是 C</strong>。如果你不想使用异常或 RTTI，则只需要关闭功能即可。大多数 C 程序都可以使用 C++ 编译器进行编译，只需进行很小的更改或完全不进行任何更改。举个例子，我们只需要这个微不足道的更改</p><pre><code class="bash">$ diff -up nbody.c nbody-new.cc    @@ -112,9 +112,9 @@ static void advance(body bodies[])&#123;         // ROUNDED_INTERACTIONS_COUNT elements to simplify one of the following         // loops and to also keep the second and third arrays in position_Deltas         // aligned properly.    -    static alignas(__m128d) double    -      position_Deltas[3][ROUNDED_INTERACTIONS_COUNT],    -      magnitudes[ROUNDED_INTERACTIONS_COUNT];    +    static double    +      position_Deltas[3][ROUNDED_INTERACTIONS_COUNT] __attribute__((aligned(16))),    +      magnitudes[ROUNDED_INTERACTIONS_COUNT] __attribute__((aligned(16)));         // Calculate the position_Deltas between the bodies for each interaction.         for(intnative_t i=0, k=0; i &lt; BODIES_COUNT-1; ++i)    </code></pre><p>用 G++ 编译器编译 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/nbody-clang-8.html">C 程序</a> 。现代的 C++ 编译器提供了 C 兼容性扩展，例如 <code>_restrict</code> 关键字。我们总是可以用 C 风格编写 C++ 程序中性能最关键的代码。如果你不喜欢 <a href="https://250bpm.com/blog:8/">带有额外开销的 STL 容器</a>，则可以使用 <a href="https://www.boost.org/doc/libs/1_74_0/doc/html/intrusive.html">Boost.intrusive</a> ，或者甚至从 Linux 内核或其他高速 C 项目移植类似的容器。在大多数情况下，这不会感到痛苦。例如，请参阅如何在 C++ <a href="https://github.com/tempesta-tech/blog/tree/master/htrie">benchmark</a> 中使用 PostgreSQL 的哈希表，<a href="https://github.com/tempesta-tech/tempesta/tree/master/tempesta_db">Tempesta DB</a> 的 HTrie 以及 Linux 内核读&#x2F;写自旋锁（全部都是用 C 编写的。）</p><p>关于使用 C++ 编写高性能程序的最后一件事必须提到的是<a href="https://en.wikipedia.org/wiki/Template_metaprogramming">模板元编程</a>。对于现代 C++ 标准而言，令人兴奋的是，使用模板可以编写非常复杂的逻辑，这些逻辑在编译时就可以完全计算出来，而在运行时则不增加任何负担。</p><h2 id="GOTO-C-的力量所在"><a href="#GOTO-C-的力量所在" class="headerlink" title="GOTO - C 的力量所在"></a>GOTO - C 的力量所在</h2><p><strong>专业的工具必须允许你以最有效的方式使用它。</strong> 高级和高性能的编程语言的目标是生成最高效的机器代码。每种硬件体系结构都支持 <em>jumps</em> 指令，这意味着你可以在任何条件下跳转到任何地址。C 和 C++ 编程语言中最接近跳转的抽象就是<code>goto</code> 操作符。它不像汇编那样灵活 <code>jmp</code> ，但是 C 编译器提供了扩展，使操作符几乎可以完全等同于汇编的 <code>jmp</code>. 不幸的是，Rust <a href="https://internals.rust-lang.org/t/gotos-in-restricted-functions/4393">并不支持 goto</a>，这使它在整个性能关键性任务中都显得笨拙。</p><p>我们谈论解析器。这里并不是说通过一堆 <code>switch</code> 和 <code>if</code> 语言完美完成的配置文件解析器，而是关于大型且非常快速的解析器（如 HTTP 解析器）。你可能会认为这是 “太狭窄” 或 “太具体” 的任务，但是回想一下解析器生成器，例如 <a href="http://www.colm.net/open-source/ragel/">Ragel</a> 或 <a href="https://www.gnu.org/software/bison/">GNU Bison</a>. 如果开发这样的解析器生成器，那么你将永远不知道将出现多大的解析器。（顺便说一下，Ragel 广泛使用 <code>goto</code> 生成非常快的解析器。）还要注意每个 RDMS 中的 SQL 解析器。实际上，我们可以将任务的类别概括为<em>大型和快速的有限状态机</em>，例如：正则表达式。</p><p><a href="https://github.com/tempesta-tech/tempesta/">Tempesta FW</a>  中的 <a href="https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http_parser.c">HTTP 解析器</a> 比其他 Web 服务器中的 HTTP 解析器要大得多，因为，除了基本的 HTTP 解析，也做了很多的安全检查，严格验证对 RFC 的输入。此外，我们的解析器还可以处理零拷贝数据，因此也非常关心数据块。在 <a href="https://www.socallinuxexpo.org/scale/17x/presentations/fast-http-string-processing-algorithms">SCALE 17x 会议</a>上的演讲中描述了解析器的技术细节，您可以观看<a href="https://youtu.be/LQc4er8ng64?t=25501">演讲视频</a>或者<a href="http://tempesta-tech.com/research/http_str.pdf">幻灯片</a>。</p><p>通常，HTTP 解析器被实现为输入字符和嵌套 <code>switch</code> 语句的循环，以获取允许的字符和可用状态。例如 <a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_http_parse.c#L104"><code>ngx_http_parse_request_line()</code></a> ，请参见 <a href="https://github.com/nginx/nginx/blob/master/src/http/ngx_http_parse.c">Nginx 解析器源代码</a>。为了简洁其间，让我们考虑一个简化的代码版本：</p><pre><code class="c">while (++str_ptr) &#123;    switch (current_state) &#123;    case 0:        ...    case 1:        ...    ...    case 100:        switch (*str_ptr) &#123;        case &#39;a&#39;:            ...            current_state = 200;            break;        case &#39;b&#39;:            ...            current_state = 101;            break;        &#125;        break;    case 101:        ...    ...    &#125;&#125;</code></pre><p>假设解析器已经完成了对处于状态 <code>100</code> 的先前数据块的解析，而当前数据库从字符 <code>b</code> 开始。不管 <a href="http://tempesta-tech.com/research/http_str.pdf">switch语句优化</a>（可以由编译器使用查找表或二进制搜索进行优化），代码都存在以下三个问题：</p><ol><li>查找状态 <code>100</code> 仍然比直接跳转更耗时。</li><li>当状态码放置在状态 <code>100</code> 后的状态 <code>101</code> 时，我们必须重新进入 <code>while</code> 和 <code>switch</code> 语句，即再次查找下一个状态，而不是仅一步移动一个字符并直接跳到下一个状态。</li><li>即使我们总是在状态 <code>100</code> 后的状态 <code>101</code>，编译器也可以通过以下方式重新组织代码：将状态 <code>101</code> 放在 <code>switch</code> 语句的开头，而将状态 <code>100</code> 放在语句的末尾。</li></ol><p>Tempesta FW 使用 <code>goto</code> 语句和标签的 GCC 编译器扩展（<a href="https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html">标签变量</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gcc/Label-Attributes.html">标签属性</a>）通过以下代码解决了所有问题：</p><pre><code class="c">// Use labels as values to remember the current state when we// exit the state machine at the end of current data chunk.parser-&gt;state = &amp;&amp;state_100;goto *parser-&gt;state;while (true) &#123;state_0:    ...state_1:    ...// The state is placed by a compiler closer to the beginning// of the code.state_100: __attribute__((hot))    // We still use small switches for small character sets.     switch (*str_ptr) &#123;    case &#39;a&#39;:        ...        ++str_ptr;        goto state_200;    case &#39;b&#39;:        ...        ++str_ptr;        // Just fall through to the state 101.    &#125;// This state is placed by the compiler after state_100.state_101: __attribute__((cold))    ...&#125;   </code></pre><p>由于 Rust 不支持 <code>goto</code> 语句，因此我们需要使用汇编语言通过直接跳转和最佳代码布局来实现状态机。</p><h2 id="当汇编比-C-容易时"><a href="#当汇编比-C-容易时" class="headerlink" title="当汇编比 C 容易时"></a>当汇编比 C 容易时</h2><p>现在我们先看一个示例，该示例中的汇编语言不仅可以生成更快的代码，还可以以更有效率的方式编写程序。此示例是关于多精度整数运算。</p><p>公钥密码学和椭圆曲线密码算法尤其依赖大整数运算。Tom St Denis所著的《<a href="https://www.amazon.com/BigNum-Math-Implementing-Cryptographic-Arithmetic/dp/1597491128">BigNum Math：实现加密多精度算术</a>》一书提供了有关该主题以及许多算法的 C 实现的详细细节，但现在让我们考虑一下 64 位上 128 位长的两个大整数的基本加法机。大整数包括<em>几个块</em>，两个64位 <code>long</code>。为了求和整数，我们必须关心块之间的进位，因此生成的C代码看起来像（参见书中的4.2.1）：</p><pre><code class="c">// a := a + b// x[0] is the less significant limb,// x[1] is the most significant limb.void s_mp_add(unsigned long *a, unsigned long *b)&#123;    unsigned long carry;    a[0] += b[0];    carry = (a[0] &lt; b[0]);    a[1] += b[1] + carry;&#125;    </code></pre><p>代码虽小又简单，但是你可能不得不考虑使用进行操作的正确性的 <code>carry</code>。幸运的事，x86-64 是 <a href="https://en.wikipedia.org/wiki/Complex_instruction_set_computer">CISC</a> 体系结构，它为我们提供了许多计算功能，其中就有带进位的计算，因此上面的代码只用两条指令就可以完成，而无需进行比较：</p><pre><code class="c">// Pointer to a is in %RDI, pointer to b is in %RSImovq    (%rdi), %r8movq    8(%rdi), %r9addq    (%rsi), %r8     // add with carryaddc    8(%rsi), %r9    // use the carry in the next additionmovq    (%r8), (%rdi)movq    (%r9), 8(%rdi)    </code></pre><p>如果您查看任何经过优化的加密库，例如 <a href="https://www.openssl.org/">OpenSSL</a> 或 <a href="https://github.com/tempesta-tech/tempesta/tree/master/tls">Tempesta TLS</a>，那么您会发现很多汇编代码（OpenSSL实际上使用Perl脚本生成了汇编源代码）。</p><h2 id="Rust-一览"><a href="#Rust-一览" class="headerlink" title="Rust 一览"></a>Rust 一览</h2><p>乍一看，Rust具备开发非常高效的代码的精良装备：<a href="https://doc.rust-lang.org/edition-guide/rust-2018/simd-for-faster-computing.html">SIMD内在函数</a>，<a href="https://doc.rust-lang.org/reference/type-layout.html">内存对齐</a>，<a href="https://doc.rust-lang.org/std/sync/atomic/fn.fence.html">内存屏障</a>，<a href="https://doc.rust-lang.org/1.8.0/book/inline-assembly.html">内联汇编</a>。Rust 与 C 或 C++ 有很多比较，例如 <a href="https://kornel.ski/rust-c-speed">Rust与C</a> 或 <a href="https://www.viva64.com/en/b/0733/">C++ 的速度比 Rust 更快，更安全：Yandex 基准测试</a>。但是，如果你考虑使用 Rust 开发基准测试领先产品，那么您可能会面临一些障碍以及缺少 <code>goto</code> 操作符的麻烦：</p><ul><li>从技术上讲，Rust支持自定义内存分配器，但是存在<a href="https://www.reddit.com/r/rust/comments/80jqvn/allocator_story_in_rust/">严重的局限性</a>。值得一提的是，任何<a href="https://natsys-lab.blogspot.com/2015/09/fast-memory-pool-allocators-boost-nginx.html">高性能软件都使用许多临时内存分配器</a>。</li><li>就像 C++ 一样，Rust 不提供 VLA 。但是，如果 C++ 仍然可以使用 <code>alloca(3)</code>，Rust 根本不会提供堆栈分配。太可惜了，因为栈分配是消耗最小的，而由于先前的考虑，自定义内存分配器不是一个选择。</li><li>这似乎<a href="https://doc.rust-lang.org/std/intrinsics/fn.unlikely.html">可能&#x2F;不可能</a>支持是比现代的C或C ++编译器强大得多。</li><li>在 Rust 中可以从原始内存读写数据结构，但是比 C 甚至 C++ 需要<a href="https://users.rust-lang.org/t/reading-structures-in-memory-via-pointers/33886">更多的代码</a>。不过没什么大不了的。</li><li>Rust的<a href="https://doc.rust-lang.org/book/ch10-01-syntax.html">泛型</a>和<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">宏</a>功能<a href="https://users.rust-lang.org/t/generic-functions-c-vs-rust/21965/">远不及</a> C++ 模板和 C 宏所提供的<a href="https://users.rust-lang.org/t/generic-functions-c-vs-rust/21965/">功能强大</a>。虽然，这也不是那么关键。</li></ul><p>关于Rust系统编程的最关键的失望是它处理原始内存的能力有限，这是内存安全的另一方面。</p><h2 id="C-和-Rust-中的可靠性和安全性"><a href="#C-和-Rust-中的可靠性和安全性" class="headerlink" title="C++ 和 Rust 中的可靠性和安全性"></a>C++ 和 Rust 中的可靠性和安全性</h2><p>如果不解决 Rust 和 C++ 编程语言提供的可靠性和安全性，本文将是不完整的。幸运的是，<a href="https://www.youtube.com/watch?v=_pQGRr4P16w">Microsoft 的 Sunny Chatterjee 最近在 CppCon 2020上发表了这个话题</a>。Rust的主要好处是内存和并发安全性，但是现代的C ++也解决了这些主题。在本演示中，Sunny 解决了 Rust 与 C++ 之间的以下6个差距：转换，switch 语句，更智能的循环，更智能的复制，生存期和可变性。让我们回顾一下差距。</p><ul><li>带有编译器选项的现代 C 和 C++ 编译器可以很好地处理类型<strong>转换</strong> <code>-Wall</code>。</li><li>**<code>switch</code>**语句也使用进行处理 <code>-Wall</code>。此外，GCC 还<a href="https://lwn.net/Articles/794944/">引入了</a> <code>-Wimplicit-fallthrough</code>编译器选项，该选项使“通过”明确。</li><li>自 C++ 11起，<strong>更聪明的循环</strong>由基于C ++<a href="https://en.cppreference.com/w/cpp/language/range-for">范围的for循环解决</a>。</li><li><code>const auto &amp;</code>参考和细粒度的复制和移动语义会注意<strong>智能复制</strong>。</li><li><a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>提供了强大的<strong>生命周期</strong>，但不幸的<em>是并非涵盖所有情况</em>。</li><li><code>const</code>带有或不带有<code>mutable</code>成员，<code>const</code>引用和变量的C ++类提供了细粒度的<strong>可变性</strong>，但是bust也<em>不能涵盖所有情况</em>。</li></ul><p>演示最后以“ <a href="https://github.com/isocpp/CppCoreGuidelines">C++ 核心准则</a>规定许多重大项目”进行了总结，且现代 C 和 C++ 编译器趋向于实现忽略检查。还值得一提的是，C &#x2F; C++世界有效地使用了地址清理器（例如，<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">ASAN</a>内置于LLVM和GCC编译器的现代版本中）来捕获<a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">越界</a>内存访问。毕竟，<code>unsafe</code>就像在C ++中使用原始指针一样，您仍然可以使用Rust中的代码来产生错误。</p><h2 id="计算机语言的基准测试"><a href="#计算机语言的基准测试" class="headerlink" title="计算机语言的基准测试"></a>计算机语言的基准测试</h2><p>由于我们在谈论性能，因此我们必须看一下“<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">计算机语言基准测试”</a>。要比较不同语言的性能，您需要以相同的方式在所有语言中实现相同的任务。这不是人们通常要做的事情，因此很难找到不同语言的真实代码示例，这些示例使您可以将桔子与桔子进行比较，而不是将桔子与苹果进行比较。虽然Benchmarks游戏是一款游戏，它会比较一些小的特定任务的实现，但这是我们拥有的最好的游戏之一。所述<a href="https://github.com/dmitryikh/rust-vs-cpp-bench">VS锈比较C ++ 11</a>是C ++和Rust中相等实现的又一比较。Benchmarks游戏中没有汇编语言，但是相应地有Rust（用于G ++编译器的C ++）和两个用于Clang和GCC编译器的C。在撰写本文时，实现的性能为（以秒为单位，越少越好）：</p><table><thead><tr><th align="left">Problem</th><th align="left">G++</th><th align="left">GCC</th><th align="left">Clang</th><th align="left">Rust</th></tr></thead><tbody><tr><td align="left">fannkuch-redux</td><td align="left">8.07</td><td align="left">7.53</td><td align="left">9.45</td><td align="left"><strong>6.88</strong></td></tr><tr><td align="left">spectral-norm</td><td align="left">0.72</td><td align="left">0.72</td><td align="left">0.72</td><td align="left"><strong>0.71</strong></td></tr><tr><td align="left">n-body</td><td align="left">4.09</td><td align="left">4.30</td><td align="left"><strong>3.31</strong></td><td align="left"><strong>3.31</strong></td></tr><tr><td align="left">binary-trees</td><td align="left"><strong>1.12</strong></td><td align="left">1.78</td><td align="left">1.88</td><td align="left">1.20</td></tr><tr><td align="left">fasta</td><td align="left">1.04</td><td align="left"><strong>0.82</strong></td><td align="left">0.88</td><td align="left">0.91</td></tr><tr><td align="left">pidigits</td><td align="left"><strong>0.71</strong></td><td align="left">0.73</td><td align="left">0.81</td><td align="left">0.74</td></tr><tr><td align="left">mandelbrot</td><td align="left"><strong>0.84</strong></td><td align="left">1.27</td><td align="left">2.09</td><td align="left">0.92</td></tr><tr><td align="left">regex-redux</td><td align="left">1.08</td><td align="left"><strong>0.80</strong></td><td align="left">0.81</td><td align="left">1.28</td></tr><tr><td align="left">reverse-complement</td><td align="left"><strong>0.63</strong></td><td align="left">0.87</td><td align="left">0.98</td><td align="left">0.75</td></tr><tr><td align="left">k-nucleotide</td><td align="left"><strong>1.93</strong></td><td align="left">3.71</td><td align="left">6.19</td><td align="left">3.29</td></tr></tbody></table><p>只有一个测试，第一个测试，其中 Rust 或多或少明显优于 C 和 C++ 实现。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>您可能很好奇，为什么 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-rust-5.html">Rust中</a> 的 <em>fannkuch-redux</em> <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-rust-5.html">实现</a>比 <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/fannkuchredux-gcc-5.html">C 实现</a>更快？我们也是。这两个程序的副本已附在下文：</p><p>C 程序</p><pre><code class="c">// The Computer Language Benchmarks Game// https://salsa.debian.org/benchmarksgame-team/benchmarksgame///// Contributed by Jeremy Zerfas// Based on the Ada program by Jonathan Parker and Georg Bauhaus which in turn// was based on code by Dave Fladebo, Eckehard Berns, Heiner Marxen, Hongwei Xi,// and The Anh Tran and also the Java program by Oleg Mazurov.// This value controls how many blocks the workload is broken up into (as long// as the value is less than or equal to the factorial of the argument to this// program) in order to allow the blocks to be processed in parallel if// possible. PREFERRED_NUMBER_OF_BLOCKS_TO_USE should be some number which// divides evenly into all factorials larger than it. It should also be around// 2-8 times the amount of threads you want to use in order to create enough// blocks to more evenly distribute the workload amongst the threads.#define PREFERRED_NUMBER_OF_BLOCKS_TO_USE 12#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;// intptr_t should be the native integer type on most sane systems.typedef intptr_t intnative_t;int main(int argc, char ** argv)&#123;   const intnative_t n=atoi(argv[1]);   // Create and initialize factorial_Lookup_Table.   intnative_t factorial_Lookup_Table[n+1];   factorial_Lookup_Table[0]=1;   for(intnative_t i=0; ++i&lt;=n;)      factorial_Lookup_Table[i]=i*factorial_Lookup_Table[i-1];   // Determine the block_Size to use. If n! is less than   // PREFERRED_NUMBER_OF_BLOCKS_TO_USE then just use a single block to prevent   // block_Size from being set to 0. This also causes smaller values of n to   // be computed serially which is faster and uses less resources for small   // values of n.   const intnative_t block_Size=factorial_Lookup_Table[n]/     (factorial_Lookup_Table[n]&lt;PREFERRED_NUMBER_OF_BLOCKS_TO_USE ?     1 : PREFERRED_NUMBER_OF_BLOCKS_TO_USE);   intnative_t maximum_Flip_Count=0, checksum=0;   // Iterate over each block.   #pragma omp parallel for \     reduction(max:maximum_Flip_Count) reduction(+:checksum)   for(intnative_t initial_Permutation_Index_For_Block=0;     initial_Permutation_Index_For_Block&lt;factorial_Lookup_Table[n];     initial_Permutation_Index_For_Block+=block_Size)&#123;      intnative_t count[n];      int8_t temp_Permutation[n], current_Permutation[n];      // Initialize count and current_Permutation.      count[0]=0;      for(intnative_t i=0; i&lt;n; ++i)         current_Permutation[i]=i;      for(intnative_t i=n-1,        permutation_Index=initial_Permutation_Index_For_Block; i&gt;0; --i)&#123;         const intnative_t d=permutation_Index/factorial_Lookup_Table[i];         permutation_Index=permutation_Index%factorial_Lookup_Table[i];         count[i]=d;         for(intnative_t j=0; j&lt;n; ++j)            temp_Permutation[j]=current_Permutation[j];         for(intnative_t j=0; j&lt;=i; ++j)            current_Permutation[j]= j+d&lt;=i ?              temp_Permutation[j+d] : temp_Permutation[j+d-i-1];      &#125;      // Iterate over each permutation in the block.      const intnative_t last_Permutation_Index_In_Block=        initial_Permutation_Index_For_Block+block_Size-1;      for(intnative_t permutation_Index=initial_Permutation_Index_For_Block; ;        ++permutation_Index)&#123;         // If the first value in the current_Permutation is not 1 (0) then         // we will need to do at least one flip for the current_Permutation.         if(current_Permutation[0]&gt;0)&#123;            // Make a copy of current_Permutation[] to work on. Note that we            // don&#39;t need to copy the first value since that will be stored            // in a separate variable since it gets used a lot.            for(intnative_t i=0; ++i&lt;n;)               temp_Permutation[i]=current_Permutation[i];            intnative_t flip_Count=1;            // Flip temp_Permutation until the element at the first_Value            // index is 1 (0).            for(intnative_t first_Value=current_Permutation[0];              temp_Permutation[first_Value]&gt;0; ++flip_Count)&#123;               // Record the new_First_Value and restore the old               // first_Value at its new flipped position.               const int8_t new_First_Value=temp_Permutation[first_Value];               temp_Permutation[first_Value]=first_Value;               // If first_Value is greater than 3 (2) then we are flipping               // a series of four or more values so we will also need to               // flip additional elements in the middle of the               // temp_Permutation.               if(first_Value&gt;2)&#123;                  intnative_t low_Index=1, high_Index=first_Value-1;                  // Note that this loop is written so that it will run at                  // most 16 times so that compilers will be more willing                  // to unroll it. Consequently this won&#39;t work right when                  // n is greater than 35. This would probably be the                  // least of your concerns since 21! won&#39;t fit into 64                  // bit integers and even if it did you probably wouldn&#39;t                  // want to run this program with a value that large                  // since it would take thousands of years to do on a                  // modern desktop computer. ;-)                  do&#123;                     const int8_t temp=temp_Permutation[high_Index];                     temp_Permutation[high_Index]=                       temp_Permutation[low_Index];                     temp_Permutation[low_Index]=temp;                  &#125;while(low_Index+++3&lt;=high_Index-- &amp;&amp; low_Index&lt;16);               &#125;               // Update first_Value to new_First_Value that we recorded               // earlier.               first_Value=new_First_Value;            &#125;            // Update the checksum.            if(permutation_Index%2==0)               checksum+=flip_Count;            else               checksum-=flip_Count;            // Update maximum_Flip_Count if necessary.            if(flip_Count&gt;maximum_Flip_Count)               maximum_Flip_Count=flip_Count;         &#125;         // Break out of the loop when we get to the         // last_Permutation_Index_In_Block.         if(permutation_Index&gt;=last_Permutation_Index_In_Block)            break;         // Generate the next permutation.         int8_t first_Value=current_Permutation[1];         current_Permutation[1]=current_Permutation[0];         current_Permutation[0]=first_Value;         for(intnative_t i=1; ++count[i]&gt;i;)&#123;            count[i++]=0;            const int8_t new_First_Value=current_Permutation[0]=              current_Permutation[1];            for(intnative_t j=0; ++j&lt;i;)               current_Permutation[j]=current_Permutation[j+1];            current_Permutation[i]=first_Value;            first_Value=new_First_Value;         &#125;      &#125;   &#125;   // Output the results to stdout.   printf(&quot;%jd\nPfannkuchen(%jd) = %jd\n&quot;, (intmax_t)checksum, (intmax_t)n,     (intmax_t)maximum_Flip_Count);   return 0;&#125;</code></pre><p>Rust 程序</p><pre><code class="rust">// The Computer Language Benchmarks Game// https://salsa.debian.org/benchmarksgame-team/benchmarksgame///// Contributed by Cliff L. Biffle, translated from Jeremy Zerfas&#39;s C program.//// The C program was based on the Ada program by Jonathan Parker and Georg// Bauhaus which in turn was based on code by Dave Fladebo, Eckehard Berns,// Heiner Marxen, Hongwei Xi, and The Anh Tran and also the Java program by Oleg// Mazurov.extern crate rayon;use rayon::prelude::*;use std::mem::replace;// This value controls how many blocks the workload is broken up into (as long// as the value is less than or equal to the factorial of the argument to this// program) in order to allow the blocks to be processed in parallel if// possible. PREFERRED_NUMBER_OF_BLOCKS_TO_USE should be some number which// divides evenly into all factorials larger than it. It should also be around// 2-8 times the amount of threads you want to use in order to create enough// blocks to more evenly distribute the workload amongst the threads.const PREFERRED_NUMBER_OF_BLOCKS_TO_USE: usize = 12;// One greater than the maximum `n` value. Used to size stack arrays.const MAX_N: usize = 16;fn main() &#123;    let n = std::env::args().nth(1).unwrap().parse().unwrap();    // This assert eliminates several bounds checks.    assert!(n &lt; MAX_N);    // Create and initialize factorial_lookup_table.    let factorial_lookup_table = &#123;        let mut table: [usize; MAX_N] = [0; MAX_N];        table[0] = 1;        for i in 1..MAX_N &#123;            table[i] = i * table[i - 1];        &#125;        table    &#125;;    // Determine the block_size to use. If n! is less than    // PREFERRED_NUMBER_OF_BLOCKS_TO_USE then just use a single block to prevent    // block_size from being set to 0. This also causes smaller values of n to    // be computed serially which is faster and uses less resources for small    // values of n.    let block_size =        1.max(factorial_lookup_table[n] / PREFERRED_NUMBER_OF_BLOCKS_TO_USE);    let block_count = factorial_lookup_table[n] / block_size;    // Iterate over each block.    let (checksum, max_flip_count) = (0..block_count)        .into_par_iter()        .map(|bn| &#123;            let initial_permutation_index = bn * block_size;            let mut count: [usize; MAX_N] = [0; MAX_N];            let mut current_permutation: [u8; MAX_N] =                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];            // Initialize count and current_permutation.            &#123;                let mut temp_permutation: [u8; MAX_N] = [0; MAX_N];                let mut permutation_index = initial_permutation_index;                for i in (1..n).rev() &#123;                    let f = factorial_lookup_table[i];                    let d = permutation_index / f;                    count[i] = d;                    // Rotate the permutation left by d places. This is faster                    // than using slice::rotate_left.                    temp_permutation[0..=i - d]                        .copy_from_slice(&amp;current_permutation[d..=i]);                    temp_permutation[i - d + 1..=i]                        .copy_from_slice(&amp;current_permutation[..d]);                    current_permutation = temp_permutation;                    permutation_index = permutation_index % f;                &#125;            &#125;            let mut max_flip_count = 0;            let mut checksum = 0;            // Iterate over each permutation in the block.            let last_permutation_index = initial_permutation_index + block_size;            for permutation_index in                initial_permutation_index..last_permutation_index            &#123;                // If the first value in the current_permutation is not 1 (0)                // then we will need to do at least one flip for the                // current_permutation.                if current_permutation[0] &gt; 0 &#123;                    // Make a copy of current_permutation[] to work on.                    let mut temp_permutation = current_permutation;                    let mut flip_count: usize = 1;                    // Flip temp_permutation until the element at the                    // first_value index is 1 (0).                    let mut first_value = current_permutation[0] as usize &amp; 0xF;                    while temp_permutation[first_value] &gt; 0 &#123;                        // Record the new_first_value and restore the old                        // first_value at its new flipped position.                        let new_first_value = replace(                            &amp;mut temp_permutation[first_value],                            first_value as u8,                        );                        // If first_value is greater than 3 (2) then we are                        // flipping a series of four or more values so we will                        // also need to flip additional elements in the middle                        // of the temp_permutation.                        if first_value &gt; 2 &#123;                            for (low_index, high_index) in                                (1..first_value).zip((1..first_value).rev())                            &#123;                                temp_permutation.swap(high_index, low_index);                                if low_index + 3 &gt; high_index &#123;                                    break;                                &#125;                            &#125;                        &#125;                        // Update first_value to new_first_value that we                        // recorded earlier.                        first_value = new_first_value as usize &amp; 0xF;                        flip_count += 1;                    &#125;                    // Update the checksum.                    if permutation_index % 2 == 0 &#123;                        checksum += flip_count;                    &#125; else &#123;                        checksum -= flip_count;                    &#125;                    // Update max_flip_count if necessary.                    max_flip_count = max_flip_count.max(flip_count);                &#125;                // Generate the next permutation.                current_permutation.swap(0, 1);                let mut first_value = current_permutation[0];                for i in 1..MAX_N - 2 &#123;                    count[i] += 1;                    if count[i] &lt;= i &#123;                        break;                    &#125;                    count[i] = 0;                    let new_first_value = current_permutation[1];                    for j in 0..i + 1 &#123;                        current_permutation[j] = current_permutation[j + 1];                    &#125;                    current_permutation[i + 1] = first_value;                    first_value = new_first_value;                &#125;            &#125;            (checksum, max_flip_count)        &#125;)        .reduce(            || (0, 0),            |(cs1, mf1), (cs2, mf2)| (cs1 + cs2, mf1.max(mf2)),        );    // Output the results to stdout.    println!(&quot;&#123;&#125;&quot;, checksum);    println!(&quot;Pfannkuchen(&#123;&#125;) = &#123;&#125;&quot;, n, max_flip_count);&#125;</code></pre><p>让我们启动C程序，并使用<a href="https://perf.wiki.kernel.org/index.php/Main_Page">Linux perf工具</a>收集该程序的性能概况。我们可以通过程序中最热门的代码<code>perf report</code>或看到<code>perf annotate</code>什么：</p><pre><code class="c">    0.46 |       movzbl    -0x9(%r15,%rax,1),%ecx    0.96 |       movzbl    0x9(%r15),%r8d         |       mov       %r8b,-0x9(%r15,%rax,1)    2.31 |       mov       %cl,0x9(%r15)         |       lea       -0xa(%rax),%rcx   12.76 |       cmp       $0xb,%rdi    </code></pre><p>性能杀手获得了12.76％的时间是展开循环的一部分</p><pre><code class="c">do&#123;   const int8_t temp=temp_Permutation[high_Index];   temp_Permutation[high_Index]=     temp_Permutation[low_Index];   temp_Permutation[low_Index]=temp;&#125;while(low_Index+++3&lt;=high_Index-- &amp;&amp; low_Index&lt;16);</code></pre><p>和<code>cmp</code>指令的部分<code>while</code>循环条件。实际上，他的循环只是反转数组中的字节。尽管C实现使用带有数组索引的朴素操作和繁重操作，而Rust实现使用<a href="https://users.rust-lang.org/t/how-to-zip-two-slices-efficiently/2048/2">高效的double迭代器</a>：</p><pre><code class="c">if first_value &gt; 2 &#123;    for (low_index, high_index) in        (1..first_value).zip((1..first_value).rev())    &#123;        temp_permutation.swap(high_index, low_index);        if low_index + 3 &gt; high_index &#123;            break;        &#125;    &#125;&#125;</code></pre><p><a href="https://dev.to/wunk/fast-array-reversal-with-simd-j3p">使用SIMD进行快速阵列反转！</a>介绍了几种提高C程序性能的方法（本文使用C ++）。第一种是只使用一个索引<code>i</code>和迭代仅直到与所述阵列的经置换的部分的中间<code>temp_Permutation[i]</code>和<code>temp_Permutation[high_Index - i]</code>。那将与Rust双迭代器非常接近。顺便说一下，提高两个程序性能的更高级的方法是使用<code>PSHUFB</code>SSSE3指令或<code>_mm_shuffle_epi8()</code>内部指令，而不是整个循环。由于混洗掩码的数量很少，因此可以在编译时定义所有混洗掩码，然后将它们立即加载到指令的控制掩码寄存器中。</p><p>但是，这不是实现之间的唯一区别。Rust程序利用最大输入数<code>const MAX_N: usize = 16</code>。由于编译器现在可以对循环和静态数组进行更好的优化，因此这种小的改进可能对性能的影响最大。该程序显式使用静态数组初始化 </p><pre><code class="c">let mut current_permutation: [u8; MAX_N] =    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];</code></pre><p>, 而 C 实现在运行时无需输入数据即可进行此操作</p><pre><code class="c">for(intnative_t i=0; i&lt;n; ++i)   current_Permutation[i]=i;</code></pre><p>Rust 程序使用内置内存复制功能复制阵列</p><pre><code class="c">let mut temp_permutation = current_permutation;</code></pre><p>，而 C 程序再次循环执行此操作</p><pre><code class="c">for(intnative_t i=0; ++i&lt;n;)   temp_Permutation[i]=current_Permutation[i];</code></pre><p>这些并不是C程序中的所有低效率，在Rust实施中已将其消除（这两个程序都基于相同的初始Ada程序）。在大多数地方，该程序的优化版本不仅会更快，而且会更短。</p><p>因此，在这种情况下，当Rust实现的速度快于C时，性能的差异不是关于更好的编译器，而是关于程序的更有效的结构，这使编译器可以更好地优化代码。</p><h2 id="Rust-作为系统编程语言？"><a href="#Rust-作为系统编程语言？" class="headerlink" title="Rust 作为系统编程语言？"></a>Rust 作为系统编程语言？</h2><p><strong>真正的高级系统编程语言必须与C兼容。</strong>仅考虑我们现实生活项目中的2个示例。</p><p>第一个是Web应用程序防火墙（WAF）。这种软件<a href="http://tempesta-tech.com/blog/waf-acceleration">通常基于Nginx或HAproxy</a> HTTPS服务器（它们是用C编写）<a href="http://tempesta-tech.com/blog/waf-acceleration">构建的。为Nginx</a>编写 C++ 模块很容易，但是我们需要额外的粘合代码才能在Rust中开发该模块并维护所有补丁。 Nginx的C代码。相同的开发人员可以轻松地在代码的C和C ++部分之间切换。</p><p>在第二种情况下，我们的客户希望使用<a href="https://github.com/mysqludf/lib_mysqludf_sys">MySQL用户定义函数（UDF）</a>与操作系统进行交互来执行一些外部逻辑。我们可以用任何编程语言开发逻辑，但是有一个限制：我们必须在每个CPU内核上每秒执行5000个程序！即使使用<code>posix_spawnp()</code>Linux中执行程序的最快方法，也无法实现这一点。我们最终为MySQL开发了一个自定义UDF，这是一个加载到MySQL服务器进程中的共享对象。使用C ++非常简单。</p><p>将Rust用作Nginx模块的一个相反的示例是CloudFlare的<a href="https://github.com/cloudflare/quiche">Quiche</a>，这是一种Nginx扩展，支持QUIC和HTTP &#x2F; 3协议。尽管绝对可以将Rust用于此类任务，但是除了用于<a href="https://github.com/cloudflare/quiche/issues/6">C &#x2F; C ++绑定</a>的<a href="https://github.com/cloudflare/quiche/blob/master/src/ffi.rs">FFI代码</a>之外，这些家伙仍然必须编写一些C代码来<a href="https://github.com/cloudflare/quiche/blob/master/extras/nginx/nginx-1.16.patch">修补Nginx</a>。这意味着：</p><ul><li>您必须为 C &#x2F; C++ 绑定编写一些额外的样板代码</li><li>而且您仍然必须处理 C &#x2F; C++ <strong>和</strong> 第二种语言，这使项目更加复杂。</li></ul><p>（顺便说一下，同样适用于<a href="https://dlang.org/">D编程语言</a>，它也不能直接包含C标头。）Quiche项目中的FFI和Nginx补丁程序仅约5,000行代码，即整个代码的10％项目，这是40,000行Rust代码。如果该项目是用C或C ++开发的，那么他们也将需要Nginx补丁，但是不需要第二语言。但是在Nginx主代码库中采用代码的机会为零。这就是实际发生的情况：Nginx团队<a href="https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/">拥有</a>大供应商的生产就绪QUIC实现，因此开发<a href="https://www.nginx.com/blog/introducing-technology-preview-nginx-support-for-quic-http-3/">了自己的C实现</a>。很难说“绑定”代码是可以忽略的还是开发人员在样板代码上花费了多少时间。问题是，Rust内存安全性（现代核心C ++，静态分析和地址清理器也可以实现）是否使开发如此高效，以至于额外的代码和以两种不同语言维护的代码库变得可以忽略不计？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们意识到，在为Tempesta FW开发<a href="https://github.com/tempesta-tech/tempesta/blob/master/tempesta_fw/http_parser.c">HTTP解析器</a>时，我们达到了C语言的极限：如果没有在<code>switch</code>语句中进行查找，就无法直接跳到解析器的所需状态，也无法获得令人满意的代码布局。那时我们考虑将内联汇编引入解析器的代码中。零拷贝状态机已经非常复杂，我们对此想法不满意。在编译器扩展中找到计算的标签和热&#x2F;冷属性真是太令人惊讶了！由于这些功能，编译器为解析器生成了最佳代码。</p><p><a href="https://en.wikipedia.org/wiki/There's_more_than_one_way_to_do_it">TIMTOWTDI</a>表示C ++的强大功能是“有多种方法可以做到” 。是的，这是Perl的想法，但是在很多情况下，C ++允许您使用高级STL或经过优化的自定义算法和数据结构，以纯C语言，在模板元编程中编写程序。现代C ++非常复杂，需要多年的经验才能熟练使用该语言，但是它是一种专业工具，可以使专业开发人员创建最快，最可靠的软件。</p><p>不仅Rust不成熟，而且语言设计者似乎故意限制了语言。有许多不良的程序在滥用<code>goto</code>，因此它们只是删除了运算符：对初级用户有利，但对专业人员而言太有限了。当您在复杂的技术任务中苦苦挣扎时，语言和编译器不可能给您带来惊喜。取而代之的是，当您需要做一些简单的事情时，很可能是您在C或C ++时代所做的事情，您会感到失望，并开始与编译器抗争。作为一个例子，<code>likely</code>和<code>unlikely</code>编译器提示在Linux内核的年龄和使用它们在用户空间C &#x2F; C ++编程如此流行，它们被<a href="https://en.cppreference.com/w/cpp/language/attributes/likely">包含在C ++ 20</a>标准（在程序员不得不使用编译器内部函数之前）。但是使用Rust，您会发现<a href="https://doc.rust-lang.org/std/intrinsics/fn.unlikely.html">该API是试验性的，<code>if</code>仅适用于语句</a>。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://tempesta-tech.com/blog/waf-acceleration">Web应用程序防火墙加速</a><br>从我们在开发Web应用程序防火墙（WAF）的自定义核心逻辑方面的经验，我们了解到大多数或什至所有现代WAF典型的一些性能问题，这些问题可能导致高昂的拥有成本和&#x2F;或拒绝服务。在本文中，我们介绍了WAF加速器，它与Web加速器一样，可以提高WAF的性能并保护其免受DDoS攻击。</p><p><a href="http://tempesta-tech.com/blog/natsys-lab-blog">回顾 NatSys Lab. 博客</a><br>我们回顾了自2011年以来最古老的 NatSys Laboratory 博客中最有趣的帖子：最近的 CPU 漏洞对 Linux 系统调用性能的影响，深入研究HTTP代理功能以及使用 Nginx 和 HAProxy 的 Tempesta FW 的性能比较，快速字符串处理算法，无锁数据结构和内存分配器。很多技术细节！</p><p>转载自：<a href="http://tempesta-tech.com/blog/fast-programming-languages-c-c++-rust-assembly">http://tempesta-tech.com/blog/fast-programming-languages-c-c++-rust-assembly</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> C </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间管理的8个高效经验</title>
      <link href="/posts/2020-10-29-8-experiences-for-efficient-time-management.html"/>
      <url>/posts/2020-10-29-8-experiences-for-efficient-time-management.html</url>
      
        <content type="html"><![CDATA[<p>同样是拥有一天24小时，我们中的一些人似乎比其他人更能充分地利用这些时间。时间管理是做计划、有意识地控制时间的能力。它需要“有意识”地控制，因为我们的注意力一旦转移，时间就会花在别的东西上面（比如你的手机）。</p><h2 id="复盘的力量"><a href="#复盘的力量" class="headerlink" title="复盘的力量"></a>复盘的力量</h2><ul><li>高效利用现有资源</li><li>更加明确环境和目标</li></ul><p>我个人认为，回顾和复盘是你做任何一个项目最有价值的一部分之一。通过分析与复盘能够让你更加清晰的知道这次实践中超出预期以及需要改进和提升的地方。当然最有价值的就是，通过分析不太满意的地方得到的有建设性的 Action。这些 Action 可以帮助你在下一次实践中，做出更好的改变。</p><h2 id="单线程执行"><a href="#单线程执行" class="headerlink" title="单线程执行"></a>单线程执行</h2><ul><li>合理分配时间，一次只做好一件事。</li></ul><p>尽可能保证一段时间内，只做一件事情。当我们进入到做一件事情的 Flow 当中，这时候突然出现一件事情打断，我们回来再继续做这件事情的时候，同样需要一个恢复到 Flow 状态的时间，这样会一定程度上降低我们的效率。</p><h2 id="限定时间"><a href="#限定时间" class="headerlink" title="限定时间"></a>限定时间</h2><ul><li>有 DDL，才有动力</li></ul><p>首先对于自己，我们会更加清晰的知道完成这个任务所要花费的时间。在整个任务时间轴上，估算出完成的时间点之后，可以更加合理的安排剩下的任务。</p><p>对于合作的同事，也可以准确的知道你完成的时间以及和你对接的时间点。在大家约定好的前提下，可以更加高效的促进整个任务的完成。</p><h2 id="拆分任务"><a href="#拆分任务" class="headerlink" title="拆分任务"></a>拆分任务</h2><ul><li>按优先级有序化分，缓解压力与焦虑</li></ul><p>当我们拿到一个非常大的任务，且知道里面有比较有挑战的事情的时候，第一时间的反应是有些焦虑和压力的，因为这个时候只知道我们最终要达到的目标和有挑战的事情，对整个任务的规划和时间预估都是不清晰的。</p><p>这个时候我们需要做的，就是拆分任务。将一个比较大的任务拆分成可预估的小任务，并且按照优先级排序。而且在我们完成每一个小任务的过程中，给到自己很多正向的反馈，帮助我们建立信心，而且对还没有完成的部分也有很清晰的认知，有助于我们更高效的完成这个任务。</p><h2 id="ToDoList"><a href="#ToDoList" class="headerlink" title="ToDoList"></a>ToDoList</h2><ul><li>每时每刻清晰的知道我们的当下任务和进度</li><li>进入到工作和学习状态的一种仪式感</li></ul><p>每天早上，进入工作状态之前，我会写下今日份的 ToDoList ，一般会用两种方式。小本子，写好就打开放在桌面上。或者是用便签纸，写好我会贴到显示器上。这样我就可以随时随地的知道我今天要做哪些任务、现在的进度是怎样的以及还有哪些事情没有开始进行。</p><p>这样对于我来说，每次看到这个 ToDoList 我都对今天要完成的事情很清晰，而且一般 List 的顺序也都是按照优先级有序排列的，如果有事情想要插入进来我也可以很清晰的知道，这一天的时间是否足够，如果插入新任务，放在哪个位置比较合理。</p><h2 id="大局观意识"><a href="#大局观意识" class="headerlink" title="大局观意识"></a>大局观意识</h2><ul><li>结果导向</li><li>跳出细节看整体</li></ul><p>无论是工作还是学习当中，我们很容易由于过于专注陷入到一个 Flow 中无法自拔，当然这是一件很好的事情，说明我们注意力集中，在完成这件事情上完全投入。但也别忘记，在忙碌中需要找到合适的时间，跳出现有的细节来看整体。</p><p>比如现在花费的时间是不是和预期相符，是不是在按照优先级有序的进行，整体的规划是否需要调整等等。</p><h2 id="懂得拒绝，学会说不"><a href="#懂得拒绝，学会说不" class="headerlink" title="懂得拒绝，学会说不"></a>懂得拒绝，学会说不</h2><ul><li>懂得拒绝，将主动权掌握在自己手上</li></ul><p>学会说不，在适当的时候懂得拒绝。尤其是在自己比较紧急的事情没有做完的前提下，一定要分清事情的主次。而且需要确定职责范围，是否是自己可以触及到的领域和范围。</p><p>这一点在初入职场的朋友身上尤为常见，因为刚入公司，在其他同事寻求自己帮助的时候，不太好意思拒绝。我见过很多实习生和刚入职的朋友，因为不懂得拒绝，压缩自己的时间默默加班完成。还有一些职场新人，因为帮助同事，触及到了自己不应该触及的领域，不是说职责范围外的事情就不能帮忙，而是我们需要非常清楚的上下游关系，可能有更合适处理这个问题的同时，所以当别人寻求我们帮助的时候我们也需要理性的进行分析。</p><h2 id="拒绝低质量的勤奋"><a href="#拒绝低质量的勤奋" class="headerlink" title="拒绝低质量的勤奋"></a>拒绝低质量的勤奋</h2><ul><li>要么提高效率，要么暂时放弃</li></ul><p>当你被一个问题困扰了很长时间（且这个时间远远超过了预期），这个时候很有可能你已经进入了一个状态不好的循环当中而不自知。</p><p>比如预期一个小时想要解决的问题三个小时都没有解决，或者想要下班之前解决的问题，到了下班这个时间点还没有解决，不免会陷入到纠结又很焦虑的状态里面，有可能会导致事情越做效率越低。</p><p>这个时候我们最应该做的是要么提高效率要么暂时放弃，我们需要勇敢的放下手头的事情，及时作出一些调整和改变，从而可以让每一份花费的时间都可以凸显出它的价值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中 screen 常用命令</title>
      <link href="/posts/2020-10-29-intro-to-linux-screen-command.html"/>
      <url>/posts/2020-10-29-intro-to-linux-screen-command.html</url>
      
        <content type="html"><![CDATA[<p>本文要介绍如何使用 Screen 命令来操作 Linux 命令行，让工作更有效率。</p><p>我想，很多同学在使用 Linux 命令行都会有以下这些的需求或者是困惑：</p><ul><li>如何让一个程序后台运行？</li><li>程序后台运行，但是我还想偶尔来看一下程序运行的进度，该怎么弄呢？</li><li>这个要运行的程序并不是我自己写的，我无法通过修改代码来实现后台运行，并把进度输出到日志文件，该怎么办呢？</li><li>要是有一款能够像图形化可以让程序运行在 Terminal 终端中，我想看的时候解锁一下屏幕就好了。</li></ul><p>以上这些困惑也是笔者经常遇到的一个问题，今天就来跟大家介绍一下一个 Linux 命令行下非常好用的一个工具 —— screen.</p><h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>Screen 是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen 可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</p><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p><h2 id="0x01-常见用法"><a href="#0x01-常见用法" class="headerlink" title="0x01 常见用法"></a>0x01 常见用法</h2><p>笔者最常用的用法就是：创建一个screen会话，并在会话中执行程序，通过Ctrl+A D将会话挂在后台运行，需要查看程序运行进度时候通过 <code>screen -r &#123;session_name&#125;</code> 命令恢复会话进行查看即可。</p><p>下面我们就来讲讲这个过程中我们所用到的命令：</p><ul><li><code>screen -S &#123;session_name&#125;</code> 创建一个 screen 会话，需要指定会话名称。比如：<code>screen -S c9</code></li><li><code>screen -r &#123;session_name&#125;</code> 恢复后台运行的 screen 会话。</li><li><code>screen -list</code> 或者 <code>screen -ls</code> 列出当前所有的会话列表。</li></ul><p><strong>注：</strong>在 screen 会话中，通过 Ctrl+A D 快捷键可以将会话分离至后台运行。</p><p>以上者三个命令我相信已经够大部分同学使用了。</p><h2 id="0x02-更多用法"><a href="#0x02-更多用法" class="headerlink" title="0x02 更多用法"></a>0x02 更多用法</h2><p>完整的官方文档在此：<a href="https://www.gnu.org/software/screen/manual/">https://www.gnu.org/software/screen/manual/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写论文必备软件列表</title>
      <link href="/posts/2020-10-26-softwares-for-writing-papers.html"/>
      <url>/posts/2020-10-26-softwares-for-writing-papers.html</url>
      
        <content type="html"><![CDATA[<p>本文主要列出了一些笔者常用的写论文软件。</p><ol><li><p>Office 2013</p><pre><code class="text">ed2k://|file|SW_DVD5_Office_Professional_Plus_2013_64Bit_ChnSimp_MLF_X18-55285.ISO|958879744|678EF5DD83F825E97FB710996E0BA597|/</code></pre></li><li><p>Visio 2013</p><pre><code class="text">ed2k://|file|cn_visio_professional_2013_with_sp1_x64_3910821.exe|566078120|238DBAB9F597E05EB93C06229AF3A57B|/</code></pre></li><li><p>MathType</p><p><a href="https://download.ismdeep.com/MathType6.9a-ismdeep.zip">https://download.ismdeep.com/MathType6.9a-ismdeep.zip</a></p></li><li><p>VirtualDriveMaster（虚拟光驱软件）</p><p><a href="https://download.ismdeep.com/virtualdrivemaster.exe">https://download.ismdeep.com/virtualdrivemaster.exe</a></p></li><li><p>文献管理软件 <a href="https://www.mendeley.com/download-desktop-new/">Mendeley</a></p><p><a href="https://www.mendeley.com/">https://www.mendeley.com/</a></p></li><li><p>Tex Live 2020</p><p><a href="https://mirrors.aliyun.com/CTAN/systems/texlive/Images/">https://mirrors.aliyun.com/CTAN/systems/texlive/Images/</a></p><p>地址来源： <a href="https://www.latexstudio.net/">https://www.latexstudio.net/</a></p><p>macOS 上的 LaTeX 工具（MacTeX）也可以在这里找到。因为地址变化可能随时间而不同，所以就不贴下载地址了。</p></li><li><p>Texpad</p><p>macOS 下优秀的 LaTeX 编辑器。</p></li><li><p>CONNECTED PAPERS</p><p><a href="https://www.connectedpapers.com/">https://www.connectedpapers.com/</a></p></li><li><p>SCI-HUB</p><p><a href="https://sci-hub.st/">https://sci-hub.st/</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome 浏览器代理设置</title>
      <link href="/posts/2020-10-23-chrome-proxy-configuration.html"/>
      <url>/posts/2020-10-23-chrome-proxy-configuration.html</url>
      
        <content type="html"><![CDATA[<p>Chrome 浏览器（即谷歌浏览器），我听到最多的误解就是：谷歌不是访问不了了么？谷歌浏览器还能用吗？OK! Try it! Why NOT just TRY IT?!</p><p>当然，谷歌浏览器自然是可以使用的，谷歌浏览器是一款非常好用的浏览器，有着非常多的插件，而且安全性也还是很优秀的。</p><p>本文主要讲述谷歌浏览器在代理方面的设置，很多人用谷歌浏览器，为了访问国外的一些被墙的网站，都需要在谷歌浏览器上设置翻墙代理。本文推荐使用 Proxy SwitchyOmega：<a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif</a></p><p>首先，设置 proxy 代理，设置成自己的代理服务器地址和端口。</p><p>其实，推荐设置 auto switch，默认选择 Direct，Rule List 选择 Proxy，那么 Rule List 使用什么呢？这里推荐 <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a> 这样设置之后，Chrome 可以根据规则列表，自动为访问的网站选择走代理还是走国内网络。以上 gfwlist 其实是一个被墙网址的集合，也就是大陆不能正常访问的域名列表，Proxy SwitchyOmega 在识别访问域名在此列表中，则选择走 proxy 代理。这样自动选择，能够让你访问国内的网站不至于通过 proxy 来访问，能够像正常国内访问一样迅速。当然也可以节省你购买的代理节点流量。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/23/6cd37f8a78b17f6e9662cceb6397f66c-925f64.png" alt="image-20201023101616163"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 下 Laravel 项目开发</title>
      <link href="/posts/2020-10-21-laravel-develop-with-docker.html"/>
      <url>/posts/2020-10-21-laravel-develop-with-docker.html</url>
      
        <content type="html"><![CDATA[<p>在开始这篇文章之前，我觉得有必要先交代一下笔者所使用的开发环境。电脑是一台 MacBook Pro. 我相信很多从事 PHP 项目开发的小伙伴都有过这样的一些问题，自己电脑上很难配置出于生产环境一样的运行环境。比如，生产环境用的是 Linux 系统，而自己电脑上又是 macOS 系统，而且我发现 macOS 环境下想要安装 PHP 扩展也是一件非常麻烦的事情，这其中当然也有部分原因是得益于咱们特有的局域网环境问题。当然，笔者也不推荐在 macOS 环境下用 Homebrew 安装的 PHP 运行环境。<strong>这里推荐大家使用 Docker 环境来运行咱们的 PHP 项目。</strong></p><p>使用 Docker 来运行 PHP 项目考虑是有原因的：</p><ul><li>Docker 中咱们可以使用 Linux 的系统，基本上可以跟生产服务器所使用的环境一样了。</li><li>Docker 中可以配置多种环境，无论是老版本的 PHP 5.x 还是最新的 PHP 7.4 都是可以根据需要自行安装的。</li><li>Linux 下 PHP 环境更加简单，社区文档更加丰富，所有操作起来会更加简单，避免踩上很多无用的坑。</li></ul><h1 id="1-说明"><a href="#1-说明" class="headerlink" title="1. 说明"></a>1. 说明</h1><p>本文将讲述创建一个博客网站的过程。</p><p>项目名称：<code>blog</code></p><p>测试域名：<code>blog.local</code></p><p>操作系统：<code>Ubuntu 18.04</code></p><p>PHP 版本：<code>PHP 7.2</code></p><p>数据库：<code>MySQL</code></p><p>数据库名称：<code>db_blog</code></p><p>数据库用户名：<code>db_blog</code></p><p>数据库密码：<code>saJXUFS9</code></p><h1 id="2-构建-Ubuntu-LNMP-镜像"><a href="#2-构建-Ubuntu-LNMP-镜像" class="headerlink" title="2. 构建 Ubuntu-LNMP 镜像"></a>2. 构建 Ubuntu-LNMP 镜像</h1><p>镜像构建文件见： <a href="https://github.com/ismdeep/dockerfile/tree/master/ubuntu-lnmp">https://github.com/ismdeep/dockerfile/tree/master/ubuntu-lnmp</a></p><pre><code class="bash">git clone https://github.com/ismdeep/dockerfile.gitcd dockerfile/ubuntu-lnmpdocker build -t ubuntu-lnmp .</code></pre><h1 id="3-运行-Ubuntu-LNMP-容器"><a href="#3-运行-Ubuntu-LNMP-容器" class="headerlink" title="3. 运行 Ubuntu-LNMP 容器"></a>3. 运行 Ubuntu-LNMP 容器</h1><ol><li><p>首先创建一个空的文件夹 <code>blog</code> ，本文使用目录为 <code>/Users/ismdeep/Data/blog</code></p></li><li><p>运行容器：</p><pre><code class="bash">docker run --name blog \-v /Users/ismdeep/Data/blog:/var/www/blog \-p 80:80 \-p 3306:3306 \-d ubuntu-lnmp</code></pre></li><li><p>进入 Docker 容器并初始化项目。</p><pre><code class="bash">docker exec -it blog bashcd /var/wwwcomposer create-project --prefer-dist laravel/laravel blog</code></pre></li><li><p>配置 Nginx</p><p> Nginx 配置目录在 <code>/etc/nginx/sited-enabled</code></p><p> Nginx 配置如下</p><pre><code>server &#123;    listen 80;    root /var/www/blog/public;    index index.php;    server_name blog.local;    location / &#123;        try_files $uri $uri/ /index.php?$query_string;    &#125;    location ~\.php$ &#123;        include snippets/fastcgi-php.conf;        fastcgi_pass unix:/var/run/php/php7.2-fpm.sock;    &#125;    location ~/\.ht &#123;        deny all;    &#125;&#125;</code></pre></li><li><p>配置 MySQL 数据库</p><p> 为了能够通过 PhpStorm 等开发软件能够连接 MySQL 数据库，我们需要将 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 文件中 <code>bind-address          = 127.0.0.1</code> 注释起来。并重启数据库。重启方法嘛，直接重启 Docker 不就成了？</p></li><li><p>创建数据库及用户</p><p> 在 Docker 容器中，运行以下命令，即可进入 MySQL.</p><pre><code>mysql -uroot -p</code></pre><pre><code>create database db_blog default character set utf8mb4 collate utf8mb4_unicode_ci;CREATE USER &#39;db_blog&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;saJXUFS9&#39;;grant all privileges on db_blog.* to &#39;db_blog&#39;@&#39;%&#39;;flush privileges;</code></pre></li><li><p>将项目使用的 MySQL 配置信息写入项目的 <code>.env</code> 文件中</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/21/5bfd9f6a9dd374121f8fb10f2619ebe1-177048.png" alt="image-20201021114119538"></p></li></ol><h1 id="4-PHP-命令说明"><a href="#4-PHP-命令说明" class="headerlink" title="4. PHP 命令说明"></a>4. PHP 命令说明</h1><p>对于项目开发过程中所需要使用的 <code>php artisan</code> 的命令，当然我们需要去 Docker 容器中执行了。</p><pre><code class="php">php artisan migrate</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
            <tag> macOS </tag>
            
            <tag> Docker </tag>
            
            <tag> PHP </tag>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 网络编程</title>
      <link href="/posts/2020-10-20-java-network-for-beginners.html"/>
      <url>/posts/2020-10-20-java-network-for-beginners.html</url>
      
        <content type="html"><![CDATA[<p>网络编程是指编程运行在多个设备（计算机）上的程序，这些设备通过网络连接起来。</p><h2 id="0x01-网络编程概述"><a href="#0x01-网络编程概述" class="headerlink" title="0x01 网络编程概述"></a>0x01 网络编程概述</h2><p><strong>网络编程：</strong>在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换。</p><h2 id="0x02-网络编程三要素"><a href="#0x02-网络编程三要素" class="headerlink" title="0x02 网络编程三要素"></a>0x02 网络编程三要素</h2><ul><li>IP 地址：要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来制定要接收数据的计算机和识别发送的计算机，而 IP 地址就是这个标识号，也就是设备的标识。</li><li>端口：网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说 IP 地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了 。也就是应用程序的标识。</li><li>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤做了统一的规定，通信双方必须同时遵守才能完成数据交换。常见的协议有 UDP 协议和 TCP 协议。</li></ul><h2 id="0x03-通过-InetAddress-类获取本机-IP-地址。"><a href="#0x03-通过-InetAddress-类获取本机-IP-地址。" class="headerlink" title="0x03 通过 InetAddress 类获取本机 IP 地址。"></a>0x03 通过 <code>InetAddress</code> 类获取本机 IP 地址。</h2><pre><code class="java">import java.net.InetAddress;import java.net.UnknownHostException;public class Main &#123;    public static void main(String[] args) throws UnknownHostException &#123;        InetAddress address = InetAddress.getLocalHost();        System.out.println(&quot;主机名：&quot; + address.getHostName());        System.out.println(&quot;IP地址：&quot; + address.getHostAddress());    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo —— 图片上传新推荐</title>
      <link href="/posts/2020-10-18-uploading-pictures-with-picgo.html"/>
      <url>/posts/2020-10-18-uploading-pictures-with-picgo.html</url>
      
        <content type="html"><![CDATA[<p>一直以来，写博客文章都会遇到上传图片的问题。Hexo 自带的“将图片放置到assert文件夹，然后引用的方式” 显得不那么优雅，比如，在 Typora 这样的编辑器中，则无法正常显示图片，让人无法确定自己放置的是什么图片。所以我们都在不断寻找更加优雅的上传图片的方式。有人将图片上传至微博；有人将图片上传至 SM.MS 这样专业的图床网站；还有人剑走偏锋，选择百家号，腾讯云文档等这样的内容平台，上传图片。当然以上方式，笔者都觉得不那么“安全”、“稳定”。比如，哪天微信开始清理无效引用的图片，那么你上传的这些图片，可能就会丢失。这可能会得不偿失。那么笔者将在下文介绍一下自己探索出来的一种博客图片上传存储的方式。</p><p><strong>本文使用到的工具：</strong></p><ul><li>Nodejs 环境</li><li>Typora 编辑器</li><li>PicGo-Core 命令行工具</li><li>GitHub 账号</li></ul><h2 id="0x00-创建一个-GitHub-Repository"><a href="#0x00-创建一个-GitHub-Repository" class="headerlink" title="0x00 创建一个 GitHub Repository"></a>0x00 创建一个 GitHub Repository</h2><p>打开方式有两种：</p><ul><li>前往 <a href="https://github.com/new">https://github.com/new</a></li><li>打开 GitHub 网页右上角用户头像左边的下拉菜单中的 “New repository” 选项，前往创建新的 Repository.  （<strong>注：</strong> Repository 是库的意思）</li></ul><p>填写 Repo 名称，访问权限勾选 “Public” （不然其他人则无法访问），然后点击 “Create repository” 即可。</p><p>本文使用 Repo 名称为：<code>upload</code></p><h2 id="0x01-为-GitHub-Repository-启用-GitHub-Pages-功能"><a href="#0x01-为-GitHub-Repository-启用-GitHub-Pages-功能" class="headerlink" title="0x01 为 GitHub Repository 启用 GitHub Pages 功能"></a>0x01 为 GitHub Repository 启用 GitHub Pages 功能</h2><p>打开创建的 GitHub Repo 的 Settings，下滑页面找到 GitHub Pages，然后 Source 选择 main，然后点击 “Save”。</p><h2 id="0x02-申请一个-GitHub-Token"><a href="#0x02-申请一个-GitHub-Token" class="headerlink" title="0x02 申请一个 GitHub Token"></a>0x02 申请一个 GitHub Token</h2><p>打开方式有两种：</p><ul><li>前往 <a href="https://github.com/settings/tokens">https://github.com/settings/tokens</a></li><li>打开 GitHub 网页右上角用户头像的下拉列表中 Settings 然后 “Developer settings - Personal access tokens”</li></ul><p>点击 “Generate new token” 进入生成 GitHub Token 的界面。Note 部分随便填写即可，用来描述此次申请 GitHub Token 用途即可，比如此处笔者填写 “PicGo Token” ；并且勾选 <code>repo</code> 下的 <code>public_repo</code> 即可。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/18/628542963273dfecb0de6d9fe111f500-c2dd9a.png" alt="image-20201018195311002"></p><p>然后点击 “Generate token” 即可跳转至生成 GitHub Token 结果页面，此页面会有一个随机生成的字符串。复制，并保存下来。（<strong>注意⚠️：</strong>切勿遗失或被盗。）</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/18/fa6509d272989010db3fccfd0448f8df-a7d7be.png" alt="image-20201018195444828"></p><h2 id="0x03-安装-PicGo-Core"><a href="#0x03-安装-PicGo-Core" class="headerlink" title="0x03 安装 PicGo-Core"></a>0x03 安装 PicGo-Core</h2><p>打开命令行，输入以下命令安装 PicGo-Core：</p><pre><code class="bash">npm install picgo -g</code></pre><p>安装完成之后，可以输入以下命令，验证是否已经安装完成：</p><pre><code class="bash">picgo -v</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/18/0c0f61a0e7719cd362d81cc48f94db92-307c32.png" alt="image-20201018195811407"></p><h2 id="0x04-安装-PicGo-使用的-picgo-plugin-rename-file-插件"><a href="#0x04-安装-PicGo-使用的-picgo-plugin-rename-file-插件" class="headerlink" title="0x04 安装 PicGo 使用的 picgo-plugin-rename-file 插件"></a>0x04 安装 PicGo 使用的 <code>picgo-plugin-rename-file</code> 插件</h2><p>在用户目录（笔者这里为 <code>C:\Users\ismdeep</code>）下，<code>cd .picgo</code> 进入配置文件目录。并输入 <code>npm i picgo-plugin-rename-file</code> 命令进行安装重命名文件插件。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/18/13375ab62d55e75ad3b1fd894038e30a-0b1fde.png" alt="image-20201018200104970"></p><h2 id="0x05-配置-PicGo-Core"><a href="#0x05-配置-PicGo-Core" class="headerlink" title="0x05 配置 PicGo-Core"></a>0x05 配置 PicGo-Core</h2><p>打开用户目录下的 <code>.picgo</code> 文件夹中的 <code>config.json</code> 文件。笔者使用的配置文件如下：</p><pre><code class="json">&#123;  &quot;picBed&quot;: &#123;    &quot;current&quot;: &quot;github&quot;,    &quot;github&quot;: &#123;      &quot;repo&quot;: &quot;ismdeep/upload&quot;,      &quot;branch&quot;: &quot;main&quot;,      &quot;token&quot;: &quot;ad6d*******************************389c3&quot;,      &quot;path&quot;: &quot;images/&quot;,      &quot;customUrl&quot;: &quot;https://ismdeep.github.io/upload&quot;    &#125;  &#125;,  &quot;picgoPlugins&quot;: &#123;    &quot;picgo-plugin-rename-file&quot;: true  &#125;,  &quot;picgo-plugin-rename-file&quot;: &#123;    &quot;format&quot;: &quot;&#123;y&#125;/&#123;m&#125;/&#123;d&#125;/&#123;hash&#125;-&#123;rand:6&#125;&quot;  &#125;&#125;</code></pre><p>配置文件需要修改的参数说明如下：</p><ul><li><code>repo</code> 替换成自己的用户名和 Repo 名称</li><li><code>token</code> 填写自己生成的 GitHub Token</li><li><code>path</code> 可直接填写 <code>images</code> ，看完上传图片后返回的 URL 你就懂了。</li><li><code>customUrl</code> 需要将 <code>ismdeep</code> 和 <code>upload</code> 换成自己的用户名和 Repo 名称</li></ul><h2 id="0x06-配置-Typora-并测试上传功能"><a href="#0x06-配置-Typora-并测试上传功能" class="headerlink" title="0x06 配置 Typora 并测试上传功能"></a>0x06 配置 Typora 并测试上传功能</h2><p>打开 Typora “文件 - 偏好设置” ，在打开的设置窗口中选择图像设置页面。其中 “上传服务设定” 选择 “Custom command”，并在自定义命令中填写 <code>picgo upload</code></p><p>接下来点击 “验证图片上传选项” 进行验证即可。</p><h2 id="0x07-使用-Typora-上传图片"><a href="#0x07-使用-Typora-上传图片" class="headerlink" title="0x07 使用 Typora 上传图片"></a>0x07 使用 Typora 上传图片</h2><p>上传图片可使用以下几种方式：</p><ul><li>复制图片至 Typora 编辑器中，然后右键图片上传即可。（复制图片可以复制图片文件，当然大部分截图软件截图后都自动将图片放到剪切板中，此处直接粘贴即可。）</li><li>拖拽图片文件至 Typora 编辑器中，然后右键图片上传即可。</li></ul><p><strong>注：</strong>上传文件需要等一段时间才可访问，因为 GitHub Page 有一个同步时间。</p><h2 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h2><p>方便安装，配置起来也简单，但是需要注意一点的是，图片访问在国内网络环境下，可能会有点慢，但图片存储在 GitHub 上，至少会比国内的平台上，安全稳定。需要为存储图片的 GitHub Repo 启用 GitHub Pages 功能，不然国内用户则无法访问图片。</p><h2 id="0x09-常见问题"><a href="#0x09-常见问题" class="headerlink" title="0x09 常见问题"></a>0x09 常见问题</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> PicGo </tag>
            
            <tag> Typora </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 多线程编程</title>
      <link href="/posts/2020-10-15-java-thread-for-beginners.html"/>
      <url>/posts/2020-10-15-java-thread-for-beginners.html</url>
      
        <content type="html"><![CDATA[<p>进程与线程的区别就不过多去说了吧，进程和线程都是由操作系统进行管理与调度的，不同的是，进程与进程之间数据并不共享，各自拥有自己独立的数据存储空间。然而同一个进程下面的线程之间是可以共享进程的内存空间的。本来将从 Java 中最简单的多线程程序一点一点来讲解 Java 中多线程编程的一些方法。</p><h2 id="0x01-实现多线程类的两种方式"><a href="#0x01-实现多线程类的两种方式" class="headerlink" title="0x01 实现多线程类的两种方式"></a>0x01 实现多线程类的两种方式</h2><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><pre><code class="java">public class MyThread extends Thread &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><pre><code class="java">public class MyThread implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p>相比继承 Thread 类，实现 RUnnable 接口的好处</p><ul><li>避免了 Java 单继承的局限性</li><li>适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好体现了面向对象的设计思想</li></ul><h3 id="创建并启动线程"><a href="#创建并启动线程" class="headerlink" title="创建并启动线程"></a>创建并启动线程</h3><ul><li><p>创建类的对象方式</p><pre><code class="java">MyThread thread1 = new MyThread();thread1.start();</code></pre></li><li><p>创建 Thread 类的对象方式</p><pre><code class="java">Thread thread1 = new Thread(new MyThread());thread1.start();</code></pre></li></ul><p><strong>注意⚠️：</strong> 线程在启动应该调用其 <code>start()</code> 方法，而不是 <code>run()</code> 方法，如果调用的是 <code>run()</code> 方法，则程序执行是阻塞式的。只有在调用 <code>start()</code> 方法后，才是通过线程的方式进行执行。</p><h2 id="0x02-设置并获取线程名称"><a href="#0x02-设置并获取线程名称" class="headerlink" title="0x02 设置并获取线程名称"></a>0x02 设置并获取线程名称</h2><p>Thread 类提供了两个方法类设置和获取线程的名称：</p><ul><li><code>void setName(String name)</code> 设置线程的名称</li><li><code>String getName()</code> 获取线程名称</li></ul><p><strong>注：</strong> 通过 <code>Thread.getCurrentThread()</code> 可以获取当前正在执行的线程对象的引用。</p><h2 id="0x03-线程调度"><a href="#0x03-线程调度" class="headerlink" title="0x03 线程调度"></a>0x03 线程调度</h2><p>线程调度的两种模型：</p><ul><li><strong>分时调度模型：</strong> 所有线程轮流获得 CPU 的使用权，平均分配每个线程占用 CPU 的时间片。</li><li><strong>抢占式调度模型：</strong>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。</li></ul><p>Java 中使用的是抢占式调度模型。</p><p>Thread 类提供了用来<strong>设置线程优先级</strong>和<strong>获取线程优先级</strong>的两个方法：</p><ul><li><code>public final int getPriority()</code> 获取线程优先级</li><li><code>public final void setPriority(int newPriority)</code> 设置线程优先级</li></ul><p>Java 中线程优先级三个常量即可说明：</p><pre><code>public static final int MIN_PRIORITY = 1;public static final int NORM_PRIORITY = 5;public static final int MAX_PRIORITY = 10;</code></pre><p><strong>注意：</strong> 线程优先级高仅仅表示线程获取的 CPU 时间片的机率高。</p><h2 id="0x04-线程控制"><a href="#0x04-线程控制" class="headerlink" title="0x04 线程控制"></a>0x04 线程控制</h2><ul><li><code>static void sleep(long millis)</code> 使当前正在执行的线程暂停执行指定的毫秒数</li><li><code>void join()</code> 等待这个线程死亡</li><li><code>void setDaemon(boolean on)</code> 将此线程标记为守护线程，当运行的线程都是守护线程时，Java 虚拟机将退出。</li></ul><h2 id="0x05-线程生命周期"><a href="#0x05-线程生命周期" class="headerlink" title="0x05 线程生命周期"></a>0x05 线程生命周期</h2><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/16/086d58e5f1cc596d52b9ecf1e5a92b38-f3bdba.jpeg" alt="DA350B60-DCFE-45A5-A563-DE8C196D794A_1_105"></p><h2 id="0x06-线程同步"><a href="#0x06-线程同步" class="headerlink" title="0x06 线程同步"></a>0x06 线程同步</h2><p>这里来写一个模拟售票员卖票的过程。我们会有一个票务中心（TicketCenter），以及多个售票员（TicketSeller），那么多个售票员售票就是多线程同时运行的过程，当然，每个售票员售票都是从票务中心拿的票。</p><p>首先，我们来实现一个简单的。</p><p><code>TicketCenter.java</code></p><pre><code class="java">import java.util.ArrayList;import java.util.List;/** * 票务中心 */public class TicketCenter &#123;    private final List&lt;String&gt; tickets;    private int nextIndex;    public TicketCenter() &#123;        tickets = new ArrayList&lt;&gt;();        nextIndex = 0;    &#125;    public void pushTicket(String ticket) &#123;        tickets.add(ticket);    &#125;    public String getNextAvailable() &#123;        if (nextIndex &gt;= tickets.size()) &#123;            return null;        &#125;        return tickets.get(nextIndex++);    &#125;&#125;</code></pre><p><code>TicketSeller.java</code></p><pre><code class="java">/** * 售票员 */public class TicketSeller implements Runnable &#123;    private final String sellerName;    private TicketCenter ticketCenter;    public void setTicketCenter(TicketCenter ticketCenter) &#123;        this.ticketCenter = ticketCenter;    &#125;    public TicketSeller(String sellerName, TicketCenter ticketCenter) &#123;        this.sellerName = sellerName;        setTicketCenter(ticketCenter);    &#125;    @Override    public void run() &#123;        while (true) &#123;            String ticket = ticketCenter.getNextAvailable();            if (ticket == null) &#123;                break;            &#125;            System.out.println(sellerName + &quot; -&gt; &quot; + ticket);        &#125;    &#125;&#125;</code></pre><p><code>Main.java</code></p><pre><code class="java">import java.util.UUID;public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        int ticketCnt = 10000;        TicketCenter ticketCenter = new TicketCenter();        for (int i = 0; i &lt; ticketCnt; i++) &#123;            ticketCenter.pushTicket(UUID.randomUUID().toString());        &#125;        Thread seller1 = new Thread(new TicketSeller(&quot;刘备&quot;, ticketCenter));        Thread seller2 = new Thread(new TicketSeller(&quot;关羽&quot;, ticketCenter));        Thread seller3 = new Thread(new TicketSeller(&quot;张飞&quot;, ticketCenter));        Thread seller4 = new Thread(new TicketSeller(&quot;赵云&quot;, ticketCenter));        seller1.start();        seller2.start();        seller3.start();        seller4.start();    &#125;&#125;</code></pre><p>这份代码，运行结果中就有可能会出现下图所示的重复取票问题。刘备卖了一张 <code>d9d3b45a-c131-4fa5-b9a4-7305d14677e4</code> 的票，赵云也卖了一张 <code>d9d3b45a-c131-4fa5-b9a4-7305d14677e4</code> 的票。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/18/420158db7559edf612368177864a05ed-d5fdd0.png" alt="image-20201018111115089"></p><p>造成以上问题的原因就是在取票的时候，没有进行加锁操作。</p><p>那我们接下来对取票的操作进行加锁操作。则能够保证不出现重复卖票的情况。既然多个售票员取票都是通过 <code>getNextAvailable()</code> 函数进行取票，那我们可以对此函数进行 <code>synchronized</code> 修饰，则可以达到加锁的目的：</p><pre><code class="java">synchronized public String getNextAvailable() &#123;    if (nextIndex &gt;= tickets.size()) &#123;        return null;    &#125;    return tickets.get(nextIndex++);&#125;</code></pre><p>当然，还可以通过 <code>synchronized</code> 同步代码块，如：</p><pre><code class="java">synchronized (obj) &#123;&#125;</code></pre><p>当然，这里的 <code>obj</code> 需要各个线程使用的是同一个对象实体。</p><p>通过上面的例子我们知道，线程同步有两种方式：</p><ul><li>同步代码块</li><li>同步方法（同步方法的锁对象是 <code>this</code>）</li></ul><p>总结：无论是同步代码块还是同步方法，都需要明确使用的锁对象是啥，不然加锁是无效的。</p><p>注：如果是静态方法设置 <code>synchronized</code> 同步方法，则其锁对象是 <code>ClassName.class</code> 的静态文件对象。</p><h2 id="0x07-线程安全的类"><a href="#0x07-线程安全的类" class="headerlink" title="0x07 线程安全的类"></a>0x07 线程安全的类</h2><ul><li><code>StringBuffer</code> 当不需要线程安全的环境时，则建议使用 <code>StringBuilder</code> ，速度更快。</li><li><code>Vector</code> 当不需要线程安全的环境时，则建议使用 <code>ArrayList</code> ，速度更快。</li><li><code>HashTable</code> 当不需要线程安全的环境时候，则建议使用 <code>HashMap</code>，速度更快。</li></ul><table><thead><tr><th>用途</th><th>同步类</th><th>非同步类（速度更快）</th></tr></thead><tbody><tr><td>字符串构造器</td><td><code>StringBuffer</code></td><td><code>StringBuilder</code></td></tr><tr><td>列表</td><td><code>Vector</code></td><td><code>ArrayList</code></td></tr><tr><td>键值存储</td><td><code>HashTable</code></td><td><code>HashMap</code></td></tr></tbody></table><p>通过 <code>Collections.synchronizedList()</code> 方法，可以将一个线程不安全的列表对象，转化成一个线程安全的列表对象。</p><pre><code class="java">List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;String&gt;());</code></pre><h2 id="0x08-Lock-锁"><a href="#0x08-Lock-锁" class="headerlink" title="0x08 Lock 锁"></a>0x08 Lock 锁</h2><p><code>Lock</code> 实现提供比使用 <code>synchronized</code> 方法和语句可以获得更广泛的锁定操作</p><p>Lock 中提供了获得锁和释放锁的方法</p><ul><li><code>void lock()</code> 获得锁</li><li><code>void unlock()</code> 释放锁</li></ul><p><code>Lock</code> 是接口不能直接实例化，这里采用它的实现类 <code>ReentrantLock</code> 来实例化</p><p><code>ReentrantLock</code> 的构造方法</p><ul><li><code>ReentrantLock</code> 创建一个 <code>ReentrantLock</code> 的实例</li></ul><p>我们将 <code>TicketCenter.java</code> 改成如下即可：</p><pre><code class="java">import java.util.ArrayList;import java.util.List;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 票务中心 */public class TicketCenter &#123;    private final List&lt;String&gt; tickets;    private int nextIndex;    private final Lock lock = new ReentrantLock();    public TicketCenter() &#123;        tickets = new ArrayList&lt;&gt;();        nextIndex = 0;    &#125;    public void pushTicket(String ticket) &#123;        tickets.add(ticket);    &#125;    public String getNextAvailable() &#123;        if (nextIndex &gt;= tickets.size()) &#123;            return null;        &#125;        lock.lock();        String ticket = tickets.get(nextIndex++);        lock.unlock();        return ticket;    &#125;&#125;</code></pre><p>注意：以上所使用锁进行 <code>lock()</code> 操作，有一点不够严谨，那就是，如果 <code>String ticket = tickets.get(nextIndex++);</code> 出现异常的时候，则可能导致无法执行 <code>lock.unlock()</code> 操作，也就是无法释放锁，就会出现死锁的现象。那么我们可以这样写</p><pre><code>try &#123;    lock.lock();    String ticket = tickets.get(nextIndex++);&#125; finally &#123;    lock.unlock();&#125;</code></pre><h2 id="0x09-生产者消费者模式"><a href="#0x09-生产者消费者模式" class="headerlink" title="0x09 生产者消费者模式"></a>0x09 生产者消费者模式</h2><p>生产者消费者模式是一个十分经典的多线程协作模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。所谓生产者消费者问题，实际上主要是包含两类线程：</p><ul><li>一类是生产者线程用于生产数据</li><li>一类是消费者线程用于消费数据</li></ul><p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p><ul><li>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为。</li><li>消费者只需要从共享数据区中获取数据，并不需要关心生产者的行为。</li></ul><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/18/2e0d3bfa8aae8e734c6bc2277d58e9da-133102.jpeg" alt="DFAD33F1-0D26-427D-A165-C12E3C3CF245_4_5005_c"></p><p>为了体现生产和消费过程中的等待和唤醒，Java 就提供了几个方法供我们使用，这几个方法在 Object 类中。</p><p>Object 类的等待和唤醒方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>void wait()</code></td><td>导致当前线程等待，直到另一个线程调用该对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法</td></tr><tr><td><code>void notify()</code></td><td>唤醒正在等待对象监视器的单个线程</td></tr><tr><td><code>void notifyAll()</code></td><td>唤醒正在等待对象监视器的所有线程</td></tr></tbody></table><p><strong>生产者消费者案例</strong></p><p>生产者消费者案例中包含的类：</p><ul><li>奶箱类（<code>Box</code>）：定义一个成员变量，表示第 <code>x</code> 瓶奶，提供存储牛奶和获取牛奶的操作。</li><li>生产者类（<code>Producer</code>）：实现 <code>Runnable</code> 接口，重写 <code>run()</code> 方法，调用存储牛奶的操作。</li><li>消费者类（<code>Consumer</code>）：实现 <code>Runnable</code> 接口，重写 <code>run()</code> 方法，调用获取牛奶的操作。</li><li>测试类（<code>BoxDemo</code>）：里面有 <code>main()</code> 方法，<code>main()</code> 方法中的步骤如下：<ol><li>创建奶箱对象，这是共享数据区域</li><li>创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作。</li><li>创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作。</li><li>创建两个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递。</li><li>启动线程</li></ol></li></ul><p><code>Box.java</code></p><pre><code class="java">public class Box &#123;    public static final boolean BOX_EMPTY = false;    public static final boolean BOX_FULL = true;    // 定义一个成员变量，表示第x瓶奶    private int milk;    // 定义一个成员变量，表示奶箱的状态    private boolean state = BOX_EMPTY;    // 提供存储奶箱和获取奶箱的操作    public synchronized void put(int milk) &#123;        // 如果有牛奶，等待消费        if (state == BOX_FULL) &#123;            try &#123;                wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        // 如果没有牛奶，就生产牛奶        this.milk = milk;        System.out.printf(&quot;送奶工将第%d瓶牛奶放入奶箱。\n&quot;, milk);        // 生产完毕后，修改奶箱状态        state = BOX_FULL;        // 唤醒其他等待线程        notifyAll();    &#125;    public synchronized void get() &#123;        // 如果没有牛奶，等待生产        if (state == BOX_EMPTY) &#123;            try &#123;                wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        // 如果有牛奶，就消费牛奶        System.out.printf(&quot;用户拿到第%d瓶牛奶。\n&quot;, this.milk);        // 消费完毕后，修改奶箱状态        state = BOX_EMPTY;        // 唤醒其他等待线程        notifyAll();    &#125;&#125;</code></pre><p><code>Producer.java</code></p><pre><code class="java">public class Producer implements Runnable &#123;    private final Box box;    public Producer(Box box) &#123;        this.box = box;    &#125;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 5; i++) &#123;            this.box.put(i);        &#125;    &#125;&#125;</code></pre><p><code>Consumer.java</code></p><pre><code class="java">public class Consumer implements Runnable &#123;    private final Box box;    public Consumer(Box box) &#123;        this.box = box;    &#125;    @Override    public void run() &#123;        while (true) &#123;            this.box.get();        &#125;    &#125;&#125;</code></pre><p><code>BoxDemo.java</code></p><pre><code class="java">public class BoxDemo &#123;    public static void main(String[] args) &#123;        // 1. 创建奶箱对象，这是共享数据区域        Box box = new Box();        // 2. 创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作。        Producer p = new Producer(box);        // 3. 创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作。        Consumer c = new Consumer(box);        // 4. 创建两个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递。        Thread thread1 = new Thread(p);        Thread thread2 = new Thread(c);        // 5. 启动线程        thread1.start();        thread2.start();    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 常用命令</title>
      <link href="/posts/2020-10-13-virtualbox-commands.html"/>
      <url>/posts/2020-10-13-virtualbox-commands.html</url>
      
        <content type="html"><![CDATA[<p>对 VirtualBox 中的虚拟机，有时候手动打开 VirtualBox 软件然后图形化界面进行操作，显得过于笨拙，或者说是不方便一键操作。以下我们将介绍一些 VirtualBox 常用的命令行命令。</p><h2 id="0x00-查看虚拟机列表"><a href="#0x00-查看虚拟机列表" class="headerlink" title="0x00 查看虚拟机列表"></a>0x00 查看虚拟机列表</h2><ul><li><code>VBoxManage list vms</code> 查看虚拟机列表（所有）</li><li><code>VBoxManage list vms --long</code> 查看虚拟机列表（所有）（详细信息）</li><li><code>VBoxManage list runningvms</code> 查看正在运行的虚拟机</li></ul><h2 id="0x01-启动虚拟机"><a href="#0x01-启动虚拟机" class="headerlink" title="0x01 启动虚拟机"></a>0x01 启动虚拟机</h2><ul><li><code>VBoxManage startvm &#123;vmname&#125; --type headless </code> 启动虚拟机</li></ul><h2 id="0x02-关闭虚拟机"><a href="#0x02-关闭虚拟机" class="headerlink" title="0x02 关闭虚拟机"></a>0x02 关闭虚拟机</h2><ul><li><code>VBoxManage controlvm &#123;vmname&#125; poweroff</code> 关闭虚拟机（强制关机）</li><li><code>VBoxManage controlvm &#123;vmname&#125; acpipowerbutton</code> 关闭虚拟机</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> VirtualBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈虚拟机网络配置</title>
      <link href="/posts/2020-10-12-talking-about-virtual-machine-networks.html"/>
      <url>/posts/2020-10-12-talking-about-virtual-machine-networks.html</url>
      
        <content type="html"><![CDATA[<p>本文我打算讲一讲虚拟机网络配置的一些常见问题。当然，虚拟机有很多种，常见的有 VirtualBox、VMWare 等。在虚拟机使用上面，笔者更倾向使用 VirtualBox，因为这东西在我们常用的三大操作系统（Windows、Linux、macOS）上都有，这样无论我在什么样的设备上都可以用，好处就是我掌握了 Windows 上如何使用 VirtualBox，那 macOS 上就基本上相同了的。不过话说回来了，其实咱们掌握了 VirtualBox 的基本使用的话，VMWare 也就不在话下了。</p><h2 id="0x00-网络基础知识"><a href="#0x00-网络基础知识" class="headerlink" title="0x00 网络基础知识"></a>0x00 网络基础知识</h2><p>虚拟机是一台通过虚拟机软件虚拟出来的计算机，其里面也有设备，虚拟出来的计算机有一个巨大的优势就是可以对虚拟计算机的设备进行修改，而不用像真是的计算机一样去购买新的设备更换啥的。比如，真实的电脑，你需要增加一个网卡，这个时候你就需要去购买新的网卡，然后往这台计算机上增加。成本就上来了。那么在虚拟机里呢，我们需要网卡，就给其新增一个虚拟的网卡上去；需要一个新的硬盘，就可以新增一个新的硬盘上去。这些都是可以通过虚拟机软件配置去做到的。</p><p>好，我们回到网络基础知识上来，那么一台电脑需要上网的话，那肯定就需要网卡，然后拿一根网线，一头接到网卡上。另一头呢？可以插在路由器上。就跟你家里的网络一样。</p><p>那么虚拟机里面配置网络有三种常用的网络连接方式：</p><ul><li><p>NAT 地址转换连接方式</p><p>NAT主要是用来供虚拟机上网的，其实这里地址转换也就是说虚拟机用的网络IP其实还是宿主机的网络IP，宿主机能够上网的话，虚拟机也可以上网。但是，宿主机无法直接通过某个IP访问到虚拟机，当然外面的网络就更加不行了。</p></li><li><p>Host-Only 连接方式</p><p>虚拟机软件在宿主系统中虚拟出一个虚拟的路由器，然后将虚拟机网卡与虚拟路由器连接起来。</p></li><li><p>桥接网卡（Bridge Adapter）连接方式</p><p>虚拟机桥接到宿主机真实网卡上面，获得一个与宿主机同一个子网的独立IP地址。比如：宿主机有一个网卡且获得 IP 地址为 172.16.40.12 ，那么虚拟机桥接了这个网卡之后就可以通过DHCP方式获取一个由路由器或交换机分配的IP，或者是手动设置一个IP地址。这个 IP 可以是 172.16.40.13，只要没有被占用就行。</p></li></ul><p>笔者在给虚拟机设置网络的时候，通常选择 <strong>NAT连接方式+Host-Only连接方式</strong> 、<strong>桥接（Bridge）网卡连接方式</strong> 这两种当中一种，具体选哪一种，视场景而定。</p><ul><li><strong>NAT连接方式+Host-Only连接方式：</strong> 这种方式，笔者用得更多一些，尤其是笔记本电脑里。因为笔记本网络使用并不固定，有时候用的是实验室的网络，有时候用的是宿舍的网络。使用桥接网卡就显得不是那么方便了。所以给第一张网卡以NAT网络，保证虚拟机能够上网，然后再选择Host-Only网络给第二张网卡，然后配置好IP这样宿主机就可以通过Host-Only配置的IP地址来访问虚拟机了。</li><li><strong>桥接网卡连接方式</strong>：家里台式机、实验室台式机会选择这种方式。这样台式机里的虚拟机系统就能够直接获得与台式机同一个子网里的IP了。这样台式机连虚拟机或者在子网里其他设备就能够直接连虚拟机了。比如笔者所在学校的实验室拥有学校子网的IP，这样就算是回到宿舍，也能够在宿舍连接到实验室台式机里的虚拟机进行一些实验了。</li></ul><p>Host-Only 虚拟路由器需要先在虚拟机软件上进行创建和设置。</p><ul><li>VirtualBox 则在 “管理” - “主机网络管理器” 进行创建和管理。</li><li>VMWare 则在 “编辑” - “虚拟网络编辑器” 进行创建和管理。</li></ul><h2 id="0x01-虚拟机内部设置"><a href="#0x01-虚拟机内部设置" class="headerlink" title="0x01 虚拟机内部设置"></a>0x01 虚拟机内部设置</h2><p>根据两种不同的连接方式组合，虚拟机的内部网络设置也有所不同。当然，我们这里主要讲述 Linux 下网络设置。首先，不得不吐槽一下 Linux 下网络设置一个很大的问题，就是太杂了。杂在哪里呢？<strong>各个 Linux 系统发行商都在搞自己的一套网络设置规则，甚至还出现了同一个发行商发布的 Linux 发行版，不同版本都有不同的网络配置方法。</strong>真希望各个厂商能够统一一下，给各位学子一个简单的网络配置环境。</p><p>那么配置网路的大致步骤视连接方式而定：</p><ul><li><p><strong>NAT连接方式+Host-Only连接方式：</strong> 在系统中通过 <code>ip addr</code> 命令查看网卡，除了 <code>lo</code> 网卡以外还能看到两张网卡，这两张网卡一张则是NAT连接方式，另一张则是 Host-Only连接方式。其中一张应该系统已经默认给设置好了NAT网络的地址，这样的地址一般以 10.0 这样开头，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/12/fbaedf8cbfb66afcac021eb453a6e7be-509ffe.png" alt="image-20201012145446055"></p></li><li><p><strong>桥接网卡连接方式：</strong> 在系统中通过 <code>ip addr</code> 命令查看网卡，除了 <code>lo</code> 网卡以外还能看到一张网卡，这种网卡就是桥接在宿主机真实网卡上的一个虚拟网卡。只需要按照宿主机中这种网卡的网络配置方式进行配置即可。</p></li></ul><h2 id="0x02-CentOS-网络配置"><a href="#0x02-CentOS-网络配置" class="headerlink" title="0x02 CentOS 网络配置"></a>0x02 CentOS 网络配置</h2><p>首先通过 <code>ip addr</code> 查看有哪些网卡，每个网卡需要配置什么样的网络。我们以下面这张图为例</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/12/64ace12b98d0765c63c14d33a8093ca4-5ab0c7.png" alt="image-20201012150739812"></p><p><code>enp0s3</code> 已经分配了一个 <code>10.0.2.15</code> 的 IP 地址，这个其实是一个 NAT 网络的地址。这里我们不去动这张网卡。</p><p><code>enp0s8</code> 尚未配置 IP 地址，这时候我们需要给其配置一个 IP 地址。我们是通过 Host-Only 连接方式设置的这张网卡，且虚拟路由器的地址为 <code>192.168.62.1</code> ，那么我们希望给这张网卡配置一个 <code>192.168.62.100</code> 的 IP 地址。</p><p>首先 CentOS 8.0 配置网络的目录是 <code>/etc/sysconfig/network-scripts</code> ，那么我们先</p><p><code>cd /etc/sysconfig/network-scripts</code> 进入这个目录，并 <code>ls</code> 查看一下有哪些文件。笔者电脑上有两张网卡，但是只出现了一个 <code>ifcfg-enp0s3</code> 的文件，<code>ifcfg-enp0s8</code> 呢？不着急，这个文件没有的话，我们可以自己手动创建的。<strong>小技巧：手动创建，需要写的代码太多了，我们可以直接 <code>cp ifcfg-enp0s3 ifcfg-enp0s8</code> 复制一个出来。然后进行编辑。</strong></p><p>以下是配置文件中常见的一些参数：</p><pre><code>TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=e4987998-a4ce-4cef-96f5-a3106a97f5bfDEVICE=enp0s8ONBOOT=no</code></pre><p>我们主要关心的是以下几个参数：</p><ul><li><code>DEVICE</code> 这个是指代哪一个网卡，填写网卡名称，比如我这里要配置 <code>enp0s8</code> 这个网卡，那就写 <code>enp0s8</code></li><li><code>NAME</code> 这个很简单，就是名称，就跟网卡名称一样就可以。</li><li><code>DEFROUTE</code> 是否是默认路由，在NAT+Host-Only组合连接方式中，NAT连接方式的网卡设置成 <code>yes</code> ，其他都设置成 <code>no</code></li><li><code>BOOTPROTO</code> 如果是 DHCP 方式获取 IP 的话就填写 <code>dhcp</code> ，如果想要静态方式分配 IP 地址，则填写 <code>static</code></li><li><code>IPADDR</code> 静态配置的 IP 地址</li><li><code>NETMASK</code> 静态配置网络的子网掩码</li><li><code>GATEWAY</code> 静态配置网络的网关</li><li><code>DNS1</code> 静态配置网络的 DNS 服务器地址（可以不配置）</li><li><code>UUID</code> 这个就是一个随机字符串，用来作为网卡的唯一标识，虽然不知道怎么用，但是还是需要的，通过 <code>uuidgen enp0s8</code> 则可以为我的 <code>enp0s8</code> 这个网卡生成一个 UUID 然后复制过去即可。</li><li><code>ONBOOT</code> 表示开机是否启用，这里我们都选择 <code>yes</code> 即可。</li></ul><p>那么笔者根据这里所说需求就可以设置成以下：</p><pre><code>TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=noIPADDR=192.168.62.100NETMASK=255.255.255.0GATEWAY=192.168.62.1DNS1=114.114.114.114IPV4_FAILURE_FATAL=noNAME=enp0s8DEVICE=enp0s8UUID=223bdb47-2fed-4773-b984-5f5733e61904ONBOOT=yes</code></pre><p>配置完可以通过 <code>nmcli c reload</code> 命令重启网络服务，当然你还可以通过重启系统来试试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
            <tag> VirtualBox </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo技巧</title>
      <link href="/posts/2020-10-11-hexo-tips.html"/>
      <url>/posts/2020-10-11-hexo-tips.html</url>
      
        <content type="html"><![CDATA[<p>上文我们讲述了《<a href="/posts/2020-10-11-how-to-build-blog-site-with-hexo.html">Hexo搭建个人博客网站</a>》，这次我们来讲讲 Hexo 使用的一些技巧。</p><ol><li><code>hexo new</code> 新建文章时，直接加上日期，如 <code>hexo new 2020-10-11-hexo-tips</code>，毕竟所有新建的文件都是以文件的形式存放在 <code>source/_posts</code> 文件夹中，如果太多了，真的很难找。</li><li><code>_config.yml</code> 中配置文章链接可以直接配置 <code>permalink</code> 项为 <code>permalink: posts/:title.html</code>，毕竟上面新建的文章名已经带上了日期了。</li><li>写博客的时候需要插入图片，Hexo 自带的插入图片方式并不好用，笔者是通过 PicGo 将图片文件上传至 GitHub 一个 Repository 中，然后 Typora 配置插入图片自动上传。这部分内容，以后笔者会写一篇文章，当然，现在网上这方面的文章也挺多的。不太推荐使用图床网站存放图片，毕竟如果图片被清理了，就麻烦了。推荐用GitHub建立图床，大公司有保障。</li><li>通过标签对文章进行分类即可。</li><li>在 GitHub 上建一个 Repository 来管理 Hexo 项目，这样以后电脑坏了，或者是迁移就很方便了。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客网站</title>
      <link href="/posts/2020-10-11-how-to-build-blog-site-with-hexo.html"/>
      <url>/posts/2020-10-11-how-to-build-blog-site-with-hexo.html</url>
      
        <content type="html"><![CDATA[<p>对于技术人员来说，写博客应该算是一件比较重要的事情。写博客可以将你所学记录下来，培养总结能力，还能帮助到其他的程序员。再说得功利一些，在简历上写上自己的博客地址也会是一个加分项。</p><p>既然是写博客，当然是要发出来给大家看的。博客平台有大致一下三种搭建形式：</p><p><strong>一、选择一个博客平台。</strong>这种方式也是笔者最开始写博客选择的方式。我们可以选择 CSDN、博客园、简书等等这样一些平台，但是这些平台往往都有一些广告啥的，以及一些其他不可描述的东西在里面。比如曾经发生在笔者身上的一件事情就是，笔者发布了一篇如何挖掘XX博客平台问题的文章，然后这文章还就是发在XX博客平台上的，当然不出意外被官方屏蔽了。如果尺度再大一些的话，你去探讨某些话题的时候，国内更是无法发表了。</p><p><strong>二、自己搭建博客网站。</strong>在经历过上述方式，笔者开始转到第二种方式上来。自己搭建博客网站需要一个VPS服务器，然后找一个博客系统的源码，然后去搭建，知名的有 WordPress、Typecho 等等。但是呢，这种方式搭建的网站，首先安全性上无法保证，笔者曾经就经历过博客网站遭受到攻击的事情。通过后台可以查看到很多攻击流量，比如恶意评论、注入攻击。虽然没有攻击成功的，但也是一个隐患，毕竟笔者不是专业从事安全方面的大牛🐮嘛，所以不能完完全全保证博客不会被黑。（即使是大牛也无法保证。</p><p><strong>三、自己搭建静态博客。</strong>这也是笔者经历过上面两种博客搭建方式之后决定采用的。这也是本文将要给大家展示的，我们将依托GitHub Page功能，来搭建我们自己的博客站点。这种搭建的方式优点是：<strong>安全性高、并发量高、操作简单</strong></p><h2 id="0x00-介绍"><a href="#0x00-介绍" class="headerlink" title="0x00 介绍"></a>0x00 介绍</h2><p>Hexo 是一款基于 Node.js 的静态博客框架，易于安装使用，可以方便的生成静态网页，社区活跃，有非常丰富的主题样式，是搭建博客的首选框架。本文将教会你以下内容：</p><ul><li>安装 Git for Windows</li><li>安装 Node.js</li><li>安装 Hexo 命令行工具</li><li>初始化博客项目</li><li>本地预览博客网站</li><li>开始写第一篇博客</li><li>Hexo 主题安装</li><li>注册 GitHub 账号</li><li>创建 GitHub Repository</li><li>配置博客项目并关联 GitHub Repository</li><li>访问并分享博客网站</li></ul><p>内容丰富，童叟无欺，老少皆宜。</p><p>阅读本文并跟着一起搭建一个博客网站你首先得熟悉一下操作：</p><ul><li>打开命令行</li><li>如何下载软件</li><li>安装软件</li></ul><p>看～是不是很零基础。</p><h2 id="0x01-安装-Git-for-Windows"><a href="#0x01-安装-Git-for-Windows" class="headerlink" title="0x01 安装 Git for Windows"></a>0x01 安装 Git for Windows</h2><p>Git for Windows 软件官网地址 <a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p><p>点击页面上的 Download 按钮进行下载。</p><p>下载 Git-xxx-64-bit.exe 文件。（这里xxx是版本号，随着时间推移，人家肯定会去发布新的版本，版本号就会不一样啦。）然后就可以安装了。安装步骤比较简单，大部分地方保持默认选项直接下一步（Next）即可。<strong>注意：</strong>在下面的界面时，笔者推荐选择最后一个 “Checkout-as-is, commit-as-is”，这样是表示文件中换行符，我们不希望 git 工具帮我们去解决这个问题，如果有需要，我们可以自己去解决。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/c237001e21920f62efd704259a9af742-048ca8.png" alt="image-20201011124852526"></p><p>Git for Windows 工具是一个非常有用的工具，让你能够在 Windows 的环境下使用很多 Linux 上的命令，比如 <code>ls</code>, <code>cat</code> 等。</p><h2 id="0x02-安装-Node-js"><a href="#0x02-安装-Node-js" class="headerlink" title="0x02 安装 Node.js"></a>0x02 安装 Node.js</h2><p>打开 Node.js 官方网站 （<a href="https://nodejs.org/%EF%BC%89%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://nodejs.org/），下载</a> TLS （长期支持版）。安装过程也是非常简单的啦，直接下一步、下一步即可。</p><p>如何确认已经正确安装好了 Node.js 呢？打开命令行或者桌面处右键菜单打开 “Git Bash Here” 然后输入以下指令查看安装版本，如果返回安装的 Node.js 的版本号，则说明安装成功。</p><pre><code class="bash">$ node --versionv12.19.0</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/eb8e56c35ecb35ace0bdacfc379b19a8-091d17.png" alt="image-20201011142201702"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/60165a12cd72f96dab75390651f0fdce-c5a6a6.png" alt="image-20201011142227835"></p><h2 id="0x03-安装-Hexo-命令行工具"><a href="#0x03-安装-Hexo-命令行工具" class="headerlink" title="0x03 安装 Hexo 命令行工具"></a>0x03 安装 Hexo 命令行工具</h2><p><a href="http://hexo.io/">Hexo</a> 官网地址：<a href="http://hexo.io/">http://hexo.io/</a></p><p>官网上有非常简单的 Hexo 安装教程，我们通过命令行就能够很轻松的安装 Hexo 命令行工具。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/b2db9e9c9c6c190948714914d7ff2b82-9099e9.png" alt="image-20201011145841527"></p><p>输入 <code>npm install hexo-cli -g</code> 即可</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/89d9d2ba1ff5a88f96fea4a44c0c6841-95ac35.png" alt="image-20201011145955879"></p><p>输入 <code>hexo --version</code> 查看 Hexo 命令行工具版本号即可验证</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/07f79ad66e1d7f6ba07196c12860fc7a-f398df.png" alt="image-20201011150057537"></p><h2 id="0x04-初始化博客项目"><a href="#0x04-初始化博客项目" class="headerlink" title="0x04 初始化博客项目"></a>0x04 初始化博客项目</h2><p>找一个用来存放代码的目录，我们这里就假设在桌面上了，右键打开 “Git Bash Here” ，然后输入 <code>hexo init blog</code> ，这样就可以在桌面上新建一个 blog 的文件夹，里面将保存我们博客项目。当然，我们在输入命令之前要保证说面上没有名为 blog 的文件夹。</p><pre><code>$ hexo init blogINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitINFO  Install dependencies...INFO  Start blogging with Hexo!</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/3d55ddc83d23241c128776b9362f36b9-228ea0.png" alt="image-20201011150603525"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/d434d7fa46e92e66cb850f9e19d4b80e-6c06ae.png" alt="image-20201011150625635"></p><p>验证一下，接下来 <code>cd blog</code> 进入项目文件夹，然后 <code>ls</code> 查看有哪些文件。</p><pre><code>ismdeep@ISMDEEP1471 MINGW64 ~/Desktop$ cd blogismdeep@ISMDEEP1471 MINGW64 ~/Desktop/blog$ ls_config.yml    package.json       scaffolds/  themes/node_modules/  package-lock.json  source/</code></pre><h2 id="0x05-本地预览博客网站"><a href="#0x05-本地预览博客网站" class="headerlink" title="0x05 本地预览博客网站"></a>0x05 本地预览博客网站</h2><p>在博客目录中输入命令 <code>hexo server</code> 则可以启动本地预览服务器。</p><pre><code>$ hexo serverINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><p>然后就可以打开浏览器，输入 <code>http://localhost:4000</code> 预览我们的博客了。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/f3743f6e82bf7ff5afa717c6d68c883e-bbaf4b.png" alt="image-20201011151121686"></p><h2 id="0x06-开始写第一篇博客"><a href="#0x06-开始写第一篇博客" class="headerlink" title="0x06 开始写第一篇博客"></a>0x06 开始写第一篇博客</h2><p>通过命令 <code>hexo new 博客名称</code> 就可以新建一篇博客了，博客名称不要带空格。</p><p>例如我们现在要写一篇记录咱们第一次学 Python 的文章，名称就可以是 《Python入门第一天》，那对应命令可以如下：</p><pre><code>ismdeep@ISMDEEP1471 MINGW64 ~/Desktop/blog$ hexo new &quot;learn-python-day-1&quot;INFO  Validating configINFO  Created: ~\Desktop\blog\source\_posts\learn-python-day-1.md</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/b7adbf68c6f9d65f1c5dfb9e9504d56c-996843.png" alt="image-20201011151709887"></p><p>新建的文件将存放到博客项目的 <code>source/_posts</code> 文件夹中。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/c38023a42e2479067ea1db696940ee66-e0dcdc.png" alt="image-20201011151821424"></p><p>那么接下来就可以开始写博客了。这里推荐一款编写 Markdown 文档的软件：<a href="https://typora.io/">Typora</a></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/74e9ba95cf92f88f72067b8c3817f216-cca7dc.png" alt="image-20201011152801397"></p><p>编写完文档，我们则可以通过本地预览服务器预览文章了。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/47a7cbe0e59b5c8ff128e940f3004cf0-77ada3.png" alt="image-20201011152941704"></p><h2 id="0x07-Hexo-主题安装"><a href="#0x07-Hexo-主题安装" class="headerlink" title="0x07 Hexo 主题安装"></a>0x07 Hexo 主题安装</h2><p>Hexo 社区非常活跃，这也是 Hexo 得以如此火热的原因之一，有了活跃的社区，就有更多的人贡献代码去增加功能、修复bug，还有更多的人去做主题供大家参考。Hexo 主题可以在 <a href="https://hexo.io/themes/">https://hexo.io/themes/</a> 中进行预览，通过预览，找到你喜欢的主题，然后点击主题链接，看看主题开发者的安装文档。不过大部分都差不多，所以安装主题比较简单的。</p><p>主题与文章分离的思想是非常重要的，博主写作时不需要考虑主题是什么样子的，只需要专注于文章内容本身。</p><h2 id="0x08-注册-GitHub-账号"><a href="#0x08-注册-GitHub-账号" class="headerlink" title="0x08 注册 GitHub 账号"></a>0x08 注册 GitHub 账号</h2><p>本文搭建博客最终博客站点是托管在 GitHub 上的，为什么会选择 GitHub 呢？因为 GitHub 是全球最大的开源社区，其稳定性自然没啥质疑的。往往最大的 DDoS 攻击也是发生在针对 GitHub 上的，毕竟承受能力不行的估计连小几个数量级的 DDoS 流量攻击都顶不住。那好，既然我们博客要托管在 GitHub 上，自然就需要一个 GitHub 账号。</p><p>首先，我们打开 GitHub 官网：<a href="https://github.com/">https://github.com</a></p><p>在打开 GitHub 官网之后，右上角能够看到两个按钮 “Sign in” 和 “Sign up” ，分表表示 “登录” 与 “注册”。通过右上角 “Sign up” 即可进入注册页面。</p><p>注册非常简单，首先选择你的用户名，咱们程序员应该都有自己的 ID，也称之为昵称。比如：笔者昵称就是 ismdeep . 在注册很多网站时候都会选择这个昵称。而我们注册的昵称也会决定我们博客的地址: 昵称.github.io ，比如笔者的就是 ismdeep.github.io ，至于这个博客想要绑定自己的域名，这以后再写文章进行说明。</p><p>注册账号的页面既然都打开了，怎么注册的事情就再简单不过了吧。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/1bfcb13456a4c27abe1fd0935159f4f0-da8b6e.png" alt="image-20201011144726780"></p><p>注册账号后有可能需要前往注册的邮箱进行一番验证。</p><p><strong>注⚠️：有的邮箱可能会把邮件丢到垃圾箱中，请注意查收。</strong></p><p>验证了邮箱之后，咱们就可以通过 GitHub 首页上的 “Sign in” 进行登录了。</p><h2 id="0x09-创建-GitHub-Repository"><a href="#0x09-创建-GitHub-Repository" class="headerlink" title="0x09 创建 GitHub Repository"></a>0x09 创建 GitHub Repository</h2><p>登录了 GitHub 之后，右上角有一加号➕，我们可以通过此处来新建一个 Repository。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/2157d35b338456926d728e6d99e957f0-78ddec.png" alt="image-20201011145133956"></p><p>即进入如下页面：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/10/11/d614ff77291f4259ebf94ad917caa31a-83c736.png" alt="image-20201011145602807"></p><h2 id="0x0a-配置博客项目并关联-GitHub-Repository"><a href="#0x0a-配置博客项目并关联-GitHub-Repository" class="headerlink" title="0x0a 配置博客项目并关联 GitHub Repository"></a>0x0a 配置博客项目并关联 GitHub Repository</h2><p>编辑博客项目文件夹中的 <code>_config.yml</code> 文件，在文件末尾处可以找到 <code>deploy</code> 配置项，我们对其进行编辑。笔者设置如下，各位可按照自己的实际情况进行设置。配置文件编辑推荐用 Sublime Text 3</p><pre><code>deploy:  type: &#39;git&#39;  repository: http://github.com/ismdeep/ismdeep.github.io.git  branch: master</code></pre><p>那接下来就可以在博客项目中通过以下两个命令进行生成静态网站并发布了。</p><pre><code>hexo generatehexo deploy</code></pre><p>提示：Hexo 命令都有简化版本，比如以上两个可以简化为</p><pre><code>hexo ghexo d</code></pre><h2 id="0x0b-访问并分享博客网站"><a href="#0x0b-访问并分享博客网站" class="headerlink" title="0x0b 访问并分享博客网站"></a>0x0b 访问并分享博客网站</h2><p>通过以上命令发布了博客，就可以访问了。笔者网址是 <a href="https://ismdeep.github.io/">https://ismdeep.github.io</a> 各位可根据自己用户名称来确定网址是啥。</p><p><strong>注意⚠️：</strong>由于从 GitHub Repository 到 GitHub Page 同步需要一定的时间，所以博客发布之后并不会非常快的就能看到效果，可能需要等一段时间，大概一两分钟即可，不会等太久的。</p><h2 id="0x0c-总结"><a href="#0x0c-总结" class="headerlink" title="0x0c 总结"></a>0x0c 总结</h2><p>写博客是一件百利无一害的事情，通过写博客，可以锻炼总结能力、向他人传授知识的能力、写作能力等等。通过本文，我们学会了自己从零搭建一个博客的所需要的所有技能。如在阅读本文中遇到任何无法理解的地方，请发邮件给我，我将耐心解答。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C程序设计语言000000000基础入门</title>
      <link href="/posts/2020-09-21-c-language-for-beginners.html"/>
      <url>/posts/2020-09-21-c-language-for-beginners.html</url>
      
        <content type="html"><![CDATA[<p>这是一篇C语言程序设计入门的教程，我寄希望于通过这篇简单的入门教程让你理解C语言以及程序设计基础。或许有人会嘲笑我，人家最短的C语言入门也得21天，你怎么就能够通过一篇文章，讲透C语言呢？emmm，话说我这里想要讲的是C语言的基本用法。有些功能会很简单，而不去过多的牵扯太多语法上的细节。</p><h2 id="一、写在前面的话"><a href="#一、写在前面的话" class="headerlink" title="一、写在前面的话"></a>一、写在前面的话</h2><p>这篇文章可以算是学习 C 语言的一个引子，不太明白的地方可以发送邮件至笔者邮箱，笔者将通过邮件方式进行回复，或者更新博客文章以更加详细的完善本文。<strong>本文尽量做到语言简洁明了，通俗易懂。</strong>正因为如此，一些概念上的描述应该会与教科书不同。</p><h2 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h2><h3 id="2-1-什么是程序设计？"><a href="#2-1-什么是程序设计？" class="headerlink" title="2.1 什么是程序设计？"></a>2.1 什么是程序设计？</h3><p>让我们先从<strong>程序设计</strong>开始说起吧。说起程序设计，一个最简单，也是大家应该都听说过的例子就是：“如何将大象放进冰箱。” 这个例子就是一个程序设计的问题。那么以下我们给出部分网友给出的方法：</p><pre><code>1. 打开冰箱门2. 将大象放进冰箱3. 关上冰箱门</code></pre><p>从上面这个例子，我们能够看出：<strong>程序</strong>就是将一系列<strong>具体明确</strong>的动作按照<strong>规定好的顺序</strong>依次执行。这里我们给出了程序的两个特点：1. 动作具体明确；2. 动作执行具有一定的顺序。</p><p><strong>解释一下：</strong></p><ol><li><strong>动作具体明确：</strong>网络上经常开玩笑说程序员都是钢铁直男。确实，不得不说，程序员在有些时候遇到问题就是这个样子的，因为程序员每天的日常工作都是跟计算机打交道，程序员需要将<strong>需求</strong>（需要完成的任务、实现的功能）转化成计算机可以执行的程序代码，而由于计算机只能够执行一些非常简单且动作明确的指令。（比如：计算1+2的结果等等。）日常工作导致了我们程序员在思考问题的时候容易具有这样的特点。当然，大部分程序员在工作以外，也还是会比较懂情调的，不会显得那么木讷。</li><li><strong>规定好的顺序</strong>：什么叫规定好的顺序呢？就像上面的例子中，只有先打开冰箱门这个动作完成了之后，才能将大象放进冰箱，当执行完将大象放进冰箱这个动作后，最后才能去关上冰箱门。这样的例子现实生活中到处都是。（比如：在某宝上购物，你首先需要打开某宝APP，然后找到想要购买的商品，接着下单，付款，在付款之后卖家收到商品购买通知，卖家才会发货。）</li></ol><p>以上两点，是笔者对于学习程序设计的人们一个最基本的思维要求。也就是要求大家在设计程序的时候要想清楚：程序里哪些动作是具体明确的，哪些动作先执行，哪些动作后执行。</p><p>那么，讲了这么多我们还是没有讲到程序设计到底是个啥。这里我们要说的是计算机编程中的程序设计，<strong>程序设计</strong>是指通过计算机编程语言设计一个让计算机按照<strong>规定好的顺序</strong>执行<strong>动作具体明确</strong>的指令以帮助我们解决问题。</p><h3 id="2-2-什么是-C-语言？"><a href="#2-2-什么是-C-语言？" class="headerlink" title="2.2 什么是 C 语言？"></a>2.2 什么是 C 语言？</h3><p>那么，什么是<strong>C语言</strong>呢？C语言就是一种计算机语言。因为计算机只能够执行由01组成的二进制机器指令，而直接用01直接编写计算机能够执行的机器代码，对人类来说是一件非常困难的事情，于是人们设计了各种各样的程序设计语言帮助人们编写计算机程序，然后将人们根据该语言<strong>规定好的语法规则</strong>写出来的程序代码转化成计算机可以直接执行的机器代码。而C语言则是这些设计出来帮助大家编写程序的计算机程序设计语言中的一种。</p><p>每种语言都会有自己<strong>规定好的语法规则</strong>，这也就意味着，如果你不按照规定好的语法规则去编写代码的话，那么该语言的<strong>编译器</strong>或者<strong>解释器</strong>则不能够将代码转化为机器能够执行的机器代码，即：编译失败！！！所以，学习程序设计语言，一定要记住该语言的语法规则。</p><h2 id="三、C-语言程序设计环境安装"><a href="#三、C-语言程序设计环境安装" class="headerlink" title="三、C 语言程序设计环境安装"></a>三、C 语言程序设计环境安装</h2><p>环境安装部分，大家可以执行网上寻找解决方案。</p><p>Windows 上笔者推荐 “MinGW + Sublime Text 3 + 命令行” 的方式。</p><p>macOS 和 Linux 上环境则简单一些，应该都是可以直接使用 gcc 编译器的。</p><h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><p>计算机处理数据都是01的二进制数据，但是我们在进行程序设计的时候，遇到的各种问题，我们会需要特定的数据类型来表示我们的数据。比如：在计数的时候我们需要用到整数；在处理金额数值的时候我们需要用到小数；在处理文本内容的时候我们需要用到字符串；等等。</p><p>接下来我们对数据类型进行分类：</p><p>整型：<code>int</code></p><p>浮点类型：<code>float</code>, <code>double</code></p><p>字符类型：<code>char</code></p><p>空类型：<code>void</code></p><p>以上是我们最常见的数据类型。</p><p>类型是用来对变量进行描述的。比如：我们要创建一个变量用来存放计数器的数值信息，则我们可以通过 <code>int count;</code> 来<strong>声明</strong>这个<strong>变量</strong>。（变量就是存放在内存中的一个名称标记，不然怎么才能知道内存应该保存在哪里、从哪里取这个数值呢？变量之所以称之为变量，是因为其值是可以改变的，我们可以通过程序指令对其存储的值进行修改。与变量相对还有叫<strong>常量</strong>，其值是不可以改变的，常量的作用是用来便于表示代码中一些特定的数值的。）</p><p>常量的作用。比如粉红色对应的RGB的值是<code>255,192,203</code>，其对应十六进制值就是<code>#FFC0CB</code>，在程序中出现这样的数值，我们称之为<strong>魔法数字</strong>。那么如果程序员直接在程序中给一个变量赋值为粉红色的值的话，代码 <code>color_val = 0xFFC0CB;</code> 则显得不方便阅读。于是我们可以通过宏定义去定义常量并在需要使用的地方去使用：</p><pre><code class="c">#define COLOR_PINK 0xFFC0CB...color_val = COLOR_PINK;</code></pre><p>对了，这里有一点要明白的：变量只有在<strong>声明</strong>了之后才可以使用。如：</p><pre><code class="c">int count;count = 0;count = count + 1;printf(&quot;%d\n&quot;, count);</code></pre><p>以上四行代码依次为：</p><ol><li>声明 <code>int</code> 类型的变量 <code>count</code> ; </li><li>对 <code>count</code> 类型赋值为 <code>0</code> ; </li><li>将 <code>count</code> 的值增加<code>1</code>;</li><li>输出 <code>count</code> 的值。</li></ol><h2 id="五、控制流"><a href="#五、控制流" class="headerlink" title="五、控制流"></a>五、控制流</h2><p>程序设计的控制流即控制程序执行的顺序。三大控制流：<strong>顺序结构</strong>、<strong>选择结构</strong>、<strong>循环结构</strong>。这部分知识点的难点在于理解循环结构。</p><p><strong>顺序结构</strong>：程序按照代码排列的顺序从上到下依次执行。比如：</p><pre><code class="c">x = 4;y = x * x;</code></pre><p>以上例子先执行 <code>x = 4</code>; 然后执行 <code>y = x * x;</code> </p><p>这部分非常容易理解，对吧。</p><p><strong>选择结构</strong>：通过判断来决定程序接下来执行哪部分代码块。比如：</p><pre><code class="c">if (表达式)&#123;    语句块1;&#125;</code></pre><p>解释：程序执行到 <code>if</code> 这个部分时，先执行表达式进行判断，如果判断成立则执行里面的”语句块1”，然后从 <code>&#125;</code> 后继续执行；否则直接从 <code>&#125;</code> 后面继续执行。</p><p><strong>循环结构：</strong> 通过循环结构来让程序不断执行某一部分代码，直到达到某种条件并跳出此结构。循环结构控制有：<code>while</code>, <code>do~while</code>, <code>for</code> 三种。</p><p>以上我们说的顺序结构和选择结构，其对应的每一条语句都只能够执行一次，然后程序就继续往后面的执行了。我们一起来思考一个问题，假如我们要计算 <code>1+2+3+4+5</code> 这样的问题，当然这里不考虑等差数列公式哈：）。那么我们在没有循环的情况下，代码应该是下面这样的：</p><pre><code class="c">int sum;sum = 0;sum += 1;sum += 2;sum += 3;sum += 4;sum += 5;</code></pre><p>这还是少的，那如果是 <code>1+2+3+...+20000</code> 呢？你还能愉快的写代码吗？我看不能！而且，当我最后这个是个变量呢？因为我想让这个程序更加通用，让这个程序允许用户输入一个数字，然后计算从 1 开始加一直加到这个数字的和。</p><p>那么这里我们就可以通过 <code>while</code> 语句来解决以上问题：</p><pre><code class="c">int sum, i;sum = 0;i = 1;while (i &lt;= 5)&#123;    sum += i;    i++;&#125;</code></pre><p>解释一下以上的 <code>while</code> 结构，当程序执行到 <code>while</code> 时，程序接下来对 <code>i &lt;= 5</code> 部分进行判断，如果成立则执行 <code>&#123;&#125;</code> 里面的，在执行完 <code>&#123;&#125;</code> 里面的跳回 <code>while</code> 这个地方；否则，直接从 <code>&#125;</code> 后面开始执行。好，我们来执行一下程序看看：</p><pre><code>1: sum = 0;2: i = 1;3: i &lt;= 5? 成立4: sum += i; (sum值为1)5: i++; (i值为2)6: i &lt;= 5? 成立7: sum += i; (sum值为3)8: i++; (i值为3)9: i &lt;= 5? 成立10: sum += i; (sum值为6)11: i++; (i值为4)12: i &lt;= 5? 成立13: sum += i; (sum值为10)14: i++; (i值为5)15: i &lt;= 5? 成立16: sum += i; (sum值为15)17: i++; (i值为6)18: i &lt;= 5? 不成立19: 执行 &#125; 后面的代码</code></pre><p>跟着以上步骤执行一下，我觉得差不多应该明白循环结构 <code>while</code> 是怎么执行的了。</p><p>那么 <code>do~while</code> 结构呢？由于我们并不常用到它，所以这里就不再过多去浪费篇幅去说了。</p><p>接下来我们重点讲一讲 <code>for</code> 结构。其实 <code>for</code> 跟 <code>while</code> 是一样的。<code>for</code> 算是对 <code>while</code> 结构的改进。我们下面的代码，再来对比地看一下上面 <code>while</code> 写的代码。我们发现，其实就是将 <code>i = 1</code> 和 <code>i++</code> 这两个语句放到 <code>for</code> 整个大括号里面去了。而这两个程序执行的过程是完全一样的。笔者把<code>for</code> 结构理解成三个部分  <code>for (初始;条件;自增)</code> 。这也是控制一个循环结构的三个要素，进入循环之前，我们需要设置一些变量的初始值；然后控制条件，再满足条件的情况下让循环里面的 <code>&#123;&#125;</code> 代码块部分执行，然后不断通过 “自增” 去改变变量的值，直至变量在条件判断的时候不成立，使得程序跳出循环结构。</p><pre><code class="c">int sum, i;sum = 0;for (i = 1; i &lt;= 5; i++)&#123;    sum += i;&#125;</code></pre><p><strong>注：</strong>学习循环结构的时候，一定要注意循环变量开始值和终止值，也就是从哪个值开始，到那个值结束。</p><h2 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h2><p>现实生活中就有很多关于数组的例子，比如：名单，购物列表，成绩单，等等。将一些具有同样属性类型的元素按照一定的顺序放在一起，就构成了一个列表，也就是数组了。对于数组的声明，我们需要三个要素：<strong>数组存储数据元素的类型</strong>、<strong>数组名称</strong>、<strong>数组大小</strong>。声明数组的格式为：</p><pre><code class="c">类型 名称[大小];</code></pre><p>比如一个班级一次数学考试的成绩（假设成绩都是整数），班级有50位学生，那么用于存储学生成绩的数组则可以如下声明：</p><pre><code class="c">int math_score[50];</code></pre><p>那么对于数组中元素应该如何引用呢？看下文中的例子就明白了：</p><pre><code>math_score[0] = 100; // 对 math_score 这个数组中，下标为 0 的元素，赋值为 100val = math_score[1]; // 将 math_score 这个数组中，下标为 1 的元素的值取出来，赋值给 val 这个变量</code></pre><p>这里有一点需要交待一下的，也是数组中非常重要的一点，那就是：<strong>数组的引用下标是从 $0$ 开始的</strong>。也就是说数组第一个元素，应该是下标为 $0$ 的元素，即 <code>math_score[0]</code> ，那么对于上面声明的这个数组来说，可用的下标元素就有：</p><p><code>math_score[0]</code>, <code>math_score[1]</code>, <code>math_score[2]</code>, … , <code>math_score[48]</code>, <code>math_score[49]</code></p><p>这个部分关于数组下标的内容是比较<strong>重要</strong>的，需要花时间去理解的，这跟我们日常计数有点不一样。</p><p>下面我们来写一个例子：从键盘上输入 10 个整数到一个数组中，并计算这些数字的总和。</p><pre><code class="c">#include &lt;stdio.h&gt;int main() &#123;    int a[10];    int sum = 0;    /* 1. 输入 10 个整数，请注意循环中 i 的初始值以及终止值 */    for (int i = 0; i &lt; 10; i++) &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    /* 2. 通过循环将每个元素的值累加到 sum 上 */    for (int i = 0; i &lt; 10; i++) &#123;        sum += a[i];    &#125;    /* 3. 输出累加结果 */    printf(&quot;%d\n&quot;, sum);    return 0;&#125;</code></pre><p>从上面的例子中，我们可以看到，有了循环操作，数组才变得更加灵活。</p><h2 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h2><p>函数，是一个数学的概念。比如：$f(x) &#x3D; x^2$ 就是一个函数。这是一个抽象的概念，是一个统一概括的概念。当然，我们都知道这是一个计算平方值的函数，当我们说到这个函数的时候，我们并没有说这是计算某个值的平方值。这时我们就是一个统一概括的概念，表示这个函数具有计算某一类数值平方值的功能。当我们计算 $10$ 的平方的时候，也就是 $f(10)$ 时，这时就是我们去调用这个函数进行计算的一个过程了。</p><p>在 C 语言中，函数会非常的常见，我们可以通过函数，将各种各样的操作抽象出来，然后去描述我们所要解决的那些问题。比如计算平方值。在定义一个函数的时候，我们需要知道这个函数所拥有的几个属性：<strong>函数参数</strong>，<strong>函数返回值是什么类型的</strong>，<strong>函数的名称</strong>。</p><p>我们可以从下面这个例子来看一下函数定义是什么样子的。</p><pre><code class="c">int f(int x) &#123;    return x * x;&#125;</code></pre><p>其实，函数本质上就是一个代码片段，这个代码片段是从哪里开始的呢？答案是：从函数参数开始的，当我们调用这个函数的时候，就会从函数参数部分开始执行，将我们调用函数所使用的参数，将值给函数代码片段的 <code>x</code> . 然后开始执行……</p><p>所以，函数就是一个代码片段，当你调用这个函数的时候，这部分代码才会开始执行，最后将执行的结果返回给你。当你调用 <code>f(10)</code> 这部分最终会返回 $100$ 给你，当你调用 <code>f(8)</code> 则会返回 $64$ 给你。</p><p>那我们接下来看下一个例子：计算一组整数的和</p><pre><code class="c">int calc_arr_sum(int a[], int n) &#123;    int sum = 0;    for (int i = 0; i &lt; n; i++) &#123;        sum += a[i];    &#125;    return sum;&#125;</code></pre><p>对于这样一个函数，需要两个参数，数组 <code>a</code> 的名称 和 数组大小值。<strong>因为函数传输过来的是数组 <code>a</code> 的首地址，而这个地址中并不包含这个数组有多大的信息，所以需要另一个参数值来传输数组大小的信息。</strong></p><p>那么我们在数组这一节最后的例子就可以用以下完整代码来编写了：</p><pre><code class="c">#include &lt;stdio.h&gt;int calc_arr_sum(int a[], int n) &#123;    int sum = 0;    for (int i = 0; i &lt; n; i++) &#123;        sum += a[i];    &#125;    return sum;&#125;int main() &#123;    int a[10];    int sum = 0;    /* 1. 输入 10 个整数，请注意循环中 i 的初始值以及终止值 */    for (int i = 0; i &lt; 10; i++) &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    /* 2. 调用计算数组元素和的函数进行计算 */    sum = calc_arr_sum(a, 10);    /* 3. 输出累加结果 */    printf(&quot;%d\n&quot;, sum);    return 0;&#125;</code></pre><p><strong>注意：</strong>这里 <code>main()</code> 函数和 <code>calc_arr_sum()</code> 两个函数中的 <code>a</code> 并不是同一个，在 <code>calc_arr_sum()</code> 函数中的 <code>a</code> 是一个抽象的概念，并不是具体的哪一个数组，我们在编写这个函数的时候也是假设其为任意数组而已，很多教材上称之为<strong>形式参数</strong>。而在 <code>main()</code> 函数中的 <code>a</code> 则是通过具体的声明的，这里面存储着从键盘输入的 10 个数值，很多教材上称之为<strong>实际参数</strong>。这部分内容需要着重去理解，理解函数参数中的变量名称的意义。</p><h2 id="八、指针"><a href="#八、指针" class="headerlink" title="八、指针"></a>八、指针</h2><p>这部分内容是很多初学者最为头大的部分了。</p><h2 id="九、C语言编程练习题"><a href="#九、C语言编程练习题" class="headerlink" title="九、C语言编程练习题"></a>九、C语言编程练习题</h2><p>敬请期待……</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> C </tag>
            
            <tag> Development </tag>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给小白的 Markdown 入门教程</title>
      <link href="/posts/2020-09-17-introduction-to-markdown-for-beginners.html"/>
      <url>/posts/2020-09-17-introduction-to-markdown-for-beginners.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 客户端工具</title>
      <link href="/posts/2020-09-11-redis-client-tools.html"/>
      <url>/posts/2020-09-11-redis-client-tools.html</url>
      
        <content type="html"><![CDATA[<p>Redis 在开发工作中的地位变得越来越重要了，作为开发者，日常对 Redis 数据进行操作也更加的频繁，不知道各位在日常操作 Redis 时都用着哪些工具呢？</p><p>本文将介绍几款非常优秀的 Redis 客户端工具&#x2F;软件，以供大家参考。</p><h2 id="1-IRedis-命令行工具"><a href="#1-IRedis-命令行工具" class="headerlink" title="1. IRedis 命令行工具"></a>1. IRedis 命令行工具</h2><p>笔者以前使用工具更加偏向命令行工具，命令行工具都具有轻量、操作速度快、简洁等功能。</p><p>此处要介绍的便是一款命令行使用的 Redis 工具：<a href="https://iredis.io/">IRedis</a></p><p>附上这个工具的官网网址，喜欢用命令行的朋友可以去试一试，绝对能让喜欢命令行的你爽的飞起来。</p><blockquote><p><a href="https://iredis.io/">https://iredis.io</a></p></blockquote><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/fe0161d38631a13f61b0cdd132dd482f-38b049.svg"></p><h2 id="2-Redis-Desktop-Manager"><a href="#2-Redis-Desktop-Manager" class="headerlink" title="2. Redis Desktop Manager"></a>2. Redis Desktop Manager</h2><p>这个工具应该是现在使用率最广的可视化工具了。存在时间很久。经过了数次迭代。跨平台支持。以前是免费的，现在为收费工具。试用可以有半个月的时间。链接为：</p><blockquote><p><a href="https://redisdesktop.com/">https://redisdesktop.com/</a></p></blockquote><p><strong>评测：</strong></p><p>之前用觉得功能还行，就是界面UI丑了点。最近下了最新版，感觉经过了那么长时间迭代，界面看着也还凑合。该有的功能都有。界面看着比较简洁，功能很全。</p><p>key的显示可以支持按冒号分割的键名空间，除了基本的五大数据类型之外，还支持redis 5.0新出的Stream数据类型。在value的显示方面。支持多达9种的数据显示方式。</p><p>命令行模式也同以前有了很大的进步，支持了命令自动提示。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/7dd64b3ff2cacf02d1fa5c2270da4c71-3c27ca.png" alt="img"></p><h2 id="3-medis"><a href="#3-medis" class="headerlink" title="3. medis"></a>3. medis</h2><p>现阶段我使用率最高的redis可视化工具。界面符合个人审美。布局简洁。跨平台支持，关键是免费。链接为：</p><blockquote><p><a href="http://getmedis.com/">http://getmedis.com/</a></p></blockquote><p><strong>评测：</strong></p><p>颜值挺高，功能符合日常使用要求。对key有颜色鲜明的图标标识。在key的搜索上挺方便的，可以模糊搜索出匹配的key，渐进式的scan，无明显卡顿。在搜索的体验上还是比较出色的。</p><p>缺点是不支持key的命名空间展示，不支持redis 5.0的stream数据类型，命令行比较单一，不支持自动匹配和提示。支持的value的展现方式也只有3种。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/2f055c12db25d8248ba7346de19071c2-62f15e.png" alt="Medis"></p><h2 id="4-AnotherRedisDesktopManager"><a href="#4-AnotherRedisDesktopManager" class="headerlink" title="4. AnotherRedisDesktopManager"></a>4. AnotherRedisDesktopManager</h2><p>一款比较稳定简洁的redis UI工具。链接为：</p><blockquote><p><a href="https://github.com/qishibo/AnotherRedisDesktopManager">https://github.com/qishibo/AnotherRedisDesktopManager</a></p></blockquote><p><strong>评测：</strong></p><p>很中规中矩的一款免费的redis可视化工具，基本的功能都有。有监控统计，支持暗黑主题，还支持集群的添加。</p><p>缺点是没什么亮点，UI很简单，不支持stream数据类型。命令行模式也比较单一。value展示支持的类型也只有3种。</p><p><img src="https://camo.githubusercontent.com/0eab991c8dc2a2c50909dd48f2cc82540ce41a14/68747470733a2f2f696d6775702e7169693430342e78797a2f6769746875622f32303230303331333134313634312e6a7067" alt="redis status dark"></p><h2 id="5-FastoRedis"><a href="#5-FastoRedis" class="headerlink" title="5. FastoRedis"></a>5. FastoRedis</h2><p>FastoRedis之前没听到过。然后去下了体验了下。</p><p>使用这款工具首先得去官网注册账号。这款软件是收费软件，虽然跨平台，但是试用只有一天的时间。链接为：</p><blockquote><p><a href="https://fastoredis.com/">https://fastoredis.com/</a></p></blockquote><p><strong>评测：</strong></p><p>毕竟是收费软件，虽然界面一股浓浓的windows风格，乍看上去有点像redis desktop manager，但是就功能而言。确实不错，支持了集群模式和哨兵模式，key的命名空间展示，redis 5.0的stream数据类型也支持。</p><p>命令行模式支持自动提示补全</p><p>value的显示支持树状，表格状等等显示方式。令我惊讶的是，值对象支持多达17种渲染方式</p><p>总的来说，除了界面UI交互略生硬，还有是一款收费软件之外，还是一款很不错的redis可视化工具。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/29a72f19f6f8489588b203ab06379545-aa4776.png" alt="img"></p><h2 id="6-RedisPlus"><a href="#6-RedisPlus" class="headerlink" title="6. RedisPlus"></a>6. RedisPlus</h2><p>一款开源的免费桌面客户端软件链接：</p><blockquote><p><a href="https://gitee.com/MaxBill/RedisPlus">https://gitee.com/MaxBill/RedisPlus</a></p></blockquote><p><strong>评测：</strong></p><p>没什么亮点，也就基本功能。加分项可能也就是有一个监控。其他的都很普通 。甚至于这款软件连命令行模式都没有。用的是javafx开发，按道理说，应该是跨平台的软件 ，但是提供的下载地址，并没有mac的直接安装包。况且就算是跨平台的吧。</p><p>⚠️：该软件作者表示不再更新迭代。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/5ba1d33270f127eb0b33e7f961fbc358-7559f8.jpeg" alt="img"></p><h2 id="7-Red"><a href="#7-Red" class="headerlink" title="7. Red"></a>7. Red</h2><p>这是一款在苹果app store下载的redis可视化工具。</p><p><strong>评测：</strong></p><p>只支持Mac端，颜值还是不错的。功能中规中矩。基本功能都有，支持key命名空间的展示。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/7b426d4f2eec503d18b5e9b5baacab35-296f1d.png" alt="image-20200911160733359"></p><h2 id="8-Redis-Insight"><a href="#8-Redis-Insight" class="headerlink" title="8. Redis Insight"></a>8. Redis Insight</h2><p>这个软件来头挺大的，是redis labs出的一款监控分析级别的redis可视化工具。这款软件是web版的</p><p>那redis labs是啥公司，redis labs创立于2011年，公司致力于为Redis、Memcached等流行的NoSQL开源数据库提供云托管服务。可以算是专门致力于redis云的一家专业公司。他们的提供的软件中，除了可以连接企业私有的redis服务，也可以连接他们的redis云。链接：</p><blockquote><p><a href="https://redislabs.com/redisinsight/">https://redislabs.com/redisinsight/</a></p></blockquote><p><strong>评测：</strong></p><p>虽然是web版本，但是这个软件超越了我对redis可视化工具的认识，一看界面就觉得很专业，不像是个人开发出来的开源产品。我发现key的查询和浏览只是这里的一个功能模块而已。</p><p>命令行方面：除了有命令补全提示，右边还有相关命令的文档解释。怎么样，是不是超人性化呢？</p><p>同样支持redis 5.0的Stream数据类型</p><p>下面的三个功能，是需要在server端安装他们家的其他redis模块的。分别是可查询的图表，redis的时间序列展示和全文本查询功能。</p><p>最牛的是，redisInsight竟然还支持rdb的分析功能，之前分析rdb的存储分布，有点经验的都会用rdb-tools去分析。而redisInsight竟然把这个都集成进去了。我之前用这个分析了公司生产环境的rdb，找出了导致数据量增长过快的原因，简直是一个神器。</p><p>这是我上次利用这个软件分析rdb出来的结果。很明确的找到了哪个key占据内存过大。</p><p>在分析功能中的Profiler能监听一段时间内所有执行的redis命令 ，Slowlog能显示出执行比较慢的redis命令。</p><p>除此之外，这个软件还能批量操作。</p><p>RedisInsight这个可视化工具对redis的覆盖之全面令人咋舌。虽然他的查询key的功能算不上优秀，但是他的全面性和分析监控方面，确实是其他redis可视化工具难以企及的，况且颜值还那么高，强烈推荐。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/a5d1a8f73183fd8ef963b841ae3cbbc1-984f65.png" alt="img"></p><h2 id="9-Iedis2"><a href="#9-Iedis2" class="headerlink" title="9. Iedis2"></a>9. Iedis2</h2><p>Iedis是一款基于IntelliJ IDEA的插件，在IDEA的plugin市场里就可以搜到，但是为收费插件，可试用7天。</p><p><strong>评测：</strong></p><p>作为IDEA的插件，当然是跨平台的，风格完全遵从于IDEA，颜值有保障。从功能上来说，Iedis也是不含糊。基本查询功能基本上挑不出毛病。加上IDEA的使用习惯，让你用起来得心应手，不需要另外打开软件。在代码和插件窗口中切换也是能提高效率的。</p><p>这个插件最大的特点就是能支持lua脚本的编写和调试，这在其他软件中是不曾看到的。以前在一个业务中大量用了lua进行redis操作，虽然尝到了redis lua原子性和性能上的甜头，但是在编写调试的时候，那叫一个痛苦，因为不能在debug所以每次都需要返回一个值来检查是哪里出了错。看到这个工具，悔恨没早点发现这个插件，付费也愿意。</p><p>这个插件还能支持慢命令的查看。</p><p>总的来说，Iedis除了需要付费，其他的一切都看上去很美好。价格是$139&#x2F;年。还是美元，看到这个价格，是不是长叹一口气呢。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/66c72f54001138e6855dbc4f363832f4-552058.png" alt="Screenshot 1"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/09/11/e9630f2d0f9cdf62494d367cce576fa0-96cad4.png" alt="Screenshot 2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单比特翻转的文件加密程序</title>
      <link href="/posts/2020-08-10-naive-file-encryption-program-with-just-bit-flipping-process.html"/>
      <url>/posts/2020-08-10-naive-file-encryption-program-with-just-bit-flipping-process.html</url>
      
        <content type="html"><![CDATA[<p><strong>注意⚠️：</strong>本文中所提简单比特翻转加密算法，严格意义上来说不能视为加密算法，或者说只能算作是广义上的加密算法，而不能称之为现代加密算法。当然也不能够满足现代密码学所需要的加密算法安全性能要求。</p><p>事情是这样的，春节期间一位小伙伴发来消息说不太理解加密算法。于是我想用这样一个超级简单的程序来讲讲加密算法的大致过程。那么在我们日常生活中，通过软件对文件进行加密和解密应该算是最容易理解的过程吧。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/10/c2d99422a26bf48c08faf4452ca9dc17-7d52f0.png" alt="encrypt-file-diagram"></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define BUF_SIZE 1024void help_msg() &#123;    printf(&quot;Usage: bit-flipping-encrypt $&#123;source_path&#125; $&#123;destination_path&#125;&quot;);&#125;int main(int argc, char *argv[]) &#123;    if (argc &lt; 3) &#123;        help_msg();        return -1;    &#125;    /* Open the FILE. */    char *source_path = argv[1];    FILE *source_file = fopen(source_path, &quot;rb&quot;);    if (source_file == NULL) &#123;        printf(&quot;File is not accessible. [%s]\n&quot;, source_path);        return -1;    &#125;    char *dest_path = argv[2];    FILE *dest_file = fopen(dest_path, &quot;wb&quot;);    if (dest_file == NULL) &#123;        printf(&quot;File is not accessible. [%s]\n&quot;, dest_path);        return -1;    &#125;    /* Core Fragment Code */    unsigned char buffer[BUF_SIZE];    size_t read_count;    while ((read_count = fread(buffer, 1, BUF_SIZE, source_file)) &gt; 0) &#123;        /* Bit Flipping Encrypt Algorithm, Simple and NAIVE. */        for (size_t i = 0; i &lt; read_count; i++) &#123;            buffer[i] ^= (unsigned char) 0xff;        &#125;        fwrite(buffer, read_count, 1, dest_file);    &#125;    fclose(source_file);    fclose(dest_file);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化技巧</title>
      <link href="/posts/2020-08-07-data-visualization-tips.html"/>
      <url>/posts/2020-08-07-data-visualization-tips.html</url>
      
        <content type="html"><![CDATA[<p>在数据真正重要的时候，我们都希望创建有效的图表。但是，数据可视化很少在学校教授，也没有在职场培训中介绍。我们大多数人在学习过程中会学习，因此我们经常做出选择或犯错，使读者感到困惑。</p><p>从过度复杂化或过度修饰的图表到传达完全不正确的信息，可以轻松避免常见的设计陷阱。我们总结了以下几点，来帮您创建更简单的图表，有效地理解数据的含义。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/46797f4a8c86d5cfe8d73e5497dec98d-a34b7f.png" alt="img"></p><h2 id="现在的事实"><a href="#现在的事实" class="headerlink" title="现在的事实"></a>现在的事实</h2><p>研究人员在 2014 年的一项研究《科学蒙蔽》(<a href="http://journals.sagepub.com/doi/abs/10.1177/0963662514549688">Blinded with science</a>.) 中发现：“只要涉及图表，大多数人都会相信您所说的一切。” 鉴于图表的说服力，重要的是我们必须正确使用它们，并将观众的最大兴趣放在设计的核心。图表可以通过多种不同方式意外传达错误信息，歪曲事实或使数据难以快速的解释意义。</p><blockquote><p>许多图表都具有复杂且智能的基础信息，但却无法传达预期的信息。</p><p><a href="http://donawong.com/">Dona M. Wong</a> —— 数据可视化专家</p></blockquote><h3 id="从无到有"><a href="#从无到有" class="headerlink" title="从无到有"></a>从无到有</h3><p><em>条形图非常适合进行比较。Bar charts are great for comparisons. To judge their end points, the bars should begin at a zero baseline.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/a150707fc194e6cb7c58ed567f341449-6a1c41.png" alt="Start from nothing"></p><p>For people to draw meaningful conclusions from a bar graph, the bars have to be presented in full. To do this, you need to start your vertical axis at zero.</p><p>Bar charts are generally easy to read because they “ask” our eyes to do a simple thing: compare the relative heights of the bars. But if we show just the tips of the bars to exaggerate differences in the data, our audience loses the ability to make useful visual comparisons.</p><p>“Truncation equals misrepresentation,” writes <a href="http://donawong.com/">Dona M. Wong</a>. So people are either misled and take away the wrong message, or end up having to read the numbers, which defeats the purpose of the chart.</p><h3 id="Distorted-reality"><a href="#Distorted-reality" class="headerlink" title="Distorted reality"></a>Distorted reality</h3><p><em>Line charts often show a trend. Stretching the height of the graph can create fake drama, while stretching the width can underplay it.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/15c6a6d77b724ae9d0028db2ce7bbe7c-ccc871.png" alt="Distorted reality"></p><p>Similar to a stretched or squished photo, a chart’s dimensions — or its aspect ratio — can change the image that we’re presenting. But while you usually can’t get away with a wrong aspect ratio in a photo, a distorted one in a chart can easily go unnoticed. Whether this results in an overblown or understated message, it just misleads your audience.</p><p>“There is no single rule to follow in terms of how high or wide to make the graph, but a useful notion involves ‘banking to 45°,’ whereby the average slope angle across your chart heads towards 45°,” writes data visualization specialist <a href="http://www.visualisingdata.com/book/">Andy Kirk</a>. This is probably impractical to measure, but judging by eye tends to do the trick.</p><h3 id="Ditch-the-pie"><a href="#Ditch-the-pie" class="headerlink" title="Ditch the pie"></a>Ditch the pie</h3><p><em>Pie charts seem friendly, but in reality they’re hard to read. In most cases, you can find a better alternative.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/9c0ec6a5323e1fc694b9a0d747c34a87-9b6b6c.png" alt="Ditch the pie"></p><p>Pie charts are part of the larger family of area graphs, which are all difficult to interpret. Nevertheless, pie charts are widely used and abused in almost every professional and educational setting.</p><p>The reason why pie charts are best avoided is straightforward: our brains can’t make accurate estimates or comparisons of angles. If the slices are fairly close in size, it’s difficult — if not impossible — to tell which is bigger, and when they’re not close in size, the best you can do is determine that one is bigger than the other, but you can’t judge by how much, explains data visualization expert <a href="http://www.storytellingwithdata.com/books/">Cole Nussbaumer Knaflic</a>.</p><p>Delivering precise numbers with a pie chart requires a lot of effort, such as relying on direct slice labels that might not fit, or legends that make our eyes jump back and forth between the pie and the legend.</p><h3 id="Size-matters"><a href="#Size-matters" class="headerlink" title="Size matters"></a>Size matters</h3><p><em>It’s harder to compare areas or volumes than lengths. To avoid people getting the wrong impression, use them as a last resort.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/08cb2a240fa746a25adfa785f3370a5b-feec45.png" alt="Size matters"></p><p>When we’re asked to judge and compare two dimensions at once, for example, two circles, we rarely make accurate estimates. We usually underestimate the size of the bigger circles and overestimate the size of the smaller ones. This happens because we instinctively judge the lengths or widths of the shapes and not their areas.</p><p>“The geometric accuracy of the size calculations is paramount,” writes <a href="http://www.visualisingdata.com/book/">Andy Kirk</a>. When building or reading a proportional shape chart, it’s useful to remember a simple rule: when we double the height of a circle we actually quadruple — not double — its area. And just bear in mind, if you decide to make your circles appear as 3D spheres, you’re no longer representing area but volume.</p><h2 id="Less-is-more"><a href="#Less-is-more" class="headerlink" title="Less is more"></a>Less is more</h2><p>“Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away,” said French writer Antoine de Saint-Exupery.</p><p>A common mistake we all make with charts is overdressing them with unnecessary elements. The usual suspects are excess color, graphical clutter and abuse of special effects. Displaying too many decimal places in our values is another one to watch out for. Details like these won’t impress anyone, but decluttering your charts will.</p><blockquote><p>Charts are not just mere illustrations, they are not just drawings, they carry meaning.</p><h5 id="Alberto-Cairo-Visual-and-data-journalist"><a href="#Alberto-Cairo-Visual-and-data-journalist" class="headerlink" title="Alberto Cairo- Visual and data journalist"></a><a href="https://www.urban.org/events/alberto-cairo-misleading-data-and-visualizations">Alberto Cairo</a>- Visual and data journalist</h5></blockquote><h3 id="Over-the-rainbow"><a href="#Over-the-rainbow" class="headerlink" title="Over the rainbow"></a>Over the rainbow</h3><p><em>Use color to communicate information and not for decoration. Too many colors can confuse and disorient.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/a1423dc6ee78f7c2e9f49d7e5ad83bf6-f9b5c3.png" alt="Over the rainbow"></p><p>When designing a graph, color can be both your friend and your enemy. Depending on how we use it, it can either gracefully highlight data and show a change, or create visual overload and confuse the audience.</p><p>“When any color appears as a contrast to the norm, our eyes pay attention, and our brains attempt to assign meaning to that difference,” writes data visualization expert <a href="http://www.stephen-few.com/idd.php">Stephen Few</a>. Too many meanings, or colors, just blur your message and throw people off-track.</p><p>Also, using different colored elements, like bars or lines, may be illegible for colorblind readers. For this reason, you can either vary the intensities or add a symbol or number to make it clear for these readers.</p><p>“Admit colors into charts gracefully, as you would receive in-laws into your home,” says <a href="http://donawong.com/">Dona M. Wong</a>.</p><h3 id="Spare-the-ink"><a href="#Spare-the-ink" class="headerlink" title="Spare the ink"></a>Spare the ink</h3><p><em>Background, borders, shading, dark grid lines and needless labels are your enemies. Banish them to draw attention to the data.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/b9e0a98be3e3810d86b5d01d8d33ca47-bdde97.png" alt="Spare the ink"></p><p>To get this point across, American statistician, Edward Tufte, in one of his most <a href="https://www.edwardtufte.com/tufte/books_vdqi">influential books</a>, coined the term ‘chartjunk’: “The interior decoration of graphics generates a lot of ink that does not tell the viewer anything new. The purpose of decoration varies — to make the graphic appear more scientific and precise, to enliven the display, to give the designer an opportunity to exercise artistic skills. Regardless of its cause, it is all non-data-ink or redundant data-ink, and it is often chartjunk.”</p><p>The simple solution is to use the least amount of ink to communicate your message, and remove anything that’s distracting. This way, you’ll make your data and your graph stand out. As <a href="http://www.thefunctionalart.com/p/the-truthful-art-book.html">Alberto Cairo</a> says: “white space isn’t empty space.”</p><h3 id="A-dimension-too-far"><a href="#A-dimension-too-far" class="headerlink" title="A dimension too far"></a>A dimension too far</h3><p><em>Unless you’re actually plotting the third dimension, don’t use 3D. It skews the data and makes comparisons harder.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/74cdce65a777c0ed836bba736518e0eb-875906.png" alt="A dimension too far"></p><p>Most data visualization experts agree that use of 3D special effects is, at best, an unnecessary and, at worst, a disorienting and confusing element. It “distorts the viewer’s ability to read values within any degree of acceptable accuracy,” writes <a href="http://www.visualisingdata.com/book/">Andy Kirk</a>.</p><p>There’s something very appealing about fancy 3D charts. However, in most cases, the third dimension — or depth — is purely decorative, and makes it difficult for people to process the data. In a 3D chart, the back part looks smaller in relation to the front, or is even hidden by it, which makes judgments of values and comparisons almost impossible. Also, people don’t know which point on the 3D shape to measure against the axis scale.</p><p>3D charts, in most circumstances, are just a waste of time and effort for both you and your audience.</p><h3 id="Stick-to-the-point"><a href="#Stick-to-the-point" class="headerlink" title="Stick to the point"></a>Stick to the point</h3><p><em>Extra decimal places look impressive and imply accuracy, but they’re often pointless. So, take a step back and round numbers off before plotting.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/3db63408df01590d2d5fc9a73b6d10c0-bbfe5a.png" alt="Stick to the point"></p><p>Overstating the numerical precision of your data by showing too many decimal places can make your chart seem accurate, but this specificity is just misleading. Even when you don’t exaggerate the precision of your data, and your numbers are genuinely accurate, overloading your audience with such detail is often useless.</p><p>“Selecting the appropriate level of precision for numbers boils down to a single design practice: the level of precision should not exceed the level needed to serve your communication objectives and the needs of your readers,” writes <a href="http://www.stephen-few.com/smtn.php">Stephen Few</a>.</p><p>Just remember, when using less precision than is available, it’s important you keep your audience in the loop.</p><h2 id="Keep-it-simple"><a href="#Keep-it-simple" class="headerlink" title="Keep it simple"></a>Keep it simple</h2><p>Charts are all about making data accessible to a broad audience. This doesn’t mean you need to over-simplify or dumb things down — just be direct and get your point across without overcomplicating things.</p><p>People tend to question their intelligence and blame themselves when they have difficulty interpreting a graph. But in most cases, it’s not people’s fault, it’s the design’s.</p><blockquote><p>It’s relatively easy to take something simple and make it complicated. It’s much harder to take something complex and present it in a way that is accessible to your audience. Aim for straightforward.</p><p><a href="http://www.storytellingwithdata.com/books/">Cole Nussbaumer Knaflic</a> - Data visualization expert</p></blockquote><h3 id="Avoid-mysteries"><a href="#Avoid-mysteries" class="headerlink" title="Avoid mysteries"></a>Avoid mysteries</h3><p><em>Text is your friend. Thoughtful use of labels means no one’s in the dark. Every chart and every axis need at least a title.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/750974dd80d1e5f478a38a43b2dc47e5-808d23.png" alt="Avoid mysteries"></p><p>Annotation is the most straightforward, but often the most neglected, step in making a graph accessible. Adding the right text, that’s brief and relevant, helps people use their brainpower to understand the data rather than figure out the chart.</p><p>“Text plays a number of roles in communicating with data: use it to label, introduce, explain, reinforce, highlight, recommend and tell a story,” suggests <a href="http://www.storytellingwithdata.com/books/">Cole Nussbaumer Knaflic</a>.</p><p>The basic types of labeling include chart titles, axis titles, axis labels or scales, which appear around the graph, plus data labels that mark specifics inside the chart. Units of measurement and data sources are frequently overlooked, but they also play a key role in removing the guesswork when people interpret your graph. Just remember, words are there to help, not to hijack the attention from the data.</p><h3 id="A-tale-of-two-stories"><a href="#A-tale-of-two-stories" class="headerlink" title="A tale of two stories"></a>A tale of two stories</h3><p><em>Charting two sets of data with one scale on the left and another on the right can be confusing, and suggests a relationship that may not exist.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/9dca960ce96c5f9adade75e5ba6a4649-985a14.png" alt="A tale of two stories"></p><p>It’s relatively easy and sometimes helpful to plot multiple sets of data using a common horizontal axis if all the data is expressed with the same unit of measure. But if they use different units, you’ll need to add a secondary vertical axis on the right of the chart.</p><p>This display requires time and effort from the audience to decode and understand which data should be read against which axis. But even if they solve this puzzle, they’re tempted to compare the magnitudes of values between the two sets of data, which is meaningless given that the scales and units of the data are different, says <a href="http://www.stephen-few.com/smtn.php">Stephen Few</a>.</p><p>As a general rule, try to avoid squeezing too much data in a small space. To tell an elaborate story, it’s better to use two or more charts.</p><h3 id="Stand-on-the-right"><a href="#Stand-on-the-right" class="headerlink" title="Stand on the right"></a>Stand on the right</h3><p><em>Tables are good for looking up individual numbers. But, to help people scan and compare them, align whole numbers flush right.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/a907799dc5a3830624abab69a6f0b27e-fe2fca.png" alt="Stand on the right"></p><p>For a table to do its job, it has to show information in a way that makes spotting numbers, and row-to-row comparisons, easy. If we align numbers to the left or center, this defeats the purpose and forces people to jump back and forth between values, making comparisons of magnitudes difficult.</p><p>Aligning numbers to the right holds true for both whole and decimal values. For values with decimal digits, <a href="http://www.stephen-few.com/smtn.php">Stephen Few</a> suggests aligning both the decimal point and the final digit to the right. He explains that “this can be accomplished by expressing each value using the same number of decimal digits, even when they are zeroes.”</p><p>Also, adding thousands separators — like commas, dots, or spaces — to break the numbers up into smaller chunks, can help people store values in working memory and easily spot differences between the numbers.</p><h3 id="Back-to-basics"><a href="#Back-to-basics" class="headerlink" title="Back to basics"></a>Back to basics</h3><p><em>With charts, simpler is always better. To keep things even clearer, when you have one or two values, just show the numbers.</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/9af499dc0a49ac425ddcfa5e3f7bc1e3-8055dc.png" alt="Back to basics"></p><p>We often ask ourselves: what kind of graph should I use? Most data visualization experts agree that it’s always better to use graphic forms that people are familiar with. Bars, lines, tables, or just a number, in most cases, are the most efficient ways to show your data to the world, with the minimal amount of effort and space used.</p><p>“The fact that you have some numbers does not mean that you need a graph,” underlines <a href="http://www.storytellingwithdata.com/books/">Cole Nussbaumer Knaflic</a>. When we try to present just one or two numbers on a chart, the medium steals the attention from the data. Showing the number directly is much simpler and truly impactful.</p><hr><p>原文：<a href="https://www.geckoboard.com/best-practice/data-visualization-tips/">https://www.geckoboard.com/best-practice/data-visualization-tips/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>康奈尔笔记：高效笔记</title>
      <link href="/posts/2020-08-07-cornell-notes-take-effective-notes.html"/>
      <url>/posts/2020-08-07-cornell-notes-take-effective-notes.html</url>
      
        <content type="html"><![CDATA[<p>几乎所有人都需要上课，充分利用课堂时间的人则全心全意地学习，也总是在记笔记。和生活中许多东西一样，并不是所有记笔记的方法效果都一样，有的不怎么样，有的则挺好的。接下来我们要介绍的便是康奈尔方法。</p><p>威奇托州立大学（Wichita State University）于 2010 年进行的一项研究发现，在调回过程中，康奈尔笔记记录方法要比其他（指导笔记记录）方法优越（<a href="https://soar.wichita.edu/bitstream/handle/10057/1388/grasp-2008-56.pdf?sequence=1">资料来源</a>）。另一项 2013 年的研究指出，“接受过康奈尔笔记学习的学生的笔记要比没有学习过康奈尔笔记的学生做得更好。” （<a href="http://yourspace.minotstateu.edu/laurie.geller/Capstone%20Examples/Final%20Capstone%20Projects/Duane%20Broe%20Capstone%20Project.pdf">来源</a>）</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/f8266454b7b3c237370a3b79410603a7-65b644.jpeg" alt="3e71fa9d-7de6-44e5-bfe1-a5d489613f1c_723x482"></p><h3 id="什么是康奈尔方法？"><a href="#什么是康奈尔方法？" class="headerlink" title="什么是康奈尔方法？"></a>什么是康奈尔方法？</h3><p><a href="http://lsc.cornell.edu/study-skills/cornell-note-taking-system/">康奈尔方法</a> (Cornell Notes, CM) 是一种用于巩固和组织笔记的系统化格式。</p><p>首先将页面分为三部分：</p><ol><li>笔记：用简短的句子描述主要思想。</li><li>召回：关键词、短语以及可能的问题。</li><li>摘要：用2-3个句子描述关键思想及相关信息。</li></ol><h3 id="这是常用格式："><a href="#这是常用格式：" class="headerlink" title="这是常用格式："></a>这是常用格式：</h3><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/c42b6ebdf08b93fb0804d811b770e856-b02297.png" alt="fadff747-6597-45e5-81a9-57d3fdf7409d_200x260"></p><h3 id="它不只是一种格式，也是一个过程"><a href="#它不只是一种格式，也是一个过程" class="headerlink" title="它不只是一种格式，也是一个过程"></a>它不只是一种格式，也是一个过程</h3><p>如果你想记高效的笔记并且充分利用会议时间，则需要以下步骤：</p><ol><li>记录：在笔记栏中记录下那些重要的想法。</li><li>召回：在召回栏中提出评估者可能感兴趣的问题。</li><li>背诵：把遮住笔记栏，并尝试回答召回栏中的问题。</li><li>思考：根据你的回答对主题进行自我评估，以确保理解并在必要时重复。</li><li>复习：经过反思，将提出的想法概括为2-3个句子以供复习。</li></ol><hr><p>原文：<a href="https://models.substack.com/p/-cornell-notes-take-effective-notes">https://models.substack.com/p/-cornell-notes-take-effective-notes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 新手常见错误</title>
      <link href="/posts/2020-08-04-django-newbie-mistakes.html"/>
      <url>/posts/2020-08-04-django-newbie-mistakes.html</url>
      
        <content type="html"><![CDATA[<p>当你开始学习并使用 Django 后，请勿吝啬分享让你兴奋的东西（错误）。我们将尝试改进 Django 的错误处理，以在将来捕获此类错误。</p><h2 id="常见错误一：POST-提交数据到视图而丢失-POST-数据"><a href="#常见错误一：POST-提交数据到视图而丢失-POST-数据" class="headerlink" title="常见错误一：POST 提交数据到视图而丢失 POST 数据"></a>常见错误一：POST 提交数据到视图而丢失 POST 数据</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>你有一个需要提交数据到某个视图的表单，然而视图并没有获取到 POST 提交的表单数据。</p><h3 id="可能的原因"><a href="#可能的原因" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>你可能在表单的 <code>action</code> 中忘了最后的 <code>/</code>. 如果是这样的话，<code>CommonMiddleware</code>（查看你的 <code>MIDDLEWARE_CLASSES</code>） 会重定向至视图的确切名称 —— 并且总会有带上一个 <code>/</code>. 因为它是通过标准 HTTP 的 <code>Location</code>  头来实现重定向的，所以它无法传递 POST 数据，这就是为什么它会丢失数据的原因。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>始终确保表单 <code>action</code> 以 <code>/</code> 结尾，如下所示：</p><pre><code class="html">&lt;form action=&quot;/registration/login/&quot; method=&quot;POST&quot;&gt;&lt;input name=&quot;username&quot;&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/form&gt;</code></pre><p>注：Django 现在正尝试捕获这个问题，见 <a href="https://www.djangoproject.com/svntogit/3109/">[3109]</a></p><h2 id="常见错误二：表单无法上传文件"><a href="#常见错误二：表单无法上传文件" class="headerlink" title="常见错误二：表单无法上传文件"></a>常见错误二：表单无法上传文件</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>在你的表单中有 <code>FileField()</code> 和 <code>ImageField()</code> ，但是当你提交表单后，并没有上传文件。</p><h3 id="可能的原因-1"><a href="#可能的原因-1" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>当你实例化 <code>Form</code> 时，你可能忘记了 <code>request.FILES</code> 参数。</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>确保实例化 <code>Form</code> 时传递 <code>requests.FILES</code>.</p><pre><code class="python">form = MyForm(request.POST, request.FILES)</code></pre><h3 id="另一种可能"><a href="#另一种可能" class="headerlink" title="另一种可能"></a>另一种可能</h3><p>表单中可能缺少 <code>enctype</code> 属性。</p><h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>确保你的表单中有如下形式的 <code>enctype</code> 属性：</p><pre><code class="html">&lt;form method=&quot;post&quot; action=&quot;/some/url/&quot; enctype=&quot;multipart/form-data&quot;&gt;</code></pre><h2 id="常见错误三：URLconf-include-失效"><a href="#常见错误三：URLconf-include-失效" class="headerlink" title="常见错误三：URLconf include() 失效"></a>常见错误三：URLconf include() 失效</h2><h3 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h3><p>你的 <code>URLconf</code> 文件无法正常工作，但也收不到任何关于找不到模块 <code>index</code> 的信息（<code>index</code> 是你尝试分配为视图的某些功能） 或者 模块 <code>foo</code> 缺失 <code>urlpattern</code> 属性的信息。</p><h3 id="可能的原因-2"><a href="#可能的原因-2" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>你可能在 <code>URLconf</code> 文件中用 <code>include()</code> 方法尝试加载视图文件 （ 在教程 3 中，是  <code>myproject/settings/urls/main.py</code> ）。这里的 <code>include()</code> 调用是假设加载的也是一个 <code>URLconf</code> 文件</p><h3 id="解决方法-3"><a href="#解决方法-3" class="headerlink" title="解决方法"></a>解决方法</h3><p>移除 <code>include()</code> 方法。就用模块名和函数名（例如：<code>myproject.apps.polls.views.polls.index</code>） 组成字符串即可，不需要 <code>include()</code> 方法去包含它。</p><h2 id="常见错误四：空白对象名"><a href="#常见错误四：空白对象名" class="headerlink" title="常见错误四：空白对象名"></a>常见错误四：空白对象名</h2><h3 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h3><p>The automatic admin interface is showing nothing (or a single <code>&amp;nbsp;</code>) in the “Select [object_type] to change” view.</p><h3 id="可能的原因-3"><a href="#可能的原因-3" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>You may have forgotten to create a <code>__str__()</code> function for your model (<code>__unicode__()</code> in Python 2). Django calls <code>__str__()</code> to find out how to display objects in the admin interface. An alternate cause is the string you return from <code>__str__()</code> includes brackets (an therefore looks like an html tag), and is cleaned up by the <code>strip_tags</code> template filter, resulting in blank entries.</p><h3 id="解决方法-4"><a href="#解决方法-4" class="headerlink" title="解决方法"></a>解决方法</h3><p>Add a correct <code>__str__()</code> function (without brackets in the output) to all your models. Make it a habit so it becomes automatic.</p><h2 id="常见错误五：整数和空值"><a href="#常见错误五：整数和空值" class="headerlink" title="常见错误五：整数和空值"></a>常见错误五：整数和空值</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>你有如下字段：</p><pre><code>current_zip = meta.IntegerField(max_length=5, blank=True)</code></pre><p>Django 会在你的数据库中创建一个非空的字段。然而，当你表单留空（在管理后台或者是网页上）时，Django 会尝试向你数据库插入 <code>NULL</code> 的空值。</p><h3 id="解决方法-5"><a href="#解决方法-5" class="headerlink" title="解决方法"></a>解决方法</h3><p>加上 <code>null=True </code> :</p><pre><code class="python">current_zip = meta.IntegerField(max_length=5, null=True, blank=True)</code></pre><h2 id="常见错误六：日期和空值"><a href="#常见错误六：日期和空值" class="headerlink" title="常见错误六：日期和空值"></a>常见错误六：日期和空值</h2><p>问题与解决方法同 “常见错误五：整数和空值”。</p><h2 id="常见错误七：无法往-session-中添加列表"><a href="#常见错误七：无法往-session-中添加列表" class="headerlink" title="常见错误七：无法往 session 中添加列表"></a>常见错误七：无法往 session 中添加列表</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>session 中有一个列表，但是无法向该列表中添加数据。</p><h3 id="解决方法-6"><a href="#解决方法-6" class="headerlink" title="解决方法"></a>解决方法</h3><p>将列表拷贝出来，然后添加数据，再拷贝回去：</p><pre><code class="python">sessionlist = request.session[&#39;my_list&#39;]sessionlist.append(new_object)request.session[&#39;my_list&#39;] = sessionlist</code></pre><p>或者，将 session 标记为已修改：</p><pre><code class="python">request.session[&#39;my_list&#39;].append(new_object)request.session.modified = True</code></pre><h2 id="常见错误八：关于带有一个字符名称的未定义属性的错误"><a href="#常见错误八：关于带有一个字符名称的未定义属性的错误" class="headerlink" title="常见错误八：关于带有一个字符名称的未定义属性的错误"></a>常见错误八：关于带有一个字符名称的未定义属性的错误</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>You get an AttributeError with some weird attribute name that’s only one char long. You don’t have that attribute name anywhere in your code.</p><h3 id="解决方法-7"><a href="#解决方法-7" class="headerlink" title="解决方法"></a>解决方法</h3><p>Search your model and code for situations where you have to pass a tuple of values and want to pass a tuple with one element - and that element is a string like in this sample:</p><pre><code>class META:         ...    admin = meta.Admin(        list_display = (&#39;total_price&#39;),        ...    )</code></pre><p>You are just missing a comma in the list_display assignment like this:</p><pre><code>class META:         ...    admin = meta.Admin(        list_display = (&#39;total_price&#39;,),        ...    )</code></pre><p>Remember, in python:</p><pre><code>&gt;&gt;&gt; a = (1) ## This causes problems1&gt;&gt;&gt; a = (1,) ## These are fine.(1,)&gt;&gt;&gt; a = [1][1]&gt;&gt;&gt; a = [1,][1]</code></pre><p>Since a tuple is expected but a string provided, the code will merrily iterate over the characters of the string instead of the tuple elements - and that’s where the single-char attribute names come from. If the commas are consistently causing you problems, try using brackets [] instead of parentheses.</p><h2 id="常见错误九：使用-formfields-FormWrapper-但表单字段均不显示"><a href="#常见错误九：使用-formfields-FormWrapper-但表单字段均不显示" class="headerlink" title="常见错误九：使用 formfields.FormWrapper 但表单字段均不显示"></a>常见错误九：使用 <code>formfields.FormWrapper</code> 但表单字段均不显示</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>You are using code similar to that documented <a href="http://www.djangoproject.com/documentation/forms/">here</a>, but when you put , you get nothing. </p><h3 id="解决方法-8"><a href="#解决方法-8" class="headerlink" title="解决方法"></a>解决方法</h3><p>Make sure when you create your form object, you are passing in empty <strong>dictionaries</strong>, not tuples. For example:</p><pre><code>    manip = things.AddManipulator()    form = formfields.FormWrapper(manip, &#123;&#125;, &#123;&#125;)</code></pre><p>Not:</p><pre><code>    manip = things.AddManipulator()    form = formfields.FormWrapper(manip, (), ())</code></pre><p>If you pass in empty tuples for data &amp; errors, it will silently fail to insert your form fields.</p><h2 id="常见错误十：使用-SQLite3-时，Django-提示-“Unable-to-Open-Database-File”"><a href="#常见错误十：使用-SQLite3-时，Django-提示-“Unable-to-Open-Database-File”" class="headerlink" title="常见错误十：使用 SQLite3 时，Django 提示 “Unable to Open Database File”"></a>常见错误十：使用 SQLite3 时，Django 提示 “Unable to Open Database File”</h2><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>You’re using SQLite3, your DATABASE_NAME is set to the database file’s full path, the database file is writeable by Apache, but you still get the above error.</p><h3 id="解决方法-9"><a href="#解决方法-9" class="headerlink" title="解决方法"></a>解决方法</h3><p>Make sure Apache can also write to the parent directory of the database. SQLite needs to be able to write to this directory. Avoid setting the permissions to 777, as it’s a security risk (see <a href="http://askubuntu.com/questions/20105/why-shouldnt-var-www-have-chmod-777">this page</a> for an explanation why).</p><p>Make sure each folder of your database file’s full path does not start with number, eg. &#x2F;www&#x2F;4myweb&#x2F;db (observed on Windows 2000).</p><p>If DATABASE_NAME is set to something like ‘&#x2F;Users&#x2F;yourname&#x2F;Sites&#x2F;mydjangoproject&#x2F;db&#x2F;db’, make sure you’ve created the ‘db’ directory first.</p><p>Make sure your &#x2F;tmp directory is world-writable (an unlikely cause as other thing on your system will also not work). <code>ls /tmp -ald</code> should produce <code>drwxrwxrwt ...</code>.</p><p>Make sure the path to the database specified in settings.py is a full path.</p><p>If you working on windows make also sure that you have the path to the db directory written with double backlashes (using os.path methods are recommended)</p><pre><code>&#39;C:\\django\\sqlite\\django.db&#39;</code></pre><p>or</p><pre><code>r&#39;C:\django\sqlite\django.db&#39;</code></pre><p>Make sure there is no special charcaters in the path like “éè” or “(“.</p><p>If you are using Windows and this message appears intermittently make sure that your security software (Anti-malware) are not opening (and locking) your database file to check for malware presence.</p><h2 id="常见错误十一：如何将-Apache-指向媒体文件目录"><a href="#常见错误十一：如何将-Apache-指向媒体文件目录" class="headerlink" title="常见错误十一：如何将 Apache 指向媒体文件目录"></a>常见错误十一：如何将 Apache 指向媒体文件目录</h2><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><p>You have no clue how to map a media url to your media directory when using apache2. </p><h3 id="解决方法-10"><a href="#解决方法-10" class="headerlink" title="解决方法"></a>解决方法</h3><p>Use the <em>Alias</em> Directive and don’t forget to set-up access rights correctly.</p><pre><code class="xml">Alias /mediaurl /path/to/files&lt;Directory /path/to/files&gt;Order allow,denyAllow from all&lt;/Directory&gt;</code></pre><h2 id="常见错误十二：数据库查询结果并不是列表"><a href="#常见错误十二：数据库查询结果并不是列表" class="headerlink" title="常见错误十二：数据库查询结果并不是列表"></a>常见错误十二：数据库查询结果并不是列表</h2><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><p>You have been playing with the database API and noticed that a returned query set looks a lot like a list:</p><pre><code>&gt;&gt;&gt; from mysite.polls.models import Poll,Choice&gt;&gt;&gt; Poll.objects.all()[&lt;Poll: What is up?&gt;, &lt;Poll: What is your favourite colour?&gt;]  ## looks a lot like a list to me</code></pre><p>But, it doesn’t behave like a list in some cases.</p><h3 id="解决方法-11"><a href="#解决方法-11" class="headerlink" title="解决方法"></a>解决方法</h3><p>Here are a couple of cases where the behaviour is not list-like and their solution.</p><p>In Python this is how we can test for an empty list:</p><pre><code>&gt;&gt;&gt; b=[]&gt;&gt;&gt; b==[]True</code></pre><p>This doesn’t work with a QuerySet. You might try the following but it will fail:</p><pre><code>&gt;&gt;&gt; from mysite.polls.models import Poll,Choice&gt;&gt;&gt; p = Poll.objects.filter(question__startswith=&#39;ZZZZZZZZZZZZ&#39;)&gt;&gt;&gt; p[]&gt;&gt;&gt; p==[]False</code></pre><p>The way to do it is test for p.exists: </p><pre><code>&gt;&gt;&gt; from mysite.polls.models import Poll,Choice&gt;&gt;&gt; p = Poll.objects.filter(question__startswith=&#39;ZZZZZZZZZZZZ&#39;)&gt;&gt;&gt; p[]&gt;&gt;&gt; p.exists()False</code></pre><p>Another case occurs when you want to retrieve the last member of a QuerySet:</p><pre><code>&gt;&gt;&gt; from mysite.polls.models import Poll,Choice&gt;&gt;&gt; p = Poll.objects.all()&gt;&gt;&gt; p[&lt;Poll: What is up?&gt;, &lt;Poll: What is your favourite colour?&gt;]&gt;&gt;&gt; p[-1]Traceback (most recent call last):  File &quot;&lt;console&gt;&quot;, line 1, in ?  File &quot;c:\python24\lib\site-packages\django-0.95-py2.4.egg\django\db\models\query.py&quot;, line 98, in__getitem__    assert (not isinstance(k, slice) and (k &gt;= 0)) \AssertionError: Negative indexing is not supported.</code></pre><p>The way I get the last member is either:</p><pre><code>&gt;&gt;&gt; p[p.count()-1]&lt;Poll: What is your favourite colour?&gt;</code></pre><p>or</p><pre><code class="python">&gt;&gt;&gt; p.last()&lt;Poll: What is your favourite colour?&gt;</code></pre><h2 id="常见错误十三：在应用程序中使用保留名称会破坏管理"><a href="#常见错误十三：在应用程序中使用保留名称会破坏管理" class="headerlink" title="常见错误十三：在应用程序中使用保留名称会破坏管理"></a>常见错误十三：在应用程序中使用保留名称会破坏管理</h2><h3 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h3><p>After creating a new application, with a model that validates, trying to log on to the admin causes an error similar to:</p><pre><code>ImproperlyConfigured: Error importing middleware django.middleware.common: &quot;No module named ... &quot;</code></pre><h3 id="可能的原因-4"><a href="#可能的原因-4" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>Check to see that you didn’t use a reserved name in naming your application, i.e. “email”, “date” and “time” are common application names that would validate when the server starts but will break Django’s admin. </p><h3 id="解决方法-12"><a href="#解决方法-12" class="headerlink" title="解决方法"></a>解决方法</h3><p>Rename your application directory using a non-reserved name, i.e., “email_app” instead of “email”. Go into the <code>INSTALLED_APPS</code> section of settings.py and change the name there too. Also, don’t forget to migrate your database (<code>python manage.py migrate</code>) to create the newly renamed app in your database. You may also want to go in to your database and drop the old “mis-named” table.</p><h2 id="常见错误十四：未绑定方法-contribute-to-class"><a href="#常见错误十四：未绑定方法-contribute-to-class" class="headerlink" title="常见错误十四：未绑定方法 contribute_to_class()"></a>常见错误十四：未绑定方法 <code>contribute_to_class()</code></h2><h3 id="现象-5"><a href="#现象-5" class="headerlink" title="现象"></a>现象</h3><p>模型不可用，报错信息如下：</p><pre><code>Validating models...project.allication: Error when calling the metaclass bases    unbound method contribute_to_class() must be called with TextField instance as first argument (got ModelBase instance instead)1 error found.</code></pre><h3 id="可能的原因-5"><a href="#可能的原因-5" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>未正确声明模型字段，缺少字段类型名称后的括号：</p><p>错误写法：</p><pre><code>class Content(models.Model):    content = models.TextField</code></pre><p>正确写法：</p><pre><code>class Content(models.Model):    content = models.TextField()</code></pre><h3 id="解决方法-13"><a href="#解决方法-13" class="headerlink" title="解决方法"></a>解决方法</h3><p>模型字段是特定 <code>Field</code> 类的<em>实例</em>，所以是需要括号的。</p><h2 id="常见错误十五：使用静态服务时权限被拒绝"><a href="#常见错误十五：使用静态服务时权限被拒绝" class="headerlink" title="常见错误十五：使用静态服务时权限被拒绝"></a>常见错误十五：使用静态服务时权限被拒绝</h2><h3 id="可能的原因-6"><a href="#可能的原因-6" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>The ADMIN_MEDIA_PREFIX is the same as MEDIA_URL in settings.py </p><h3 id="解决方法-14"><a href="#解决方法-14" class="headerlink" title="解决方法"></a>解决方法</h3><p>Ensure they have different values - e.g. ADMIN_MEDIA_PREFIX &#x3D; ‘admin-media’ and MEDIA_URL &#x3D; ‘&#x2F;media’</p><h2 id="常见错误十六：默认值和调用"><a href="#常见错误十六：默认值和调用" class="headerlink" title="常见错误十六：默认值和调用"></a>常见错误十六：默认值和调用</h2><h3 id="现象-6"><a href="#现象-6" class="headerlink" title="现象"></a>现象</h3><p>You call a method to set a default value, such as random.randint(), but the value is the same for every new instance of your object.</p><h3 id="可能的原因-7"><a href="#可能的原因-7" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>每一个新的实例并没有调用 <code>random.randint()</code></p><h3 id="解决方法-15"><a href="#解决方法-15" class="headerlink" title="解决方法"></a>解决方法</h3><p>使用 “lambda:” ，如：</p><pre><code class="python">MyRandNum = models.CharField(max_length=4, default=lambda:random.randint(1000,9999))</code></pre><h2 id="常见错误十七：页面无法找到"><a href="#常见错误十七：页面无法找到" class="headerlink" title="常见错误十七：页面无法找到"></a>常见错误十七：页面无法找到</h2><p>Using the URLconf defined in wikicamp.urls, Django tried these URL patterns, in this order:</p><pre><code>    ^wikicamp/(?P&lt;page_name&gt;[^/+])/edit/$    ^wikicamp/(?P&lt;page_name&gt;[^/+])/save/$    ^wikicamp/(?P&lt;page_name&gt;[^/+])/$</code></pre><p>The current URL, , didn’t match any of these.</p><h2 id="常见错误十八：空表单"><a href="#常见错误十八：空表单" class="headerlink" title="常见错误十八：空表单"></a>常见错误十八：空表单</h2><p>Be it a normal form , model form or class-based-view The page display a blank (empty) page </p><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><p>One possible reason might be you forgot to add <code>{% block content %}</code> <code>{% endblock %}</code> in your template file</p><h3 id="解决方法-16"><a href="#解决方法-16" class="headerlink" title="解决方法"></a>解决方法</h3><p>Make sure that template used to display the page actually contains the tags <code>{% block content %}</code> <code>{% endblock %}</code> wrapping your form definition in the template file.</p><h2 id="常见错误十九：SECRET-KEY-不可为空"><a href="#常见错误十九：SECRET-KEY-不可为空" class="headerlink" title="常见错误十九：SECRET_KEY 不可为空"></a>常见错误十九：<code>SECRET_KEY</code> 不可为空</h2><h3 id="现象-7"><a href="#现象-7" class="headerlink" title="现象"></a>现象</h3><p>You’re attempting to run the Django shell from your terminal (ie. python manage.py shell), for either the first time or after rebooting your system. Instead of a Django shell opening, you are presented with the following error.</p><pre><code class="text">django.core.exceptions.ImproperlyConfigured: The SECRET_KEY setting must not be empty.</code></pre><h3 id="可能的原因-8"><a href="#可能的原因-8" class="headerlink" title="可能的原因"></a>可能的原因</h3><p>A DJANGO_SETTINGS_MODULE has not been specified as an environment variable and therefore no settings file could be loaded as the shell attempts to open.</p><h3 id="解决方法-17"><a href="#解决方法-17" class="headerlink" title="解决方法"></a>解决方法</h3><p>Add a DJANGO_SETTINGS_MODULE environment variable with the appropriate python module in your shell. </p><pre><code class="bash">export DJANGO_SETTINGS_MODULE=&lt;projectname&gt;.settings</code></pre><hr><p>原文：<a href="https://code.djangoproject.com/wiki/NewbieMistakes">https://code.djangoproject.com/wiki/NewbieMistakes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Development </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包管理器：安装魔法背后的逻辑</title>
      <link href="/posts/2020-06-23-package-managers.html"/>
      <url>/posts/2020-06-23-package-managers.html</url>
      
        <content type="html"><![CDATA[<p>如果你想学画画，可能会有人直接给你纸和笔。他们不会花时间讨论纸和笔的来源，取而代之的是，他们会告诉你线条、形状和立体空间的信息。如果你是第一次编写 Python 程序，则有人可能会在你的电脑上运行以下命令：</p><pre><code class="bash">$ apt install python3$ pip3 install ipython</code></pre><p>然后他们会打开 iPython 并秀你一发基础的 Python 语法。</p><p>包管理器经常被轻描淡写的一笔带过了。主要是因为编程大部分时候都是写代码，而不是安装代码。然而，编程也是在组织代码，并且有时候就是在安装代码。经过了多年在我的 Mac 上用 brew，gem 以及 npm 等安装及卸载包，我终于明白了包管理器是如何在我的 Ubuntu 虚拟机里工作的。对我来说，了解包管理器工作方式真的是太美妙了，我希望你也是如此。</p><h4 id="什么是包管理器？"><a href="#什么是包管理器？" class="headerlink" title="什么是包管理器？"></a>什么是包管理器？</h4><p>程序包管理器跟踪计算机上安装了什么软件，并允许您轻松安装新软件，将软件升级到较新版本或删除以前安装的软件。 顾名思义，程序包管理器处理程序包：捆绑在一起的文件集合，可以成组安装和删除。 —— Apt 用户手册</p><p>包管理器实际上有两种：</p><ul><li><strong>系统级包管理器</strong></li><li><strong>特定语言包管理器</strong></li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><h4 id="Gems"><a href="#Gems" class="headerlink" title="Gems"></a>Gems</h4><h4 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h4><h4 id="超级权限"><a href="#超级权限" class="headerlink" title="超级权限"></a>超级权限</h4><p>翻译自：<a href="https://nicoleorchard.com/blog/package-managers">https://nicoleorchard.com/blog/package-managers</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 中的 Tor 网关客户端</title>
      <link href="/posts/2020-06-23-tor-gateway-client-on-docker.html"/>
      <url>/posts/2020-06-23-tor-gateway-client-on-docker.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述如何通过 Docker 搭建 Tor 网络网关客户端。</p><p>笔者在搭建 Tor 网关时需要用到上一篇文章的 Trojan 客户端 《<a href="/posts/2020-06-23-trojan-client-on-docker.html">Docker 中的 Trojan 客户端</a>》，将这篇文章运行的 Docker 容器链接到 Tor 容器中。</p><ol><li><p>通过 git 将项目下载到本地</p><pre><code class="bash">git clone https://github.com/tor-on-synology/tor-client-minimal.git</code></pre></li><li><p>同上文一样修改 Dockerfile 文件</p></li><li><p>构建 Docker 镜像</p><pre><code class="bash">docker build -t tor .</code></pre></li><li><p>准备你的 Tor 配置文件</p><p>笔者使用的目录为 <code>/Users/ismdeep/Data/tor-config</code></p><p>在上述文件夹中写入配置文件 <code>torrc</code></p><pre><code class="text">## The directory for keeping all the keys/etcDataDirectory /var/lib/tor## Socks5ProxySocks5Proxy trojan:1080## Tor opens a socks proxy on port 9150SocksPort 0.0.0.0:9150## Entry policies to allow/deny SOCKS requests based on IP address.## SocksPolicy accept 192.168.1.0/24SocksPolicy accept 172.17.0.0/16SocksPolicy reject *## Logs go to stdout at level &quot;notice&quot;Log notice stdoutControlPort 9051# Try for at most NUM seconds when building circuits. If the circuit isn&#39;t open in that time, give up on it. (Default: 1 minute.)CircuitBuildTimeout 5# Send a padding cell every N seconds to keep firewalls from closing our connections while Tor is not in use.KeepalivePeriod 60# Force Tor to consider whether to build a new circuit every NUM seconds.NewCircuitPeriod 15# How many entry guards should we keep at a time?NumEntryGuards 8</code></pre><p>解释以上配置文件：</p><p><code>Socks5Proxy trojan:1080</code> trojan 为上文中创建的 trojan 容器，在下面创建 Docker 容器时会用到</p><p><code>SocksPort 0.0.0.0:9150</code> 则监听 9150 端口</p></li><li><p>创建 Docker 容器并运行</p><pre><code class="bash">docker run --name tor --link trojan:trojan -v /Users/ismdeep/Data/tor-config:/etc/tor -p 9150:9150 -d tor</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Docker </tag>
            
            <tag> Tor </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 中的 Trojan 客户端</title>
      <link href="/posts/2020-06-23-trojan-client-on-docker.html"/>
      <url>/posts/2020-06-23-trojan-client-on-docker.html</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述如何通过 Docker 运行一个 Trojan 客户端，而并不介绍 Trojan 服务器端如何搭建。</p><p>这里笔者用的是 GitHub 上开源的 trojan 项目 <a href="https://github.com/trojan-gfw/trojan">https://github.com/trojan-gfw/trojan</a></p><ol><li><p>通过 git 将项目下载到本地</p><pre><code class="bash">git clone https://github.com/trojan-gfw/trojan.git</code></pre></li><li><p>修改项目中 Dockerfile</p><p>这一步对于使用大陆局域网的用户来说是非常重要的。将下面这行代码添加至 Dockerfile 中 <code>FROM alpine:3.11</code> 的下一行</p><pre><code class="bash">RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#39; /etc/apk/repositories</code></pre><p>大致如下：</p><pre><code class="text">FROM alpine:3.11RUN sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#39; /etc/apk/repositoriesCOPY . trojan...</code></pre></li><li><p>构建 Docker 镜像</p><p>通过 cd 命令切换目录至 Dockerfile 文件所在目录，然后</p><pre><code class="bash">docker build -t trojan .</code></pre></li><li><p>查看 Docker 镜像是否存在</p><pre><code class="bash">docker images</code></pre><pre><code class="bash">$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEtrojan              latest              44d7a749e0bf        2 days ago          11.5MBmongo               latest              2b2cc1f48aed        6 days ago          388MBredis               latest              235592615444        12 days ago         104MBmysql               5.6                 8de95e6026c3        2 weeks ago         302MBmysql               5.7                 9cfcce23593a        2 weeks ago         448MBmysql               8.0                 be0dbf01a0f3        2 weeks ago         541MBalpine              latest              a24bb4013296        3 weeks ago         5.57MBubuntu-lnmp         latest              8dcf6426c958        5 weeks ago         892MBubuntu              latest              1d622ef86b13        2 months ago        73.9MBubuntu              18.04               c3c304cb4f22        2 months ago        64.2MBalpine              3.11                f70734b6a266        2 months ago        5.61MBnginx               latest              602e111c06b6        2 months ago        127MB</code></pre></li><li><p>准备你的 Trojan 配置文件</p><p>创建一个单独的目录用来存放 Trojan 配置文件，如笔者使用 <code>/Users/ismdeep/Data/trojan-config</code> 作为 Trojan 配置文件目录，然后将配置文件命名为 <code>config.json</code> 放入此文件夹。配置文件格式大致如下</p><pre><code class="json">&#123;    &quot;run_type&quot;: &quot;client&quot;,    &quot;local_addr&quot;: &quot;0.0.0.0&quot;,    &quot;local_port&quot;: 1080,    &quot;remote_addr&quot;: &quot;&quot;,    &quot;remote_port&quot;: 443,    &quot;password&quot;: [        &quot;&quot;    ],    &quot;log_level&quot;: 1,    &quot;ssl&quot;: &#123;        &quot;verify&quot;: true,        &quot;verify_hostname&quot;: true,        &quot;cert&quot;: &quot;&quot;,        &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:AES128-SHA:AES256-SHA:DES-CBC3-SHA&quot;,        &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384&quot;,        &quot;sni&quot;: &quot;&quot;,        &quot;alpn&quot;: [            &quot;h2&quot;,            &quot;http/1.1&quot;        ],        &quot;reuse_session&quot;: true,        &quot;session_ticket&quot;: false,        &quot;curves&quot;: &quot;&quot;    &#125;,    &quot;tcp&quot;: &#123;        &quot;no_delay&quot;: true,        &quot;keep_alive&quot;: true,        &quot;reuse_port&quot;: false,        &quot;fast_open&quot;: false,        &quot;fast_open_qlen&quot;: 20    &#125;&#125;</code></pre></li><li><p>创建 Docker 容器并运行</p><pre><code class="bash">docker run --name trojan -v /Users/ismdeep/Data/trojan-config:/config -p 1080:1080 -d trojan</code></pre></li><li><p>启动 &amp; 停止</p><pre><code class="bash"># 启动docker start trojan# 停止docker stop trojan</code></pre></li><li><p>总结</p><p>这部分操作还是比较简单的，你只需要一点 Docker 基本操作知识即可。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Docker </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么很多硅谷工程师偏爱 OS X，而不是 Linux 或 Windows？</title>
      <link href="/posts/2020-05-14-why-programmer-in-silicon-valley-love-mac-other-than-linux-or-windows.html"/>
      <url>/posts/2020-05-14-why-programmer-in-silicon-valley-love-mac-other-than-linux-or-windows.html</url>
      
        <content type="html"><![CDATA[<p>【导读】：这个问题源自 Quora。题主说「看过许多诸如 Google、Dropbox、Quora 等公司的视频，发现有超过 90% 的工程师都在使用 Mac。Mac 为什么这么流行？难道大家没发现下面这些问题嘛？」</p><ul><li>昂贵但 GPU 性能一般！</li><li>没 Linux 开放（Linux 允许你编辑任何文件）</li><li>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好。</li></ul><p>本文摘编了 3 位程序员的回复，全文如下。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/710ad287c78b60f61924f463d789a861-61b878.jpg" alt="img"></p><h3 id="Mike-Mikowski-的回答，2700-顶"><a href="#Mike-Mikowski-的回答，2700-顶" class="headerlink" title="Mike Mikowski 的回答，2700+ 顶"></a>Mike Mikowski 的回答，2700+ 顶</h3><p>我觉得以上大部分原因跟问题并不相关。</p><p>图中的这位，显然认为把 Linux 作为自己的首选操作系统，这是个非常好的主意。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/941c7c2232bf5465c5948a36f7a9c210-7531ca.jpg" alt="Jeff Dean"></p><p>他就是 Jeff Dean，在过去十年中为 Google 创造了数十亿美元的收入。</p><p>我们俩的桌面看起来很像：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/6dd404a0b476c918ddd410ae906c2170-a97158.jpg" alt="Our&#39;s desktop"></p><p>作为硅谷的一名高级架构师，Linux 和 OS X 我都在使用，但 Linux 更适合我。我坚信 Linux 应该被普及。说实话，OS X 在某些方面的确比 Linux 好，但这优势已经越来越小，因为 OS X 的缺陷越来越多了。</p><p>我相信，当工程师花 2500 美元买了一台 Macbook Retina Pro（16 GB 内存，Intel Iris Pro Graphics 图形处理器 和 AMD Radeon R9 M370X 图形处理器），就会发现 Mac 并没有比 Linux 优秀。随着 Mac 硬件（GPU）进一步落后和软件质量下降，我能预料 Linux 的普及。</p><p>让 Linux 普及的要点是可定制以及厂家的支持。这将解决硬件兼容性问题，启动时再也不会出现“just some old hardware”的提示。我现在用 System76 的笔记本和台式电脑，他们的电脑和售后非常好。我其中的一台笔记本 Oryx Pro 配置如下：搭载 GSync 技术的 GTX970m 显卡，固态硬盘， i7 处理器，32 GB 内存和 IPS 显示器，一点也不比 Macbook Pro 差。同时，我维护着一份 Kubuntu 下装机必备软件列表，欢迎评论和补充。</p><p>以下是我为什么用 Linux 开发和个人电脑的原因：</p><p><strong>1.强劲的 GPU 和 CPU。</strong>我的家用电脑和笔记本都培了顶级的显示器和 GPU。我和孩子 Steam 上玩了有 2000 个游戏，并且我对 CUDA 和 深度学习很感兴趣。而 Mac 对此就无能为力了。对我来说，强大的 GPU 是非常重要的，所以我配了一台搭载 GTX980Ti 显卡、32 GB 内存、3440×1440分辨率的曲面屏、i7 WildDogPro 处理器的电脑。而价格跟 MBP Retina 的价格相差无几。</p><p><strong>2. 与服务器真正的兼容。</strong>我曾工作过的一家公司，半数脚本是用 Linux 脚本和 GNU 工具写的，另一半是 Bash 和 BSD 工具写的，因为这部分开发者坚持用 Mac 开发，并认为 Mac 和 Linux 相差无几。我只想说，这真的太乱了。后来，我花了几周时间重写了代码（为了兼容）。这些人一边说：“Mac OS X 是不同的”，但另一边又说：“Mac OS X 跟 Linux 相差无几”。但事实并不是，Mac OS X 与 Linux 差很多。</p><p><strong>3. Linux 使我更高效。</strong>几乎不需要切换环境，我可以使用相同的工具，专注编写脚本，与服务器无缝衔接。至今，我还没发现哪个 Mac 用户能展现出令我印象深刻的 脚本编写能力。我曾经管理过一个需要超过 100 台以上 Linux 服务器集群的软件，除了 Linux ，其它系统根本胜任不了这个任务。</p><p><strong>4. Linux 上一切允许正常（Everything just works）。</strong>相对那些用 Mac 的同事，我在 Linux 上碰到的问题更少。不需要安装 <a href="http://brew.sh/">homebrew</a>、<a href="http://www.finkproject.org/">fink</a>、<a href="https://www.macports.org/">MacPorts</a>，只要运行 <code>suao apt-get update</code> 和 <code>sudo apt-get upgrade</code> 这两个命令就可以了。团队里有少数人还在坚持使用 Mac，他们认为这是一种荣耀。编写脚本和程序设置电脑， Mac 大概要 2-3 天，而 Linux 只要一个小时，而且几乎是全自动化的。</p><p><strong>5. Linux 能做 Mac 不能做的事。</strong>有一天，我们需要超高清分辨率的屏幕截图，在 Linux 上只要输入: <code>$ xrandr --output DP-2.8 -s 3440x2880 --panning 3440x2880</code> ，之后用 Chrome 把图片放大一倍，并用 Ksnapshot 获得所需图片，前后只需要几分钟。谁能在 Mac 或者 Windows 上实现？</p><p><strong>6. “Linux 上不能运行商业软件”这个争论是毫无意义的</strong>，尤其是在硅谷，这里早就不使用微软的 Office 软件了。我使用 Balsamiq 3、Slack、DropBox、Chrome、Hangout、Google 办公套件、GoToMeeting、WebStorm、Skype、Gimp、Insync等软件…对了，在休息时间我会在 Steam 上玩会游戏。所有程序都运行良好，几乎没有应用程序或者系统崩溃。Webstorm（JetBrains IDE）在 Linux 上更友好，同样，NodeJS、MongoDB、MySQL和其它一系列开发工具在 Linux 都比 Mac 友好。</p><p>KED&#x2F;Plasma 的界面比 Mac 和 Windows 都友好多了。你问我为什么这么说，因为我 KDE&#x2F;Plasma 我都在使用。</p><p>这么多开发人员缺乏系统管理和使用脚本的技能，真是一件令人沮丧的事。相对命令行来说，Mac OS X 的图形界面限制了程序员的思考。如果有一天我在硅谷创业，我会把 Linux 当做首选的操作系统。</p><p><strong>注：</strong></p><ul><li>CUDA：一种由 NVIDIA 推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</li><li>deep learning：深度学习。源于人工神经网络的研究。含多隐层的多层感知器就是一种深度学习结构。深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示。需要 N 卡支持，而 Macbook 基本上配的都是 Intel 显卡。</li></ul><h3 id="Garry-Taloy-的回答，103-顶"><a href="#Garry-Taloy-的回答，103-顶" class="headerlink" title="Garry Taloy 的回答，103 顶"></a>Garry Taloy 的回答，103 顶</h3><p>GPU:</p><p><strong>程序员 !&#x3D; 游戏玩家。</strong></p><p>毫无疑问，配有更快的 GPU 显示效果更好，但除非你是开发游戏或者需要进行 3D 渲染，否则太奢侈了。我自己的两台开发用电脑，都只配备了普通的 Intel 集成显卡。</p><p><strong>Linux 允许你修改任何文件：</strong></p><p>我只是一位程序员，我只关心自己的代码，除此之外，别的文件能否修改和编译我并不关心。或许你该问问自己：什么是我真正需要编辑的？我是否有能力去修改文件？我为什么要这么做？</p><p><strong>在同一个系统下开发更好（代指服务器环境和开发环境相同）</strong></p><p>首先，这个理由相当不错，但对于 Apache 或者其它什么，在 Mac OS X 上和 Linux 上运行的效果是极其相似的。如果使用诸如 OpenVMS 、 IBM i 或者 z&#x2F;OS 这些操作系统，那就另当别论了。但是，我敢打赌，在 Mac 上运行网页的效果肯定跟 Linux 是一样的。</p><p><strong>Expensive:</strong></p><p><strong>贵</strong></p><p>实则不然，在相似情况下，一台搭载高清屏、 SSD 固态硬盘 、工业设计都不错的、你听过的牌子的笔记本， Mac 的价格其实并没有贵多少。姑且就说 Mac 贵几百美元吧，但能给程序员支付高薪的公司，并不会吝啬这部分钱。假设 Google 程序员的年薪是 100,000 美元，加上税收和医疗保险、办公空间等额外支出，Google 每年在程序员身上的花费可能会达到 150000 美元。你认为 Google 会在乎多花 300 美元购买 Mac 嘛？</p><p>这就好像花 10 美元买喜欢的披萨，和话 10.01 美元买你很喜欢的披萨，没多少差别~</p><p>回答你的问题，就要忽略你说的，因为你说的 99% 与问题无关。</p><h3 id="Ivan-Apple-的回答"><a href="#Ivan-Apple-的回答" class="headerlink" title="Ivan Apple 的回答"></a>Ivan Apple 的回答</h3><p><strong>服务器是运行在 Linux 上的，在 Linux 上开发岂不更好</strong></p><p>兄弟，你这让我想起这个论点还有价值的年代。想当年，想用 Linux 却没钱买新电脑，唯一的选择就是将 Linux 作为你的主操作系统（学会忍受糟糕的 GUI、应用少等这些不足之处）。</p><p>如今，通过 VirtualBox，可以很轻松地在 Windows 或 Mac 上安装 Linux 服务器发行版，“在同一个操作系统下开发”就迎刃而解了。</p><p>最终，学习如何调整 KDE Plasma 和 分析 Wi-Fi 驱动并不会让你成为一个更好的程序员和系统管理员。这只是一个习惯问题，而且是相当无聊的习惯。</p><p><strong>Linux 允许你修改任何文件</strong></p><p>这个观点经常出现在争论中。</p><p>我就说一句话：Ubuntu 和 Red Hat 是现实世界中最流行的 Linux 发行版，而它们可以在 VirtualBox 很好的工作。</p><p><strong>昂贵但 GPU 性能一般！</strong></p><p>其实 Mac 并不贵。MB Pro 大概只要 1300 欧元（折合人民币约 9500 元）。而差不多配置 HP 或者 Lenove 笔记本大概要 900 欧元（折合人民币约 6600元）。根据笔记本平均生命周期，购买外形轻薄、耐用（强劲的电池寿命）的 Mac 每个月只要多支付 7 欧元即可。这是一个很划算的投资。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> Development </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写出专业的代码注释？</title>
      <link href="/posts/2020-05-09-how-to-write-code-comments-like-a-pro.html"/>
      <url>/posts/2020-05-09-how-to-write-code-comments-like-a-pro.html</url>
      
        <content type="html"><![CDATA[<p>Over the years I’ve changed my mind multiple times about code comments.</p><p>In this article, I’ll explain how my commenting practice (yes, that’s a thing :p) has evolved as well as what I currently recommend, whether you’re a junior fresh out of school, a seasoned developer or a team lead.</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/f5bb59c868ec4e8c3d3caa933375d09f-d9a397.png" alt="image-20200509205349504"></p><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><p>At the beginning of my career as a software developer, I used to write tons and tons of comments to remind me of <em>why</em> and <em>how</em> things worked.</p><p>As I grew more accustomed to the recurring patterns and got used to the weird (read: <em>horrendous</em>) APIs of some libraries, I progressively wrote less and less comments.</p><p>The reason behind this evolution is that as your experience grows, you need less and less explanations about the <em>how.</em></p><p>What remains pretty much constant, independently of your experience level, is the need to <strong>have an understanding of the rationale&#x2F;reasoning behind certain implementation details</strong>.</p><p>Having a strong understanding of the language&#x2F;technology being used is key, but doesn’t tell you the whole story. Without hints about the intent of the code, things can get blurry real quick.</p><p>I once joined a really large project where nobody on the team even knew why some areas of the system were there. And that means trouble…</p><p>Nowadays, I tend to write comments mostly to explain why some sub-systems exist, why they’re structured the way they are or why a certain data structure has been chosen over another (e.g., for performance reasons).</p><p>UML schemas and wiki documentation can also be useful for higher level explanations, but I tend to avoid creating too many of those as they’re far away from the code and really hard to maintain.</p><p>I still like to use comments to highlight the “danger zones”. That is: critical pieces of the code that should only ever be touched with <em>care</em>. Those are useful, as the most sensitive code paths in a system have usually been battle tested and <em>just work</em>. This is not to say that we can’t refactor such code, but it has to be done with care (even if automated tests are in place). Sometimes there’s a subtle bug fix; sometimes it’s a matter of performance.</p><p>What I also often do is add references as comments; for instance towards the documentation of specific APIs or features that are being used, or pointers to relevant StackOverflow questions.</p><h2 id="为什么注释写太多反而不好？"><a href="#为什么注释写太多反而不好？" class="headerlink" title="为什么注释写太多反而不好？"></a>为什么注释写太多反而不好？</h2><p>As a junior developer, when a codebase is littered with comments, you might feel safe, as you see tons of helpful messages to guide&#x2F;reassure you and clear out any doubts.</p><p>Although, as time goes by, you’ll realize that, often times, those comments are out of sync with the code. When you’ll have noticed this multiple times, you’ll start paying less and less attention to those comments; until you just ignore them. At least that’s one possible reaction; it’s related to the <a href="https://en.wikipedia.org/wiki/Broken_windows_theory">theory of broken windows</a>; the same is true of bad&#x2F;ugly code and a lack of attention to technical debt. The alternative is to systematically try to fix the comments, which is better but also has an associated <em>cost</em>.</p><p>The main issue with having too many comments is that those not “safe” &#x2F; “type safe” &#x2F; “compiled”. Nothing apart us, humans reading&#x2F;writing them, can make sure that they’re still correct&#x2F;relevant. In a sense we’re the comment parsers; it’s up to us to keep them relevant.</p><p>Comments are <em>metadata</em>; they live in another “dimension”, independent of the code itself. More importantly, comments have an associated maintenance cost. Each and every comment line is actually something more to maintain in the project. To me, code comments <em>decay</em> is also technical debt of sorts.</p><p>The more comments you have in your codebase, the more costly it becomes to maintain. This fact alone is a good reason to write <em>less</em> comments.</p><p>Although, writing too few comments is not good either; it’s always a question of balance. You should at least document the rationale behind important design choices, the reason for which elements exist in your system.</p><p>Things such as who the author of something is, what the filename is, when it was modified, etc doesn’t make any sense. Source control takes care of that.</p><p>Copyright headers also don’t make any sense; if you need those, then take that out of your code and move that into your build. Create a template and let your build system insert whatever notice you need in the generated artifacts.</p><h2 id="说一说注释掉的代码"><a href="#说一说注释掉的代码" class="headerlink" title="说一说注释掉的代码"></a>说一说注释掉的代码</h2><p>As surprising as it is (to me at least), many experienced software engineers tend to comment out sections of code, thinking that they <em>might</em> need to recover those or “re-enable” that code later on.</p><p>I’m certainly not the only one to say this, but don’t. Just <em>don’t</em>. Commented-out code is <a href="https://en.wikipedia.org/wiki/Signal-to-noise_ratio">pure noise</a>. Not only that, but it is even <em>dangerous</em>.</p><p>In addition, <strong>commented-out code is still code that has to be maintained</strong>. But in most cases, it isn’t. The more commented-out code you see, the less you pay attention to it. Unfortunately, if you really decide to uncomment lines of code after some time has passed, then if that code hasn’t been maintained along with the rest, then it might end up introducing bugs (or worse).</p><p>Whenever you think about commenting out some code, just forget it. Don’t. Delete it. Right there.</p><p>If that code was never committed, then it doesn’t matter; it was just an idea; forget about it.</p><p>If that code was previously in the codebase, then removing it altogether now doesn’t mean that it is gone forever. Your source control management system is there exactly for that purpose. If you end up needing that code ever again, then you’ll dive into the history of your project and you’ll find it back, safe and sound.</p><p>Whenever I notice commented-out code, I don’t hesitate one bit: I delete it right away. And you should do that too. Less is <em>more</em>.</p><h2 id="使用日志的方式去说明发生了什么"><a href="#使用日志的方式去说明发生了什么" class="headerlink" title="使用日志的方式去说明发生了什么"></a>使用日志的方式去说明发生了什么</h2><p>Code comments are relevant for maintenance; they help your teammates, your successors and even your future self to know <em>why</em> things are there and what is the rationale behind the architecture&#x2F;design choices.</p><p>On the other hand, as I’ve explained above, comments detailing <em>what</em> the code is doing are mostly useless, misleading and costly to maintain. On the contrary, log statements that explain what the code is doing are incredibly valuable for any production system. When things go awry in production, you’ll be happy to find log files filled with useful troubleshooting information.</p><p>If you think about writing a comment to explain what the code is doing, then you should instead add a log statement, with the correct granularity (I’ll soon write an article about that!).</p><p>Nowadays, what I tend to do when I notice that there are too many comments is to immediately remove those that are useless&#x2F;outdated. If I notice that there’s no or not enough logging, then I add some log statements.</p><h2 id="编写自动化测试来解释运行原理"><a href="#编写自动化测试来解释运行原理" class="headerlink" title="编写自动化测试来解释运行原理"></a>编写自动化测试来解释运行原理</h2><p><a href="https://en.wikipedia.org/wiki/Behavior-driven_development">行为驱动开发(Behavior-Driven Development, BDD)</a> is all about creating a shared understanding of how the system works. By applying BDD, you’ll create tests that double as specifications for the code it covers.</p><p>This is awesome because since tests are strongly tied with the code that is being tested, it is much harder to let it fall behind. Tests can be statically checked along with the rest of your code. Moreover, if a test fails, then you know that you either need to adapt the specs&#x2F;tests or fix the broken code. Isn’t that great? To me it is, and certainly much more helpful than bogus comments!</p><p>Do yourself a favor; whenever you feel like writing a comment explaining the “how”, write tests instead.</p><p>By the way, BDD is awesome for many other reasons, so if you’re not familiar with that, make sure to read a few articles about it and give it a try in your next projects.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这这篇文章中，我分享了编写代码注释的一些想法。</p><p>听起来可能会觉得比较无聊，但这些东西确实是你项目中重要的一部分。如果它们是相关的且是最新的，则会很有用。但如果是过时的话，很容易产生误导。</p><p>有用的注释大多都是关于“为什么”，而不是“如何”。</p><p>前文太长，总结如下：</p><ul><li>不要写太多的注释。如有必要，请专注于解释理由&#x2F;意图，或者写一些重要的警告，外部引用之类的东西。</li><li>维护代码时不要忘记注释，它们也是“技术债”的一部分。不要忽略注释。删除那些无用的注释，更改代码时要对应维护注释。</li><li>如果是为了说明发生了什么，建议使用日志。这也将有助于生产环境的故障排查。</li><li>如果是为了解释某个东西为什么存在，以及是如何工作的。建议编写自动化的 BDD 测试</li><li>代码不用时不要注释掉，请直接删掉。</li></ul><p>Translate from <a href="https://itnext.io/how-to-write-code-comments-like-a-pro-c830e68cec92">https://itnext.io/how-to-write-code-comments-like-a-pro-c830e68cec92</a> by <a href="https://ismdeep.com/">ismdeep</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员必备技能（Windows篇）</title>
      <link href="/posts/2020-05-05-basic-skills-for-programmers-on-windows.html"/>
      <url>/posts/2020-05-05-basic-skills-for-programmers-on-windows.html</url>
      
        <content type="html"><![CDATA[<p>此文应该算作是程序员学习编程以及其他技术的一个前置技能。很多同学经常遇到一些奇怪的问题，主要都是由系统配置不对、文件名配置错误、命令提示符不会使用所造成的。</p><ol><li>显示隐藏文件</li><li>显示文件后缀名</li><li>命令提示符（命令行）的使用</li><li>配置环境变量</li><li>git for windows</li><li>Windows 服务管理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 数据库连接</title>
      <link href="/posts/2020-05-04-connect-to-mysql-server.html"/>
      <url>/posts/2020-05-04-connect-to-mysql-server.html</url>
      
        <content type="html"><![CDATA[<p>之前一篇文章是关于如何在 Windows 环境中安装 MySQL 服务的。</p><h3 id="01-查看-MySQL-服务状态"><a href="#01-查看-MySQL-服务状态" class="headerlink" title="01 查看 MySQL 服务状态"></a>01 查看 MySQL 服务状态</h3><p>在命令提示符中使用 <code>net start</code> 即可查看 MySQL 是否正在运行。当然也可以直接打开 Windows 服务查看 MySQL 服务是否正在运行。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/fe9666d44e22473afa645bc1396897d5-3aa614.png" alt="image-20200504112645380"></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/88c513d3d549592ff5dcd8697bb6fc1f-1f4b89.png" alt="image-20200504112711751"></p><h3 id="02-命令行连接-MySQL-服务"><a href="#02-命令行连接-MySQL-服务" class="headerlink" title="02 命令行连接 MySQL 服务"></a>02 命令行连接 MySQL 服务</h3><p><strong>注意：</strong>当 MySQL 服务在运行的时候才能连上 MySQL 服务。这个应该能够理解吧。这事情就好比只有你男朋友手机是开机的情况下你才有可能打通电话，对吧。</p><p>打开命令提示符并切换至 MySQL 目录的 <code>bin</code> 子目录。再执行 <code>mysql -uroot -p</code> ，换行后如果你的 root 账号有密码则输入密码，如果没有则直接换行即可。</p><p>进入之后执行 <code>show databases;</code> 查看当前帐号可以访问的数据库列表。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/958856f4b9c961114e85eed5eb49e182-13716c.png" alt="image-20200504113338879"></p><p>到此，如果没有出现啥问题，则表明你通过命令行访问数据库的操作一切正常。</p><h3 id="03-其他客户端连接-MySQL-服务"><a href="#03-其他客户端连接-MySQL-服务" class="headerlink" title="03 其他客户端连接 MySQL 服务"></a>03 其他客户端连接 MySQL 服务</h3><p>接下来和大家聊一聊 MySQL 服务和 MySQL 客户端的关系。</p><p>一个完整可运行的 MySQL 服务软件是不需要包括 MySQL 客户端的，MySQL 服务端软件其实就是一个运行在后台的进程。这个进程你看不见摸不着。默默在后台处理着各种来自客户端的命令。而这里所说的客户端有很多种，有来自数据库管理员（DBA）对数据库管理所使用的命令行或者其他工具；也有开发人员用来测试并访问数据库使用的工具；甚至还有是用 C 语言或者是 PHP 写的程序代码执行时调用的 MySQL 库。而这些所有连接数据库的原理都是一样的。它们都通过 MySQL 标准的数据通信协议与 MySQL 进行数据交互（如：数据插入、数据删除、数据修改、数据查询等。）</p><p>于是对数据库访问并操作的工具有特别多，甚至你要是有一点创造力还可以自己动手写一个小工具（[&#x2F;呲牙]）。</p><p>以下给大家推荐几款笔者觉得还算不错的可在 Windows 上使用的 MySQL 客户端软件。</p><ul><li>DataGrip （JetBrains家的东西就是香呀。这个 DataGrip 是 JetBrains 专门用来管理数据库的软件。）</li><li>JetBrains 其他产品，当然除了上面的 DataGrip， JetBrains 家的其他产品上也有对应的插件去连接并管理数据库。其优势在于：<strong>你在一个开发的工具中既可以完成代码编写工作，也可以进行数据库的管理。这样会很方便，无需在各种界面中切换。</strong></li><li>Navicat 推荐用 Navicat Premium 11 ，网上也有不错的破解工具。</li><li><a href="https://dbeaver.io/">DBeaver</a> <strong>优点：免费</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 安装</title>
      <link href="/posts/2020-04-29-mysql-install.html"/>
      <url>/posts/2020-04-29-mysql-install.html</url>
      
        <content type="html"><![CDATA[<p>工欲善其事，必先利其器。几乎所有的计算机类教程中，对新手来说最重要的一篇教程就是如何安装需要使用到的软件，从 C 语言到大数据，再到云计算，到处都充斥着各种各样的开发软件及运行系统。至于为什么需要这么软件，主要原因在于，你安装了这些软件，就如同站在了巨人的肩膀上。前人已经把一些工作做完了，你可以直接拿过来用了。</p><p>话不多说，我们来看看如何安装？</p><p>如教程介绍中一样，我们使用 MySQL 5.7 版本。</p><h3 id="01-为什么会有这么多版本？"><a href="#01-为什么会有这么多版本？" class="headerlink" title="01 为什么会有这么多版本？"></a>01 为什么会有这么多版本？</h3><p>数据库其实也是一套软件，软件都是处于不断更新迭代的过程的，无论是如 QQ、微信这样的聊天软件，还是像 Windows 这样的操作系统，都会为了各种各样的目的，不断更新软件的版本。其目的有修复已知BUG，推出新的功能等等。</p><h3 id="02-MySQL-版本有哪些？"><a href="#02-MySQL-版本有哪些？" class="headerlink" title="02 MySQL 版本有哪些？"></a>02 MySQL 版本有哪些？</h3><p>目前 MySQL 已知主流的版本有 5.0、5.1、5.5、5.6、5.7、8.0 版本号越大说明软件越新，当然功能及稳定性、安全性等<strong>应该</strong>更强。那么，本文我们将使用 MySQL 5.7 作为安装及学习的一个版本。</p><h3 id="03-下载-MySQL数据库"><a href="#03-下载-MySQL数据库" class="headerlink" title="03 下载 MySQL数据库"></a>03 下载 MySQL数据库</h3><p>安装软件的第一步工作就是下载这个软件，当今网络环境，下载软件、安装软件都已经成为了一项技术活，因为一个不小心，都有可能会安装上一些神奇的软件。作为一名程序员，我希望我的系统尽量的干净简单，因为某些神奇的软件会影响我正在运行的服务（这些服务就会包括 MySQL 数据库服务）。</p><p>首先打开 MySQL 官网：<a href="https://www.mysql.com/">https://www.mysql.com</a> 当然，你也可以去某度上搜索，记住要看清楚你需要打开的网址，不然跳到某个奇怪的页面，笔者可不负责。</p><p>打开之后，你会看到一个类似下图这样的网页</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/5e75c83723faa920fb43dd7a66912006-8e6669.png" alt="20200429205757.png"></p><p>接下来点击网站顶部导航栏中的 <code>DOWNLOADS</code> 进入 MySQL 下载主页，并将页面往下滑，看到这样的一个页面</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/88c7d88dd48e6ccfcf95c9d896985b96-9dce22.png" alt="20200429205948.png"></p><p>接下来点击页面上的 <code>MySQL Community(GPL) Downloads</code> 链接。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/d1ee3c68b972eaf05258f4852c110277-264f60.png" alt="image-20200429210309455"></p><p>在进入这个页面之后点击 <code>MySQL Community Server</code> 链接进入 MySQL 下载选择页面。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/c725b86298c4c69a0b5cfbf2bf6ccf11-134614.png" alt="image-20200429211027662"></p><p>由于目前（2020-04-29） MySQL 最新版版本已经是 MySQL 8.0.20 了，我们需要下载的 MySQL 5.7 已经不在下载选择页面的默认页了。我们需要点击页面上的 <code>Archives</code> 切换导存档 MySQL 下载页面。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/65161ecfbe4dae08f47300f14cb2e871-336aa0.png" alt="image-20200429211244674"></p><p>在进入到这样的页面之后，我们依次选择 <code>Product Version</code> , <code>Operating System</code> 选项，就可以筛选出对应的版本及操作系统的 MySQL 数据库服务器软件了。本教程使用是 MySQL 5.7 版本，我们下拉筛选的时候选择 5.7版本最大的即可。由于大部分同学用的都是 Windows 64位的操作系统，按上图选择即可。最后筛选出来会有两个文件： <code>ZIP Archive</code> 和 <code>ZIP Archive, Debug Binaries &amp; Test Suite</code> ，这里下载第一个 <code>ZIP Archive</code> 即可。</p><p>点击后面的 <code>Download</code> 即可下载。当然，这里下载速度可能会比较感人，笔者顺便给大家安利一个 Windows 下用来下载国外资源很快的软件 <a href="https://www.internetdownloadmanager.com/">IDM</a></p><p>如果下载速度还是比较慢的话，可以前往 <a href="https://mirrors.ustc.edu.cn/mysql-ftp/Downloads/MySQL-5.7/">https://mirrors.ustc.edu.cn/mysql-ftp/Downloads/MySQL-5.7/</a> 找相应的下载包。如 MySQL 5.7.29 x64 版本对应名称为：mysql-5.7.29-winx64.zip</p><p>下载之后你会看到名称为 mysql-5.7.xx-winx64.zip 的一个压缩包文件</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/d5574082ca97277200aa64cec25ecf43-77b980.png" alt="image-20200429213606350"></p><p>接下来将这个压缩包文件复制到一个用于存放软件的目录中（<strong>重点：这个目录的完整地址中最好不要出现空格和中文字符以及一些奇怪的符号。尽量用英文即可。</strong>）笔者这里则将其复制到 <code>C:\apps</code> 里面。目录没有可以自己新建。为了避免踩坑，建议大家跟我一样选择 <code>C:\apps</code> 文件来存放我们的压缩包文件。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/7621ce307dfee6ef1be00f82dbfc2463-615b27.png" alt="image-20200429214243271"></p><p>将这个文件解压。（嗨呀，我又要来安利软件了，那就是 <a href="https://www.7-zip.org/">7-Zip</a> 特点：小巧，才 1MB；效率，解压速度快；安全无捆绑；嗨呀，还是各种国内压缩软件的爷爷，国内这些基本都是拿着人家内核过来加上捆绑的广告就成了自主研发的。）</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/9fb3dd4118a4c84df855de6d5b4fb8ad-a541ce.png" alt="image-20200429214627808"></p><h3 id="04-编辑配置文件"><a href="#04-编辑配置文件" class="headerlink" title="04 编辑配置文件"></a>04 编辑配置文件</h3><p>在 MySQL 目录下新建两个文件 <code>my-default.ini</code> 与 <code>my.ini</code> ，并都保存一下文本。（如果你存放 MySQL 的目录与本文不同则需要对应地修改 <code>basedir</code> 与 <code>datadir</code>）</p><pre><code class="text">[mysqld]port = 3306basedir=C:\apps\mysql-5.7.29-winx64datadir=C:\apps\mysql-5.7.29-winx64\datamax_connections=200character-set-server=utf8mb4default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]default-character-set=utf8mb4</code></pre><p>接下来打开命令行，并切换到 <code>C:\apps\mysql-5.7.29-winx64</code> 目录下，再执行以下命令。</p><pre><code class="bash">bin\mysqld.exe --initialize-insecure</code></pre><p>如下图</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/11b3a8c907f5b0f9f2956aeb3f39b4f6-fc1e29.png" alt="image-20200504110714003"></p><p>这里是初始化一份MySQL的数据，而且这里初始化后的 root 账号密码是空。后续可以根据需求自行修改。</p><p><strong>注：</strong>在这部分执行命令时可能会弹出 <code>msvcr120.dll</code> <code>msvcp120.dll</code> 缺少这样的错误提示。可前往 <a href="https://www.techpowerup.com/download/visual-c-redistributable-runtime-package-all-in-one/">https://www.techpowerup.com/download/visual-c-redistributable-runtime-package-all-in-one/</a> 下载并安装 Visual C++ 运行时依赖即可。</p><h3 id="05-安装-MySQL-服务"><a href="#05-安装-MySQL-服务" class="headerlink" title="05 安装 MySQL 服务"></a>05 安装 MySQL 服务</h3><p>先说一说这样安装的特点吧， <strong>与系统关联不大，没有多余的系统资源占用，卸载方便，迁移方便</strong> 。</p><p>通过下载的安装包，MySQL 是可以直接运行的，安装时其实只需要注册一个 Windows 服务，卸载时只需要将这个服务删除即可。</p><p>在安装之前，你需要知道如何打开 Windows 命令提示符，包括如何以管理员身份打开 Windows 命令提示符。并且知道如何切换到指定目录。</p><p><strong>首先</strong>，打开 Windows 命令提示符。无论是 Windows 7 还是 Windows 10，都可以通过 <code>C:\Windows\System32</code> 目录找到一个名称为 <code>cmd.exe</code> 的文件。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/3e0fb95c2b8f678cada3cc5daadf9b1f-ea63be.png" alt="image-20200430083519324"></p><p>选中 <code>cmd.exe</code> 右键 - 以管理员身份运行，接下来可能会弹出一个授权窗口，点击确定。就能以管理员身份打开命令提示符了。</p><p>由于我们这里存放 MySQL 数据库的目录是 <code>C:\apps</code> ，那么接下来我们在命令提示符中输入 <code>cd C:\apps</code> 并输入 <code>dir</code> 就能看到 MySQL 解压后的目录。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/d2ff2d5602b2231111387f9284d1148a-d4710d.png" alt="image-20200430084106633"></p><p>接下来输入 <code>cd mysql-5.7.29-winx64</code> 就能进入此目录了，并继续 <code>cd bin</code> 进入 MySQL 的 <code>bin</code> 目录。</p><p><em>小技巧：在命令提示符中输入 <code>cd mysql</code> 之后直接按 tab 键，能自动补全后面的信息，非常方便。</em></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/565e866763ff6b90ff541fd403e28b3a-a1288a.png" alt="image-20200430084521583"></p><p>在此处执行 <code>mysqld --install</code> 即可安装 MySQL 到 Windows 服务。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/c62fccfa9fc267f0e9ac121a01070afa-5e9bac.png" alt="image-20200504111045615"></p><p>在 Windows 服务列表中就能看到 MySQL 了，如果你不希望 MySQL 服务开机自启动可以选择设置启动类型为手动。</p><h3 id="06-启动-MySQL-服务"><a href="#06-启动-MySQL-服务" class="headerlink" title="06 启动 MySQL 服务"></a>06 启动 MySQL 服务</h3><p>打开命令行可以通过 <code>net start mysql</code> 启动 MySQL 服务。</p><h3 id="07-关闭-MySQL-服务"><a href="#07-关闭-MySQL-服务" class="headerlink" title="07 关闭 MySQL 服务"></a>07 关闭 MySQL 服务</h3><p>打开命令行可以通过 <code>net stop mysql</code> 关闭 MySQL 服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 实用教程</title>
      <link href="/posts/2020-04-29-mysql-tutorial.html"/>
      <url>/posts/2020-04-29-mysql-tutorial.html</url>
      
        <content type="html"><![CDATA[<p>从今天开始，我们一起来学习一下 MySQL 数据库。</p><p>在给系列教程起名字的时候，本想着用《MySQL 简明教程》的。但终究名字还是不尽如意，因为如果是简明，肯定会遗漏掉很多东西，抑或者教程会变得非常简陋，以至于不知所云。本系列教程暂且目标为实用主义，也就是说主要在 MySQL 实际项目开发中的使用。至于一些底层原理，甚至是教科书上的范式之类的东西，这里暂且不去讨论。</p><p><strong>本教程目标：</strong>讲授 MySQL 实际使用，尽量帮助读者尽快掌握 MySQL 的<strong>使用</strong>。</p><p><strong>写在前面的话：</strong> 为了统一以及以免因为数据库版本不同造成命令无法使用或错误的问题，我们将统一使用 MySQL 5.7 版本的 MySQL 数据库。</p><ul><li><a href="/posts/2020-04-29-mysql-install.html">01-MySQL安装</a></li><li><a href="/posts/2020-05-04-connect-to-mysql-server.html">02-MySQL 数据库连接</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装 Nginx + MySQL + PHP 环境（ macOS篇 ）</title>
      <link href="/posts/2020-04-22-install-nginx-mysql-php-on-macos.html"/>
      <url>/posts/2020-04-22-install-nginx-mysql-php-on-macos.html</url>
      
        <content type="html"><![CDATA[<p>现在的 PHP 开发基本上都是基于 Nginx + PHP-FPM + MySQL 环境来运行的，那么接下来笔者打算来简单介绍一下 macOS 环境下搭建 PHP 开发环境的步骤。</p><h4 id="0x01-安装-Homebrew"><a href="#0x01-安装-Homebrew" class="headerlink" title="0x01 安装 Homebrew"></a>0x01 安装 Homebrew</h4><pre><code class="bash">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><h4 id="0x02-安装必要的一些软件"><a href="#0x02-安装必要的一些软件" class="headerlink" title="0x02 安装必要的一些软件"></a>0x02 安装必要的一些软件</h4><pre><code class="bash">brew install wgetbrew install autoconfbrew install openssl</code></pre><h4 id="0x03-安装-Nginx"><a href="#0x03-安装-Nginx" class="headerlink" title="0x03 安装 Nginx"></a>0x03 安装 Nginx</h4><pre><code class="bash">brew install nginx</code></pre><h4 id="0x04-安装-MySQL"><a href="#0x04-安装-MySQL" class="headerlink" title="0x04 安装 MySQL"></a>0x04 安装 MySQL</h4><pre><code class="bash">brew install mysql</code></pre><h4 id="0x05-安装-php72"><a href="#0x05-安装-php72" class="headerlink" title="0x05 安装 php72"></a>0x05 安装 php72</h4><pre><code class="bash">brew install php72</code></pre><h4 id="0x06-配置"><a href="#0x06-配置" class="headerlink" title="0x06 配置"></a>0x06 配置</h4><ol><li><p>配置 php-fpm 权限</p><p>打开 <code>/usr/local/etc/php/7.2/php-fpm.d/www.conf</code> 并找到 <code>user = _www</code> 和 <code>group = _www</code> ，应该就是相邻的两行，将 <code>user = _www</code> 的 <code>_www</code> 替换成自己的用户名，比如笔者用户名为 <code>ismdeep</code> ，则这一行就替换成 <code>user = ismdeep</code> 即可。<strong>注意：这里的 <code>group = _www</code> 是不需要修改的。</strong></p><p><strong>用户名如何看？</strong> 打开终端，然后输入 <code>whoami</code> 即可。</p></li><li><p>配置 nginx 站点</p><p>配置前，你需要想好一个用于测试的域名。这个域名当然不用去域名注册商注册。你只需要一个本地的一个名称即可。笔者推荐使用 <code>.test</code> 作为后缀。虽然我看网上也有教程教大家安装 dnsmaq 然后配置所有 <code>.dev</code> 后缀的域名都指向本地 <code>127.0.0.1</code> IP. 但是笔者觉得这样做并不好，两个原因：1. 多安装了一个软件；2. <code>.dev</code> 后缀域名在 Chrome 浏览器中会自动定向到 https</p><p>嗨呀，想个名字好难呀。这里笔者以 <code>firstwebsite.test</code> 作为用于测试的域名。</p><ul><li><p>第一步，修改 <code>/etc/hosts</code> 文件。在最后添加 <code>127.0.0.1firstwebsite.test</code> <strong>注意：IP 与域名之间用 tab 键进行分割。空格可能会有问题。</strong> 至于域名配置是否成功可以打开终端输入 <code>ping firstwebsite.test</code> 测试一下。如果返回是 <code>127.0.0.1</code> 那么说明配置是成功的。</p></li><li><p>第二步，你需要确定你的 php 代码所存放的目录。比如这里笔者写了一个简单的 php 程序放在了 <code>/Users/ismdeep/Data/firstwebsite</code></p></li><li><p>第三步，通过命令行进入 <code>/usr/local/etc/nginx/servers</code> 目录。然后在其中添加文件 <code>firstwebsite</code> ，并输入一下文本至 <code>firstwebsite</code></p><pre><code class="text">server &#123;    listen       80;    server_name  firstwebsite.test;    root /Users/ismdeep/Data/firstwebsite;    location / &#123;        index index.php index.html;        autoindex on;    &#125;    location ~ \.php$ &#123;        fastcgi_pass   127.0.0.1:9000;        fastcgi_index  index.php;        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include        fastcgi_params;    &#125;&#125;</code></pre></li><li><p>第四步，重启 php-fpm 和 nginx</p><pre><code class="bash">sudo killall php-fpmsudo php-fpm -Dsudo /usr/local/Cellar/nginx/1.17.9/bin/nginx -s quitsudo /usr/local/Cellar/nginx/1.17.9/bin/nginx</code></pre></li><li><p>第五步，打开浏览器并访问 <code>firstwebsite.test</code></p></li></ul></li></ol><h4 id="0x06-启动-关闭命令"><a href="#0x06-启动-关闭命令" class="headerlink" title="0x06 启动 &amp; 关闭命令"></a>0x06 启动 &amp; 关闭命令</h4><ul><li>php-fpm<ul><li>启动 <code>sudo killall php-fpm</code></li><li>停止 <code>sudo /usr/local/Cellar/php@7.2/7.2.29/sbin/php-fpm -D</code></li></ul></li><li>nginx<ul><li>启动 <code>sudo /usr/local/Cellar/nginx/1.17.9/bin/nginx</code></li><li>停止 <code>sudo /usr/local/Cellar/nginx/1.17.9/bin/nginx -s quit</code></li></ul></li><li>mysql<ul><li>启动 <code>brew services start mysql</code></li><li>停止 <code>brew services stop mysql</code></li><li>重启 <code>brew services restart mysql</code></li></ul></li></ul><p><strong>提示：</strong> 以上命令中使用了绝对路径的调用方式。这是笔者一个执行程序的习惯。你可以把对应的目录加入到 <code>PATH</code> 环境变量中。</p><p>软件对应的版本号可能会随着本文发布之后的时间推移会有所变化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Development </tag>
            
            <tag> Server </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谁去参赛？</title>
      <link href="/posts/2020-04-12-who-goto-the-contest-problem.html"/>
      <url>/posts/2020-04-12-who-goto-the-contest-problem.html</url>
      
        <content type="html"><![CDATA[<p>最近再次遇到一个很久以前就见过的一个编程题。当然，题目是非常简单的，很多参加算法竞赛的同学应该都见过这个问题。</p><p>事情是这样的，在一个阳光还算明媚的下午，肖导给我发来一张图片。如下：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/738908e89b8fd537b19a796b6e329a92-01db4e.JPG" alt="img"></p><p>原来是肖导受到了关爱，要求写这样的一个程序。这个题目看上去就很简单，分成三个步骤：</p><ol><li><p>枚举所有可能的参赛组合情况</p></li><li><p>对每一个组合情况进行上诉判断</p></li><li><p>如果通过所有的判断则输出当前组合去参赛的同学名称</p></li></ol><p>但是可达鸭眉头一皱，觉得问题并不简单。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>A、B、C、D、E、F、G、H、I、J十名同学有可能参加本次竞赛，也有可能不参加。因为某种原因，他们是否参赛收到下列条件的约束：</p><ol><li>如果 A 参加，B 也参加；</li><li>如果 C 不参加， D 也不参加；</li><li>A 和 C 中只能有一人可以参加；</li><li>B 和 D 有且只有一个人可以参加；</li><li>D 、E 、F 、G 、H 五个人中至少有两个人参加；</li><li>C 和 G 或者都参加，或者都不参加；</li><li>C 、 E 、 G 、 I 中至多只能有两人参加；</li><li>如果 E 参加，那么 F 和 G 也都参加；</li><li>如果 F 参加，G 和 H 就不能参加；</li><li>如果 I 和 J 都不参加，那么 H 必须参加。</li></ol><p>请编程实现判断这些同学哪些会参加本次竞赛，如果有多种可能，则输出所有可能情况。每种情况占一行。参赛同学按字母升序排列，之间用空格隔开。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>如上述分析，只需三步。那么笔者觉得问题并不简单的考虑在于，如果按照上述方式来编写代码，其实很容易实现，但是写出来的代码可读性非常差。随手翻看了一下网上找到的几篇博客写的代码</p><p><a href="https://blog.csdn.net/u013091087/article/details/43793545">https://blog.csdn.net/u013091087/article/details/43793545</a></p><p><a href="https://blog.csdn.net/wang263334857/article/details/9191215">https://blog.csdn.net/wang263334857/article/details/9191215</a></p><p><a href="http://bbs.bccn.net/thread-341841-1-1.html">http://bbs.bccn.net/thread-341841-1-1.html</a></p><p>当然我这里并不是打算去 diss 谁，或者说是批评这些代码写得如何如何不好。</p><p><strong>首先</strong>，分析一下遍历的过程，我大概看到最多的遍历就是 <code>for</code> 循环一层套一层，如下所示：</p><pre><code class="c">for (int a = 0; a &lt;= 1; a++) &#123;    for (int b = 0; b &lt;= 1; b++) &#123;        for (int c = 0; c &lt;= 1; c++) &#123;            for (int d = 0; d &lt;= 1; d++) &#123;                ...            &#125;        &#125;    &#125;&#125;</code></pre><p>还有就是通过 DFS（Depth-First Search，深度优先搜索）的方式进行遍历所有的组合，如下所示：</p><pre><code class="c">void dfs(int cur) &#123;    if (cur == 10) &#123;        Test();        return ;    &#125;    a[cur] = 1;    dfs(cur+1);    a[cur] = 0;    dfs(cur + 1);&#125;</code></pre><p>都是可以实现的， 第一种方式通过层层 <code>for</code> 嵌套带来的问题就是代码太长，而且使用大量的变量；第二种方式通过 DFS 遍历带来的问题在于可读性会变差，而且这里还使用了全局变量。</p><p>在编写程序时，需要尽量不使用全局变量，因为全局变量可能会带来变量冲突的问题。</p><p>那么通过分析发现，其实这里每一位同学的参赛情况就是两种状态：参加、不参加。而十位同学的所有参赛状态组合，正好就是十位二进制的所有数字，即：数字0 ～ 数字1023的二进制表示。</p><p>于是对于遍历就可以非常简单的变为：<code>for (int val = 0; val &lt;= 1023; val++)</code> 然后只需要将 <code>val</code> 展开成每位同学的参赛情况即可。</p><p>展开代码如下：</p><pre><code class="c">void extract_data(int val, bool data[]) &#123;    for (int i = 0; i &lt; STU_CNT; i++) &#123;        data[i] = val % 2;        val /= 2;    &#125;&#125;</code></pre><p><strong>其次</strong>，约束判断的写法也有考虑，通过对问题的分析发现所有的约束条件都可以写成：<strong>如果 p ，那么 q.</strong> 这样的形式。也就是说在 <code>p</code> 发生的条件下，<code>q</code> 必须要满足。言下之意，如果 <code>p</code> 不发生，那么就不需要去考虑 <code>q</code> 是否成立。</p><p>于是笔者封装了如下函数：</p><pre><code class="c">bool if_then (bool if_case, bool then_case) &#123;    if (if_case &amp;&amp; !then_case) &#123;        return false;    &#125;    return true;&#125;</code></pre><p>至于判断是否满足约束时，则只需要设置好十个条件，一次判断并计数通过判断的个数，最后如果通过判断个数的计数器等于 10 ，则表明通过了所有的判断。</p><p><strong>最后</strong>，输出参加比赛的学生列表。这里比较简单，就不过多去说了。</p><pre><code class="c">void print_students(bool data[]) &#123;    for (int i = 0; i &lt; STU_CNT; i++) &#123;        if (data[i]) &#123;            printf(&quot;%C &quot;, &#39;A&#39; + i);        &#125;    &#125;    printf(&quot;\n&quot;);&#125;</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define A 0#define B 1#define C 2#define D 3#define E 4#define F 5#define G 6#define H 7#define I 8#define J 9#define STU_CNT 10#define MAX_VAL (1&lt;&lt;STU_CNT)-1void extract_data(int val, bool data[]) &#123;    for (int i = 0; i &lt; STU_CNT; i++) &#123;        data[i] = val % 2;        val /= 2;    &#125;&#125;bool if_then (bool if_case, bool then_case) &#123;    if (if_case &amp;&amp; !then_case) &#123;        return false;    &#125;    return true;&#125;bool test_func (const bool data[]) &#123;    int passed = 0;    /* 1. 如果A参加，B也参加 */    passed += if_then(data[A], data[B]);    /* 2. 如果C不参加，D也不参加 */    passed += if_then(!data[C], !data[D]);    /* 3. A和C中只能有一人可以参加 */    passed += if_then(true, data[A] + data[C] &lt; 2);    /* 4. B和D有且只有一个人可以参加 */    passed += if_then(true, data[B] + data[D] == 1);    /* 5. D、E、F、G、H五个人中至少有两个人参加 */    passed += if_then(true, data[D] + data[E] + data[F] + data[G] + data[H] &gt;= 2);    /* 6. C与G或者都参加，或者都不参加 */    passed += if_then(true, data[C] + data[G] == 2 || data[C] + data[G] == 0);    /* 7. C、E、G、I中至多只能有两人都参加 */    passed += if_then(true, data[C] + data[E] + data[G] + data[I] &lt;= 2);    /* 8. 如果E参加，那么F和G也都参加 */    passed += if_then(data[E], data[F] &amp;&amp; data[G]);    /* 9. 如果F参加，G和H就不能参加 */    passed += if_then(data[F], !data[G] &amp;&amp; !data[H]);    /* 10. 如果I和J都不参加，那么H必须参加 */    passed += if_then(!data[I] &amp;&amp; !data[J], data[H]);    if (passed &lt; 10) &#123;        return false;    &#125;    return true;&#125;void print_students(bool data[]) &#123;    for (int i = 0; i &lt; STU_CNT; i++) &#123;        if (data[i]) &#123;            printf(&quot;%C &quot;, &#39;A&#39; + i);        &#125;    &#125;    printf(&quot;\n&quot;);&#125;int main() &#123;    bool *data = (bool*) malloc(sizeof(bool) * STU_CNT);    for (int val = 0; val &lt;= MAX_VAL; val++) &#123; /* 1. 遍历 */        extract_data(val, data);               /* 2. 展开 */        if (test_func(data)) &#123;                 /* 3. 约束判断 */            print_students(data);              /* 4. 输出 */        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>完整代码中宏定义是一个增强代码可读性的一个方法，通过宏定义设置 <code>A</code> 同学占用 <code>data[0]</code> ，依此类推。</li><li>通过函数封装提高代码的可读性</li><li>出现多个同属性的数据时应该考虑使用数组进行存储，如这里的十位同学是否参赛的数据。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 开发工具包</title>
      <link href="/posts/2020-03-22-java-tools.html"/>
      <url>/posts/2020-03-22-java-tools.html</url>
      
        <content type="html"><![CDATA[<p>Java 开发工具包下载。</p><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><ul><li><a href="https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/jdk1.8.0_241.zip">https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/jdk1.8.0_241.zip</a></li><li><a href="https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/jre1.8.0_241.zip">https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/jre1.8.0_241.zip</a></li><li><a href="https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/jdk-8u241-windows-x64.exe">https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/jdk-8u241-windows-x64.exe</a></li></ul><h4 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h4><ul><li><a href="https://www.eclipse.org/downloads/packages/release/2020-03/r/eclipse-ide-eclipse-committers">Eclipse IDE for Eclipse Committers</a></li><li>直接下载链接地址<ul><li>Windows x64: <a href="http://iso.mirrors.ustc.edu.cn/eclipse/technology/epp/downloads/release/2020-03/R/eclipse-committers-2020-03-R-win32-x86_64.zip">eclipse-committers-2020-03-R-win32-x86_64.zip</a></li><li>Linux x64: <a href="http://mirrors.ustc.edu.cn/eclipse/technology/epp/downloads/release/2020-03/R/eclipse-committers-2020-03-R-linux-gtk-x86_64.tar.gz">eclipse-committers-2020-03-R-linux-gtk-x86_64.tar.gz</a></li><li>macOS x64: <a href="http://iso.mirrors.ustc.edu.cn/eclipse/technology/epp/downloads/release/2020-03/R/eclipse-committers-2020-03-R-macosx-cocoa-x86_64.dmg">eclipse-committers-2020-03-R-macosx-cocoa-x86_64.dmg</a></li></ul></li></ul><h4 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h4><ul><li><a href="https://www.jetbrains.com/idea/">官网网址</a></li></ul><h4 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h4><ul><li><a href="https://www.sublimetext.com/">官网网址</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NicePE</title>
      <link href="/posts/2020-03-22-nicepe.html"/>
      <url>/posts/2020-03-22-nicepe.html</url>
      
        <content type="html"><![CDATA[<p>NicePE 是本人通过天意U盘维护系统进行修改的。特点是：轻量、无任何捆绑软件、安全等。当然啦，如果是学习国内某些操作系统的话来说就是：NicePE 是柯北安全中心自主研发的轻量级U盘维护系统。</p><span id="more"></span><p>下载地址：<a href="https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/NicePE.iso">https://ismdeep.oss-cn-shenzhen.aliyuncs.com/software/NicePE.iso</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊普通笔记本电脑和苹果笔记本电脑</title>
      <link href="/posts/2020-03-07-ordinary-laptop-vs-macbook.html"/>
      <url>/posts/2020-03-07-ordinary-laptop-vs-macbook.html</url>
      
        <content type="html"><![CDATA[<p>我打算聊一聊普通笔记本电脑和苹果笔记本电脑的区别，以及各自的优缺点。正是因为有太多的同学和朋友来问我以下这些问题，所以我觉得必要来写这样一篇博客来解一解大家心中的疑惑，顺便以后再有这样的问题，我也可以一篇文章甩上去。</p><p>那么有哪些问题是经常被问到的呢？</p><ul><li>我想买一台电脑，有没有什么推荐的？</li><li>我电脑好卡呀，怎么办呀？</li><li>苹果笔记本到底好在哪里呀？</li><li>Linux 怎么样？</li><li>普通笔记本电脑有什么推荐的？</li></ul><p>下面针对这些问题一一进行解答。</p><p><strong>未完待续</strong></p><h2 id="0x01-买什么电脑？"><a href="#0x01-买什么电脑？" class="headerlink" title="0x01 买什么电脑？"></a>0x01 买什么电脑？</h2><p>买电脑的话，首先当然是跟着需求来的。我发现关于买电脑有以下几种方式：</p><ol><li>被亲戚&#x2F;朋友领进电脑店，看中或被推荐一台，然后付款。</li><li>自己随便挑中一台好看的 or 某位爱豆代言的，然后付款。</li><li>自己似乎很专业，懂得一大堆配置名称，以及一大堆配置之间的性能对比。</li><li>买苹果</li></ol><p>第一种方式，基本上就是等着被喂的，所以无论买到什么样的，都不是自己所能够左右的。被宰的可能性很大。</p><p>第二种方式，基本看颜值，所以无论买到什么样的，都不会好到哪里去吧。被忽悠的可能性很大。</p><p>第三种方式，挑得眼花缭乱，配置对比来对比去，最后发现真正想买的配置，超出预算太多。被累死的可能性很大。</p><p>第四种方式，只要是从官方商店购买，那就是，全国统一价。良心。被吃土噎死的可能性很大。</p><p>那么买电脑到底应该买什么样的电脑呢？</p><p>笔者目前用的电脑还是 2016 年 11 月份入手的 MacBook Pro A1502 ，即 2015 年初产的 MacBook Pro 13.3 寸。放在现在来看的话，性能还是很不错的，大型应用肯定无望。但是用来写代码，还是很稳的。</p><h2 id="0x02-电脑卡怎么办？"><a href="#0x02-电脑卡怎么办？" class="headerlink" title="0x02 电脑卡怎么办？"></a>0x02 电脑卡怎么办？</h2><p>正确的使用电脑，在现在这个年代来看，还真是一门技术活。</p><p>不要安装奇奇怪怪的国产软件。</p><p>那么针对使用什么样的软件，我大致总结为：能不用国内软件就不用国内软件。不得不说，我国的软件厂商，没有多少是有良心的。大部分人解释道：“要恰饭的嘛～”</p><h2 id="0x03-苹果好在哪？"><a href="#0x03-苹果好在哪？" class="headerlink" title="0x03 苹果好在哪？"></a>0x03 苹果好在哪？</h2><p>说实话，我已经开始并不觉得苹果好在哪里了。对于这种感觉，我自己都觉得非常奇怪。我或许是这样的，我跟 MacBook Pro 的日常，就跟两夫妻过日子一样，平淡如水。并不觉得它有多么重要，但是细想一下，如果不给我用了，或者突然让我用 Windows 的系统，我就会觉得特别不爽。而这种突然换到 Windows 系统上去的经历对我来说时有发生。这感觉就像看到某位可爱的小姐姐，突然想接触接触，于是鼓起勇气去尝试了一番。然后怀着忐忑的心情深入了解，突然意识到，这位可爱的小姐姐有太多我无法接受的问题。还是觉得家里的好哇。</p><p>MacBook Pro 自带的 macOS 系统就是给我以这样的感觉。我在使用的时候并不会觉得它的存在，并没有觉得它有非常特别的地方。但细想，确实很多时候用起来就是很方便。</p><p><strong>优点：</strong></p><ul><li><strong>系统稳定</strong>，系统得益于 macOS 特别稳定</li><li><strong>续航持久</strong>，续航真的太棒了，正常写代码，我能从早上九点一直用到下午五点。也就说如果公司不是996，很多上班族完全不用带充电器去公司了。再如学生党去上个实验课也不需要带充电器。再比如我这种喜欢窝在床上的人，就完全可以在床上窝一上午了（不要问我为什么床上没有充电口，对就是没有）。</li><li><strong>触摸板丝滑</strong>，曾经某位小姐姐说过：Mac 的触摸板不知道甩了普通笔记本电脑的触摸板几个世纪。<ul><li>触摸板的手势操作非常方便与人性化。很多操作拿到手的时候几乎不需要再去看个教程或者说明书什么的。因为这些操作基本上跟玩手机玩平板是一回事。</li></ul></li><li><strong>屏幕好</strong>，还在哪？曾经某位小姐姐说过：用了 Mac 再看看自己的普通笔记本，无法直视，辣眼睛！原因就在于 MacBook Pro 使用的是 Retina 视网膜屏幕。</li><li><strong>软件安装方便</strong>，macOS 上安装软件非常方便，常见的安装软件方式有两种：1. 加载 dmg 文件，并拖动软件至 Applications 文件夹；2. 打开 pkg 文件，然后下一步安装。<ul><li>为什么我说简单呢，相比于目前 Windows 上软件安装来看，却是良心了太多了。虽然 Windows 软件安装过程跟 Windows 系统自身并没有太大关系，但是 Windows 上那些软件安装过程实在是过于复杂与恶心。一不小心就安装了全家桶，而且安装过程的勾选已经不像常人思维中的勾选则安装，已经进入了一种类似于公务员考试般勾心斗角的题目级别了。</li></ul></li><li><strong>安全性高</strong>，这里的安全性高我又分为两个方面：1. 操作系统方面，macOS 的系统确实相对于 Windows 来说不知道安全到哪里去了。2. 官网对第三方软件上架审查也十分严格，所以第三方软件也相对会安全很多。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>贵</strong>，却是，同样性能的配置，macOS 会贵出不少。<ul><li>所以笔者也不太建议所有人都去购买苹果笔记本，当然<strong>如果经济允许下，又不会有非 Windows 不能运行的重度使用软件的话，我非常建议购买 MacBook Pro.</strong> 此话解释如下：<ul><li>macOS 有非常好用的虚拟机软件 Parallels Dekstop，可以用来安装各种各样的虚拟机系统。比如 Windows 系统。也就是说，macOS 上无法使用的软件，可以通过虚拟机来运行。虚拟机软件优化得非常好，所以无需担心性能上的问题。</li><li>如果某个需要通过 Windows 来运行的软件，是你在工作或者学习中经常需要用到的，那么我建议你购买方便安装 Windows 系统的普通笔记本电脑。</li><li>虽然 MacBook 可以通过 BootCamp 来安装 Windows 系统，但是我<strong>不太建议这么干</strong>。</li></ul></li></ul></li><li><strong>系统过于封闭</strong>，由于 macOS 系统过于封闭，已经开始逐渐不能满足我了。我还是更加喜欢使用 Linux 系列，CentOS or Ubuntu 足矣。</li></ul><h2 id="0x04-Linux-怎么样？"><a href="#0x04-Linux-怎么样？" class="headerlink" title="0x04 Linux 怎么样？"></a>0x04 Linux 怎么样？</h2><p>不得不说 Linux 确实是一个非常优秀的软件。无论是从用户体验的角度还是系统优化的角度。</p><p>首先本人是一位从事软件开发工作的人。那么对我来说最重要的工具是哪些呢？</p><p>首先最重要的肯定是各种编程语言的编译器或者解释器。当然，很明显，除了微软家自制的那些编译器，其他几乎所有的编程语言的编译器或者是解释器，都能在 Linux 下运行得非常良好。</p><p>其次，当然是我们最喜欢用的命令行。命令行 shell ，我还是喜欢使用 zsh + oh-my-zsh 那么这个也就 Linux 和 macOS 上表现良好。至于 Windows 上的 cmd 或者是 powershell，我简直不忍直视。无力吐槽。为什么需要用命令行？你们这些程序员，就这么喜欢用命令行搞得自己跟个黑客一样？对于这样的问题，我的解释大概就是：因为用命令行我可以节省很多时间，很多时间面对一些问题，我能很快地去写一个非常简单的脚本去完成一些重复性的工作。那么为什么我不去写一些图形化的软件，鼠标点来点去岂不美哉？首先，不得不说鼠标的工作方式在某些事情上，确实很方便。但是，也是一种低效率的工作方式，低效率在于，鼠标很难去执行一些重复性的工作。</p><h2 id="0x05-普通笔记本电脑有什么推荐的？"><a href="#0x05-普通笔记本电脑有什么推荐的？" class="headerlink" title="0x05 普通笔记本电脑有什么推荐的？"></a>0x05 普通笔记本电脑有什么推荐的？</h2><p>其实推荐笔记本电脑的话，大致需要根据需求来。比如是普通学生党用来学习、刷网课、做笔记、存PPT、做思维导图等，或者是用来做一般性编程的，比如是学习 C 语言或者是 Python 等，又或者是从事游戏开发的，再或者还有用来做视频剪辑的。<strong>不同的购买需求就要对应不同的推荐方式。</strong></p><p>首先从品牌上来看的话，大致推荐三家：ThinkPad 系列、小米笔记本、华为 Magic Book （先有华为后有天，不买华为是汉奸嘛～逃）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python argparse 用法总结</title>
      <link href="/posts/2020-03-01-python-argparse-usage.html"/>
      <url>/posts/2020-03-01-python-argparse-usage.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><h2 id="0x00-argparse-介绍"><a href="#0x00-argparse-介绍" class="headerlink" title="0x00 argparse 介绍"></a>0x00 <code>argparse</code> 介绍</h2><p><code>argparse</code> 是 Python 的一个命令行解析包，用户编写可读性非常好的程序。</p><h2 id="0x01-基本用法"><a href="#0x01-基本用法" class="headerlink" title="0x01 基本用法"></a>0x01 基本用法</h2><pre><code class="python">import argparseparser = argparse.ArgumentParser()parser.parse_args()</code></pre><p>运行结果：</p><pre><code class="text">&gt; python3 argparse-demo-help.py&gt; python3 argparse-demo-help.py --helpusage: argparse-demo-help.py [-h]optional arguments:  -h, --help  show this help message and exit&gt; python3 argparse-demo-help.py -husage: argparse-demo-help.py [-h]optional arguments:  -h, --help  show this help message and exit&gt; python3 argparse-demo-help.py -vusage: argparse-demo-help.py [-h]argparse-demo-help.py: error: unrecognized arguments: -v&gt;</code></pre><h2 id="0x02-固定参数"><a href="#0x02-固定参数" class="headerlink" title="0x02 固定参数"></a>0x02 固定参数</h2><p>固定参数是必须按照固定的顺序加入的参数，而且不可缺省。如：<code>ping 127.0.0.1</code> 这样的一个命令，<code>ping</code> 后面直接更上 <code>127.0.0.1</code></p><pre><code class="python">import argparseparser = argparse.ArgumentParser()parser.add_argument(&quot;echo&quot;, help=&quot;Input what echo what.&quot;)args = parser.parse_args()print(args.echo)</code></pre><p>运行结果：</p><pre><code class="text">&gt; python3 argparse-demo-positional-argument.py hellohello&gt; python3 argparse-demo-positional-argument.py -husage: argparse-demo-positional-argument.py [-h] echopositional arguments:  echo        Input what echo what.optional arguments:  -h, --help  show this help message and exit&gt;</code></pre><h2 id="0x03-可选参数"><a href="#0x03-可选参数" class="headerlink" title="0x03 可选参数"></a>0x03 可选参数</h2><p>有两种方式：</p><ol><li>一种通过一个 <code>-</code> 来指定的短参数，如 <code>-h</code></li><li>一种通过 <code>--</code> 来指定的长参数，如 <code>--help</code></li></ol><p>这两种方式可以同时存在，也可以只存在一个。</p><pre><code class="python">import argparseparser = argparse.ArgumentParser()parser.add_argument(&#39;-H&#39;, &#39;--host&#39;, help=&#39;host&#39;)args = parser.parse_args()print(&#39;host is %s&#39; % args.host)</code></pre><p>运行结果：</p><pre><code class="python">&gt; python3 argparse-demo-optional-argument.py -husage: argparse-demo-optional-argument.py [-h] [-H HOST]optional arguments:  -h, --help            show this help message and exit  -H HOST, --host HOST  host&gt; python3 argparse-demo-optional-argument.py -H 127.0.0.1host is 127.0.0.1&gt; python3 argparse-demo-optional-argument.py --host 127.0.0.1host is 127.0.0.1</code></pre><p><strong>注意：</strong> 设置的参数不可以重名，会冲突。这也是为什么以上的例子中是 <code>-H</code> 而不是 <code>-h</code> ，因为 <code>-h</code> 已经被帮助信息默认绑定了。</p><h2 id="0x04-参数默认值"><a href="#0x04-参数默认值" class="headerlink" title="0x04 参数默认值"></a>0x04 参数默认值</h2><pre><code class="python">import argparseparser = argparse.ArgumentParser()parser.add_argument(&#39;-H&#39;, &#39;--host&#39;, help=&#39;host&#39;, default=&#39;127.0.0.1&#39;)args = parser.parse_args()print(&#39;host is %s&#39; % args.host)</code></pre><p>运行结果：</p><pre><code class="text">&gt; python3 argparse-demo-with-default-value.py -husage: argparse-demo-with-default-value.py [-h] [-H HOST]optional arguments:  -h, --help            show this help message and exit  -H HOST, --host HOST  host&gt; python3 argparse-demo-with-default-value.pyhost is 127.0.0.1&gt; python3 argparse-demo-with-default-value.py -H 127.0.0.2host is 127.0.0.2</code></pre><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>其实大部分时候我们只需要以上功能就足够了，所以一些其他的用法这里就不去过多的描述了。</p><hr><p>喵喵怪的小枪枪、biu～～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Selenium 和 Python 的网络爬虫</title>
      <link href="/posts/2020-02-23-web-scraping-using-selenium-and-python.html"/>
      <url>/posts/2020-02-23-web-scraping-using-selenium-and-python.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p>转载自 <a href="https://www.scrapingbee.com/blog/selenium-python/">https://www.scrapingbee.com/blog/selenium-python/</a> By Kevin Sahin 27 January 2020</p><p>翻译 <a href="https://ismdeep.github.io/">ismdeep</a></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/6f180f9dcf6fee8f9e5a5384cd7c9688-d60481.jpg" alt="header_selenium_python_huded21d234109b3c4b11fa08146297559_67295_1200x0_resize_q75_box"></p><p>在<a href="https://www.scrapingbee.com/blog/web-scraping-with-scrapy/">上一教程</a>中，我们了解了如何利用 Scrapy 框架解决许多常见的网络爬虫问题。今天我们将通过教程来逐步学习 Selenium （ 使用 Python ❤️ ）。</p><p>Selenium 是指用于浏览器自动化的许多不同的开源项目。它支持所有主流编程语言，包括我们最喜欢的语言：Python .</p><p>Selenium API 使用 WebDriver 协议来控制浏览器（ 例如 Chrome ，Firefox 或 Safari . ）。而该浏览器可以运行在本地或者是远程。</p><p>这个项目最初（ 大概是 20 年前 ）主要是用于跨浏览器的端到端测试（ 验收测试 ）。</p><p>现在它仍然用于测试，还可以用作通用的浏览器自动化平台，当然还可以用于网络爬虫。</p><p>当你必须在网站上执行下列操作时，Selenium 就特别有用：</p><ul><li>点击按钮</li><li>填写表单</li><li>页面滚动</li><li>截屏</li></ul><p>Selenium 对于执行 Javascript 代码也非常有用。假设你要爬取一个单页程序，而找不到直接调用底层 API 的简便方法，那么 Selenium 可能正好能满足你的需要。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们将用 Chrome 来作为演示，因为请确保你的电脑上已经安装 Chrome：</p><ul><li><a href="https://www.google.com/chrome/">Chrome 下载页面</a></li><li><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads">Chrome 驱动下载</a></li><li><code>selenium</code> 包</li></ul><p>如往常一样，为了安装 Selenium 包，建议你使用虚拟环境，例如通过 virtualenv 创建一个虚拟环境：</p><pre><code class="bash">pip install selenium</code></pre><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>下载完 Chrome 和 Chrome驱动，并且安装了 Selenium 包之后，就可以启动浏览器了：</p><pre><code class="python">from selenium import webdriverDRIVER_PATH = &#39;/path/to/chromedriver&#39;driver = webdriver.Chrome(executable_path=DRIVER_PATH)driver.get(&#39;https://google.com&#39;)</code></pre><p>以上代码会以完全模式打开 Chrome 浏览器（ 跟平常用的 Chrome 浏览器一样，只是目前你的浏览器是由 Python 代码来控制的 ）。你应该看到一条消息，显示现在浏览器由自动化软件控制的。</p><p>如果想要让 Chrome 浏览器运行于服务器上的无头模式（ 没有任何图形用户界面 ），例如：</p><pre><code class="python">from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsoptions = Options()options.headless = Trueoptions.add_argument(&quot;--window-size=1920,1200&quot;)driver = webdriver.Chrome(options=options, executable_path=DRIVER_PATH)driver.get(&quot;https://www.nintendo.com/&quot;)print(driver.page_source)driver.quit()</code></pre><p><code>driver.page_source</code> 会返回完整的页面的 HTML 代码。</p><p>这里还有另外两个有趣的 webdriver 属性：</p><ul><li><code>driver.title</code> 获取页面标题</li><li><code>driver.current_url</code> 获取当前 URL（ 当网站有重定向并且你需要知道最终 URL 时，此功能就很有用了。 ）</li></ul><h2 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h2><p>在网站上查找数据是 Selenium 的主要用例之一。无论是用于测试套件（确保页面上存在或不存在特定元素）还是网页爬取（提取数据并将其保存以进行进一步分析）。</p><p>Selenium API 中提供了许多方法来选择页面上的元素。你可以使用：</p><ul><li>标签名</li><li>class</li><li>id</li><li>XPath</li><li>CSS 选择器</li></ul><p>我们最近发布了一篇<a href="https://www.scrapingbee.com/blog/practical-xpath-for-web-scraping/">解释 XPath 的文章</a>，如果你不熟悉 Xpath ，建议去看看。</p><p>通常，查找元素最简单的方法就是打开你的 Chrome 开发工具并检查所需的元素。一个很酷的快捷方式就是用鼠标放在你想要突显的元素上然后按住 <strong>Ctrl + Shift + C</strong> （ macOS 则按住 <strong>cmd + shift + c</strong> ）即可，这样就不必每次都右键再点击检查(inspect)。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/155137d02df01f508cce5f304d702792-827e0f.png" alt="screenshot_dom_hud6287075ec09d704ecf4a54fd6ad5f23_232087_1500x0_resize_box_2"></p><h3 id="find-element"><a href="#find-element" class="headerlink" title="find_element"></a><code>find_element</code></h3><p>在 Selenium 中有很多中定位元素的方法。假设我们要在下面 HTML 中找到 h1 标签：</p><pre><code class="html">&lt;html&gt;    &lt;head&gt;        ... some stuff    &lt;/head&gt;    &lt;body&gt;        &lt;h1 class=&quot;someclass&quot; id=&quot;greatID&quot;&gt;Super title&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="python">h1 = driver.find_element_by_name(&#39;h1&#39;)h1 = driver.find_element_by_class_name(&#39;someclass&#39;)h1 = driver.find_element_by_xpath(&#39;//h1&#39;)h1 = driver.find_element_by_id(&#39;greatID&#39;)</code></pre><p>所有这些方法都是 <code>find_element_*()</code> 以返回元素列表。</p><p>例如，要获取页面上的所有 <code>a</code> 锚点：</p><pre><code class="python">all_links = driver.find_elements_by_tag_name(&#39;a&#39;)</code></pre><p>一些元素并不容易通过 id 或者 class 去获取到，这个时候你就需要 XPath 表达式来处理了。你可能还会有多个具有相同 class 的元素需要获取（ id 应该是唯一的 ）。</p><p>XPath 是我最喜欢用来在网页上查找元素的方式。无论是根据在页面 DOM 上的绝对位置还是相对于另一个元素的相对位置，用 XPath 来提取页面上的任何元素都是非常强大的。</p><h2 id="WebElement"><a href="#WebElement" class="headerlink" title="WebElement"></a><code>WebElement</code></h2><p><code>WebElement</code> 是一个用于表示 HTML 元素的 Selenium 对象。</p><p>你可以对这些元素执行许多操作，下面是最常用的几个：</p><ul><li><code>element.text</code> 可以获取到元素的文本</li><li><code>element.click()</code> 执行对这个元素的点击</li><li><code>element.get_attribute(&#39;class&#39;)</code> 获取属性</li><li><code>element.send_keys(&#39;mypassword&#39;)</code> 发送文本到输入框</li></ul><p>还有其他一些有趣的方法，例如 <code>is_displayed()</code>, 如果元素对用户是可见的，则返回 <code>True</code> .</p><p>这可以很巧妙的避免蜜罐（ 例如填写隐藏的输入框 ）。</p><h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><p>这是一个使用我们刚刚提及的有关 Selenium API 不同方法的完整示例。</p><p>我们将要登陆 <a href="https://news.ycombinator.com/login">Hacker News</a>：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/7dc25bb5cc6eb3a0fd61059fb7569896-90a2c1.png" alt="screenshot_hn_login"></p><p>在我们的示例中，对 Hacker News 进行身份验证这件事情本身并没有真正的用处，但是可以想象我们可以创建一个自动发布指向你最新博客文章链接的机器人。</p><p>为了进行身份认证，我们需要进行以下操作：</p><ul><li>通过 <code>driver.get()</code> 打开登录页面</li><li>通过 <code>driver.find_element_by_*</code> 选中用户名输入框，然后通过 <code>element.send_keys()</code> 往输入框中填入文本</li><li>同样的操作应用在密码输入框上</li><li>通过 <code>element.click()</code> 点击登录按钮</li></ul><p>是不是很简单？我们来看看代码：</p><pre><code class="python">driver.get(&quot;https://news.ycombinator.com/login&quot;)login = driver.find_element_by_xpath(&quot;//input&quot;).send_keys(USERNAME)password = driver.find_element_by_xpath(&quot;//input[@type=&#39;password&#39;]&quot;).send_keys(PASSWORD)submit = driver.find_element_by_xpath(&quot;//input[@value=&#39;login&#39;]&quot;).click()</code></pre><p>简单吧？现在，其实这里有一件很重要的事情我们没有做，那就是我们如何知道是否已经登录了？</p><p>有一下几个方法：</p><ul><li>检查错误信息（ 比如 “Wrong password” ）</li><li>检查页面上只有登录后才显示的元素</li></ul><p>我们将检查 logout 按钮，也就是 id 为 <code>logout</code> 的页面元素。简单！</p><p>我们并不能仅仅检查元素是否为 <code>None</code> ，因为所有的 <code>find_element_by_*</code> 函数在 DOM 中找不到元素的时候都是抛出异常。因此，我们必须使用 try&#x2F;except 并捕获 <code>NoSuchElementException</code> 异常：</p><pre><code class="python"># dont forget from selenium.common.exceptions import NoSuchElementException  try:    logout_button = driver.find_element_by_id(&quot;logout&quot;)    print(&#39;Successfully logged in&#39;)except NoSuchElementException:    print(&#39;Incorrect login/password&#39;)</code></pre><h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>通过以下代码我们就可以轻松地使用截图功能：</p><pre><code class="python">driver.save_screenshot(&#39;screenshot.png&#39;)</code></pre><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/0c32f61303071982f64feb5f133cf9dd-fb531c.png" alt="screenshot_hucad4c981400a32fa0cf914b0c7692a3a_855594_1500x0_resize_box_2"></p><p>注意：使用 Selenium 截屏时，很多时候都可能会出错。首先，你必须确保窗口大小已经正确设置了。然后，你需要确保前端 Javascript 代码所进行的每一个异步 HTTP 调用均已完成，并且页面已经完全渲染显示出来。</p><p>在我们刚刚的 Hacker News 这个例子中，我们不必担心这些问题，因为这个页面非常简单。</p><h3 id="等待元素出现"><a href="#等待元素出现" class="headerlink" title="等待元素出现"></a>等待元素出现</h3><p>处理大量使用 Javascript 呈现内容的网站可能很棘手。如今，越来越多的网站将 Angular ，React ，Vue.js 等框架用作前端。这些前端框架处理起来很复杂，因为它们会触发许多 AJAX 调用。</p><p>如果我们不得不担心对 API 的异步 HTTP 调用（或许有很多），则有两种方法可以解决此问题：</p><ul><li>截屏前使用 <code>time.sleep(ARBITRARY_TIME)</code></li><li>使用 <code>WebDriverWait</code> 对象</li></ul><p>如果使用 <code>time.sleep()</code> 则可能会使用任意值。问题在于等待的时间太长还是不够。此外，网站在本地 Wi-Fi 环境下可能加载很慢，但是在云服务器上速度则会提高 10 倍。使用 <code>WebDriverWait</code> 方法，你将等待加载元素或者数据的确切时间。</p><pre><code class="python">try:    element = WebDriverWait(driver, 5).until(        EC.presence_of_element_located((By.ID, &quot;mySuperId&quot;))    )finally:    driver.quit()</code></pre><p>这将等待 5 秒钟，以加载 id 为 “mySuperId” 的元素。还有许多其他有趣的条件可以使用，例如：</p><ul><li><code>element_to_be_clickable</code></li><li><code>text_to_be_present_in_element</code></li><li><code>element_to_be_clickable</code><br>你可以在 <a href="https://selenium-python.readthedocs.io/waits.html">Selenium 文档</a> 中找到有关此信息更多的信息。</li></ul><h3 id="执行-Javascript"><a href="#执行-Javascript" class="headerlink" title="执行 Javascript"></a>执行 Javascript</h3><p>有时，你可能需要在页面上执行一些 Javascript. 例如，假设你要截取一些信息的屏幕快照，但首先需要稍微滚动一下才能看到它，那么通过 Selenium 来处理就会变得轻松一点：</p><pre><code class="python">javaScript = &quot;window.scrollBy(0,1000);&quot;driver.execute_script(javaScript)</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望您喜欢这篇博客！现在你应该对 Selenium API 在 Python 中时如何工作的有了一个更好的理解。如果你想了解更多有关使用 Python 爬取网页不同的方法的信息，请随时查看我们的 <a href="https://www.scrapingbee.com/blog/web-scraping-101-with-python/">python 网页爬虫指南</a>。</p><p>对于从一些大量使用 Javascript 的网站获取数据来说，Selenium 通常是所必需的。问题是大规模运行大量 Selenium &#x2F; 无头模式 Chrome 浏览器实例是很困难的。这也正是我们使用我们网页爬虫API <a href="https://www.scrapingbee.com/">ScrapingBee</a> 的原因之一。</p><p>Selenium 确实是是网络上几乎所有内容自动化的一个很出色的工具。</p><p>如果你需要执行一些重复的任务，例如填写表单，检查网站上需要登录后才有的一些信息而并没有提供 API 接口。那么使用 Selenium 自动化应该是一个不错的方法。不过不要忘记这个：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/afffbf6566a6e67ea6427d28d76d7eea-d4d18a.png" alt="automation_xkcd"></p><hr><p>喵喵怪的小枪枪、biu~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言编写数据结构所需要面临的两个挑战</title>
      <link href="/posts/2020-02-17-two-challenges-in-c-to-overcome-when-writing-data-structure.html"/>
      <url>/posts/2020-02-17-two-challenges-in-c-to-overcome-when-writing-data-structure.html</url>
      
        <content type="html"><![CDATA[<p>C语言是使用得最多的编程语言。当用C语言来构造数据结构时，在C语言语句和数据结构在内存中的表示之间有一个直接的映射存在。由于C语言的这种简单语法和直接映射，C语言成为了一种展示数据结构本质的理想语言。然而，学习C语言的时候，我们不得不面对两个在学习其他语言不需要考虑的挑战。</p><p><strong>挑战 1</strong>: 指针。理解指针要求进行培训和练习，以建立将指针语法从思维方式转换为点对图的能力，这对于掌握C代码的语义至关重要。</p><p><strong>挑战 2</strong>: C语言的内存模型。没有由其运行时系统明确执行，并且经验不足的编程人员经常编写违反内存模型并导致隐式分段错误或不确定行为的代码。 两者都是造成学习C语言挫折感的主要原因。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天的计算机编程与20年前有何不同？</title>
      <link href="/posts/2020-02-04-how-is-computer-programming-different-today-than-20-years-ago.html"/>
      <url>/posts/2020-02-04-how-is-computer-programming-different-today-than-20-years-ago.html</url>
      
        <content type="html"><![CDATA[<p>这个问题是我在 Quora 上看到的，于是来回答回答。但是花了这么长时间，我才在这里转贴。</p><p>以下是我注意到的过去 20 年发生的一些变化，顺序无前后：</p><ul><li>20 年前的大部分理论性的编程概念已经成为主流，包括许多函数式范式，例如不变性、尾递归、惰性求值、模式匹配、头等函数。并且鄙视一切不使用它们的人。</li><li>现在的桌面软件意味着捆绑了浏览器的网页。</li><li>尽管可能面向对象编程（OOP）仍然是最受欢迎的编程模型，但它已经失去了很多市场信誉。新的基于特征的编程模型在 Go 、Rust 和 Swift 等现代语言中更为普遍。组合优于继承。</li><li>在你参加 $2k 会议并从那里分享自拍照之前，你不再被正式视为程序员。</li><li>由于多处理器 CPU 的大量增加，现在在编程语言级别上通常都支持并行编程，而不是20年前的原始操作系统的系统调用。 它引入了异步编程原语（sync&#x2F;wait），并行协程（如Go语言中的goroutine或D中的管道），可组合性语义（如可观的反应式编程）。</li><li>像素不再是相关的度量单位。</li><li>垃圾回收已经成为安全编程的常用方法，但也出现了新的安全模型，例如 Rust 的生命周期语义和代码审查。</li><li>30亿个设备运行Java。 在过去的十年中，这个数字没有改变。</li><li>程序包管理生态系统对于现在的编程语言至关重要。 人们根本不想再经历寻找，下载和安装库的麻烦。 20年前，我们曾经访问过网站，下载了zip文件，将它们复制到正确的位置，将它们添加到构建配置中的路径中，并祈祷它们可以工作。</li><li>现在，作为软件开发团队，所有团队成员都要执行神秘的仪式，早上起来15分钟，站起来，并用便利贴画出神秘的符号。</li><li>今天，语言工具变得更加丰富。编程语言通常是编译器或许是调试器。今天，它们往往都附带 linter 、代码格式化、模版生成器、自更新能力以及用于与竞争者进行辩论的论据。</li><li>甚至关于编程语言的 Tab 缩进和空格缩进都能引发争论。</li><li>幸运的是，以往在网络上提供一些流畅的交互的唯一方法的 Adobe Flash 现在不再存在。现在，我们必须在三个编程模型完全不同的平台上进行开发，以提供相同级别的交互。</li><li>IDE 和编程语言之间的距离越来越远。20年前，IDE 是专门为一种语言开发的，例如用来开发 Java 程序的 Eclipse，Visual Basic 等。现在我们有了诸如 VS Code 之类的文本编辑器，可以支持具有 IDE 等功能的任何编程语言。</li><li>现在，代码必须运行在至少三个虚拟层之上。 在裸机上运行代码是没有必要的。</li><li>由于移动设备、云服务器、嵌入式物联网系统等多种架构的存在，跨平台开发现已成为标准。 20年前几乎完全是PC。</li><li>很少在本地运行代码。</li><li>文档都是在线的，称之为 Google. 不再有什么离线文档之类的东西了，即使是有，也没什么人知道。</li><li>如果教程不是一部视频，而其理解时间比其文本要长几个数量级，那么该教程并没有真正的作用。</li><li>那时根本就不存在 StackOverflow，询问编程问题也都是问自己的同事。</li><li>人们在 Mac 上开发软件。</li><li>在线是常态，离线是例外。这与当时的情况正好相反。</li><li>安全是我们现在必须要考虑的问题。</li><li>现在，移动设备可以显示常规网页，因此不再需要在单独的子域上创建单独的WAP页面。 我们改为在单独的子域上创建移动页面。</li><li>默认情况下，我们会开源所有内容，除了那些真正使我们难堪的代码。</li><li>多亏每个反对歧视的人，现在该行业有更多有才华的妇女，有色人种和LGBT。 我仍然不能说我们已经完全平等，但是已经好很多了。</li><li>被黑是常有的事。通常通过写一篇推荐更改密码的博客文章基本上就能避免丢失所有用户数据。而且无需道歉。</li><li>得益于视频会议、无处不在的互联网和 Keurigs 等新技术，对程序员来说远程办公比以往任何时候都更容易了。</li><li>我们不再使用 IRC 进行沟通了。我们更喜欢使用一种叫做 Slack 的臃肿软件，仅仅是因为我们不想再去输入服务器地址。</li><li>我们现在在显卡上运行程序。</li><li>除非包含区块链和AI，但您的项目目前没有任何商业价值，尽管基于规则的集中式版本将更快，更高效。</li><li>在某些情况下，1 GB 存储空间已经不够用了。</li><li>由于旁路攻击的出现，我们现在甚至无法再相信物理处理器了。</li><li>现在，大部分的编程工作都在桌上足球桌上进行。</li><li>由于我们现在有更快的CPU，因此数值计算是在 Python 中完成的，这比 Fortran 慢得多。 因此，数值计算所需的时间基本上与20年前没什么变化。</li><li>创建一种新的编程语言或者甚至是创建新的硬件已经成为了一种普遍的爱好。</li><li>单元测试已经大肆宣传，并且像所有有用的东西一样，它的好处被高估了，并且不可避免地变成了一种宗教。</li><li>现在，以明文形式存储密码的做法已经不合时宜了，但是我们还是这样做。</li></ul><hr><p>转载自 <a href="https://medium.com/swlh/how-is-computer-programming-different-today-than-20-years-ago-9d0154d1b6ce">https://medium.com/swlh/how-is-computer-programming-different-today-than-20-years-ago-9d0154d1b6ce</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写安全 Shell 脚本</title>
      <link href="/posts/2020-02-04-safe-shell.html"/>
      <url>/posts/2020-02-04-safe-shell.html</url>
      
        <content type="html"><![CDATA[<p>编写 shell 脚本给犯错留出了许多空间，以导致你的脚本会被特定的输入终止或者在碰到不受信任的输入时触发一些公开的安全漏洞。以下是一些让你编写更加安全的 shell 脚本的一些技巧。</p><h2 id="尽量不用-shell-脚本"><a href="#尽量不用-shell-脚本" class="headerlink" title="尽量不用 shell 脚本"></a>尽量不用 shell 脚本</h2><p>最简单的方法就是不使用 shell 脚本。许多高级语言都更容易编写代码，并且也可以避免一些 shell 中有的问题。例如，当你用试图读取一个未初始化的变量（虽然往里面写入并不会）或者是一些函数调用出错的时候，Python 都会自动返回报错信息并结束程序。</p><p>One of shell’s chief advantages is that it’s easy to call out to the huge variety of command-line utilities available. Much of that functionality will be available through libraries in Python or other languages. For the handful of things that aren’t, you can still call external programs. In Python, the <a href="https://docs.python.org/2/library/subprocess.html">subprocess</a> module is very useful for this. You should try to avoid passing <code>shell=True</code> to <code>subprocess</code> (or using <code>os.system</code> or similar functions at all), since that will run a shell, exposing you to many of the same issues as plain shell has. It also has two big advantages over shell — it’s a lot easier to avoid <a href="https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html">word-splitting</a> or similar issues, and since calls to subprocess will tend to be relatively uncommon, it’s easy to scrutinize them especially hard. When using <code>subprocess</code> or similar tools, you should still be aware of the suggestions in “Passing filenames or other positional arguments to commands” below.</p><h2 id="Shell-配置"><a href="#Shell-配置" class="headerlink" title="Shell 配置"></a>Shell 配置</h2><p>POSIX sh and especially bash have a number of settings that can help write safe shell scripts.</p><p>I recommend the following in bash scripts:</p><pre><code>set -euf -o pipefail</code></pre><p>In dash, <code>set -o</code> doesn’t exist, so use only <code>set -euf</code>.</p><p>What do those do?</p><h3 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -e</code></a></h3><p>If a command fails, <code>set -e</code> will make the whole script exit, instead of just resuming on the next line. If you have commands that can fail without it being an issue, you can append <code>|| true</code> or <code>|| :</code> to suppress this behavior — for example <code>set -e</code> followed by <code>false || :</code> will not cause your script to terminate.</p><h3 id="set-u"><a href="#set-u" class="headerlink" title="set -u"></a><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -u</code></a></h3><p>Treat unset variables as an error, and immediately exit.</p><h3 id="set-f"><a href="#set-f" class="headerlink" title="set -f"></a><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -f</code></a></h3><p>Disable filename expansion (globbing) upon seeing <code>*</code>, <code>?</code>, etc..</p><p>If your script depends on globbing, you obviously shouldn’t set this. Instead, you may find <a href="https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html"><code>shopt -s failglob</code></a> useful, which causes globs that don’t get expanded to cause errors, rather than getting passed to the command with the <code>*</code> intact.</p><h3 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html"><code>set -o pipefail</code></a></h3><p><code>set -o pipefail</code> causes a pipeline (for example, <code>curl -s https://sipb.mit.edu/ | grep foo</code>) to produce a failure return code if any command errors. Normally, pipelines only return a failure if the last command errors. In combination with <code>set -e</code>, this will make your script exit if any command in a pipeline errors.</p><h2 id="使用引号"><a href="#使用引号" class="headerlink" title="使用引号"></a>使用引号</h2><p>Whenever you pass a variable to a command, you should probably quote it. Otherwise, the shell will perform <a href="https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html">word-splitting</a> and <a href="https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html">globbing</a>, which is likely not what you want.</p><p>For example, consider the following:</p><pre><code>alex@kronborg tmp [15:23] $ dir=&quot;foo bar&quot;alex@kronborg tmp [15:23] $ ls $dirls: cannot access foo: No such file or directoryls: cannot access bar: No such file or directoryalex@kronborg tmp [15:23] $ cd &quot;$dir&quot;alex@kronborg foo bar [15:25] $ file=*.txtalex@kronborg foo bar [15:26] $ echo $filebar.txt foo.txtalex@kronborg foo bar [15:26] $ echo &quot;$file&quot;*.txt</code></pre><p>Depending on what you are doing in your script, it is likely that the word-splitting and globbing shown above are not what you expected to have happen. By using <code>&quot;$foo&quot;</code> to access the contents of the <code>foo</code> variable instead of just <code>$foo</code>, this problem does not arise.</p><p>When writing a wrapper script, you may wish pass along all the arguments your script received. Do that with:</p><pre><code>wrapped-command &quot;$@&quot;</code></pre><p>See <a href="https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html">“Special Parameters” in the bash manual</a> for details on the distinction between <code>$*</code>, <code>$@</code>, and <code>&quot;$@&quot;</code> — the first and second are rarely what you want in a safe shell script.</p><h2 id="Passing-filenames-or-other-positional-arguments-to-commands"><a href="#Passing-filenames-or-other-positional-arguments-to-commands" class="headerlink" title="Passing filenames or other positional arguments to commands"></a>Passing filenames or other positional arguments to commands</h2><p>If you get filenames from the user or from shell globbing, or any other kind of positional arguments, you should be aware that those could start with a “-“. Even if you quote correctly, this may still act differently from what you intended. For example, consider a script that allows somebody to run commands as <code>nobody</code> (exposed over <code>remctl</code>, perhaps), consisting of just <code>sudo -u nobody &quot;$@&quot;</code>. The quoting is fine, but if a user passes <code>-u root reboot</code>, <code>sudo</code> will catch the second <code>-u</code> and run it as <code>root</code>.</p><p>Fixing this depends on what command you’re running.</p><p>For many commands, however, <code>--</code> is accepted to indicate that any options are done, and future arguments should be parsed as positional parameters — even if they look like options. In the <code>sudo</code> example above, <code>sudo -u nobody -- &quot;$@&quot;</code> would avoid this attack (though obviously specifying in the <code>sudo</code> configuration that commands can only be run as <code>nobody</code> is also a good idea).</p><p>Another approach is to prefix each filename with <code>./</code>, if the filenames are expected to be in the current directory.</p><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>TODO: mumble <code>mktemp</code>?</p><h2 id="Use-ShellCheck-to-check-for-bugs"><a href="#Use-ShellCheck-to-check-for-bugs" class="headerlink" title="Use ShellCheck to check for bugs"></a>Use <a href="https://www.shellcheck.net/">ShellCheck</a> to check for bugs</h2><p>The <a href="https://www.shellcheck.net/">ShellCheck</a> linter automatically catches a number of the above mistakes and more. Run it regularly, ideally with integration into your editor and your test suite, and address all of its diagnostics. Even warnings that might sound unimportant could be obscuring important bugs.</p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>Google 有一份 <a href="https://google.github.io/styleguide/shell.xml">Shell 风格指南</a>。很明显，这份指南主要关注于 Google 代码风格，但是也有一些部分跟安全有关。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果可能的话，尽量用<em>像 Python 这样的高级语言</em>去写而不是去写 “安全” 的 shell 脚本。如果非要用 shell 的话，有一些 shell 的<em>选项配置</em>可以降低出 bug 的风险并且记得<em>使用引号</em>。</p><hr><p>转载自 <a href="https://sipb.mit.edu/doc/safe-shell/">https://sipb.mit.edu/doc/safe-shell/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Repost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用的 Tampermonkey （油猴）脚本推荐</title>
      <link href="/posts/2020-01-12-useful-tampermonkey-scripts.html"/>
      <url>/posts/2020-01-12-useful-tampermonkey-scripts.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.tampermonkey.net/">Tampermonkey</a>（油猴）是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome、Firefox、Safari 等浏览器。至于这东西有多🐂🍺，就不过多去说了，谁用谁知道。以下是笔者整理的也是自己使用非常多的脚本推荐。</p><ul><li><a href="https://greasyfork.org/zh-CN/scripts/18842-cnki-%E4%B8%AD%E5%9B%BD%E7%9F%A5%E7%BD%91-pdf-%E5%85%A8%E6%96%87%E4%B8%8B%E8%BD%BD-%E7%89%B9%E5%88%B6%E7%89%88">CNKI 中国知网 PDF 全文下载（特制版）</a> 从知网下载论文时，硕士博士学位论文默认是提供caj下载，使用此插件可以在下载页面显示PDF下载按钮。</li><li><a href="https://github.com/ismdeep/tampermonkey-scripts/raw/master/vjudge-helper.user.js">vjudge-helper</a> 是笔者自己编写的一个 vjudge.net 刷题小工具。用于在一些公开的 contest 中显示题目是否已经刷过。</li><li><a href="https://github.com/ismdeep/tampermonkey-scripts/raw/master/hacker-news-hide-low-point-posts.user.js">Hacker News Hide Low Point Posts</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/14178-ac-baidu-%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%98%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%8B%97%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2-%E5%8E%BB%E5%B9%BF%E5%91%8A-favicon-%E5%8F%8C%E5%88%97">AC-baidu:重定向优化百度搜狗谷歌搜索_去广告_favicon_双列</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/3249-yet-another-weibo-filter">Yet Another Weibo Filter</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/393394-%E5%9F%8E%E9%80%9A%E7%BD%91%E7%9B%98-%E7%9A%AE%E7%9A%AE%E7%9B%98-%E7%89%9B%E7%9B%98%E6%98%BE%E7%A4%BA%E6%AD%A3%E7%A1%AE%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80">城通网盘、皮皮盘、牛盘显示正确下载地址</a></li><li><a href="https://greasyfork.org/zh-CN/scripts/38182-hide-youtube-google-ad">隐藏YouTube Google广告</a></li></ul><hr><p>喵喵怪的小枪枪、biu~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现更加通用的排序算法</title>
      <link href="/posts/2020-01-11-more-universal-sort-implementation-in-c.html"/>
      <url>/posts/2020-01-11-more-universal-sort-implementation-in-c.html</url>
      
        <content type="html"><![CDATA[<p>初学C语言的学生应该都写过排序算法吧。选择排序、插入排序还有快速排序。但是最初开始学的时候写的都是对一组整数（int）进行排序。而且排序规则也是写死在函数内部的。那么问题来了，如果给你这样一个需求：实现一个排序函数，要能够允许用户自定义排序规则，而且要能处理各种各样的数据类型。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>以上描述就是本文所需要实现的排序需求。</p><p><strong>首先</strong> 我们要知道，所有其他语言能够实现的功能在C语言里面都是可以实现的。</p><p><strong>再者</strong> C语言是非常底层的语言，需要更多的去理解内存结构。</p><h1 id="什么是排序算法"><a href="#什么是排序算法" class="headerlink" title="什么是排序算法"></a>什么是排序算法</h1><p><strong>排序算法</strong>（Sorting Algorithm）就是一种用来将一组数据按照特定排序方式（例如：从小到大）进行重新排列的一种算法。最常考虑的排序方式就是数值顺序以及字典顺序。</p><p>排序算法的输出需要满足以下两个要求：</p><ol><li>输出的元素任意两个相邻的元素必须满足排序算法定义的排序方式规则。</li><li>所有输出的结果应与原数据组中的数据一样且各元素个数也一样。</li></ol><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h1 id="自定义排序规则"><a href="#自定义排序规则" class="headerlink" title="自定义排序规则"></a>自定义排序规则</h1><h1 id="任意数据类型的排序"><a href="#任意数据类型的排序" class="headerlink" title="任意数据类型的排序"></a>任意数据类型的排序</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code class="c">bool cmp(const double *data_left, const double *data_right) &#123;    return *data_left &lt;= *data_right;&#125;</code></pre><pre><code class="c">void select_sort(const void *data_start, const void *data_end, size_t item_size,                 bool (*cmp_func)(const void *, const void *)) &#123;    void *left = data_start;    while (left &lt; data_end) &#123;        void *min_p = left;        void *cur = min_p + item_size;        while (cur &lt; data_end) &#123;            if (!cmp_func(min_p, cur)) &#123;                min_p = cur;            &#125;            cur += item_size;        &#125;        void *tmp = malloc(item_size);        memcpy(tmp, left, item_size);        memcpy(left, min_p, item_size);        memcpy(min_p, tmp, item_size);        free(tmp);        left = left + item_size;    &#125;&#125;</code></pre><pre><code class="c">select_sort(a, a + 10, sizeof(double), cmp);</code></pre><hr><p>喵喵怪的小枪枪、biu~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Hacker </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何利用 Tor 网络转发流量</title>
      <link href="/posts/2019-12-30-tor-as-proxy.html"/>
      <url>/posts/2019-12-30-tor-as-proxy.html</url>
      
        <content type="html"><![CDATA[<p>如果你比较关注网络互联网记录的隐私的话，我觉得你应该知道Tor网络（洋葱网络）。我觉得每个人都应该有使用 Tor 网络的需要。</p><p><strong>Tor</strong> 是实现匿名通信的自由软件。用户可以通过 Tor 网络连接到全球志愿者免费提供的中继节点，从而达到至隐藏用户真实地址、避免网络监控及流量分析的目的。</p><p>那么在使用 Tor 的时候，有时候我们想要其他软件的流量也从 Tor 网络通过，比如 Telegram 这样的聊天软件，或者是你的 Chrome 浏览器流量。这个时候就可以使用到 Tor 浏览器自带的 Tor Browser Bundle 功能。它可以提供一个监听端口，然后用户就可以在自己的软件中设置 Socks 代理进行使用 Tor 网络流量。</p><h3 id="0x01-配置"><a href="#0x01-配置" class="headerlink" title="0x01 配置"></a>0x01 配置</h3><p>只需要打开 Tor 浏览器的配置文件 <code>torrc</code> ，然后在文件末尾添加以下内容即可：</p><pre><code class="text">SocksListenAddress 0.0.0.0SocksPort 9998</code></pre><ul><li>macOS 上这个文件在 <code>subl &quot;/Users/&lt;Username&gt;/Library/Application Support/TorBrowser-Data/Tor/torrc&quot;</code> , 这里面的 <code>&lt;Username&gt;</code> 是你用户名，如果不知道就打开终端输入 <code>whoami</code> 并按回车就能看到了。</li><li>Windows 上这个文件应该在 <code>&lt;InstallDirectory&gt;\Data\Tor\torrc</code> , 这里的 <code>&lt;InstallDirectory&gt;</code> 就是你安装的 Tor 浏览器的目录。比如笔者就习惯把 Tor 浏览器安装在 <code>C:\tor-app</code> 里面。</li></ul><p>很明显，这里启动的监听端口就是 9998 端口了。</p><p>接下来你需要打开你的 Tor 浏览器，然后就可以使用其他软件设置代理地址为 <code>127.0.0.1</code> ，以及代理端口 <code>9998</code> 进行使用 Tor 网络流量。</p><h3 id="0x02-测试是否有用"><a href="#0x02-测试是否有用" class="headerlink" title="0x02 测试是否有用"></a>0x02 测试是否有用</h3><p>UNIX&#x2F;Linux 环境下，命令行一般都有 <code>curl</code> 这个命令，那么你可以使用以下两个命令对比一下返回的 IP 地址就可以判断了。</p><pre><code class="bash">&gt; curl ip.sb180.7.6.4&gt; http_proxy=socks5://127.0.0.1:9998 curl ip.sb109.70.100.30</code></pre><p>至于如何下载 Tor 浏览器并且使用 Tor 浏览器这等事情，emmmmmmmm……</p><hr><p>喵喵怪的小枪枪、biu~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Tor </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过去十年的重大科技事件</title>
      <link href="/posts/2019-12-20-major-technology-events-in-the-past-decade.html"/>
      <url>/posts/2019-12-20-major-technology-events-in-the-past-decade.html</url>
      
        <content type="html"><![CDATA[<p>一个十年即将结束，是时候回顾总结了：过去十年科技行业发生了多少足以载入史册的大事件？</p><ol><li>2010-01-12 <strong>谷歌退出中国</strong></li><li>2011-03-30 <strong>科技公司的隐私权争议</strong></li><li>2012-05-18 <strong>Facebook上市</strong></li><li>2013-06-05 <strong>爱德华·斯诺登披露NSA的大规模监视活动</strong> </li><li>2014-09-19 <strong>朝鲜攻击索尼影业</strong></li><li>2015-06-28 <strong>谷歌将黑人标记为“猩猩”</strong></li><li>2016-03-09 <strong>AlphaGo战胜了人类围棋世界冠军</strong></li><li>2017-05-12 <strong>WannaCry病毒席卷全球导致比特币涨势迅猛</strong></li><li>2018-05-25 <strong>欧盟实施《一般数据保护条例》（GDPR）</strong></li><li>2019-06-13 <strong>谷歌实现“量子霸权”</strong></li></ol><hr><p>内容整理自互联网。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lisp in Less Than 200 Lines of C</title>
      <link href="/posts/2019-12-12-lisp-in-less-than-200-lines-of-c.html"/>
      <url>/posts/2019-12-12-lisp-in-less-than-200-lines-of-c.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p><em>Objective: implement a lambda calculus based programming language like LisP, simply and briefly in C</em></p><p>After learning some Scheme and Lisp and implementing LispKit and reading about eval&#x2F;apply and how minimal the evaluator is, I decided to try implement Lisp in as little C as I could.</p><p>Sine it’s less than 200 lines of C code I’ll just discuss the code inline:</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;</code></pre><p>Included are standard headers files: <code>stdio.h</code> gives us <code>printf</code> and <code>puts</code> for printing to stdout, and <code>getchar</code> for retreving a character from stdin. <code>stdlib.h</code> provides <code>calloc</code> for dynamically allocating memory while the program is running. <code>string.h</code> provides <code>strcmp</code> for comparing two string, and <code>strdup</code> for making a duplicate copy of a string.</p><pre><code class="c">#define debug(m,e) printf(&quot;%s:%d: %s:&quot;,__FILE__,__LINE__,m); print_obj(e,1); puts(&quot;&quot;);</code></pre><p>This debug macro was used to help troubleshoot the program when it didn’t work. I’d add a line like <code>debug(&#39;evaluating&#39;, exp)</code> and it would print out the file, line number, a message, and the Lisp expression representation in a readable form.</p><pre><code class="c">typedef struct List &#123;    struct List *next;    void *data;&#125; List;</code></pre><p>The <code>List</code> structure is the fundamental data structure used to represent code and data. It is a singly linked list with two pointers: <code>next</code> points to the next item in the list, and <code>data</code> points to either a symbol or another list structure. <code>data</code> could be cast to either a <code>char *</code> or <code>List *</code>. To determine which one keep reading (spoiler: pointer tagging is used).</p><pre><code class="c">List *symbols = 0;</code></pre><p>The global variable <code>symbols</code> represents the head of a list of symbols. When symbol is parsed, we’ll look for it in the list of symbols, if it’s not there we’ll add it. This way we can compare two symbols by using the equals comparison operator, &#x3D;&#x3D;. It saves a little bit of storage space when the same symbol is repeated many times in a LisP program, but with 8GB of RAM memory in my computer I probably won’t notice the space saving.</p><pre><code class="c">static int look; /* look ahead character */static char token[32]; /* token */</code></pre><p>Because a symbol can contain more than one character, we have a complete symbol when a character that doesn’t belong in a symbol in encountered. Non symbol characters include whitespace(space, tab, newline etc), and syntax characters such as parenthesis, (,). To determine whether the end of a symbol has been reached we need to look ahead by one character. The <code>look</code> variable stores the look ahead character. If this character contains a non-symbol character we’ll know to stop reading the symbol. The <code>token</code> variable is an array of characters, it stores the current symbol that has been read from the input. Note that it has a size of 32, so the maxinum length of a symbol will be 31 characters, because the token is a NULL terminated string, so the token is always terminated with a <code>\0</code> character.</p><pre><code class="c">#define is_space(x)  (x == &#39; &#39; || x == &#39;\n&#39;)#define is_parens(x) (x == &#39;(&#39; || x == &#39;)&#39;)</code></pre><p>The two macros above are really just a convenience for the sake of readability and possibly maintainability and extensibility of the program. <code>is_space</code> takes a single character and will return true if that character is a space of a newline. <code>is_parens</code> takes a single character and will return true if that character is a parenthesis.</p><pre><code class="c">static void gettoken() &#123;    int index = 0;    while (is_space(look)) &#123;        look = getchar();    &#125;    if (is_parens(look)) &#123;        token[index++] = look;        look = getchar();    &#125; else &#123;        while (look != EOF &amp;&amp; !is_space(look) &amp;&amp; !is_parens(look)) &#123;            token[index++] = look;            took = getchar();        &#125;    &#125;    token[index] = &#39;\0&#39;;&#125;</code></pre><p>The function <code>gettoken</code> is responsible for reading characters from standard input and determining whether parenthesis or a symbol has been discovered. First it will skip over any white space. If the look variable, the look ahead character, is a parenthesis, it is stored in <code>token</code>, and the next character in the input stream read into <code>look</code>. If the lookahead character is not a parenthesis, it’s assumed to belong to a symbol. Keep looking ahead and saving the character until either <code>EOF</code> the end of file is reached, or the look ahead character is whitespace, or the look ahead character is a parenthesis. <code>index</code> stores the current position in the <code>token</code> array so it is incremented every time a character belonging to the symbol is stored. At the end of the token is NULL terminated.</p><pre><code class="c">#define is_pair(x) (((long)x &amp;  0x1) == 0x1) /* tag pointer to pair with 0x1 (alignment dependent) */#define untag(x)   ((long) x &amp; ~0x1)#define tag(x)     ((long) x |  0x1)</code></pre><p>Above contains a curiosity that can be found in many language implementations. Remember from the <code>List</code> structure that the <code>data</code> pointer can be either a <code>char *</code> a symbol, or <code>List *</code> another List. The way we are indicating the type of pointer is by setting the lowest bit on the pointer on. For example, given a pointer to the address <code>0x100200230</code>, if it’s a pair we’ll modify that pointer with a bitwise or with 1 so the address becomes <code>0x100200231</code>. The questionable thing about modifying a pointer in this way is how can we tell a pointer tagged with 1, from a regular untagged address. Well, partly as a performance optimization, many computers and their Operating System, allocate memory on set boundaries. It’s referred to as memory alignment, and if for example the alignment is to an 8-byte(64 bit) boundary, it means that when memory is allocated it’s address will be a multiple of 8. For example the next 8 byte boundary for the address <code>0x100200230</code> is <code>0x1000200238</code>. Memory could be aligned to 16-bits(2 bytes), 32-bits(4 bytes) as well. Typically it will be aligned on machine word, which means 32-bits if you have a 32-bit CPU and bus. [Thanks to mtnygard for pointing out that I’d mixed bits and bytes previously]. A more thorough discussion is on wikipedia<a href="https://en.wikipedia.org/wiki/Data_structure_alignment">https://en.wikipedia.org/wiki/Data_structure_alignment</a>. Effectively for us it means that whenever we call <code>calloc</code> we’ll always get back an address where the lowest bit is off(0), so we can set it on if we want. The macro <code>is_pair</code> returns non-zero if the address is a pair (which means we’ll need to unset the lowest bit to get the address). It uses a bitwise and with 1 to determine this. The <code>untag</code> macro switches the lowest bit off, with a bitwise and of the ones complement of 1. The <code>tag</code> macro switches the lowest bit on with a bitwise or of 1.</p><pre><code class="c">#define car(x) (((List*)untag(x))-&gt;data)#define cdr(x) (((List*)untag(x))-&gt;next)</code></pre><p>There’s two fundamental primitive operations in a typical Lisp&#x2F;Scheme, <code>car</code> which returns the head of a list, and <code>cdr</code> which returns the tail of the list. They are named after operations on an IBM computer, some information on the history is on Wikipedia <a href="https://en.wikipedia.org/wiki/CAR_and_CDR">https://en.wikipedia.org/wiki/CAR_and_CDR</a>. We could as easily call them head and tail, but since they are so ingrained in Lisp and Scheme conventions they are perpetuated here.</p><pre><code class="c">#define e_true     cons( intern(&quot;quote&quot;), cons( intern(&quot;t&quot;), 0))#define e_false    0</code></pre><p>The <code>e_true</code> and <code>e_false</code> macros are a convenience for defining a what true and false in this implementation. Basically so long as true is non-zero everything should be ok. It will help if the values they have can be readily printed in human readable form.</p><pre><code class="c">List *cons(void *_car, void *_cdr) &#123;    List *_pair = calloc(1, sizeof(List));    _pair-&gt;data = _car;    _pair-&gt;next = _cdr;    return (List*) tag(_pair);&#125;</code></pre><p>Another fundamental Lisp&#x2F;Scheme operation is <code>cons</code>. It constructs a pair, which means a pair of pointers, in this implementation the <code>List</code> structure that holds the <code>data</code> pointer and the <code>next</code> pointer. <a href="https://en.wikipedia.org/wiki/Cons">https://en.wikipedia.org/wiki/Cons</a> Because pointers to a <code>List</code> (a pair) must be tagged using the lowest bit, we rely on <code>calloc</code> to provide memory large enough to hold the <code>List</code> data structure and that the memory is aligned to an address that does not involve to lowest bit. The <code>cons</code> function here takes two arguments, the first is an address that will be stored in the <code>data</code> field, and the second an address that will be stored in the <code>next</code> field. Finally the address where the <code>List</code> structure is stored in returned, after being tagged as a special kind of pointer.</p><pre><code class="c">void *intern(char *sym) &#123;    List *_pair = symbols;    for (; _pair; _pair = cdr(_pair)) &#123;        if (strncmp(sym, (char*) car(_pair), 32) == 0) &#123;            return car(_pair);        &#125;    &#125;    symbols = cons(strdup(sym), symbols);    return car(symbols);&#125;</code></pre><p>Here’s where a symbol is retrieved from the global list of symbols, or added if it is not found. It takes a single string argument. It uses <code>strncmp</code> to determine if anyone of the symbols are equivalent to the string passed in. If we get to the end of the list of symbols and didn’t find a match. The symbol is duplicated with <code>strdup</code> and added to the head of the list. This is the effect of <code>cons</code> when given an existing list as the second parameter: a new symbol is pushed onto the list, and a new list head is constructed. The reason <code>strdup</code> is used, and the string is duplicated, is because we want a more permanent copy of the string. When the program runs, the <code>sym</code> parameter could be a pointer to the <code>token</code> global variable which will be modified as symbols are read from the input stream. The function is called <code>intern</code> out of convention, see <a href="https://en.wikipedia.org/wiki/String_interning">https://en.wikipedia.org/wiki/String_interning</a> for more background on string interning.</p><pre><code class="c">List *getlist();</code></pre><p>Above is a forward declaration of the function <code>getlist</code> which is defined further down. A forward declaration is needed because the <code>getobj</code> function can call it, and <code>getlist</code> can call <code>getobj</code> which is a chichen and egg kind of problem. The C compiler needs to know that the full signature of this function so it can be used before it is defined.</p><pre><code class="c">void *getobj() &#123;    if (token[0] == &#39;(&#39;) return getlist();    return intern(token);&#125;</code></pre><p>All <code>getobj</code> has to do is check if the current token from the input stream was an opening parenthesis, which means a list is being defined, and <code>getlist</code> can be called to construct the list. Otherwise, the token is treated as a symbol, and <code>intern</code> is used to either return the single copy, or create a single copy and add it to the list of symbols.</p><pre><code class="c">List *getlist() &#123;    List *tmp;    gettoken();    if (token[0] == &#39;(&#39;) return 0;    tmp = getobj();    return cons(tmp, getlist());&#125;</code></pre><p>The function <code>getlist</code> reads the next token from the input. If the token is a closing parenthesis it returns 0 (a NULL pointer). Otherwise the token is probably a symbol, so call <code>getobj</code> and intern that symbol, the use <code>cons</code> to add that symbol to the head of the list, calling <code>getlist</code> recursively to get the tail of the list. Take note that the variable <code>tmp</code> - an abbreviation ot temporary - and explicity assigned to the return value of <code>getobj</code> before the <code>cons</code>. This is to ensure that the list is constructed in the correct order from head towards tail. Before the <code>cons</code> function is called, it’s arguments are evaluated, and in this case it’s second argument is a function call to <code>getlist</code>. So <code>getlist</code> is called again before <code>cons</code> is called, and either the end of the list (right parens) is discovered, or the next item in the list is. How this recursive function call works is worthwhile understanding. In C, when function are called, the arguments to the function, and the variables in the function are pushed on top of a data structure called a stack. A stack is literally a stack of things, like a stack of plates, where the last thing on top is the first thing that will come off. The arguments and variable to the function come off the stack when the function returns, literally where you see <code>return</code> in the code. With every call to the <code>getlist</code> function as it comes across items in the list it is processing, the stack grows with another set of variables needed by <code>getlist</code>. So 3 recursive calls to <code>getlist</code> means the stack grows by 3 times the <code>getlist</code> functions storage requirements. The inefficiency here is the longer the list, the taller the stack. Some programming languages have a stack overflow error where the stack has out grown the available memory. Wikipedia has a page about this <a href="https://en.wikipedia.org/wiki/Stack_overflow">https://en.wikipedia.org/wiki/Stack_overflow</a> Programming languages like Scheme implement something called tail call optimization where the language can determine if the variable used by a recursive function call will be needed after is returns and if not, it does not grow the stack. This is a pretty cool feature of a programming language and it would be great to have in this language, and maybe we can add it later on. For more on tail calls, <a href="https://en.wikipedia.org/wiki/Tail_call">https://en.wikipedia.org/wiki/Tail_call</a></p><pre><code class="c">void print_obj(List *ob, int head_of_list) &#123;    if (!is_pair(jb)) &#123;        printf(&quot;%s&quot;, ob ? (char *) ob : &quot;null&quot;);    &#125; else &#123;        if (head_of_list) &#123;            printf(&quot;(&quot;);        &#125;        print_obj(car(ob), 1);        if (cdr(ob) != 0) &#123;            if (is_pair(cdr(ob))) &#123;                printf(&quot; &quot;);                print_obj(cdr(ob), 0);            &#125;        &#125; else &#123;            printf(&quot;)&quot;);        &#125;    &#125;&#125;</code></pre><p>The <code>print_obj</code> function is tremendously useful in that it can print either a symbol, or an entire list, to stdout so that we can read it. If the first argument, <code>object</code> isn’t the specially tagged pointer, it’s just a symbol so it can be output with <code>printf</code> using the <code>%s</code> format specifier, which says that the provided pointer is a null terminated string. Otherwise <code>print_obj</code> is being asked to print a list, so <code>ob</code> will be the address of a <code>List</code> structure, meaning it is somewhere, either the beginning, middle or end, or printing a list. The <code>head_of_lst</code> argument is the giveaway here. If <code>head_of_list</code> is non-zero, it’s the beginning of a new list, so print the left parenthesis. In any case it has to print the value of the current item (it could either be a symbol or a nested listed) so it calls itself with the value of the current head of the list, <code>car(ob)</code>. If the tail of the list is non-zero, this means there’s more, so as long as the tail of the list is a pointer to another <code>List</code> structure, print a space, and then print the tail of the list. Otherwise, the tail of the list is zero, which means we’re at the end of the list, so print the closing parenthesis.</p><pre><code class="c">List *fcons(List *a)    &#123;  return cons(car(a), car(cdr(a)));  &#125;List *fcar(List *a)     &#123;  return car(car(a));  &#125;List *fcdr(List *a)     &#123;  return cdr(car(a));  &#125;List *feq(List *a)      &#123;  return car(a) == car(cdr(a)) ? e_true : e_false;  &#125;List *fpair(List *a)    &#123;  return is_pair(car(a))       ? e_true : e_false;  &#125;List *fsym(List *a)     &#123;  return ! is_pair(car(a))     ? e_true : e_false;  &#125;List *fnull(List *a)    &#123;  return car(a) == 0           ? e_true : e_false; &#125;List *freadobj(List *a) &#123;  look = getchar(); gettoken(); return getobj();  &#125;List *fwriteobj(List *a)&#123;  print_obj(car(a), 1); puts(&quot;&quot;); return e_true;  &#125;</code></pre><p>Above are defined the basic primitive operations required by Lisp, all using the same return value and argument specification. These functions will be referenced in the interpreters environment so the can be used from a Lisp program. Because the Lisp language we’re implementing will know nothing about C and how many arguments and what type they should be in C, the arguments are represented using the linked list structure, which has an equivalent Lisp representation using parenthesis, whitespace and symbols. These functions are prefixed with <code>f</code> which stands for function. They are called indirectly only when a Lisp program looks one up and wants to apply it.</p><pre><code class="c">List *eval(List *exp, List *env);</code></pre><p>This is a forward declaration of eval the meta-circular evaluator.</p><pre><code class="c">List *evlist(List *list, List *env) &#123;    List *head = 0, **args == &amp;head;    for (; list; list = cdr(list)) &#123;        *args = cons(eval(car(list), env), 0);        args = &amp;((list *)untag(*args))-&gt;next;    &#125;    return head;&#125;</code></pre><p>Above is the <code>evlist</code> function, short for “evaluate list”. It takes a list and an environment, and evaluates each item in the list, returning a corresponding list with the evaluation of each input item, maintaining the order. There is use of a pointer to a pointer here which makes this code less immediately obvious, but it means we can walk through the list, creating a parallel list with the evaluated elements in the same order. In “The C Programming Lanugae” by Brian Kernighan and Dennis Ritchie, a pointer is said to be a variable that contains the address of another variable, The <code>*</code> operator dereferences a pointer, giving the object pointed to. The <code>&amp;</code> operator gives the address of a variable. <code>evlist</code> iterates through the <code>list</code> argument in a for loop. Two local variables , a pointer, <code>head</code>, is initialized to 0, the purpose of <code>head</code> is to store the head of the list that will be returned. <code>args</code> is a pointer to a pointer, it is initialied to the address of <code>head</code>. On each iteration, <code>args</code> is dereferenced and the resulting pointer is assigned to a newly constructed cell. On the next time, <code>args</code> is assigned to the address of the <code>next</code> field in that constructed cell. This means that on the next iteration, <code>args</code> is a pointer to a pointer to the <code>next</code> field of the previous element. When it is dereferenced with a signle <code>*</code> and assigned, we are effectively setting the <code>next</code> field to point to the newly constructed cell in the current iteration.</p><pre><code class="c">List *apply_primitive(void *primfn, List *args) &#123;    return ((List * (*) (List *))primfn) (args);&#125;</code></pre><p>The <code>apply_primitive</code> function does nothing more than cast the <code>primfn</code> to a pointer to a function that takes a single <code>List *</code> and returns a <code>List *</code>, and then calls that function with <code>args</code>.</p><pre><code class="c">List *eval(List *exp, List *env) &#123;    if (!is_pair(exp)) &#123;        for (; env != 0; env = cdr(env)) &#123;            if (exp == car(car(env)))                return car(cdr(car(env)));        &#125;        return 0;    &#125; else &#123;        if (!is_pair(car(exp))) &#123;            /* special forms */            if (car(exp) == intern(&quot;quote&quot;)) &#123;                return car(cdr(exp));            &#125; else if (car(exp) == intern(&quot;if&quot;)) &#123;                if (eval(car(cdr(exp)), env) != 0) &#123;                    return eval(car(cdr(cdr(exp))), env);                &#125; else &#123;                    return eval(car(cdr(cdr(cdr(exp)))), env);                &#125;            &#125; else if (car(exp) == intern(&quot;lambda&quot;)) &#123;                return exp; /* todo: create a closure and capture free vars */            &#125; else if (car(exp) == intern(&quot;apply&quot;)) &#123;                /* apply function to list */                List *args = evlist(cdr(cdr(exp)), env);                args = car(args); /* assume one argument and that it is a list */                return apply_primitive(eval(car(cdr(exp)), env), args);            &#125; else &#123;                /* function call */                List *primop = eval(car(exp), env);                if (is_pair(primop)) &#123;                    /* user defined lambda, arg list eval happens in binding below */                    return eval(cons(primop, cdr(exp)), env);                &#125; else if (primop) &#123;                    /* built-in primitive */                    return apply_primitive(primop, evlist(cdr(exp), env));                &#125;            &#125;        &#125; else &#123;            /* should be a lambda, bind names into env and eval body */            if (car(car(exp)) == intern(&quot;lambda&quot;)) &#123;                List *extenv = env, *names = car(cdr(car(exp))), *vars = cdr(exp);                for (; names; names = cdr(names), vars = cdr(vars)) &#123;                    extenv = cons(cons(car(names), cons(eval(car(vars), env), 0)), extenv);                &#125;                return eval(car(cdr(cdr(car(exp)))), extenv);            &#125;        &#125;    &#125;    puts(&quot;cannot evaluate expression&quot;);    return 0;&#125;</code></pre><p>The <code>eval</code> function is the heart of LiSP. It interprets LisP expressions. If the expression is not a pair (not a <code>List</code> structure), we look for that value it is associated with in the environment. In other implementations of eval, the equivalent test is if the expression is an <code>atom</code>. Otherwise the expression must be a list, and then the first element of that list is checked, if that first element is not a <code>List</code> structure - it is a symbol, or more officially an atom, then the following series of if statements handle it: if the first element is a <code>quote</code> symbol, the next element is return, that is, the head of the tail of the list; if the first element is an <code>if</code> symbol, the head of the tail of the list is evaluated, if that returns non-zero, the head of the tail of the tail of the list is evaluated and returned, if it returns zero, the head of the tail of the tail of the tail is evaluated and returned. If the first element is the symbol <code>lambda</code> the expression is simply returned (maybe this is redundant so many indicate a bug or some optimization that is missing). In a Scheme interpreter, a closure would be created and the free variables in the closure captured using the current environment. If the first symbols is <code>apply</code> that means, in this interpreter at least, that the next element is a function and the element after that, the third element in this list is a list - the <code>(b c d)</code> in <code>(apply a (b c d))</code>. The assumption is that <code>apply</code> is being used to call one of the basic primitive operations defined above: <code>car</code>, <code>cdr</code>, <code>cons</code>, <code>eq?</code>, <code>pair?</code>, <code>symbol?</code>, <code>null?</code>, <code>read</code>, <code>write</code>. If the first symbol did not match any of the prior if statements, we assume a the first symbol is in the environment and is either a user defined function - a lambda, or a primitive function (and apply is not being used to call it). We find out which it is by evaluating that first element, if it’s a pair, it’s a list, i.e. an expression in the form <code>(lambda (arg) (body expressions ...))</code>. If it’s not a pair we assume it’s a pointer to a function, and use <code>apply_primitive</code> to invocate that function, evaluating it’s arguments before calling it. The remaining block is the <code>else</code> which meant the first argument in the expression was a pair - eval was called with a list nested inside a list, i.e. <code>((x y z))</code>, and the only form of nested expression handled, is lambda, e.g. <code>((lambda (arg) (body expr ....)) value )</code>. In this case the names of the arguments in the lambda definition are bound to the corresponding values, and the name value pairs are pushed onto the head of the environment, until there are no more arguments (names) left to bind. The body of the lambda is then evaluated with the extended environment.</p><p>A newer article describing eval is called “The Root of Lisp” by Paul Graham, and can be downloaded from <a href="http://www.paulgraham.com/rootsoflisp.html">http://www.paulgraham.com/rootsoflisp.html</a>. A thorough explanation can be found is “Structure and Interpretation of Computer Programs”, by Harold Ableson and Gerald Jay Sussman. This book can be found online: <a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1">https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1</a>. The earliest implementations of eval I have found is in the Lisp 1.5 Programmers Manual.</p><pre><code class="c">int main(int argc, char *argv[]) &#123;    List *env = cons (cons(intern(&quot;car&quot;), cons((void *)fcar, 0)),                cons (cons(intern(&quot;cdr&quot;), cons((void *)fcdr, 0)),                cons (cons(intern(&quot;cons&quot;), cons((void *)fcons, 0)),                cons (cons(intern(&quot;eq?&quot;), cons((void *)feq, 0)),                cons (cons(intern(&quot;pair?&quot;), cons((void *)fpair, 0)),                cons (cons(intern(&quot;symbol?&quot;), cons((void *)fsym, 0)),                cons (cons(intern(&quot;null?&quot;), cons((void *)fnull, 0)),                cons (cons(intern(&quot;read&quot;), cons((void *)freadobj, 0)),                cons (cons(intern(&quot;write&quot;), cons((void *)fwriteobj, 0)),                cons (cons(intern(&quot;null&quot;), cons(0,0)), 0))))))))));    look = getchar();    gettoken();    print_obj( eval(getobj(), env), 1 );    printf(&quot;\n&quot;);    return 0;&#125;</code></pre><p><code>main</code>is the entry point for this program when it is run. It has one variable, <code>env</code> which is assigned to a list of lists, effectively just associating a symbol with a primitive function. The remaining lines, look ahead one character, load the first token with <code>gettoken</code>, and then print with <code>print_obj</code>, the evaluated object read by <code>getobj</code>.</p><p>That is it a very small and incomplete interpreter… Noticeably there is no garbage collection, or even any explicit free of the memory allocated by <code>calloc</code>. Neither is there any error handling, so a program with missing or unmatched parenthesis, unresolved symbols, etc will likely just result in something like a segmentation fault.</p><p>Despite the limitations, this interpreter provides enough primitive functions to implement an equivalent eval on itself.</p><p>The complete source code and some tests can be found at <a href="https://github.com/carld/micro-lisp">https://github.com/carld/micro-lisp</a>. Pull requests on github are welcome.</p><p>An implementation of eval that runs on the interpreter about can be found in <code>repl.lisp</code>. It implements a Read Eval Print Loop and it can. be run using:</p><pre><code class="bash">cat repl.lisp - | ./micro-lisp</code></pre><p>Repost from <a href="https://carld.github.io/2017/06/20/lisp-in-less-than-200-lines-of-c.html">https://carld.github.io/2017/06/20/lisp-in-less-than-200-lines-of-c.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> C </tag>
            
            <tag> Repost </tag>
            
            <tag> Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何像程序员一样思考</title>
      <link href="/posts/2019-12-08-how-to-think-like-a-programmer.html"/>
      <url>/posts/2019-12-08-how-to-think-like-a-programmer.html</url>
      
        <content type="html"><![CDATA[<p>如果你对编程感兴趣的话，你应该听说过下面这段话：</p><blockquote><p>这个国家的每个人都应该学习编程，因为它可以教你如何思考。—— 史蒂夫·乔布斯</p></blockquote><p>你可能有点懵了。“像程序员一样思考”到底是什么意思？而且应该<em>怎么</em>做呢？</p><p>其实啊，这都是一些关于 <strong>如何更有效的解决问题</strong> 的方法。</p><p>在这篇文章里，我主要就是讲讲这些方法。</p><p>在最后，你应该就会知道具体该怎么一步一步以更好的方式去解决问题。</p><h3 id="为什么这很重要？"><a href="#为什么这很重要？" class="headerlink" title="为什么这很重要？"></a>为什么这很重要？</h3><p>解决问题这样的能力是基本技能。我们都在不断遇到问题，有大的也有小的。有时候，我们是怎么去面对它们的呢？很随意吧。</p><p>除非你已经自成体系了，否则接下来的方式大概就是你解决问题的步骤了（这也是我开始学编程时候的样子）：</p><ol><li>尝试一个解决方案。</li><li>如果不行，就换一个解决方案。</li><li>如果不行，重复步骤 2 直到你运气来了终于试出来了。</li></ol><p>看吧，有时候你可能运气会比较好。这时解决问题最差的一种方式了。并且，这会浪费你很多，很多时间。</p><p>最好的方式应该是 a) 整理好框架 b) <strong>练习</strong>。</p><blockquote><p>几乎所有的面试官都把解决问题的能力放在第一位。</p><p>相比对编程语言的熟练程度、调试能力和系统设计能力，面试官更看重面试者的解决问题的能力。</p><p>展示计算思维或解决大型复杂问题的能力与工作所需的基本技术技能有同样的价值。</p><p>—— Hacker Rank（2018年开发者技能报告）</p></blockquote><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>我遵循着Tim Ferriss关于学习的书《厨艺解构》中建议去寻找合适的框架。这也使我访问了两位令我印象深刻的人：C. Jordan Ball 和 V. Anton Spraul. 我问了他们一些问题，你们猜怎么着？他们的回答都近乎一样。你一会就能很快的了解这其中是为什么了。</p><p>注：这并不意味着他们做什么事情都一样。每个人都是不同的。你也会跟他们不同。但是你如果从这些我们都认可是对的原则开始的话，你将会更快地更加深入地理解这些。</p><blockquote><p>我看到新手程序员遇到问题犯的最大错误是专注于学习编程语言的语法，而不是学习如何解决问题。—— V. Anton Spraul</p></blockquote><p>所以，当你遇到问题的时候你应该怎么做呢？</p><p>步骤如下：</p><h3 id="1-理解问题"><a href="#1-理解问题" class="headerlink" title="1. 理解问题"></a>1. 理解问题</h3><p>应该了解你要解决的问题是什么。很多很难的问题其难的原因在于你并没有理解问题（这也是为什么理解问题放在第一步的原因）</p><p>怎么能够知道你已经完全理解问题了呢？就是当你能够用很直白的话语描述出来的时候。当你在一个问题上卡住的时候，尝试去解释这个问题。然后你马上就会发现你逻辑上漏洞。是不是有那种似曾相识的感觉？很多程序员都有这种感觉。这就是为什么你要把问题写下来的原因，画一画图表，或者跟别人说一说这是什么（或者跟某个物件…… 有些人会用一个小黄鸭）</p><p>这也是费曼学习法里面的东西，尝试像别人解释你所学的知识。</p><blockquote><p>如果你不能以一种简单的方式去描述某个东西，那么就不算理解它。 —- Richard Feynman</p></blockquote><h3 id="2-计划"><a href="#2-计划" class="headerlink" title="2. 计划"></a>2. 计划</h3><p>不要在没有做好计划之前盲目的埋头解决问题。计划好你的解决方案。没有什么比你能够写下明确的解决步骤更好的了。</p><p>在编程方面，这也就是说不要一开始就想着直接解决问题。先好好分析问题、处理信息。</p><p>为了获得一个好的计划，应该尝试回答一下以下问题：</p><p>“输入X，得出Y 需要那些必须的步骤？”</p><p>注：程序员有一个非常好的工具去帮助他们来完成这样的计划——注释！</p><h3 id="3-分解问题"><a href="#3-分解问题" class="headerlink" title="3. 分解问题"></a>3. 分解问题</h3><p>注意啦，这应该是所有问题中最为<strong>重要的</strong>。不要尝试去直接解决一个很大的问题。你会心态崩溃的。反而，你应该把问题拆解成一个个很容易解决的子问题。然后，从最简单的开始，挨个解决这些子问题。最简单就是你一眼就能知道答案的（或者很接近答案的）。当然，最简单的也意味着解决这个问题的时候并不依赖于其他问题的解决。</p><p>当你解决了每个子问题后，将它们连起来。将你所有子问题的解决方案连起来，你就得到原问题的完整解决方案了。恭喜你！</p><p>分解问题是解决问题的基石。记住以下内容（如有必要，再来看看以下步骤）：</p><blockquote><p>如果我要教会每一个编程初学者一项解决问题的技能的话，那会是“拆分问题的技能”。例如，假设你是一个编程初学者，你被要求编程实现读取10个数字然后找出其中第三大的数字。即使解决这个问题只要一点点基本的编程语言语法，但对一个编程初学者来说，这可能也还算是一个比较困难的任务了。</p><p>如果你卡住了，你应该把问题拆分成更加简单的问题。不是去思考第三大的数字这个问题，而是去思考找所有数字中最大的数字呢？还是太难了？那么只给你三个数字找其中最大的呢？再或者两个数字中找最大的呢？</p><p>不断拆分这个问题直到你知道如何解决或者能够直接写出解决方法。然后扩展这个问题并再次写出解决方案，直到回到最初你碰到的那个问题。</p><p>—— V. Anton Spraul</p></blockquote><h3 id="4-卡住了？"><a href="#4-卡住了？" class="headerlink" title="4. 卡住了？"></a>4. 卡住了？</h3><p>到现在为止，你可能会想“嘿……这看上去很有趣呀。但是，要是我卡住了，甚至一个子问题都不能解决呢？”</p><p>首先，深呼吸。然后，这很正常的。不要慌，每个人都会有这样的情况。</p><p>好的程序员的不同之处在于他们在面对的bug或者错误的时候会充满好奇心，而不是烦躁。</p><p>事实上，在遇到问题的时候可以尝试接下来三个步骤：</p><ul><li><p>调试：一步一步的去看看你的程序在哪一步出错了。程序员称这样的过程为<em>调试</em>。（事实上，这就是调试器的全部功能。）</p><blockquote><p>调试的艺术是在于找出你实际上告诉程序怎么做而不是你以为你告诉它怎么做了。—— Andrew Singer</p></blockquote></li><li><p>重新评估：从另一个角度来看看这个问题。这是否可以抽象一下，是否有一个通用的方法能够解决这样的问题？</p><blockquote><p>有时候我们会在问题的细节中迷失了方向，以至于忽略了问题可以用一种更加通用的方法来解决。最经典的问题就是高斯小时候遇到的那个对连续的数列进行求和问题：1 + 2 + 3 + … + n. 他很快就意识到这直接有一个通用公式可以用：n(n+1)&#x2F;2 来避免那么多加法计算。 —— C. Jordan Ball</p></blockquote><p>  注：另一个重新评估的好方法就是重新开始。删掉所有的东西，然后重新开始。这并不是开玩笑，因为你会惊奇地发现这真的很有效。</p></li><li><p>研究：哇哦，Google搜索呀，你没看错。无论你遇到什么问题，都有可能已经有人解决了的。找到他人的解决方法。然而事实上，就算你已经解决了问题也应该去搜一下，看看别人的解决方法。你可以从中学到更多的东西。</p></li></ul><p><strong>警告：</strong>不要去寻找大问题的解决方法。应该仅仅去寻找子问题的解决方法。为什么？因为这不会让你学到什么东西。如果你学不到任何东西的话，你就是在浪费你自己的时间。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>不要指望你花一周的时间就可以在解决问题方面变得很强。如果想你成为一个很好的解决问题的人，你需要解决大量的问题。</p><p>练习！练习！练习！在你碰到一个问题会有“这个问题用XXX来解决就很简单”这样的想法之前，你唯一可以做的就是利用大量的时间来练习。</p><p>如何练习？有很多，比如数学问题、数独游戏、游戏、加密猫、吧啦吧啦……</p><p>事实上，很多成功人士的一些解决问题的常见模式都来自于他们解决“微小问题”的模式。</p><blockquote><p>Byron Reeves 表示：“如果你想了解三到五年内业务领导的模样，可以参考网络游戏发生的事情。”</p><p>今天，Elon，Reid，Mark Zuckerberg 等人都表示游戏是他们成功创立他们公司的基础。</p><p>—- Mary Meeker</p></blockquote><p>这是不是就是说你只要玩游戏就行了？当然不是了。但是游戏是什么呢？就是解决问题！</p><p>因此，你应该做的是找到一个练习东西，这些东西可以让你练习很多微小的问题（当然，理想状态下都是一些你感兴趣的问题）。</p><p>例如，我比较喜欢编程挑战，我每天就找上至少一个编程挑战的问题来练习。</p><p>就像我说的，所有的问题都有着类似的模式。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>就这些了。现在你应该更好的理解了 “像程序员一样思考”是什么意思了。还知道了解决问题是一项不可思议的技能（基本技能）。如果这还不够的话，那你应该知道了如何练习解决问题的技能。是不是很酷呀。最后，我希望你能遇到很多问题。</p><p>对，你没有看错。最少现在你知道如何去解决它们了。当然，以上我说的方法你也可以去改善的。</p><blockquote><p>当你认为自己已经成功克服了一个问题的时候，就会出现另一个问题。但这就是让生活变得有趣的原因。生活就是一个不断解决问题的过程，一系列我们必须突破的强化路线。</p><p>每次我们都能学到些东西。</p><p>每次我们都会变得更强、更有智慧、更有远见。</p><p>每次更多的竞争都会消失。最后剩下的只有你：你自己最好的一个版本。</p><p>—— Ryan Holiday</p></blockquote><p>现在，去找点问题来尝试尝试吧。加油，祝你好运。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft Office 2013 下载链接及激活工具</title>
      <link href="/posts/2019-11-27-microsoft-office-2013.html"/>
      <url>/posts/2019-11-27-microsoft-office-2013.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="text">链接: https://pan.baidu.com/s/1RsupiwR4QLzRwX__oXhQNg提取码: 8psy</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Keys </tag>
            
            <tag> Windows </tag>
            
            <tag> Office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之策略模式</title>
      <link href="/posts/2019-11-26-python-design-pattern-strategy.html"/>
      <url>/posts/2019-11-26-python-design-pattern-strategy.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p><p><strong>主要解决：</strong> 在有多种算法相似的情况下，使用 <code>if..else</code> 所带来的复杂和难以维护。</p><p><strong>何时使用：</strong> 一个系统有许多许多类，而区分它们的只是它们直接的行为。</p><p><strong>关键代码：</strong> 实现同一个接口。</p><p><strong>应用实例：</strong> 1. 诸葛亮的精囊妙计，每一个精囊就是一个策略。 2. 旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3. Java AWT 中的 LayoutManager</p><p><strong>优点：</strong> 1. 算法可以自由切换。 2. 避免使用多重条件判断。 3. 扩展性良好。</p><p><strong>缺点：</strong> 1. 策略类会增多。 2. 所有策略类都需要对外暴露。</p><p><strong>使用场景：</strong> 1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2. 一个系统需要动态地在几种算法中选择一种。 3. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/6c472e56a115d1678214d1454280a300-bfd2df.jpg" alt="photo_2019-11-26_17-02-49"></p><pre><code class="python"># -*- coding: utf-8 -*-class TravelStrategy(object):    &#39;&#39;&#39;出行策略&#39;&#39;&#39;    def travelAlgorithm(self):        passclass AirplaneStrategy(TravelStrategy):    def travelAlgorithm(self):        print(&quot;坐飞机出行&quot;)class TrainStrategy(TravelStrategy):    def travelAlgorithm(self):        print(&quot;坐高铁出行....&quot;)class CarStrategy(TravelStrategy):    def travelAlgorithm(self):        print(&quot;自驾出行....&quot;)class BicycleStrategy(TravelStrategy):    def travelAlgorithm(self):        print(&quot;骑车出行....&quot;)class TravelInterface(object):    def __init__(self, travel_strategy):        self.travel_strategy = travel_strategy    def set_strategy(self, travel_strategy):        self.travel_strategy = travel_strategy    def travel(self):        return self.travel_strategy.travelAlgorithm()# 坐飞机travel = TravelInterface(AirplaneStrategy())travel.travel()# 改开车travel.set_strategy(TrainStrategy())travel.travel()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之观察者模式</title>
      <link href="/posts/2019-11-26-python-design-pattern-observer.html"/>
      <url>/posts/2019-11-26-python-design-pattern-observer.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>适用性：</strong> 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/959d1aeabc2ad60c4ccbf4600fd146f0-b928b6.jpg" alt="photo_2019-11-26_16-48-52"></p><pre><code class="python"># -*- coding: utf-8 -*-## 观察者（Observer）模式又名发布-订阅（Publish/Subscribe）模式# 当我们希望一个对象的状态发生变化，那么依赖与它的所有对象都能相应变化(获得通知),那么就可以用到Observer模式， 其中的这些依赖对象就是观察者的对象，那个要发生变化的对象就是所谓’观察者’# 经过乱搞版的测试，为什么要使用property，因为类 属性的值是动态的，不是固定的,每个对象有不同的msg,所有只有使用动态赋值class ObserverBase(object):    &#39;&#39;&#39;观察者基类&#39;&#39;&#39;    def __init__(self):        self._observerd_list = []    def attach(self, observe_subject):        &#39;&#39;&#39;        添加要观察的对象        :param observe_subject:        :return:        &#39;&#39;&#39;        if observe_subject not in self._observerd_list:            self._observerd_list.append(observe_subject)            print(&quot;[%s]已经将[%s]加入观察队列...&quot; % (self.name, observe_subject))    def detach(self, observe_subject):        &#39;&#39;&#39;        解除观察关系        :param observe_subject:        :return:        &#39;&#39;&#39;        try:            self._observerd_list.remove(observe_subject)            print(&quot;不再观察[%s]&quot; % observe_subject)        except ValueError:            pass    def notify(self):        &#39;&#39;&#39;        通知所有被观察者        :return:        &#39;&#39;&#39;        for objserver in self._observerd_list:            # 把自己传进去            objserver.update(self)class Observer(ObserverBase):    &#39;&#39;&#39;观察者类&#39;&#39;&#39;    def __init__(self, name):        super(Observer, self).__init__()        self.name = name        self._msg = &#39;&#39;    @property    def msg(self):        &#39;&#39;&#39;        当前状况        :return:        &#39;&#39;&#39;        return self._msg    @msg.setter    def msg(self, content):        self._msg = content        self.notify()class GCDViewer(object):    &#39;&#39;&#39;    共军被观察者    &#39;&#39;&#39;    # observer_subject就是观察者对象    def update(self, observer_subject):        print(&quot;共军:收到[%s]消息[%s] &quot; % (observer_subject.name, observer_subject.msg))class GMDViewer(object):    &#39;&#39;&#39;    国军被观察者    &#39;&#39;&#39;    def update(self, observer_subject):        print(&quot;国军:收到[%s]消息[%s] &quot; % (observer_subject.name, observer_subject.msg))if __name__ == &#39;__main__&#39;:    observer1 = Observer(&quot;共军放哨者&quot;)    observer2 = Observer(&quot;国军放哨者&quot;)    gongjun1 = GCDViewer()    guojun1 = GMDViewer()    observer1.attach(gongjun1)    observer1.attach(guojun1)    observer2.attach(guojun1)    observer1.msg = &quot;\033[32;1m敌人来了...\033[0m&quot;    observer2.msg = &quot;\033[31;1m前方发现敌人,请紧急撤离,不要告诉共军\033[0m&quot;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之责任链模式</title>
      <link href="/posts/2019-11-26-python-design-pattern-chain-of-responsibility.html"/>
      <url>/posts/2019-11-26-python-design-pattern-chain-of-responsibility.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p><strong>适用性：</strong> 1. 有多个的对象可以处理一个请求，哪个对象处理该请求运行时候自动确定。 2. 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3. 可处理一个请求的对象集合应被动态指定。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/44cac38e6b5f8b3f539690ad942da2e2-f531ed.jpg" alt="photo_2019-11-26_16-37-24"></p><pre><code class="python"># -*- coding: utf-8 -*-class BaseHandler(object):    &#39;&#39;&#39;处理基类&#39;&#39;&#39;    def successor(self, successor):        # 与下一个责任者关联        self._successor = successorclass RequestHandlerL1(BaseHandler):    &#39;&#39;&#39;第一次请求处理者&#39;&#39;&#39;    name = &#39;Teamleader&#39;    def handle(self, request):        if request &lt; 500:            print(&quot;审批者[%s],请求金额[%s],审批结果[审批通过]&quot; % (self.name, request))        else:            print(&quot;\033[31;1m[%s]无权审批,交给下一个审批者\033[0m&quot; % self.name)            self._successor.handle(request)class RequestHandlerL2(BaseHandler):    &#39;&#39;&#39;第二级请求处理者&#39;&#39;&#39;    name = &quot;DeptManager&quot;    def handle(self, request):        if request &lt; 5000:            print(&quot;审批者[%s],请求金额[%s],审批结果[审批通过]&quot; % (self.name, request))        else:            print(&quot;\033[31;1m[%s]无权审批,交给下一个审批者\033[0m&quot; % self.name)            self._successor.handle(request)class RequestHandlerL3(BaseHandler):    &#39;&#39;&#39;第三级请求处理者&#39;&#39;&#39;    name = &quot;CEO&quot;    def handle(self, request):        if request &lt; 10000:            print(&quot;审批者[%s],请求金额[%s],审批结果[审批通过]&quot; % (self.name, request))        else:            print(&quot;\033[31;1m[%s]要太多钱了,不批\033[0m&quot; % self.name)            # self._successor.handle(request)class RequestAPI(object):    h1 = RequestHandlerL1()    h2 = RequestHandlerL2()    h3 = RequestHandlerL3()    h1.successor(h2)    h2.successor(h3)    def __init__(self, name, amount):        self.name = name        self.amount = amount    def handle(self):        &#39;&#39;&#39;统一请求接口&#39;&#39;&#39;        self.h1.handle(self.amount)if __name__ == &quot;__main__&quot;:    r1 = RequestAPI(&quot;Alex&quot;, 30000)    r1.handle()    print(r1.__dict__)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之模板方法模式</title>
      <link href="/posts/2019-11-26-python-design-pattern-template-method.html"/>
      <url>/posts/2019-11-26-python-design-pattern-template-method.html</url>
      
        <content type="html"><![CDATA[<p>在模板方法模式（Template Method Pattern）中，一个抽象类公开定义了执行它的方法&#x2F;模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><p><strong>意图：</strong> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>主要解决：</strong> 一些方法通用，却在每一个子类都重新写了这个方法。</p><p><strong>何时使用：</strong> 有一些通用的方法。</p><p><strong>如何解决：</strong> 将这些通用的算法抽象出来。</p><p><strong>关键代码：</strong> 在抽象类实现，其他步骤在子类实现。</p><p><strong>应用实例：</strong> 冒泡排序中的排序算法是固定的，但是针对不同的数据类型有不同的排序规则，比如整数数列中的排序既有从小到大排序，也有从大到小排序的。</p><p><strong>优点：</strong> 1. 封装不变部分，扩展可变部分。 2. 提取公共代码，便于维护。 3. 行为由父类控制，子类实现。</p><p><strong>缺点：</strong> 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><strong>使用场景：</strong> 1. 有多个子类共有的方法，且逻辑相同。 2. 重要的、复杂的方法，可以考虑作为模板方法。</p><pre><code class="python"># -*- coding: utf-8 -*-# 模板方法模式概述#        在现实生活中，很多事情都包含几个实现步骤，例如请客吃饭，无论吃什么，一般都包含点单、吃东西、买单等几个步骤，通常情况下这几个步骤的次序是：点单 --&gt; 吃东西 --&gt; 买单。在这三个步骤中，点单和买单大同小异，最大的区别在于第二步——吃什么？吃面条和吃满汉全席可大不相同，如图1所示：## 图1 请客吃饭示意图#         在软件开发中，有时也会遇到类似的情况，某个方法的实现需要多个步骤（类似“请客”），其中有些步骤是固定的（类似“点单”和“买单”），而有些步骤并不固定，存在可变性（类似“吃东西”）。为了提高代码的复用性和系统的灵活性，可以使用一种称之为模板方法模式的设计模式来对这类情况进行设计，在模板方法模式中，将实现功能的每一个步骤所对应的方法称为基本方法（例如“点单”、“吃东西”和“买单”），而调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法（例如“请客”）。在模板方法模式中，可以将相同的代码放在父类中，例如将模板方法“请客”以及基本方法“点单”和“买单”的实现放在父类中，而对于基本方法“吃东西”，在父类中只做一个声明，将其具体实现放在不同的子类中，在一个子类中提供“吃面条”的实现，而另一个子类提供“吃满汉全席”的实现。通过使用模板方法模式，一方面提高了代码的复用性，另一方面还可以利用面向对象的多态性，在运行时选择一种具体子类，实现完整的“请客”方法，提高系统的灵活性和可扩展性。#        模板方法模式定义如下：# 模板方法模式：定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。## Template Method Pattern:  Define the skeleton of an algorithm in an  operation, deferring some steps to subclasses. Template Method lets  subclasses redefine certain steps of an algorithm without changing the  algorithm&#39;s structure.#        模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。#        模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。#class Register(object):    &#39;&#39;&#39;用户注册接口&#39;&#39;&#39;    def register(self):        pass    def login(self):        pass    def auth(self):        self.register()        self.login()class RegisterByQQ(Register):    &#39;&#39;&#39;qq注册&#39;&#39;&#39;    def register(self):        print(&quot;---用qq注册-----&quot;)    def login(self):        print(&#39;----用qq登录-----&#39;)class RegisterByWeiChat(Register):    &#39;&#39;&#39;微信注册&#39;&#39;&#39;    def register(self):        print(&quot;---用微信注册-----&quot;)    def login(self):        print(&#39;----用微信登录-----&#39;)if __name__ == &quot;__main__&quot;:    register1 = RegisterByQQ()    register1.auth()    register2 = RegisterByWeiChat()    register2.auth()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之代理模式</title>
      <link href="/posts/2019-11-26-python-design-pattern-proxy.html"/>
      <url>/posts/2019-11-26-python-design-pattern-proxy.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 为其他对象提供一种代理以控制对这个对象的访问。</p><p><strong>主要解决：</strong> 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要远程外的访问）直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问对象时加上一个对此对象的访问层。</p><p><strong>何时使用：</strong> 想在访问一个类时做一些控制。</p><p><strong>如何解决：</strong> 增加中间层。</p><p><strong>关键代码：</strong> 实现与被代理类组合。</p><p><strong>应用实例：</strong> 1. Windows 里面的快捷方式。 2. 买火车票不一定在火车站买，也可以去代售点。</p><p><strong>优点：</strong> 1. 职责清晰 2. 高扩展性 3. 智能化</p><p><strong>缺点：</strong> 1. 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2. 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p><p><strong>使用场景：</strong> 按职责来划分，通常有以下使用场景：1. 远程代理 2. 虚拟代理 3. Copy-on-Write 代理 4. 保护（Protect on Access）代理 5. Cache 代理 6. 防火墙（Firewall）代理 7. 同步化（Synchronization）代理 8. 智能引用（Smart Reference）代理</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/e01d086cfebb02a138d1d48b1fb7fc68-7300f3.jpg" alt="photo_2019-11-26_16-11-02"></p><pre><code class="python"># -*- coding: utf-8 -*-## 代理模式# 应用特性：需要在通信双方中间需要一些特殊的中间操作时引用，多加一个中间控制层。# 结构特性：建立一个中间类，创建一个对象，接收一个对象，然后把两者联通起来class sender_base:    def __init__(self):        pass    def send_something(self, something):        passclass send_class(sender_base):    def __init__(self, receiver):        self.receiver = receiver    def send_something(self, something):        print(&quot;SEND &quot; + something + &#39; TO &#39; + self.receiver.name)class agent_call(sender_base):    def __init__(self, receiver):        self.send_obj = send_class(receiver)    def send_something(self, something):        self.send_obj.send_something(something)class receive_class:    def __init__(self, someone):        self.name = someoneif __name__ == &quot;__main__&quot;:    receive = receive_class(&#39;wuxinzhe&#39;)    agent_send = agent_call(receive)    agent_send.send_something(&#39;test message...&#39;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之享元模式</title>
      <link href="/posts/2019-11-26-python-design-pattern-flyweight.html"/>
      <url>/posts/2019-11-26-python-design-pattern-flyweight.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 运用共享技术有效地支持大量细粒度的对象。</p><p><strong>适用性：</strong> 一个应用程序使用了大量的对象。完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖于对象标识。由于 Flyweight 对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。</p><pre><code class="python"># -*- coding: utf-8 -*-# Flyweight模式，顾名思义，就是共享元数据# 在我们面向对象设计过程中，我们常常会面临着对象实例过多的问题，如果对象实例过多这将是我们系统性能提高的一个瓶颈。# 假设我们要设计一个星空场景，现在我们需要实例星星对象，我们可以实例每一颗星星，但随着我们实例星星对象增多整个场景就越来越慢了，# 如果你实例了1000+颗星星要你去维护，这可是一个吃力不讨好的工作。我们必须找到一个合适的方法解决以上问题，这就是今天要介绍的享元模式（Flyweight）。# 享元模式（Flyweight）：运用共享的技术有效地支持大量细粒度的对象。## 抽象享元角色（Flyweight）：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口或抽象类。那些需要外部状态(External State)的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。## 具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定的接口。如果有内部状态的话，必须负责为内部状态提供存储空间。享元对象的内部状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。有时候具体享元角色又叫做单纯具体享元角色，因为复合享元角色是由单纯具体享元角色通过复合而成的。## 复合享元(UnsharableFlyweight)角色：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称做不可共享的享元对象。这个角色一般很少使用。## 享元工厂(FlyweightFactoiy)角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中是否已经有一个符合要求的享元对象，如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。## 客户端(Client)角色：本角色还需要自行存储所有享元对象的外部状态。## 内部状态与外部状态：在享元对象内部并且不会随着环境改变而改变的共享部分，可以称之为享元对象的内部状态，反之随着环境改变而改变的，不可共享的状态称之为外部状态。class FlyweightBase(object):    _instances = dict()    def __init__(self, *args, **kwargs):        # 继承的子类必须初始化        raise NotImplementedError    def __new__(cls, *args, **kwargs):        # print(cls._instances,type(cls))        return cls._instances.setdefault(            (cls, args, tuple(kwargs.items())),            super(FlyweightBase, cls).__new__(cls)        )    def test_data(self):        passclass Spam(FlyweightBase):    &#39;&#39;&#39;精子类&#39;&#39;&#39;    def __init__(self, a, b):        self.a = a        self.b = b    def test_data(self):        print(&quot;精子准备好了&quot;, self.a, self.b)class Egg(FlyweightBase):    &#39;&#39;&#39;卵类&#39;&#39;&#39;    def __init__(self, x, y):        self.x = x        self.y = y    def test_data(self):        print(&quot;卵子准备好了&quot;, self.x, self.y)spam1 = Spam(1, &#39;abc&#39;)spam2 = Spam(1, &#39;abc&#39;)spam3 = Spam(3, &#39;DEF&#39;)egg1 = Egg(1, &#39;abc&#39;)print(id(spam1), id(spam2), id(spam3))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之外观模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-facade.html"/>
      <url>/posts/2019-11-25-python-design-pattern-facade.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>适用性：</strong> 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade 可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过 Facade 层。</p><p>客户程序于抽象类的实现部分之间存在着很大的依赖性。引入 Facade 将这个子系统的客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。</p><p>当你需要构建一个层次结构的子系统时，使用 Facade 模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过 Facade 进行通讯，从而简化了它们之间的依赖关系。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/4ac62bcb8c902cbafd900fd8f9ef8eb3-72939c.jpg" alt="photo_2019-11-25_20-57-37"></p><pre><code class="python"># _*_coding:utf-8_*___author__ = &#39;Alex Li&#39;# 外观模式（Facade），为子系统中的一组接口提供一个一致的界面，定义一个高层接口，这个接口使得这一子系统更加容易使用。# 在以下情况下可以考虑使用外观模式：# (1)设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。# (2) 开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。# (3) 维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。# 优点编辑# （1）实现了子系统与客户端之间的松耦合关系。# （2）客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。def printInfo(info):    print(info)class Stock():    name = &#39;股票1&#39;    def buy(self):        printInfo(&#39;买 &#39; + self.name)    def sell(self):        printInfo(&#39;卖 &#39; + self.name)class ETF():    name = &#39;指数型基金&#39;    def buy(self):        printInfo(&#39;买 &#39; + self.name)    def sell(self):        printInfo(&#39;卖 &#39; + self.name)class Future():    name = &#39;期货&#39;    def buy(self):        printInfo(&#39;买 &#39; + self.name)    def sell(self):        printInfo(&#39;卖 &#39; + self.name)class NationDebt():    name = &#39;国债&#39;    def buy(self):        printInfo(&#39;买 &#39; + self.name)    def sell(self):        printInfo(&#39;卖 &#39; + self.name)class Option():    name = &#39;权证&#39;    def buy(self):        printInfo(&#39;买 &#39; + self.name)    def sell(self):        printInfo(&#39;卖 &#39; + self.name)# 基金class Fund():    def __init__(self):        self.stock = Stock()        self.etf = ETF()        self.future = Future()        self.debt = NationDebt()        self.option = Option()    def buyFund(self):        self.stock.buy()        self.etf.buy()        self.debt.buy()        self.future.buy()        self.option.buy()    def sellFund(self):        self.stock.sell()        self.etf.sell()        self.future.sell()        self.debt.sell()        self.option.sell()def clientUI():    myFund = Fund()    myFund.buyFund()    myFund.sellFund()    returnif __name__ == &#39;__main__&#39;:    clientUI()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之组合模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-composite.html"/>
      <url>/posts/2019-11-25-python-design-pattern-composite.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>适用性：</strong> 你想表示对象的部分-整体层次结构。你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/5cec3fb8709516b6c345597a43d0f1a3-f0ffa7.jpg" alt="photo_2019-11-25_20-30-39"></p><p>典型的 Composite 对象结构如下图表示：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/ec89ece10201974dcc7f86e9ff490789-348d07.jpg" alt="photo_2019-11-25_20-32-29"></p><pre><code class="python">&quot;&quot;&quot;应用组合模式的会员卡消费    那么我们就根据我们会员卡的消费，来模拟一下组合模式的实现吧。Let&#39;s go!    首先：        1. 我们的部件有，总店，分店，加盟店。        2. 我们的部件共有的行为是：刷会员卡        3. 部件之间的层次关系，也就是店面的层次关系是，总店下有分店、分店下可以拥有加盟店。有了我们这几个必要条件后，我的要求就是目前店面搞活动当我在总店刷卡后，就可以累积相当于在所有下级店面刷卡的积分总额，设计的代码如下：&quot;&quot;&quot;class Store(object):    &quot;&quot;&quot;店面基类&quot;&quot;&quot;    &quot;&quot;&quot;添加店面&quot;&quot;&quot;    def add(self, store):        pass    &quot;&quot;&quot;删除店面&quot;&quot;&quot;    def remove(self, store):        pass    &quot;&quot;&quot;消费&quot;&quot;&quot;    def pay_by_card(self):        passclass BranchStore(Store):    def __init__(self, name):        self.name = name        self.my_store_list = []    def pay_by_card(self):        print(&quot;店面[%s]的积分已累加进该会员卡&quot; % self.name)        for s in self.my_store_list:            s.pay_by_card()    # 添加店面    def add(self, store):        self.my_store_list.append(store)    # 删除店面    def remove(self, store):        self.my_store_list.remove(store)class JoinStore(Store):    def __init__(self, name):        self.name = name    def pay_by_card(self):        print(&quot;店面[%s]的积分已累加进该会员卡&quot; % self.name)    def add(self, store):        print(&quot;无添加子店权限&quot;)    def remove(self, store):        print(&quot;无删除子店权限&quot;)if __name__ == &#39;__main__&#39;:    store = BranchStore(&quot;朝阳总店&quot;)    branch = BranchStore(&quot;海滨分店&quot;)    store.add(branch)    store.pay_by_card()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之桥接模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-bridge.html"/>
      <url>/posts/2019-11-25-python-design-pattern-bridge.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 将抽象部分与实现部分分离，使它们都可以独立的变化。</p><p><strong>适用性：</strong> 在以下的情况下应当使用桥接模式</p><span id="more"></span><ol><li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在层次之间建立静态的联系。</li><li>设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。</li><li>一个构件有多于一个点抽象化角色和实现化角色，系统需要它们之间进行动态耦合。</li><li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li></ol><p>总结：桥接模式是一个非常有用的模式，也非常复杂，它很好的符合了开放-封闭原则和优先使用对象，而不是继承这两个面向对象原则。</p><p>生活中的一个例子：就拿汽车在路上行驶来说，既有小汽车又有公共汽车。它们都不但能在市区的公路上行驶，也能在高速公路上行驶。这你会发现，对于交通工具（汽车）有不同的类型，然而它们行驶的环境（路）也在变化，在软件系统中就要适应两个方面的变化。怎样实现才能应对这种变化呢？</p><p>在软件系统中，某些类型由于自身的逻辑，它具有两个或多个维度的变化。那么如何应对这种“多维度的变化”？如何利用面向对象的技术来使得该类型能够轻松的沿着多个方向进行变化，而又不引入额外的复杂度？这就要使用桥接模式。</p><p>效果及实现要点：</p><ol><li>桥接模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</li><li>所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意它们，从而获得不同路上的不同汽车。</li><li>桥接模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。桥接模式是比多继承方案更好的觉得方法。</li><li>桥接模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不强烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用桥接模式。</li></ol><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/3ab3a51c042dec23c9a804d1b2df9ad0-4613fb.png" alt="bridge"></p><pre><code class="python">class AbstractRoad(object):    &quot;&quot;&quot;公路基类&quot;&quot;&quot;    car = Noneclass AbstractCar(object):    &quot;&quot;&quot;车辆基类&quot;&quot;&quot;    def run(self):        passclass Street(AbstractRoad):    &quot;&quot;&quot;市区街道&quot;&quot;&quot;    def run(self):        self.car.run()        print(&quot;在市区街道上行驶&quot;)class SpeedWay(AbstractRoad):    &quot;&quot;&quot;高速公路&quot;&quot;&quot;    def run(self):        self.car.run()        print(&quot;在告诉公路上行驶&quot;)class Car(AbstractCar):    &quot;&quot;&quot;小汽车&quot;&quot;&quot;    def run(self):        print(&quot;小汽车在&quot;)class Bus(AbstractCar):    &quot;&quot;&quot;公共汽车&quot;&quot;&quot;    def run(self):        print(&quot;公共汽车在&quot;)if __name__ == &#39;__main__&#39;:    &#39;&#39;&#39;小汽车在高速公路上行驶&#39;&#39;&#39;    road1 = SpeedWay()    road1.car = Car()    road1.run()</code></pre><p>桥接模式来做多维度变化，结合上面的例子，增加一个维度“人”，不同的人开着不同的汽车在不同的路上行驶（三个维度）。</p><pre><code class="python">class AbstractPerson(object):    &quot;&quot;&quot;人基类&quot;&quot;&quot;    road = None    def drive(self):        passclass AbstractRoad(object):    &quot;&quot;&quot;公路基类&quot;&quot;&quot;    car = Noneclass AbstractCar(object):    &quot;&quot;&quot;车辆基类&quot;&quot;&quot;    def run(self):        passclass Man(AbstractPerson):    def drive(self):        print(&quot;男人开着&quot;)        self.road.run()class Woman(AbstractPerson):    def drive(self):        print(&quot;女人开着&quot;)        self.road.run()class Street(AbstractRoad):    &quot;&quot;&quot;市区街道&quot;&quot;&quot;    def run(self):        self.car.run()        print(&quot;在市区街道上行驶&quot;)class SpeedWay(AbstractRoad):    &quot;&quot;&quot;高速公路&quot;&quot;&quot;    def run(self):        self.car.run()        print(&quot;在告诉公路上行驶&quot;)class Car(AbstractCar):    &quot;&quot;&quot;小汽车&quot;&quot;&quot;    def run(self):        print(&quot;小汽车在&quot;)class Bus(AbstractCar):    &quot;&quot;&quot;公共汽车&quot;&quot;&quot;    def run(self):        print(&quot;公共汽车在&quot;)if __name__ == &#39;__main__&#39;:    &#39;&#39;&#39;小汽车在高速公路上行驶&#39;&#39;&#39;    p = Man()    p.road = SpeedWay()    p.road.car = Car()    p.drive()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之适配器模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-adapter.html"/>
      <url>/posts/2019-11-25-python-design-pattern-adapter.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>适用性：</strong> 1. 你想使用一个类已经存在的类，而它的接口不符合你的需求。 2. 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</p><p>现实中有很多适配器设计模式的例子，比如国内的电脑拿到欧洲那边是不能直接使用的，因为电脑的电源插口是不一样的，欧洲那边电源提供的电压是110V，这个时候就需要一个转接器就将110V电压转换成220V电压，这个时候就可以使用国内购买的电脑了。这个转接器用的就是适配器模式</p><pre><code class="c"># coding:utf-8def printInfo(info):    print(info)# 球员类class Player():    name = &#39;&#39;    def __init__(self, name):        self.name = name    def Attack(self):        pass    def Defense(self):        pass# 前锋class Forwards(Player):    def __init__(self, name):        Player.__init__(self, name)    def Attack(self):        printInfo(&quot;前锋%s 进攻&quot; % self.name)    def Defense(self):        printInfo(&quot;前锋%s 防守&quot; % self.name)# 中锋class Center(Player):    def __init__(self, name):        Player.__init__(self, name)    def Attack(self):        printInfo(&quot;中锋%s 进攻&quot; % self.name)    def Defense(self):        printInfo(&quot;中锋%s 防守&quot; % self.name)# 后卫class Guards(Player):    def __init__(self, name):        Player.__init__(self, name)    def Attack(self):        printInfo(&quot;后卫%s 进攻&quot; % self.name)    def Defense(self):        printInfo(&quot;后卫%s 防守&quot; % self.name)# 外籍中锋（待适配类）# 中锋class ForeignCenter(Player):    name = &#39;&#39;    def __init__(self, name):        Player.__init__(self, name)    def ForeignAcctack(self):        printInfo(&quot;外籍中锋%s 进攻&quot; % self.name)    def ForeignDefense(self):        printInfo(&quot;外籍中锋%s 防守&quot; % self.name)# 翻译（适配类）class Translator(Player):    foreign_center = None    def __init__(self, name):        self.foreign_center = ForeignCenter(name)    def Attack(self):        self.foreign_center.ForeignAcctack()    def Defense(self):        self.foreign_center.ForeignDefense()def clientUI():    b = Forwards(&quot;巴蒂尔&quot;)    ym = Guards(&quot;姚明&quot;)    m = Translator(&quot;麦克格雷迪&quot;)    b.Attack()    m.Defense()    ym.Attack()    ym.Defense()clientUI()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之原型模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-prototype.html"/>
      <url>/posts/2019-11-25-python-design-pattern-prototype.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 创建一些类的模型，比如说模版之类的东西。</p><p><strong>适用性：</strong> 当类里面要创建的结构具有一定结构，但是内容会有所不同的时候。比如：电子账单、SMS 短信、Email等。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/b4f4874bc6d542b5fd0718cfaffe7673-8fb481.png" alt="prototype"></p><pre><code class="python"># coding:utf-8class EventTemplate(object):    event_subject = &#39;&#39;    event_content = &#39;&#39;    def __init__(self, event_subject, event_content):        self.event_subject = event_subject        self.event_content = event_contentclass Mail(object):    receiver = &#39;&#39;    subject = &#39;&#39;    content = &#39;&#39;    tail = &#39;&#39;    def __init__(self, event_template: EventTemplate):        self.tail = event_template.event_content        self.subject = event_template.event_subjectdef send_mail(mail: Mail):    mail.content = &#39;%s,先生（女士）：你的信用卡账单...&#39; % mail.receiver    print(mail.receiver)    print(mail.subject)    print(mail.content)def main():    et = EventTemplate(&quot;9月份信用卡账单&quot;, &quot;国庆抽奖活动...&quot;)    mail = Mail(et)    mail.receiver = &#39;Del Cooper&#39;    send_mail(mail)if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之单例模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-singleton.html"/>
      <url>/posts/2019-11-25-python-design-pattern-singleton.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><p><strong>适用性：</strong> 1. 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 2. 当这个唯一实例应该通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</p><pre><code class="python"># coding:utf-8class Singleton(object):    def __new__(cls, *args, **kwargs):        if not hasattr(cls, &#39;_instance&#39;):            orig = super(Singleton, cls)            cls._instance = orig.__new__(cls)        return cls._instanceclass MyClass(Singleton):    def __init__(self, name):        self.name = namea = MyClass(&quot;Alex&quot;)b = MyClass(&quot;Jack&quot;)print(a.name)print(b.name)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之建造者模式</title>
      <link href="/posts/2019-11-25-python-design-pattern-builder.html"/>
      <url>/posts/2019-11-25-python-design-pattern-builder.html</url>
      
        <content type="html"><![CDATA[<p><strong>意图：</strong> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>适用性：</strong> 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</p><p>当构建过程必须允许被构造的对象有不同的表示时。</p><pre><code class="python"># coding:utf-8# 建造者基类class PersonBuilder(object):    def BuildHead(self):        pass    def BuildBody(self):        pass    def BuildArm(self):        pass    def BuildLeg(self):        pass# 胖子class PersonFatBuilder(PersonBuilder):    type = &#39;胖子&#39;    def BuildHead(self):        print(&#39;构建%s的头&#39; % self.type)    def BuildBody(self):        print(&#39;构建%s的身体&#39; % self.type)    def BuildArm(self):        print(&#39;构建%s的胳膊&#39; % self.type)    def BuildLeg(self):        print(&#39;构建%s的脚&#39; % self.type)# 瘦子class PersonThinBuilder(PersonBuilder):    type = &#39;瘦子&#39;    def BuildHead(self):        print(&#39;构建%s的头&#39; % self.type)    def BuildBody(self):        print(&#39;构建%s的身体&#39; % self.type)    def BuildArm(self):        print(&#39;构建%s的胳膊&#39; % self.type)    def BuildLeg(self):        print(&#39;构建%s的脚&#39; % self.type)# 指挥者class PersonDirector(object):    pb: PersonBuilder = None    def __init__(self, pb):        self.pb = pb    def CreatePerson(self):        self.pb.BuildHead()        self.pb.BuildBody()        self.pb.BuildArm()        self.pb.BuildLeg()def clientUI():    pb = PersonThinBuilder()    pd = PersonDirector(pb)    pd.CreatePerson()    pb = PersonFatBuilder()    pd = PersonDirector(pb)    pd.CreatePerson()    return</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之抽象工厂模式</title>
      <link href="/posts/2019-11-24-python-design-pattern-abstract-factory.html"/>
      <url>/posts/2019-11-24-python-design-pattern-abstract-factory.html</url>
      
        <content type="html"><![CDATA[<p>每一个<a href="/posts/2019-11-24-python-design-pattern.html">设计模式</a>都是针对一定问题的解决方案。抽象工厂模式与<a href="/posts/2019-11-24-python-design-pattern-factory-method.html">工厂方法模式</a>的最大区别在于：工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</p><p>在学习抽象工厂具体实例之前，应该明白两个重要的概念：<strong>产品族</strong>和<strong>产品等级</strong>。</p><p>所谓<strong>产品族</strong>是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如 AMD 的主板、芯片组、CPU组成一个家族。Intel 的主板、芯片组、CPU 组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成。示意图如下：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/28c2e98c1a659f41ecf4ee14badff5a8-b27476.jpg" alt="photo_2019-11-24_20-45-12"></p><p>显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。</p><p>上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/67f284db9ac02ffbefb79e2758c469a5-385a18.jpg" alt="photo_2019-11-24_20-45-15"></p><p>那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/9a5b0abb6467a2721f705b636cedde0d-629667.jpg" alt="photo_2019-11-24_20-48-51"></p><p>可以看出，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。显然，这时候抽象工厂模式比简单工厂模式、工厂方法模式更有效率。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。</p><p>抽象工厂模式是对象的创建模式，它是<a href="/posts/2019-11-24-python-design-pattern-factory-method.html">工厂方法模式</a>的进一步推广。</p><p>假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。</p><p>通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。如下图所示：</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/b58a5b81d9f05b3e5ba066c78ff6e17a-be87fb.jpg" alt="photo_2019-11-24_20-55-55"></p><p>由于这两个产品族的等级结构相同，因此使用同一个工厂族也可以处理两个产品族的创建问题，这就是抽象工厂模式。</p><p>根据产品角色的结构图，就不难给出工厂角色的结构设计图。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/2a833501cbc8c92ca56075a0d4bebf24-0653fc.jpg" alt="photo_2019-11-24_20-57-47"></p><p>可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属于不同产品等级结构的产品对象。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/ccb04bfcbe2bbf4b6048fc016175f475-c659ff.jpg" alt="photo_2019-11-24_21-00-03"></p><p>抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和 CPU ，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/244df69053b24c964f05bcb2647b3ca9-46eade.jpg" alt="photo_2019-11-24_21-03-52"></p><p>由于抽象工厂定义的一系列对象通常是相关的相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。</p><p>这就带来非常大的灵活性，切换产品族的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以一个产品族作为一个整体被切换。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/910ba6ac7f013ebd00c411e4587424ff-6476c2.jpg" alt="photo_2019-11-24_21-07-09"></p><p><strong>在什么情况下应当使用抽象工厂模式</strong></p><ol><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。</li><li>这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</li><li>同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel 主板必须使用 Intel CPU、Intel 芯片组）</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li></ol><p><strong>抽象工厂模式的起源</strong></p><p>抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如：命令按键（Button）与文字框（Text）都是视窗构建。在 UNIX 操作系统的视窗环境和 Windows 操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。</p><p>在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是 Button 和 Text 组成的产品族。而每一个视窗构建都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。</p><p><strong>抽象工厂模式的优点</strong></p><ul><li><p>分离接口和实现</p><p>  客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，也就是说，客户端从具体的产品实现中解耦。</p></li><li><p>使切换产品族变得容易</p><p>  因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从 Intel 系列到 AMD 系列只需要切换一下具体工厂。</p></li></ul><p><strong>抽象工厂模式的缺点</strong></p><ul><li><p>不太容易扩展新的产品</p><p>  如果需要给整个产品族添加一个新的产品，那么 就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。</p></li></ul><pre><code class="python">class AbstractCPU(object):    series_name = &#39;&#39;class AbstractFactory(object):    computer_name = &quot;&quot;    def createCPU(self):        raise NotImplementedError    def createMainBoard(self):        raise NotImplementedErrorclass AbstractMainBoard(object):    series_name = &#39;&#39;class AMDCPU(AbstractCPU):    def __init__(self, series):        self.series_name = seriesclass AMDMainBoard(AbstractMainBoard):    def __init__(self, series):        self.series_name = seriesclass AMDFactory(AbstractFactory):    computer_name = &#39;AMD 4 computer&#39;    def createCPU(self):        return AMDCPU(&#39;amd444&#39;)    def createMainBoard(self):        return AMDMainBoard(&#39;amd400&#39;)class IntelCPU(AbstractCPU):    def __init__(self, series):        self.series_name = seriesclass IntelMainBoard(AbstractMainBoard):    def __int__(self):        pass    def __init__(self, series):        self.series_name = seriesclass IntelFactory(AbstractFactory):    computer_name = &#39;Intel I7-series computer&#39;    def createCPU(self):        return IntelCPU(&#39;I7-6500&#39;)    def createMainBoard(self):        return IntelMainBoard(&#39;Intel-6000&#39;)class ComputerEngineer(object):    def makeComputer(self, factory_obj):        self.prepareHardwares(factory_obj)    def prepareHardwares(self, factory_obj):        self.cpu = factory_obj.createCPU()        self.mainboard = factory_obj.createMainBoard()        info = &quot;&quot;&quot;-------------- computer %s info:\ncpu: %s\nmainboard: %s&quot;&quot;&quot; % (            factory_obj.computer_name, self.cpu.series_name, self.mainboard.series_name        )        print(info)if __name__ == &#39;__main__&#39;:    engineer = ComputerEngineer()    intel_factory = IntelFactory()    engineer.makeComputer(intel_factory)    amd_factory = AMDFactory()    engineer.makeComputer(amd_factory)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之工厂方法模式</title>
      <link href="/posts/2019-11-24-python-design-pattern-factory-method.html"/>
      <url>/posts/2019-11-24-python-design-pattern-factory-method.html</url>
      
        <content type="html"><![CDATA[<p>工厂方法模式和<a href="/posts/2019-11-24-python-design-pattern-simple-factory.html">简单工厂模式</a>的区别在于，简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂。</p><p>工厂方法模式是简单工厂模式的衍生，解决了很多简单工厂模式的问题。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/2e01a3e3883dbb62027c6df58316f2e4-80f693.png" alt="factory-method"></p><p>首先完全实现“开-闭”原则，实现了可扩展。其次更复杂的层次结构，可以应用于产品结果复杂的场合。</p><p>工厂方法模式对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不再负责具体的产品生产，而是只制定一些规范，具体的生产工作由子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，这个具体的工厂就负责生产对应的产品。</p><p>工厂方法模式（Factory Method Pattern）是最典型的模板方法模式（Template Method Pattern）应用</p><p><strong>优点：</strong> 增加一个运算类（例如N次方类），只需要增加运算类和相对应的工厂，两个类，不需要修改工厂类。</p><p><strong>缺点：</strong> 增加运算类，会修改客户端代码，工厂方法只是把简单工厂的内部逻辑判断移到了客户端进行。</p><pre><code class="python"># coding:utf-8class AbstractSchool(object):    name = &#39;&#39;    addr = &#39;&#39;    principal = &#39;&#39;    def enroll(self, name, course):        raise NotImplementedError    def info(self):        raise NotImplementedErrorclass AbstractCourse(object):    def __init__(self, name, time_range, study_type, fee):        self.name = name        self.time_range = time_range        self.study_type = study_type        self.fee = fee    def enroll_test(self):        &quot;&quot;&quot;        参加这门课程前需要进行的测试        :return        &quot;&quot;&quot;        print(&quot;课程[%s]测试中...&quot; % self.name)    def print_course_outline(self):        &quot;&quot;&quot;        打印课程大纲        :return:        &quot;&quot;&quot;        passclass LinuxOPSCourse(AbstractCourse):    &quot;&quot;&quot;Linux运维课程&quot;&quot;&quot;    def print_course_outline(self):        outline = &quot;&quot;&quot;        Linux 基础        Linux 基本服务使用        Linux 高级服务篇        Linux Shell 编程        &quot;&quot;&quot;        print(outline)    def enroll_test(self):        print(&quot;不用测试，是个人就能学...&quot;)class PythonCourse(AbstractCourse):    &quot;&quot;&quot;Python 自动化开发课程&quot;&quot;&quot;    def print_course_outline(self):        outline = &quot;&quot;&quot;        Python 介绍        Python 基础语法        Python 函数式编程        Python 面向对象        Python 网络编程        Python Web 开发基础        &quot;&quot;&quot;        print(outline)    def enroll_test(self):        print(&quot;------ Python 入学测试 ------&quot;)        print(&quot;------ 500 道题答完了 ------&quot;)        print(&quot;------ 通过了 ------&quot;)class BJSchool(AbstractSchool):    name = &quot;老男孩北京校区&quot;    def create_course(self, course_type):        if course_type == &#39;py_ops&#39;:            course = PythonCourse(&quot;Python 自动化开发&quot;, 7, &quot;面授&quot;, 11000)        elif course_type == &#39;linux&#39;:            course = LinuxOPSCourse(&quot;Linux 运维课程&quot;, 5, &quot;面授&quot;, 12800)        return course    def enroll(self, name, course):        print(&quot;开始为新学员[%s]办入学手续...&quot; % name)        print(&quot;帮学员[%s]注册课程[%s]...&quot; % (name, course.name))        course.enroll_test()    def info(self):        print(&quot;------ [%s] ------&quot; % self.name)class SHSchool(AbstractSchool):    name = &quot;老男孩上海分校&quot;    def create_course(self, course_type):        if course_type == &#39;py_ops&#39;:            course = PythonCourse(&quot;Python 自动化开发&quot;, 8, &#39;在线&#39;, 6500)        elif course_type == &#39;linux&#39;:            course = LinuxOPSCourse(&#39;Linux 运维课程&#39;, 6, &#39;在线&#39;, 8000)        return course    def enroll(self, name, course):        print(&quot;开始为新学员[%s]办入学手续...&quot; % name)        print(&quot;帮学员[%s]注册课程[%s]...&quot; % (name, course.name))        course.enroll_test()    def info(self):        print(&quot;------ [%s] ------&quot; % self.name)school1 = BJSchool()school2 = SHSchool()school1.info()c1 = school1.create_course(&#39;py_ops&#39;)school1.enroll(&#39;张三&#39;, c1)school1.enroll(&#39;王五&#39;, c1)school2.info()c2 = school2.create_course(&#39;py_ops&#39;)school2.enroll(&#39;李四&#39;, c2)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之简单工厂模式</title>
      <link href="/posts/2019-11-24-python-design-pattern-simple-factory.html"/>
      <url>/posts/2019-11-24-python-design-pattern-simple-factory.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/e952c336459baf1d499e1cd2ce854e02-f7c2d0.png" alt="simple-factory"></p><p>&nbsp;</p><pre><code class="python"># coding:utf-8class Shape(object):    def draw(self):        raise NotImplementedErrorclass Circle(Shape):    def draw(self):        print(&quot;draw circle&quot;)class Square(Shape):    def draw(self):        print(&quot;draw square&quot;)class Rectangle(Shape):    def draw(self):        print(&#39;draw rectangle&#39;)class ShapeFactory(object):    def getShape(self, shape):        if shape == &#39;Circle&#39;:            return Circle()        elif shape == &#39;Rectangle&#39;:            return Rectangle()        else:            return Nonefac = ShapeFactory()obj = fac.getShape(&#39;Circle&#39;)obj.draw()</code></pre><p><strong>优点：</strong> 客户端使用统一的代码进行创建不同类的实例。</p><p><strong>缺点：</strong> 当需要增加新的运算类的时候，不仅需新加运算类，还要修改工厂类，违反了开闭原则。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式之工厂模式</title>
      <link href="/posts/2019-11-24-python-design-pattern-factory-pattern.html"/>
      <url>/posts/2019-11-24-python-design-pattern-factory-pattern.html</url>
      
        <content type="html"><![CDATA[<p>工厂模式（Factory Pattern）是最常用的<a href="/posts/2019-11-24-python-design-pattern.html">设计模式</a>之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p><strong>意图：</strong> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p><p><strong>适用性：</strong> 1. 当一个类不知道它所必须创建的对象的类的时候。 2. 当一个类希望由它的子类来指定它所创建的对象的时候。 3. 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</p><ul><li><a href="/posts/2019-11-24-python-design-pattern-simple-factory.html">简单工厂模式</a>（Simple Factory）</li><li><a href="/posts/2019-11-24-python-design-pattern-factory-method.html">工厂方法模式</a>（Factory Method）</li><li><a href="/posts/2019-11-24-python-design-pattern-abstract-factory.html">抽象工厂模式</a>（Abstract Factory）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 设计模式</title>
      <link href="/posts/2019-11-24-python-design-pattern.html"/>
      <url>/posts/2019-11-24-python-design-pattern.html</url>
      
        <content type="html"><![CDATA[<p>设计模式有助于我们借鉴其他人成功的经验，而不是靠自己摸爬滚打。—— Mark Johnson</p><span id="more"></span><ol><li><p><strong>设计模式介绍</strong></p><blockquote><p>设计模式（Design Pattern） —— 可复用面向对象软件的基础</p></blockquote><p> 设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p></li><li><p><strong>设计模式分类</strong></p><p> 经典的《设计模式》一书归纳出23种设计模式，这23种设计模式被归类为三大类：创建型、结构型、行为型。</p><ul><li><p>创建型模式</p><p>  社会化的分工越来越细，在软件设计方面自然也是如此，因此对象的创建和使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能高效低创建对象就是创建型模式要讨论的问题。如下6种具体的创建型模式来进行研究：</p><ul><li><a href="/posts/2019-11-24-python-design-pattern-factory-pattern.html">工厂模式</a><ul><li><a href="/posts/2019-11-24-python-design-pattern-simple-factory.html">简单工厂模式</a>（Simple Factory）</li><li><a href="/posts/2019-11-24-python-design-pattern-factory-method.html">工厂方法模式</a>（Factory Method）</li><li><a href="/posts/2019-11-24-python-design-pattern-abstract-factory.html">抽象工厂模式</a>（Abstract Factory）</li></ul></li><li><a href="/posts/2019-11-25-python-design-pattern-builder.html">创建者模式</a>（Builder）</li><li><a href="/posts/2019-11-25-python-design-pattern-prototype.html">原型模式</a>（Prototype）</li><li><a href="/posts/2019-11-25-python-design-pattern-singleton.html">单例模式</a>（Singleton）</li></ul><p>  <strong>注：</strong> 严格来说，简单工厂模式不是GoF总结出来的23中设计模式之一。</p></li><li><p>结构型模式</p><p>  在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究：</p><ul><li><a href="/posts/2019-11-25-python-design-pattern-facade.html">外观模式</a>（Facade）</li><li><a href="/posts/2019-11-25-python-design-pattern-adapter.html">适配器模式</a>（Adapter）</li><li><a href="/posts/2019-11-26-python-design-pattern-proxy.html">代理模式</a>（Proxy）</li><li>装饰模式（Decorator）</li><li><a href="/posts/2019-11-25-python-design-pattern-bridge.html">桥接模式</a>（Bridge）</li><li><a href="/posts/2019-11-25-python-design-pattern-composite.html">组合模式</a>（Composite）</li><li><a href="/posts/2019-11-26-python-design-pattern-flyweight.html">享元模式</a>（Flyweight）</li></ul></li><li><p>行为型模式</p><p>  在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计得好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11种具体的行为型模式可供研究：</p><ul><li><a href="/posts/2019-11-26-python-design-pattern-template-method.html">模板方法模式</a>（Template Method）</li><li><a href="/posts/2019-11-26-python-design-pattern-observer.html">观察者模式</a>（Observer）</li><li>状态模式（State）</li><li><a href="/posts/2019-11-26-python-design-pattern-strategy.html">策略模式</a>（Strategy）</li><li><a href="/posts/2019-11-26-python-design-pattern-chain-of-responsibility.html">职责链模式</a>（Chain of Responsibility）</li><li>命令模式（Command）</li><li>访问者模式（Visitor）</li><li>调停者模式（Mediator）</li><li>备忘录模式（Memento）</li><li>迭代器模式（Iterator）</li><li>解释器模式（Interpreter）</li></ul></li></ul></li><li><p><strong>设计模式六大原则</strong></p><ul><li><p>开闭原则（Open Close Principle）</p><p>  开闭原则就是说 <strong>对扩展开放，对修改关闭</strong> 。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p></li><li><p>里氏代换原则（Liskov Substitution Principle）</p><p>  里氏代换原则（Liskov Substitution Principle，LSP）面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></li><li><p>依赖倒转原则（Dependence Inversion Principle）</p><p>  依赖倒转原则是开闭原则的基础，具体内容：只对接口编程，依赖于抽象而不依赖于具体。</p></li><li><p>接口隔离原则（Interface Segregation Principle）</p><p>  接口隔离原则的意思是：使用多个隔离的接口，比使用单个接口更好。还是一个降低类之间的耦合度的意思，从而我们可以看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p></li><li><p>迪米特法则（最少知道原则）（DemeterP Principle）</p><p>  最少知道原则就是说：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p>合成复用原则（Composite Reuse Principle）</p><p>  原则是尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 3 Universal License Keys for Windows, macOS &amp; Linux</title>
      <link href="/posts/2019-11-19-sublime-text-3-universal-license-keys-for-windows-mac-linux.html"/>
      <url>/posts/2019-11-19-sublime-text-3-universal-license-keys-for-windows-mac-linux.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><h3 id="0x00-Sublime-Text-2-3-License-Keys"><a href="#0x00-Sublime-Text-2-3-License-Keys" class="headerlink" title="0x00 Sublime Text 2&#x2F;3 License Keys"></a>0x00 Sublime Text 2&#x2F;3 License Keys</h3><ol><li><p><strong>Sublime Text 2.x (for all Builds)</strong></p><pre><code>—– BEGIN LICENSE —–Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (before Build 309X)</strong></p><pre><code>—– BEGIN LICENSE —–Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–K-20Single User LicenseEA7E-9401293A099EC1 C0B5C7C5 33EBF0CF BE82FE3BEAC2164A 4F8EC954 4E87F1E5 7E4E85D6C5605DE6 DAB003B4 D60CA4D0 77CB15333C47F579 FB3E8476 EB3AA9A7 68C43CD98C60B563 80FE367D 8CAD14B3 54FB7A9F4123FFC4 D63312BA 141AF702 F6BBA254B094B9C0 FAA4B04C 06CC9AFC FD41267182E3AEE0 0F0FAAA7 8FA773C9 383A9E18—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–J2TeaM2 User LicenseEA7E-94028245CB0D8F 09100037 7D1056EB A1DDC1A239C102C5 DF8D0BF0 FC3B1A94 4F2892B40AEE61BA 65758D3B 2EED551F A3E3478CC1C0E04E CA4E4541 1FC1A2C1 3F5FB6DBCFDA1551 51B05B5D 2D3C8CFE FA8B4285051750E3 22D1422A 7AE3A8A1 3B4188AC346372DA 37AA8ABA 6EB30E41 781BC81FB5CA66E3 A09DBD3A 3FE85BBD 69893DBD—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (after Build 309X)</strong></p><pre><code>—– BEGIN LICENSE —–MinBanSingle User LicenseEA7E-806395318133A3 8F202A61 B0DBB8EB 21E17D2E97D540E6 34079344 54620650 71E475899EF87857 345F5042 0D728DD1 8D8C979D6A4F4DD2 67BB0345 746CA297 515BDA916CEAB381 4DB56700 D77DCD14 977BD3261AC309ED 0EB414B8 4730DA10 99DBD291FC88E0EF DCC7E3A9 56E4FFED 7629746BE529AECA 92A96B60 72AE8928 8A240AAC—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Free Communities Consultoria em Informática LtdaSingle User LicenseEA7E-801302C154C122 4EFA4415 F1AAEBCC 315F3A7D2580735A 7955AA57 850ABD88 72A1DDD88D2CE060 CF980C29 890D74F2 53131895281E324E 98EA1FEF 7FF69A12 17CA7784490862AF 833E133D FD22141D D8C89B944C10A4D2 24693D70 AE37C18F 72EF0BE51ED60704 651BC71F 16CA1B77 496A0B19463EDFF9 6BEB1861 CA5BAD96 89D0118E—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Nicolas HennionSingle User LicenseEA7E-8660758A01AA83 1D668D24 4484AEBC 3B04512C827B0DE5 69E9B07A A39ACCC0 F95F5410729D5639 4C37CECB B2522FB3 8D37FDC172899363 BBA441AC A5F47F08 6CD3B3FECEFB3783 B2E1BA96 71AAF7B4 AFB61B1D0CC513E7 52FF2333 9F726D2C CDE53B4A810C0D4F E1F419A3 CDA0832B 8440565A35BF00F6 4CA9F869 ED10E245 469C233E—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Anthony SansoneSingle User LicenseEA7E-87856328B9A648 42B99D8A F2E3E9E0 16DE076EE218B3DC F3606379 C33C1526 E8B58964B2CB3F63 BDF901BE D31424D2 082891B5F7058694 55FA46D8 EFC11878 0868F093B17CAFE7 63A78881 86B78E38 0F146238BAE22DBB D4EC71A1 0EC2E701 C7F9C6485CF29CA3 1CB14285 19A46991 E9A9867614FD4777 2D8A0AB6 A444EE0D CA009B54—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Peter HallidaySingle User LicenseEA7E-8559883997BFF0 2856413A 7A555954 67069B7806D8CE12 63EAF079 AD039757 79E16D13C555AD90 465CBE53 10F6DFC4 D3A3C611411106F8 0CFEB15F 0A7BB891 111F5ED2C6AA8429 77913528 FA6291A9 B88D4550F1D6AB13 BF9153BC 91B4DFFE D296CFE0C1D8EB22 13D5F14E 75A699EC 49EDDC23D89D0F9B D240B10A A3712467 09DE7870—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Fred ZirdungSingle User LicenseEA7E-8446726089C0EC 22936E1A 1EADEBE2 B8654BBA5C98FFA6 C0FD1599 0364779B 071C74FBEEFE9EAB 92B3D867 CD1B32FE D190269F6FC08F8F 8D24191D 32828465 942CE58EAECE5307 08B62229 D788560A 6E0AAC4B48A2D9EE 24FD8CAA 07BEBDF2 28EA86D4CCB96084 6C34CAD2 E8A04F39 3B5A3CBC3B668BB7 C94D0B4B 847D6D7F 4BC07375—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–WixelSingle User LicenseEA7E-848235103D2969 8700C7ED 8173CF61 537000C0EB3C7ECB 5E750F17 6B42B67C A190090B7669164F C6F371A8 5A1D88D5 BDD0DA70C065892B 7CC1BB2B 1C8B8C7C F08E77897C2A5241 35F86328 4C8F70D9 C023D7C211245C36 59A730DB 72BDB9A7 D5B2030490E90E72 9F08CA25 73F49C20 179D938E5BC8BEDA 13457A69 39E6265F 233767F9—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Daniel RusselSingle User LicenseEA7E-9174209327EC62 44020C2A 45172A68 12FE13F11D22245B 680892EE F551F8EB C183D0328B4EDB4B 479CB7E4 07E42EDD A780021D56BADF42 AC05238B 023B47B1 EBA1B7DE6DF9A383 159F32AE 04EBE100 1278B1D252E81B60 C68AA2E8 F84A20BE FE7990EB5D44E4B6 16369263 1DDAACBC 280FF19E86CF4319 0B8615A8 4FF0512E B123B8EC—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Peter ErikssonSingle User LicenseEA7E-8900688E107C71 3100D6FC 2AC805BF 9E627C7772E710D7 43392469 D06A2F5B F9304FBDF5AB4DB2 7A95F172 FE68E300 42745819E94AB2DF C1893094 ECABADC8 71FEE76420224821 3EABF931 745AF882 87AD0A4B33C6E377 0210D712 CD2B1178 82601542C7FD8098 F45D2824 BC7DFB38 F1EBD38AD7A3AFE0 96F938EA 2D90BD72 9E34CDF0—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Ryan ClarkSingle User LicenseEA7E-8124792158A7DE B690A7A3 8EC04710 006A5EEB34E77CA3 9C82C81F 0DB6371B 79704E6F93F36655 B031503A 03257CCC 01B20F60D304FA8D B1B4F0AF 8A76C7BA 0FA94D5556D46BCE 5237A341 CD837F30 4D60772D349B1179 A996F826 90CDB73C 24D41245FD032C30 AD5E7241 4EAA66ED 167D91FB55896B16 EA125C81 F550AF6B A6820916—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (after Build 312X)</strong></p><pre><code>—– BEGIN LICENSE —–rikuSingle User LicenseEA7E-80699660C55C64D0195F15A118D93ECE0849B330C432F529F7BFAAF6568C6BFDDA1868D6DF14D0464281D64A7E2EBB32558D84148EF8041694AC00B9FA17D6119A6286611D11E26BB48DCF19F76CB1CC7B995EF41F7BFAB3348963FF69F163A70ABBEA2526B73B523AA28BF66AFEF3ED3D1D21BC6CB3B5B6D183FF5C755DE7007C6C41—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (after Build 3133)</strong></p><pre><code>—– BEGIN LICENSE —–TwitterInc200 User LicenseEA7E-8900071D77F72E 390CDD93 4DCBA022 FAF6079061AA12C0 A37081C5 D0316412 4584D13694D7F7D4 95BC8C1C 527DA828 560BB037D1EDDD8C AE7B379F 50C9D69D B35179EF2FE898C4 8E4277A8 555CE714 E1FB0E43D5D52613 C3D12E98 BC49967F 7652EED29D2D2E61 67610860 6D338B72 5CF95C69E36B85CC 84991F19 7575D828 470A92AB—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Morin2 User LicenseEA7E-924018184B9FDB 02612F57 33B15E69 BBC567F1E20FA231 C077EA95 CC14B48B 71DD2536E209843A 94D13692 03AC2FAA 895B688DB8F4A0E6 FDC15964 A5573FD7 6405ED1E6F205469 7F34C69D 3D36E475 52AF6A5BDFD15C31 85BA64EF F95DD592 4B42C314AC655762 C0F0F5A1 018824E4 17C56E16AC5AA84C 034F7A53 2C9A801B 8AED239F—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–andressSingle User LicenseEA7E-902575327DCA5B BAED1100 D98FA249 DE22F0A6E3A33C17 AC0C324A 02D3EC57 84D3B4F6A3D3E82B A2F05F50 DBB82C50 0F77A73DBBE81A0C 728A89B8 B33CCA63 6804F0216F477517 A3D373EC 96690CC0 4B2434E7B2DAC831 22649D93 3F3B5D25 0E2A7E50F9F41A45 B2BF3B44 153617C8 5B5E500B82508EE0 9E97CDC3 F6C83C24 258305C2—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Derek SoulliereSingle User LicenseEA7E-8560773C13F2BF 5E94DFA1 8E4165F5 884B277B4E2B5951 5DE2F817 AAEB799B E827826A48823165 0E89DCBE 2B4FBB67 BD5366C08244BBB1 C380940E DE22C72C 37FA291E194B0FC6 08EE8819 2E292D2F C8EB4D87F9B8723F CE453398 26EE127C 6014817F8DD00C4B F8912D8E E57DF893 5B158F9E65B0F81B C2813C12 7247A597 1C7A2BD5—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (after Build 3155)</strong></p><pre><code>—– BEGIN LICENSE —–eldonSingle User LicenseEA7E-1122628C0360740 20724B8A 30420C09 6D7E046F3F5D5FBB 17EF95DA 2BA7BB27 CCB1494727A316BE 8BCF4BC0 252FB8FF FD97DF71B11A1DA9 F7119CA0 31984BB9 7D71700C2C728BF8 B952E5F5 B941FF64 6D7979DAB8EB32F8 8D415F8E F16FE657 A35381CC290E2905 96E81236 63D2B06D E5F01A6984174B79 7C467714 641A9013 94CA7162—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Bug7sec Team (www.bug7sec.org)50 User LicenseEA7E-106883286C49532 8F829C68 2ED18D56 162664F28B934F0C EB60A7FE 81D7D5EF BB8F1673F67D69C7 C5E21B19 42E7EFBD D9C2BBC1CEBA4697 535E29CA 0D2D0D4D ACE548CE07815DC7 BDE3901E D5D198E4 BC1677C046097A55 29BCE0C9 72A358E8 CEFEEFB524CEB623 D7232749 F2515349 FB675F93C55635A7 B1E32AB0 3D055979 041E0359—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Esri, Inc19 User LicenseEA7E-853424BBB0D927 00F6E4AB 0AFFEFEA 82C4A3E54F9A99D1 7C0475AB 5A708861 6C81D74E4BBA1F56 877CE0E2 88126328 486D86008A0A85D7 49671882 49969D92 312F27A75CCAE55B D711D4E2 9069DE55 B510370C9499567E 61D548BA FB260403 711DFE241BAFDA6D 1F52E6B1 B728EF5B A40CCD4DFD716AF5 1760D208 0E05F26E 22660950—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Dylan TittelSingle User LicenseEA7E-898127CD1A23C0 E8687245 18A89BFA 7CF52C10A20AA536 9E1A57C7 D33839DC 6613C42891E9C7FF F4702893 251C6403 27A108186F48AC9C BB66843D C1D60DEA B952C2D040019115 E5278B04 95EBB709 D6B1C5B967CA940A 88701851 32910570 57AD5B96263A8906 AFBFAB46 52F6706F CACFC74EDFAD4752 D10E58B6 744B90F2 13AF2B9C—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Country RebelSingle User LicenseEA7E-99309519176BCE 3FF86EA0 3CE86508 6BE4DCA79F74D761 4D0CAD8B E4033008 43FC73F31C01F6DD C4829BE9 E7830578 A4823ADC61B224F1 DC93C458 ABAAAE0F 925C32D404A83C36 813FF6C8 9877942C 4418F99C2F15E5B8 544EDB80 D9A86985 4CBBA6A8998DE3E4 7FB33E15 6CD30357 6DC96CEAECB1BC4E D8010D5A 77BA86C8 BA7F76CC—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (after Build 3163)</strong></p><pre><code>—– BEGIN LICENSE —–sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B—— END LICENSE ——</code></pre></li><li><p><strong>Sublime Text 3.x (after Build 32XX)</strong></p><pre><code>—– BEGIN LICENSE —–Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864—— END LICENSE ——​</code></pre></li><li><p><strong>Sublime Text 2.x (Still valid for all v3 beta versions)</strong></p><pre><code>— BEGIN LICENSE —–ZYNGA INC.50 User LicenseEA7E-811825927BA117 84C9300F 4A0CCBC4 34A56B44985E4562 59F2B63B CCCFF92F 0E646B830FD6487D 1507AE29 9CC4F9F5 0A6F32E30343D868 C18E2CD5 27641A71 25475648309705B3 E468DDC4 1B766A18 7952D28CE627DDBA 960A2153 69A2D98A C87C060745DC6049 8C04EC29 D18DFA40 442C680B1342224D 44D90641 33A3B9F2 46AADB8F—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Molex, Inc.Single User LicenseEA7E-818977AE248E13 C08A1CDF 2D6751EF 3224300353F5EF8A 1522F537 6A09E721 030DC36CC477DA16 2BD1681C 0164D104 BB58D77F1C221EE9 3296957E 5784C10F 51AA00206F2E553C D8147ADF 7A5B7A4C F843F2A62489CCA4 05759326 1D16227F 4813084D61821A38 F4CD6E01 CFC5A7A5 C7D8B6851D56D4DB 6B3C3094 57A6F2F3 7CD4177B—— END LICENSE ——</code></pre><pre><code>—– BEGIN LICENSE —–Die Socialisten GmbH10 User LicenseEA7E-80061351311422 E45F49ED 3F0ADE0C E5B8A5082F4D9B65 64E1E244 EDA11F0E F9D06110B7B2E826 E6FDAA72 2C653693 5D80582F09DCFFB5 113A940C 5045C0CD 5F8332F834356CC6 D96F6FDB 4DEC20EA 0A24D83A2C82C329 E3290B29 A16109A7 EC198EB9F28EBB17 9C07403F D44BA75A C23C6874EBF11238 5546C3DD 737DC616 445C2941—— END LICENSE ——</code></pre></li></ol><h3 id="0x01-Disable-Update"><a href="#0x01-Disable-Update" class="headerlink" title="0x01 Disable Update"></a>0x01 Disable Update</h3><p>To disable Sublime Text’s update check (new version prompt) and license online checking:</p><ol><li>Go to “<strong>Preferences</strong> -&gt; <strong>Settings-User</strong>&#x2F;<strong>Distraction Free</strong>“</li><li>Add this line: <code>“update_check”: false,</code></li><li>Done!</li></ol><h3 id="0x02-Prevent-sublime-to-access-to-sublime-server"><a href="#0x02-Prevent-sublime-to-access-to-sublime-server" class="headerlink" title="0x02 Prevent sublime to access to sublime server"></a>0x02 Prevent sublime to access to sublime server</h3><p><strong>If this does not work, just add the following lines to your hosts file:</strong></p><pre><code>127.0.0.1 www.sublimetext.com127.0.0.1 sublimetext.com127.0.0.1 sublimehq.com127.0.0.1 license.sublimehq.com127.0.0.1 45.55.255.55127.0.0.1 45.55.41.2230.0.0.0 license.sublimehq.com0.0.0.0 45.55.255.550.0.0.0 45.55.41.223</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> macOS </tag>
            
            <tag> Sublime Text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Server 18.04 设置静态 IP</title>
      <link href="/posts/2019-11-19-setting-up-ip-on-ubuntu-server-18-04.html"/>
      <url>/posts/2019-11-19-setting-up-ip-on-ubuntu-server-18-04.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.  简介"></a>1.  简介</h1><p><strong>netplan</strong> 是 <strong>Ubuntu</strong> 在 17.10 版本中引入的一种新的命令行网络配置程序，用于在 Ubuntu 系统中轻松管理和配置网络设置。它允许用户使用 YAML 抽象语法来配置网络接口。它可与 NetworkManager 和 systemd-networkd 网络守护程序一起作为内核的接口。</p><p>它读取 <code>/etc/netplan/*.yaml</code> 中描述的网络配置，并且可以将所有网络接口的配置存储在这些文件中。</p><h1 id="2-静态-IP-设置步骤"><a href="#2-静态-IP-设置步骤" class="headerlink" title="2.  静态 IP 设置步骤"></a>2.  静态 IP 设置步骤</h1><ol><li><p>列出 Ubuntu 上的所有活动网络接口</p><p> 首先来查看 Ubuntu 上有哪些可以配置的网络接口。可以通过 <code>ifconfig</code> 命令来列出系统中所有连接的网络接口</p><pre><code class="bash">ismdeep@ubuntu:~$ ifconfigenp0s3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 192.168.56.103  netmask 255.255.255.0  broadcast 192.168.56.255        inet6 fe80::a00:27ff:fe7c:4250  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 08:00:27:7c:42:50  txqueuelen 1000  (Ethernet)        RX packets 361  bytes 32651 (32.6 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 240  bytes 30363 (30.3 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 1840  bytes 131056 (131.0 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 1840  bytes 131056 (131.0 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p> 这里可以看到系统中有两个网络接口：<code>enp0s3</code> 是以太网接口，<code>lo</code> 是环回接口。</p></li><li><p>Ubuntu 设置静态 IP 地址</p><p> 在这个例子中，我们将以 <code>enp0s3</code> 以太网接口配置一个静态 IP。</p><p> 如果在 <code>/etc/netplan</code> 目录中没有 yaml 文件的话，则需要通过命令来生成这些配置文件。</p><pre><code class="bash">ismdeep@ubuntu:~$ sudo netplan generate</code></pre><p> 接下来可以通过以下命令查看 <code>/etc/netplan</code> 中有哪些配置文件。</p><pre><code class="bash">ismdeep@ubuntu:~$ ls -l /etc/netplan/total 4-rw-r--r-- 1 root root 383 Nov 19 11:14 50-cloud-init.yaml</code></pre><p> 接下来通过 vim 或者其他编辑器进行编辑 yaml 文件。</p><pre><code># This is the network config written by &#39;subiquity&#39;network:  ethernets:    enp0s3:      addresses: []      dhcp4: true      optional: true  version: 2network:  ethernets:    enp0s8:      addresses:      - 192.168.56.101/24      dhcp4: no      optional: true  version: 2</code></pre><p> 说明：</p><ul><li><code>enp0s3</code> : 网络接口名称</li><li><code>dhcp4</code> : 接收 IPv4 接口的 DHCP 属性</li><li><code>dhcp6</code> : 接收 IPv6 接口的 DHCP 属性</li><li><code>addresses</code> : 接口的静态地址序列</li><li><code>gateway4</code> : 默认网关的 IPv4 地址</li><li><code>nameservers</code> : DNS 服务器地址，以英文逗号( , )分隔。</li></ul><p> <strong>注：多个网卡时请配置一个 <code>gateway4</code> 表示流量从哪个网卡出去。如果有 NAT DHCP 的网卡，则将这个放在最前。</strong></p></li><li><p>使之生效</p><p> 在编辑完配置文件后，通过以下命令使配置生效。</p><pre><code>ismdeep@ubuntu:~$ sudo netplan apply</code></pre></li></ol><h1 id="3-动态-IP-设置步骤"><a href="#3-动态-IP-设置步骤" class="headerlink" title="3.  动态 IP 设置步骤"></a>3.  动态 IP 设置步骤</h1><ol><li><p>要将 <code>enp0s3</code> 以太网接口配置为通过 DHCP 动态IP，只需使用以下配置即可</p><pre><code>network:    ethernets:        enp0s3:            dhcp4: true            dhcp6: true    version: 2</code></pre></li><li><p>使之生效</p><pre><code>ismdeep@ubuntu:~$ sudo netplan apply</code></pre></li></ol><h1 id="4-取消使用路由"><a href="#4-取消使用路由" class="headerlink" title="4.  取消使用路由"></a>4.  取消使用路由</h1><p>通过 <code>use-routes:false</code> 取消使用路由</p><pre><code class="text"># This is the network config written by &#39;subiquity&#39;network:  ethernets:    eth0:      dhcp4: true      dhcp4-overrides:        use-routes: false  version: 2</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过 GCC 查看预处理（宏展开）之后的实际代码</title>
      <link href="/posts/2019-11-19-show-preprocessing-code-with-gcc.html"/>
      <url>/posts/2019-11-19-show-preprocessing-code-with-gcc.html</url>
      
        <content type="html"><![CDATA[<p><strong>预处理</strong> 命令可以改变程序设计环境,提高编程效率,它们并不是 C 语言本身的组成部分,不能直接对 它们进行编译,必须在对程序进行编译之前,先对程序中这些特殊的命令进行“预处理” 。经过预处理后,程序就不再包括预处理命令了,最后再由编译程序对 <strong>预处理</strong> 之后的源程序进行 <strong>编译</strong> 处理,得到可供执行的目标代码。C 语言提供的预处理功能有三种,分别为 <strong>宏定义</strong>、文件包含和条件编译。</p><p>如果想知道预处理后最终的代码，可以通过 GCC 来查看。</p><h3 id="0x01-测试用的代码"><a href="#0x01-测试用的代码" class="headerlink" title="0x01 测试用的代码"></a>0x01 测试用的代码</h3><ol><li>文件名为 <code>main.c</code></li></ol><pre><code class="c">#define MAXN 100int main() &#123;    int a[MAXN];    for (int i = 0; i &lt; MAXN; i++) &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    return 0;&#125;</code></pre><h3 id="0x02-用-gcc-命令对测试用的代码进行预处理（不编译）"><a href="#0x02-用-gcc-命令对测试用的代码进行预处理（不编译）" class="headerlink" title="0x02 用 gcc 命令对测试用的代码进行预处理（不编译）"></a>0x02 用 gcc 命令对测试用的代码进行预处理（不编译）</h3><ol><li><p>通过以下指令对 <code>main.c</code> 文件进行预处理，并输出到 <code>test.log</code> 中。</p><pre><code class="bash">gcc -E main.c -o test.log</code></pre></li><li><p><code>test.log</code> 中的内容</p></li></ol><pre><code># 1 &quot;main.c&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 362 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;main.c&quot; 2int main() &#123;    int a[100];    for (int i = 0; i &lt; 100; i++) &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    return 0;&#125;</code></pre><pre><code>能看到 `main.c` 源文件中的 `MAXN` 都被替换成了 `100`</code></pre><h3 id="0x03-来点稍微复杂的预处理看看"><a href="#0x03-来点稍微复杂的预处理看看" class="headerlink" title="0x03 来点稍微复杂的预处理看看"></a>0x03 来点稍微复杂的预处理看看</h3><ol><li>源程序文件名为 <code>main.c</code></li></ol><pre><code class="c">#define MAXN 100#define FOR(id,size) for(int id = 0; id &lt; (size); id++)#define MUL(i,j) i*j#define MUL2(i,j) (i)*(j)int main() &#123;    int a[MAXN];    FOR(i, MAXN) &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    MUL(2,3+4);    MUL2(2,3+4);    return 0;&#125;</code></pre><ol start="2"><li>接下来看看预处理之后的源代码</li></ol><pre><code class="c"># 1 &quot;main.c&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 362 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;main.c&quot; 2int main() &#123;    int a[100];    for(int i = 0; i &lt; (100); i++) &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    2*3+4;    (2)*(3+4);    return 0;&#125;</code></pre><ol start="3"><li><strong>分析：</strong> 这里我们发现，预处理其实就是对 C 语言的源程序进行替换。预处理只是编译时的东西，而不是运行时的。而且这里仅仅是对文本进行替换，就算程序不能通过编译，也可以通过预处理的。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04 关闭和开启图形用户界面</title>
      <link href="/posts/2019-11-19-disable-enable-gui-on-ubuntu-18-04.html"/>
      <url>/posts/2019-11-19-disable-enable-gui-on-ubuntu-18-04.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><ol><li><p>关闭图形用户界面</p><pre><code class="bash">sudo systemctl set-default multi-user.targetsudo reboot</code></pre></li><li><p>开启图形用户界面</p><pre><code class="bash">sudo systemctl set-default graphical.targetsudo reboot</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>取消 Sublime Text 打开时记住上次打开的文档</title>
      <link href="/posts/2019-11-19-disable-sublime-text-remember-open-files.html"/>
      <url>/posts/2019-11-19-disable-sublime-text-remember-open-files.html</url>
      
        <content type="html"><![CDATA[<p>经常会使用 Sublime Text 3 来编辑文档，比如一些 Markdown 文档或者是一些源代码文件，但是每次打开的时候都会自动打开上次打开过的文档。这时 Sublime Text 就会打开多个窗口，这比较影响编辑文档时候的专注力和效率，对于多打开的文档，笔者比较习惯先关闭再来编辑需要编辑的文档。</p><p>一、首先打开 Sublime Text，打开菜单栏中的 <code>Preferences -&gt; Settings</code></p><p>二、在这段代码的中间增加以下两行代码</p><pre><code>&quot;hot_exit&quot;: false,&quot;remember_open_files&quot;: false,</code></pre><p>三、最后附上一张笔者的 Sublime Text 3的设置完成代码</p><pre><code>&#123;    &quot;color_scheme&quot;: &quot;Packages/Color Scheme - Default/Monokai.sublime-color-scheme&quot;,    &quot;font_face&quot;: &quot;Monaco&quot;,    &quot;font_size&quot;: 16,    &quot;hot_exit&quot;: false,    &quot;remember_open_files&quot;: false,    &quot;tab_size&quot;: 4,    &quot;theme&quot;: &quot;Default.sublime-theme&quot;,    &quot;translate_tabs_to_spaces&quot;: true,    &quot;update_check&quot;: false&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
            <tag> Sublime Text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关闭macOS上的SIP安全功能</title>
      <link href="/posts/2019-11-03-disable-sip-on-macos.html"/>
      <url>/posts/2019-11-03-disable-sip-on-macos.html</url>
      
        <content type="html"><![CDATA[<p>macOS 从 10.11 就是开始在系统中增加了 SIP (System Integrity Protection) 安全设置功能，不关闭这个功能，在很多时候会有很多问题。比如笔者最近就遇到一个比较麻烦的问题，就是在每次重新编译C语言代码之后，首次运行都需要多运行一些时间。这部分时间应该就是系统在进行安全性检查。</p><h3 id="关闭-Mac-的-SIP-安全设置功能"><a href="#关闭-Mac-的-SIP-安全设置功能" class="headerlink" title="关闭 Mac 的 SIP 安全设置功能"></a>关闭 Mac 的 SIP 安全设置功能</h3><ol><li>重启 Mac，按住 Command + R 键知道 Apple Logo 出现，进入 Recovery Mode</li><li>点击 Utilities &gt; Terminal</li><li>在 Terminal 中输入 <code>csrutil disable</code> ，然后换行。</li><li>重启 Mac</li></ol><p>这样 SIP 安全设置就已经被关闭了。如果想重新开启该安全设置，重复上面步骤，在第三步中将命令更换为 csrutil enable。</p><p>PS：在关闭 SIP 之后发现CLion使用起来更加流畅了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过命令行编译并运行程序之macOS版本</title>
      <link href="/posts/2019-11-01-how-to-compile-c-codes-with-terminal-on-macos.html"/>
      <url>/posts/2019-11-01-how-to-compile-c-codes-with-terminal-on-macos.html</url>
      
        <content type="html"><![CDATA[<p>引言：前文部分可先查看另一篇文章 <a href="/posts/2019-10-28-how-to-compile-c-codes-with-cmd-on-windows.html" target="_blank">如何通过命令行编译并运行程序之Windows版本</a></p><span id="more"></span><h2 id="0x00-安装-gcc-编译器"><a href="#0x00-安装-gcc-编译器" class="headerlink" title="0x00 安装 gcc 编译器"></a>0x00 安装 gcc 编译器</h2><p>通过键盘组合键 <code>command + 空格</code> 可以打开 Spotlight 进行搜索，输入 Terminal 可以打开macOS下的终端。打开之后输入 <code>gcc --version</code> 可以查看是否安装了 gcc 编译器，如果没有安装的话，系统会自动弹出下载安装 Command Line Tools 对话框。</p><p>在安装之后输入 <code>gcc --version</code> 可以查看安装的 gcc 信息。</p><pre><code class="text">&gt; gcc --versionConfigured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/4.2.1Apple clang version 11.0.0 (clang-1100.0.33.8)Target: x86_64-apple-darwin19.0.0Thread model: posixInstalledDir: /Library/Developer/CommandLineTools/usr/bin</code></pre><h2 id="0x01-命令行的基本使用"><a href="#0x01-命令行的基本使用" class="headerlink" title="0x01 命令行的基本使用"></a>0x01 命令行的基本使用</h2><ol><li><p><code>ls</code> 查看文件及文件夹列表</p><ul><li><code>ls</code> 默认方式查看当前目录下的文件及文件夹列表</li><li><code>ls -a</code> 查看当前目录下所有文件及文件夹列表（包括隐藏文件）</li><li><code>ls -l</code> 列表形式查看当前目录下的文件及文件夹列表</li><li><code>ls -la</code> 列表形式查看当前目录下所有文件及文件夹列表（包括隐藏文件）</li><li><code>ls -Slh</code> 列表形式按文件从大到小排列查看当前目录下文件及文件夹列表</li><li><code>ls ~/Desktop</code> 在 <code>ls</code> 命令后面加上目录名称可查看此目录下的文件及文件夹内容。当然 <code>ls</code> 后面依旧可以使用上路控制开关，如 <code>-a</code> , <code>-la</code> 等。</li></ul></li><li><p><code>cd</code> 切换目录</p><p> 目录的使用有两种使用方法，一种是<strong>相对路径</strong>，一种是<strong>绝对路径</strong>。</p><p> <strong>相对路径</strong>是与当前目录直接相关，如当前目录为 <code>/Users/ismdeep/Desktop</code> 那么 <code>/Users/ismdeep/Documents</code> 就相对为 <code>../Documents</code> （<strong>注</strong>： <code>..</code> 表示上一级目录，<code>.</code> 表示当前目录。）</p><p> 又例如：当前目录为 <code>/Users/ismdeep/Desktop</code> 那么 <code>/Users/ismdeep/Desktop/tmp</code> 就相对为 <code>./tmp</code> 或 <code>tmp</code></p><p> <strong>绝对路径</strong>则与当前目录无关。直接从根目录开始按层级往下写则为绝对路径。例如：<code>/Users/ismdeep/Desktop</code></p><ul><li><code>cd ../Documents</code> 相对路径切换目录方式。切换至上级目录下的 <code>Documents</code> 子目录。</li><li><code>cd tmp</code> 相对路径切换目录方式。切换至当前目录下的 <code>tmp</code> 子目录</li><li><code>cd /Users/ismdeep/Documents</code> 绝对路径切换目录方式。切换至 <code>/Users/ismdeep/Documents</code></li></ul></li><li><p><code>mkdir</code> 创建目录</p><p> <code>mkdir tmp</code> 在当前目录下创建名为 <code>tmp</code> 的子目录。</p></li><li><p><code>clear</code> 清空屏幕内容</p></li><li><p><code>gcc</code> 编译程序</p></li></ol><h2 id="0x02-编写第一个程序"><a href="#0x02-编写第一个程序" class="headerlink" title="0x02 编写第一个程序"></a>0x02 编写第一个程序</h2><ol><li>打开 Terminal 或者 iTerm2 等终端程序。（笔者非常推荐使用 iTerm2 终端程序，读者可自行通过网上教程进行安装配置 iTerm2 + zsh + oh-my-zsh 环境。《<a href="https://www.jianshu.com/p/9c3439cc3bdb" target="_blank">iTerm2 + Oh My Zsh 打造舒适终端体验</a>》）</li><li><code>cd ~/Desktop</code> 切换工作目录至桌面。（当然你也可以切换到其他目录）</li><li><code>mkdir codes</code> 新建一个名为 <code>codes</code> 的空白目录。</li><li><code>cd codes</code> 切换进这个 <code>codes</code> 目录。</li><li><code>touch main.c</code> 新建名为 <code>main.c</code> 的文件。</li><li>通过代码编辑器打开 <code>codes</code> 目录下的 <code>main.c</code> 文件。（代码编辑器有非常多，比如：vim, sublime text 3, vscode等。）</li><li><code>gcc main.c -o main</code> 通过 <code>gcc</code> 将 <code>main.c</code> 编译成可执行程序 <code>main</code> .</li><li><code>./main</code> 执行可执行程序 <code>main</code></li></ol><h2 id="0x03-gcc-g-c-编译器命令详解。"><a href="#0x03-gcc-g-c-编译器命令详解。" class="headerlink" title="0x03 gcc/g++/c++ 编译器命令详解。"></a>0x03 <code>gcc/g++/c++</code> 编译器命令详解。</h2><p><code>gcc</code> 用来编译 C 源程序，<code>g++</code> 和 <code>c++</code> 用来编译 C++ 源程序。有些系统上  <code>g++</code> 和 <code>c++</code> 其实是同一个。而这三个命令使用方式均是一样的。下面只介绍 <code>gcc</code> 的，另外两个依此类推。</p><ol><li><code>gcc main.c</code> 这是最简单的编译方式，编译 <code>main.c</code> 这个源程序，编译成功之后会在当前目录下生成一个名为 <code>a.out</code> 的可执行程序。</li><li><code>gcc main.c -o main</code> 在最简单的编译方式基础上增加了 <code>-o main</code> 表示编译成功后生成名为 <code>main</code> 的可执行程序。</li><li><code>gcc -g main.c -o main</code> 编译时生成 debug 有关的程序信息。</li><li><code>gcc main.c -I./include -o main</code> 编译时将 <code>./include</code> 文件夹加入头文件搜索目录。如 <code>./include</code> 目录下有 <code>util.h</code> 文件，则源代码中可以直接写 <code>#include &lt;util.h&gt;</code></li><li><code>gcc main.c -DONLINE_JUDGE -o main</code> 编译时加入 <code>ONLINE_JUDGE</code> 宏定义。目前几乎所有的在线测评系统都会使用 <code>-DONLINE_JUDGE</code> 编译时宏定义。</li><li><code>gcc -Wall main.c -o main</code> 编译时输出所有的错误和警告。</li><li><code>gcc -std=c99 main.c -o main</code> 编译时指定使用的语言标准。可以有 <code>-std=c++11</code>, <code>-std=c89</code>, <code>-std=c99</code>, <code>-std=c11</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过命令行编译并运行程序之Windows版本</title>
      <link href="/posts/2019-10-28-how-to-compile-c-codes-with-cmd-on-windows.html"/>
      <url>/posts/2019-10-28-how-to-compile-c-codes-with-cmd-on-windows.html</url>
      
        <content type="html"><![CDATA[<p>引言：大部分同学在学习C&#x2F;C++语言时所使用的开发环境，要不就是上古时代遗留下来的毒瘤产品，比如：VC 6.0 甚至还有 Turbo C. 这种东西在笔者开始学习C语言时候都已经是一个没什么人用的产品了。那都已经是12年前的事情了，虽然一直不能理解为什么国内编写教学教材的这些专家们为什么就不能努力努力改变一下现状呢。于是有了这么一篇简单搭建最原始也是笔者认为朴素的开发环境。</p><p>首先咱们需要知道几个概念：</p><ol><li><strong>编辑器：</strong> 编辑器是用来编写咱们的C语言或者是其他语言源代码的。</li><li><strong>编译器：</strong> 编译器是一整个套件，里面有非常多的程序，主要是用来将咱们写出来的C语言代码编译器可执行程序。</li><li><strong>调试器：</strong> 调试器是用来对编译出来的程序进行调试的，这次咱们搭建的环境中虽然有编译器，但是这种命令行调用调试器的方式略显麻烦。另外，笔者早期自学编程时还不知道有调试器这么好玩的东西的存在，于是用着 <code>printf</code> 这样的函数进行输出信息调试的。</li></ol><p>而现在常见的IDE(集成开发环境) 都是将上述功能集成在一个软件之上，虽然使用其他非常方便，但是但是如果在运行程序时候出现一些问题，解决其他就显得不是那么容易。这说明一个好的集成开发环境非常重要。Visual Studio 确实在功能上还算是一个很好的集成开发环境，但是微软搞的这一套，总是跟书上跟C语言标准不一样，所以对新手或者是算法竞赛的同学来说，并不太适合。Code::Blocks bug略显多呀，经常突然就不能编译了，而且在运行时候套用了一层 cb_console_runner 这个程序。</p><p><strong>综上所述，</strong> 笔者非常推荐下面将要介绍的命令行编译运行的方式。而且这种方式不仅可以在Windows环境上使用，而且可以在Linux、macOS上使用，最重要的是，这样就不太需要图形化了。在Linux服务器上，一般来说是没有图形化的，也就是说只有通过这种命令行编译程序的方式来在服务器上编译程序了。</p><h2 id="0x00-下载-Windows-上-GCC-编译器套件-MinGW"><a href="#0x00-下载-Windows-上-GCC-编译器套件-MinGW" class="headerlink" title="0x00 下载 Windows 上 GCC 编译器套件 MinGW"></a>0x00 下载 Windows 上 GCC 编译器套件 MinGW</h2><p>在学习C语言或者C++语言时候我们推荐使用 GCC 编译器，但是 GCC 编译器是 UNIX&#x2F;Linux 系统上的，那么 Windows 上想要使用就需要安装对应的编译器套件，也就是 MinGW.</p><p>首先通过下面的链接下载MinGW压缩包。</p><p><a href="https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z/download" target="_blank">MinGW下载地址</a></p><p>下载后会得到一个 <code>x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z</code> 的文件。</p><p>通过压缩软件解压（右键提取到 <code>&quot;x86_64-8.1.0-release-posix-seh-rt_v6-rev0\&quot;</code>）后在 <code>&quot;x86_64-8.1.0-release-posix-seh-rt_v6-rev0&quot;</code> 目录中可以得到一个 <code>mingw64</code> 的文件。将这个 <code>mingw64</code> 文件夹复制到 <code>C盘</code> 目录下面。</p><p>打开 <code>mingw64</code> 目录下的 <code>bin</code> 子目录，将其中的 <code>mingw32-make.exe</code> 复制一份命名为 <code>make.exe</code></p><h2 id="0x01-配置环境变量"><a href="#0x01-配置环境变量" class="headerlink" title="0x01 配置环境变量"></a>0x01 配置环境变量</h2><ol><li><p>右键计算机（或叫我的电脑、Win10上叫此电脑），点击属性，然后点击高级系统属性。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/db8af158cc1453cfb69cb8f9b0f510d4-28607d.jpg" alt="72ccb7773912b31b3c39aa0a8b18367adab4e179"></p></li><li><p>点击顶部的“高级”，然后点击下面的环境变量。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/0f290f63389844e706c9355c8bc7536c-4576fb.jpg" alt="0b7b02087bf40ad1a71ea0c05a2c11dfa9ecce1f"></p></li><li><p>选中系统变量中的 Path ，点击编辑。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/ece1773b897c2202439df814d5b56b5d-2f622c.jpg" alt="94cad1c8a786c917245c341ac43d70cf3bc757b1"></p></li><li><p>然后在尾部添加一个 <code>;</code> (注意是英文符号的<code>;</code> 而不是中文输入法下的；) ，并将mingw目录以及后面的 <code>\bin</code> 一起复制到添加的  <code>;</code> 后面。笔者mingw所在目录为：<code>C:\mingw</code> 于是复制 <code>C:\mingw\bin</code> 到上述 <code>;</code> 后面。<strong>注：</strong> Windows 10 系统上Path环境变量编辑时是点击添加，此时不需要添加 <code>;</code></p></li><li><p>然后点击确定即可。</p></li><li><p>打开命令提示符（Win7通过Win+R然后输入cmd即可打开，Win10打开开始菜单搜索cmd即可找到）并输入<code>gcc --version</code> ，如果有如下图显示，则表示环境变量配置完成。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/03f89fa87f2da3fad2c9aeea67d982df-3cff98.png" alt="20191028094242"></p></li></ol><h2 id="0x02-配置鼠标右键打开命令提示符"><a href="#0x02-配置鼠标右键打开命令提示符" class="headerlink" title="0x02 配置鼠标右键打开命令提示符"></a>0x02 配置鼠标右键打开命令提示符</h2><p>新建一个文本文档文件，打开输入如下代码，并将文件名改为 <code>opencmdhere.reg</code> 记住要更改后缀名，Windows 系统默认后缀名是隐藏的，需要设置为显示后缀名，至于怎么显示出来。请自行百度：Win7  如何显示文件后缀名</p><pre><code class="text">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\opencmd]@=&quot;Open CMD Here&quot;&quot;Icon&quot;=&quot;C:\\Windows\\System32\\cmd.exe&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\opencmd\command]@=&quot;cmd.exe \&quot;%V\&quot;&quot;</code></pre><p>在更改文件名后，文件图标应该会改变为如下所示。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/21a6e5275cf5f699fe02413f4f5f6d5f-b0e76b.png" alt="20191028094625"></p><p>双击该文件并点击确定。</p><h2 id="0x03-安装-Sublime-Text-3-代码编辑器"><a href="#0x03-安装-Sublime-Text-3-代码编辑器" class="headerlink" title="0x03 安装 Sublime Text 3 代码编辑器"></a>0x03 安装 Sublime Text 3 代码编辑器</h2><p>事实上，这里我们用来编写的代码编辑器有很多很多，笔者比较喜欢用 Sublime Text 3 代码编辑器。 </p><p>首先前往  <a href="http://www.sublimetext.com/">http://www.sublimetext.com/</a>  下载并安装。安装过程中需要勾选 <code>Add to explorer context menu</code> 选项，勾选之后可以方便后续通过鼠标右键打开你的源码文件。</p><p><strong>注：</strong> Sublime Text 3 是一款优秀的代码编辑器，也是收费软件，但是可以无限使用，只是在没有通过注册码激活的情况下，偶尔在保存代码的时候会弹出提示激活的提示。虽然可以通过网上找到一些激活的办法，但在个人经济允许的情况下购买激活码支持正版优秀软件。</p><h2 id="0x04-开始写代码"><a href="#0x04-开始写代码" class="headerlink" title="0x04 开始写代码"></a>0x04 开始写代码</h2><ol><li><p>新建一个空目录。笔者建议在新建目录时，这个目录名是不带空格的纯英文目录名，以避免中文字符带来的问题。而且这个目录的上一层目录以及之前的目录均是如此。</p><p> 这里使用 <code>D:\codes-demo</code> 来举例。</p></li><li><p>打开上述空目录，并新建名为 <code>main.c</code> 的文件。（源码文件名可以随意命名，命名方式建议如上述目录名规则一样。）</p></li><li><p>选中 <code>main.c</code> 文件右键 <code>Open with sublimetext</code> </p></li><li><p>接下来就可以在编辑器中开始写代码了。</p><pre><code class="c">#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello world.\n&quot;);    return 0;&#125;</code></pre></li></ol><h2 id="0x05-编译并运行程序。"><a href="#0x05-编译并运行程序。" class="headerlink" title="0x05 编译并运行程序。"></a>0x05 编译并运行程序。</h2><ol><li><p>在目录空白部分右键，<code>Open CMD Here</code></p></li><li><p>在弹出的命令提示符窗口中输入 <code>dir</code> 可以查看当前目录中的所有文件及文件夹。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/824275874760b5b1bace8eb91c47d712-198474.png" alt="20191028100327"></p></li><li><p>接下来输入 <code>gcc main.c -o main</code> 可以编译 <code>main.c</code> 文件到 <code>main.exe</code> ，当输出如下，没有编译错误信息，则表示程序编译正常，如果遇到错误信息则可以通过网络搜索找出错误在哪里。而且错误信息中都会明确指出错误出现的位置。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/a2593bc491563849b21700dc8ebdd133-c11bd7.png" alt="20191028100527"></p></li><li><p>通过编译出来的文件名进行运行。这里编译出来的是 <code>main.exe</code> 文件。</p><p> <img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/b7dd93896f6df03d2f54a5bdf97ef462-57325f.png" alt="20191028100743"></p></li></ol><h2 id="0x06-中文乱码解决方法"><a href="#0x06-中文乱码解决方法" class="headerlink" title="0x06 中文乱码解决方法"></a>0x06 中文乱码解决方法</h2><p>如果你写的程序中需要输出中文的话，那么正常编译是会乱码的。这是因为默认的GCC编译出来的中文字符集是UTF-8的，而 Windows 命令行字符集是GBK的，自然输出就乱码了。这个时候就只要指明编译的字符集。</p><pre><code class="bash">gcc -fexec-charset=GBK main.c -o main</code></pre><h2 id="0x07-文末细语"><a href="#0x07-文末细语" class="headerlink" title="0x07 文末细语"></a>0x07 文末细语</h2><p>这篇文章是在早上下雨不能骑车而在宿舍治疗拖延症的情况下写就的。这篇文章拖了整整六年了。终于在今天写出来了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Abstract Algebra Chapter 01</title>
      <link href="/posts/2019-09-05-abstract-algebra-chapter-01.html"/>
      <url>/posts/2019-09-05-abstract-algebra-chapter-01.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p><strong>Proposition 1.5</strong> $2^n \gt n$ for all integer $n \geq 0$</p><p><strong>Proof.</strong> <em>Base Step.</em> The initial statement $S(0): 2^0 \gt 0$ is true, for $2^0 &#x3D; 1 &gt; 0$</p><p><em>Inductive Step.</em> If $S(n)$ is true, then $S(n+1)$ is true.</p><p>If $2^n \gt n$ is true, then</p><p>$2^{n+1} &#x3D; 2 \cdot 2^n \gt 2n &#x3D; n + n \geq n+1 (n \geq 1)$</p><p>Hence, $2^{n+1} \gt 2n \geq n + 1$, then $2^{n+1} \gt n + 1$</p><p>$2^n \gt n$ for all $n \geq 0$</p><hr><p><strong>Proposition 1.6</strong> $1 + 2 + \dots n &#x3D; \frac{1}{2} n (n + 1)$ for every integer $n \geq 1$</p><p><strong>Proof.</strong> The proof is by induction on $n \geq 1$</p><p><em>Base Step.</em> If $n &#x3D; 1$, then $1 &#x3D; \frac{1}{2} \times 1 \times (1 + 1) &#x3D; 1$</p><p>$Inductive Step.$ $S(n+1)$: $1 + 2 + \dots + n + (n+1) &#x3D; \frac{1}{2}n(n+1)+(n+1)$</p><p>$&#x3D; \frac{1}{2}(n(n+1) + 2(n+1))$</p><p>$&#x3D; \frac{1}{2}(n+1)(n+2)$</p><p>$&#x3D; \frac{1}{2}(n+1)[(n+1)+1]$</p><p>By induction, the formula holds for all $n \geq 1$</p><hr><p><strong>Proposition 1.8</strong> $2^n \gt n^2$ is true for all integer $n \geq 5$</p><p><strong>Proof.</strong> <em>Base Step.</em> $n &#x3D; 5$. $2^5 &#x3D; 32 \gt 5^2 &#x3D; 25$</p><p><em>Inductive Step.</em> $n \geq 5$.       $2^{n+1} &#x3D; 2 \cdot 2^n \gt 2 \cdot n^2$</p><p>$&#x3D; n^2 + n^2 &#x3D; n^2 + n \cdot n \gt n^2 + 3n &#x3D; n^2 + 2n + n$</p><p>$\gt n^2 + 2n + 1 &#x3D; (n+1)^2$</p><p>$Q.E.D.$</p><hr><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><p><strong>1.1</strong> Find a formula for $1 + 3 + 5 + \dots + (2n-1)$. and use mathematical induction to prove that your formula is correct.</p><p>$1 + 3 + 5 + \dots + (2n-1) &#x3D; n^2$</p><p><strong>Proof.</strong> <em>Base Step.</em> $n &#x3D; 1$    $1 &#x3D; 1^2 &#x3D; 1$</p><p><em>Induction Step.</em> $n \geq 1$</p><p>$1 + 3 + 5 + \dots + (2n-1) + [2(n+1)-1]$</p><p>$&#x3D; n^2 + [2(n+1)-1]$</p><p>$&#x3D; n^2 + 2n + 2 - 1$</p><p>$&#x3D; n^2 + 2n + 1$</p><p>$&#x3D; (n+1)^2$</p><p>$Q.E.D.$</p><hr><p><strong>1.2</strong> Find a formula for $1 + \sum_{j&#x3D;1}^{n} j!j$. and use induction to prove that your formula is correct.</p><p>$1 + \sum_{j&#x3D;1}^{n} j!j &#x3D; (n+1)!$</p><p><strong>Proof.</strong> <em>Base Step.</em>  $n&#x3D;1$     $1+1!1 &#x3D; 2 &#x3D; (1+1)!$</p><p><em>Inductive Step.</em> $n \geq 1$</p><p>$1 + \sum_{j&#x3D;1}^{n+1} j!j$</p><p>$&#x3D; 1 + \sum_{j&#x3D;1}^{n} j!j + (n+1)!(n+1)$</p><p>$&#x3D; (n+1)! + (n+1)!(n+1)$</p><p>$&#x3D; (n+2)!$</p><p>$Q.E.D.$</p><hr><p><strong>1.3 (i)</strong> For any $n \geq 0$ and any $r \neq 1$. prove that $1 + r + r^2 + r^3 + \dots + r^n &#x3D; \frac{1-r^{n+1}}{1-r}$</p><p><strong>Proof.</strong> <em>Base Step.</em> $n &#x3D; 0$    $1 &#x3D; \frac{1 - r^{0+1}}{1-r} &#x3D; 1 (r \neq 1)$</p><p><em>Inductive Step.</em>  $n \geq 1$</p><p>$1 + r + r^2 + r^3 + \dots + r^n + r^{n+1}$</p><p>$&#x3D; \frac{1-r^{n+1}}{1-r} + r^{n+1}$</p><p>$&#x3D; \frac{1 - r^{n+1} + r^{n+1} - r \cdot r^{n+1}}{1-r}$</p><p>$&#x3D; \frac{1-r^{n+2}}{1-r}$</p><p>$Q.E.D.$</p><hr><p><strong>1.3(ii)</strong> Proof that $1 + 2 + 2^2 + \dots + 2^n &#x3D; 2^{n+1} - 1$</p><p><strong>Proof.</strong> <em>Base Step.</em> $n &#x3D; 0$    $1 &#x3D; 2^{0-1} - 1 &#x3D; 1$</p><p>$Inductive Step.$ $n \geq 0$</p><p>$1 + 2 + 2^2 + \dots + 2^n + 2^{n+1}$</p><p>$&#x3D; 2^{n+1} - 1 + 2^{n+1}$</p><p>$&#x3D; 2^{n+2} - 1$</p><p>$Q.E.D.$</p><hr><p><strong>1.4</strong> Show for all $n \geq 1$. that $10^n$ leave remainder 1 after dividing by 9</p><p><strong>Proof.</strong> <em>Base Step.</em> $n&#x3D;1$    $10^1 \equiv 1 (\mod{9})$</p><p><em>Inductive Step.</em> $n \geq 1$    $10^{n+1} &#x3D; 10^n \cdot 10 &#x3D; 10^n \times 9 + 10^n$</p><p>Then $10^{n+1} \equiv 10^n \times 9 + 10^n \equiv (0+1) \equiv 1 (\mod{9})$</p><p>$Q.E.D.$</p><hr><p><strong>1.5</strong> Prove that if $0 \leq a \leq b$, then $a^n \leq b^n$ for all $n \geq 0$</p><p><strong>Proof.</strong> <em>Base Step.</em> $n &#x3D; 0$    $a^0 &#x3D; b^0$</p><p>$Inductive Step.$ $n \geq 0$    $a^{n+1} &#x3D; a^n \cdot a \leq a^n \cdot b \leq b^b \cdot b &#x3D; b^{n+1}$</p><p>$Q.E.D.$</p><hr><p><strong>1.6</strong> Prove that $1^2 + 2^2 + \dots + n^2 &#x3D; \frac{1}{6}n(n+1)(2n+1) &#x3D; \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n$</p><p><strong>Proof.</strong> <em>Base Step.</em> $n&#x3D;1$    $1^2 &#x3D; \frac{1}{3} + \frac{1}{2} + \frac{1}{6} &#x3D; 1$</p><p><em>Inductive Step.</em> $n \geq 1$</p><p>$1^2 + 2^2 + \dots + n^2 + (n+1)^2$</p><p>$&#x3D; \frac{1}{3}n^3 + \frac{1}{2}n^2 + \frac{1}{6}n + (n+1)^2$</p><p>$&#x3D; \frac{1}{6}(2n^3 + 9n^2 + 13n + 6)$</p><p>$&#x3D; \frac{1}{6}(2n^3 + 6n^2 + 6n + 2) + \frac{1}{6}(3n^2 + 6n + 3) + \frac{1}{6}(n+1)$</p><p>$&#x3D; \frac{1}{3}(n+1)^3 + \frac{1}{2}(n+1)^2 + \frac{1}{6}(n+1)$</p><p>$Q.E.D.$</p><hr><p><strong>1.7</strong> Prove that $1^3 + 2^3 + \dots + n^3 &#x3D; \frac{1}{4}n^4 + \frac{1}{2}n^3 + \frac{1}{4}n^2$</p><hr><p><strong>1.8</strong> Prove that $1^4 + 2^4 + \dots + n^4 &#x3D; \frac{1}{5}n^5 + \frac{1}{2}n^4 + \frac{1}{3}n^3 - \frac{1}{30}n$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Abstract Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recent Developments in Cryptography 2019</title>
      <link href="/posts/2019-08-29-recent-developments-in-cryptography-2019.html"/>
      <url>/posts/2019-08-29-recent-developments-in-cryptography-2019.html</url>
      
        <content type="html"><![CDATA[<p>Things has been enormous changed in cryptography after DH inventend the Public Key Cryptography (PKC). The algorithms for complex problems like interger factorization, Discrete Logarithms and Elliptic Curve Discrete Logarithms hava improved tremendously make way for attackers to crack cryptosystems previously thought were unsolvable. Newer Methods have also been invented like Lattice based cryptography, Code based cryptography, Hash based cryptography and Multivariate cryptography. With the invention of newer public key cryptosystems, the signature systems makeing use of public key signatures have enabled authentication of individuals based on public keys. The Key Distribution mechanisms including the Key Exchange protocols and Public Key infrastructures have contributed to the development of algorithms in this area. Also we will discuss about the developments of Indentity based cryptography, Group based cryptography and Chaos based cryptography.</p><span id="more"></span><p>The field of cryptography was characterized initially by the development of Classical Cryptosystems and later by the development of Symmetric Key Cryptosystems and Public Key Cryptosystems. The invention of Public Key Cryptosystems led to the development of number of Public Key algorithms with varying degrees of complexity and strength. While the Symmetric Key Cryptosystems and the Public Key Cryptosystems focussed on the security property of Confidentiality, the development of Hash algorithms focused on achieving Integrity of data. The invention of Public Key Cryptography also led to the use of Digital Signatures which provided a very important property of non-repudiation by combining the use of private keys and hash algorithms.</p><p>While there are a number of algorithms that exist that can perform encryption using public and private keys, it would be of interest to the researchers to develop algorithms based on different principles since they can provide a platform with which we can compare the performance of different algorithms and also we can choose from a variety of algorithms based on the nature of application in use. The public key encryption algorithms are usually based on a mathematically hard and computationally difficult problem. In this chapter, a survey of the developments that have taken place in Cryptography ever since the invention of public Key Cryptography by Diffie and Hellman (Diffie, et.al.,1976) is presented. There are many important classes of cryptographic systems beyond RSA (Diffie, 1988) and DSA (Kerry, et.al., 2013) and ECDSA (Hoffman, 2012). They are:</p><ul><li><p><strong>Hash Based Cryptography:</strong> The classic example is Merkle’s hash-tree public-key signature system (Merkle., 1989).</p></li><li><p><strong>Code Based Cryptography:</strong> The classic example is McEliece’s hidden Goppa-code public-key encryption system (McEliece, 1978).</p></li><li><p><strong>Lattice Based Cryptography:</strong> The example that has attracted the most interest is the Hoffstein– Pipher–Silverman “NTRU” public-key-encryption system (Hoffstein et.al., 1988).</p></li><li><p><strong>Multivariate Quadratic Equations Cryptography:</strong> An example is the “Hidden Field Equations” by Patarin (1986).</p></li><li><p><strong>Identity Based Cryptography:</strong> A type of public-key cryptography in which a publicly known string representing an individual or organization is used as a public key. The public string could include an email address, domain name, or a physical IP address. An example is the scheme proposed by Adi Shamir (Shamir, A.,1984).</p></li><li><p><strong>Group Based Cryptography:</strong> Based on use of Groups for constructing cryptographic primitives. An example is the public key cryptography which is based on the hardness of the word problem (Magyarik et.al, 1985).</p></li><li><p><strong>Chaos Based Cryptography:</strong> The application of the mathematical chaos theory to the practice of cryptography.</p></li></ul><p>It remains to be studied to see how these public key crypto systems compare with one another in terms of processing cost, difficulty in key generation and resistance against cryptographic attacks. The performance study of the implementations of these crypto systems is very much required so the applications of these cryptosystems can be better understood.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何通过免密码 SSH 连接至 OpenWRT 路由</title>
      <link href="/posts/2019-08-23-how-to-passwordless-ssh-to-an-openwrt-router.html"/>
      <url>/posts/2019-08-23-how-to-passwordless-ssh-to-an-openwrt-router.html</url>
      
        <content type="html"><![CDATA[<p>在通过 SSH 远程访问 Linux 主机时，配置一个 ssh 密钥确实是一个不错的方式，这样不用在每次连接访问的时候输入密码。而且能够保证安全性，毕竟每次输入密码，太长了输起来太麻烦，太短了则密码安全性太差。然而这个事情做起来在普通 Linux 可以正常操作，然而 OpenWRT 里面却有些不一样。普通 Linux 下面 只需要把 <code>id_rsa.pub</code> 里面的公钥拷贝到 <code>/home/&lt;username&gt;/.ssh/authorized_keys</code> 里面，如果是 <code>root</code> 账号则拷贝到 <code>/root/.ssh/authorized_keys</code> 里面。</p><p>由于 OpenWRT 里面用的 SSH 服务端是 Dropbear. <code>authorized_keys</code> 位置是 <code>/etc/dropbear/authorized_keys</code>. 接下来只需要跟普通 Linux 一样的操作，拷贝公钥的字符串进来即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数和证明</title>
      <link href="/posts/2019-08-16-euler-function-sum-proof.html"/>
      <url>/posts/2019-08-16-euler-function-sum-proof.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p><strong>证：</strong> 设 $n$ 为正整数，则：$\sum_{d|n}\varphi(d) &#x3D; n$</p><p><strong>证明：</strong> 考虑有理数集</p><p>$S &#x3D; {\frac{r}{n}|r&#x3D;1,2,\dots,n}$ </p><p>将 $S$ 中的每个数化为既约分数，得：</p><p>$S^* &#x3D; {\frac{r&#x2F;(r,n)}{n&#x2F;(r,n)} &#x3D; \frac{h}{k}|r&#x3D;1,2,\dots,n}$</p><p>显然，$S^*$ 中的 $n$ 个分数值仍然各不相同。</p><p>$S^*$ 中的 $\frac{h}{k}$ 是既约分数，则有：</p><p>$k|n, (h,k) &#x3D; 1, h \leq k$</p><p>反之，对于给定的 $n$ ，任一满足上述条件的分数 $\frac{h}{k}$ 在 $S^*$ 中。这是因为：</p><p>$\frac{h \times \frac{n}{k}}{k \times \frac{n}{k}} &#x3D; \frac{r}{n}, r \leq n$</p><p>进一步，对于每个 $k|n$ ，满足时该条件的分数 $\frac{h}{k}$ 有 $\varphi{k}$ 个（因为与 $k$ 互素的 $h$ 值有 $\varphi{k}$ 个）。</p><p>所以满足该条件的分数 $\frac{h}{k}$ 共有 $\sum_{d|n} \varphi{(d)}$ 个。</p><p>而 $S^*$ 中有 $n$ 个分数，故：$\sum_{d|n}\varphi(d) &#x3D; n$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 安全配置</title>
      <link href="/posts/2019-06-28-nginx-secure-configuration.html"/>
      <url>/posts/2019-06-28-nginx-secure-configuration.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><h3 id="0x00-隐藏版本号"><a href="#0x00-隐藏版本号" class="headerlink" title="0x00 隐藏版本号"></a>0x00 隐藏版本号</h3><pre><code>http &#123;    server_tokens off;&#125;</code></pre><p>经常会有针对某个版本的nginx安全漏洞出现，隐藏nginx版本号就成了主要的安全优化手段之一，当然最重要的是及时升级修复漏洞。</p><h3 id="0x01-开启HTTPS"><a href="#0x01-开启HTTPS" class="headerlink" title="0x01 开启HTTPS"></a>0x01 开启HTTPS</h3><pre><code>server &#123;    listen 443;    server_name ops-coffee.cn;    ssl on;    ssl_certificate /etc/nginx/server.crt;    ssl_certificate_key /etc/nginx/server.key;    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers         HIGH:!aNULL:!MD5;&#125;</code></pre><p><strong>ssl on：</strong>开启https</p><p><strong>ssl_certificate：</strong>配置nginx ssl证书的路径</p><p><strong>ssl_certificate_key：</strong>配置nginx ssl证书key的路径</p><p><strong>ssl_protocols：</strong>指定客户端建立连接时使用的ssl协议版本，如果不需要兼容TSLv1，直接去掉即可</p><p><strong>ssl_ciphers：</strong>指定客户端连接时所使用的加密算法，你可以再这里配置更高安全的算法</p><h3 id="0x02-添加黑白名单"><a href="#0x02-添加黑白名单" class="headerlink" title="0x02 添加黑白名单"></a>0x02 添加黑白名单</h3><p>白名单配置</p><pre><code>location /admin/ &#123;    allow   192.168.1.0/24;    deny    all;&#125;</code></pre><p>上边表示只允许192.168.1.0&#x2F;24网段的主机访问，拒绝其他所有</p><p>也可以写成黑名单的方式禁止某些地址访问，允许其他所有，例如</p><pre><code>location /ops-coffee/ &#123;    deny   192.168.1.0/24;    allow    all;&#125;</code></pre><p>更多的时候客户端请求会经过层层代理，我们需要通过<code>$http_x_forwarded_for</code>来进行限制，可以这样写</p><pre><code>set $allow false;if ($http_x_forwarded_for = &quot;211.144.204.2&quot;) &#123; set $allow true; &#125;if ($http_x_forwarded_for ~ &quot;108.2.66.[89]&quot;) &#123; set $allow true; &#125;if ($allow = false) &#123; return 404; &#125;</code></pre><h3 id="0x03-添加账号认证"><a href="#0x03-添加账号认证" class="headerlink" title="0x03 添加账号认证"></a>0x03 添加账号认证</h3><pre><code>server &#123;    location / &#123;        auth_basic &quot;please input user&amp;passwd&quot;;        auth_basic_user_file key/auth.key;    &#125;&#125;</code></pre><h3 id="0x04-限制请求方法"><a href="#0x04-限制请求方法" class="headerlink" title="0x04 限制请求方法"></a>0x04 限制请求方法</h3><pre><code>if ($request_method !~ ^(GET|POST)$ ) &#123;    return 405;&#125;</code></pre><p><code>$request_method</code>能够获取到请求nginx的method</p><p>配置只允许GET\POST方法访问，其他的method返回405</p><h3 id="0x05-拒绝User-Agent"><a href="#0x05-拒绝User-Agent" class="headerlink" title="0x05 拒绝User-Agent"></a>0x05 拒绝User-Agent</h3><pre><code>if ($http_user_agent ~* LWP::Simple|BBBike|wget|curl) &#123;    return 444;&#125;</code></pre><p>可能有一些不法者会利用wget&#x2F;curl等工具扫描我们的网站，我们可以通过禁止相应的user-agent来简单的防范</p><p>Nginx的444状态比较特殊，如果返回444那么客户端将不会收到服务端返回的信息，就像是网站无法连接一样</p><h3 id="0x06-图片防盗链"><a href="#0x06-图片防盗链" class="headerlink" title="0x06 图片防盗链"></a>0x06 图片防盗链</h3><pre><code>location /images/ &#123;    valid_referers none blocked www.ops-coffee.cn ops-coffee.cn;    if ($invalid_referer) &#123;        return  403;    &#125;&#125;</code></pre><p><strong>valid_referers：</strong>验证referer，其中<code>none</code>允许referer为空，<code>blocked</code>允许不带协议的请求，除了以上两类外仅允许referer为<a href="http://www.ops-coffee.cn或ops-coffee.cn时访问images下的图片资源,否则返回403/">www.ops-coffee.cn或ops-coffee.cn时访问images下的图片资源，否则返回403</a></p><p>当然你也可以给不符合referer规则的请求重定向到一个默认的图片，比如下边这样</p><pre><code>location /images/ &#123;    valid_referers blocked www.ops-coffee.cn ops-coffee.cn    if ($invalid_referer) &#123;        rewrite ^/images/.*\.(gif|jpg|jpeg|png)$ /static/qrcode.jpg last;    &#125;&#125;</code></pre><h3 id="0x07-控制并发连接数"><a href="#0x07-控制并发连接数" class="headerlink" title="0x07 控制并发连接数"></a>0x07 控制并发连接数</h3><p>可以通过<code>ngx_http_limit_conn_module</code>模块限制一个IP的并发连接数</p><pre><code>http &#123;    limit_conn_zone $binary_remote_addr zone=ops:10m;    server &#123;        listen       80;        server_name  ops-coffee.cn;        root /home/project/webapp;        index index.html;        location / &#123;            limit_conn ops 10;        &#125;        access_log  /tmp/nginx_access.log  main;    &#125;&#125;</code></pre><p><strong>limit_conn_zone：</strong>设定保存各个键(例如<code>$binary_remote_addr</code>)状态的共享内存空间的参数，zone&#x3D;空间名字:大小</p><p>大小的计算与变量有关，例如<code>$binary_remote_addr</code>变量的大小对于记录IPV4地址是固定的4 bytes，而记录IPV6地址时固定的16 bytes，存储状态在32位平台中占用32或者64 bytes，在64位平台中占用64 bytes。1m的共享内存空间可以保存大约3.2万个32位的状态，1.6万个64位的状态</p><p><strong>limit_conn：</strong>指定一块已经设定的共享内存空间(例如name为<code>ops</code>的空间)，以及每个给定键值的最大连接数</p><p>上边的例子表示同一IP同一时间只允许10个连接</p><p>当有多个<code>limit_conn</code>指令被配置时，所有的连接数限制都会生效</p><pre><code>http &#123;    limit_conn_zone $binary_remote_addr zone=ops:10m;    limit_conn_zone $server_name zone=coffee:10m;    server &#123;        listen       80;        server_name  ops-coffee.cn;        root /home/project/webapp;        index index.html;        location / &#123;            limit_conn ops 10;            limit_conn coffee 2000;        &#125;    &#125;&#125;</code></pre><p>上边的配置不仅会限制单一IP来源的连接数为10，同时也会限制单一虚拟服务器的总连接数为2000</p><h3 id="0x08-缓冲区溢出攻击"><a href="#0x08-缓冲区溢出攻击" class="headerlink" title="0x08 缓冲区溢出攻击"></a>0x08 缓冲区溢出攻击</h3><p><strong>缓冲区溢出攻击</strong>是通过将数据写入缓冲区并超出缓冲区边界和重写内存片段来实现的，限制缓冲区大小可有效防止</p><pre><code>client_body_buffer_size  1K;client_header_buffer_size 1k;client_max_body_size 1k;large_client_header_buffers 2 1k;</code></pre><p><strong>client_body_buffer_size：</strong>默认8k或16k，表示客户端请求body占用缓冲区大小。如果连接请求超过缓存区指定的值，那么这些请求实体的整体或部分将尝试写入一个临时文件。</p><p><strong>client_header_buffer_size：</strong>表示客户端请求头部的缓冲区大小。绝大多数情况下一个请求头不会大于1k，不过如果有来自于wap客户端的较大的cookie它可能会大于 1k，Nginx将分配给它一个更大的缓冲区，这个值可以在<code>large_client_header_buffers</code>里面设置</p><p><strong>client_max_body_size：</strong>表示客户端请求的最大可接受body大小，它出现在请求头部的Content-Length字段， 如果请求大于指定的值，客户端将收到一个”Request Entity Too Large” (413)错误，通常在上传文件到服务器时会受到限制</p><p><strong>large_client_header_buffers</strong>表示一些比较大的请求头使用的缓冲区数量和大小，默认一个缓冲区大小为操作系统中分页文件大小，通常是4k或8k，请求字段不能大于一个缓冲区大小，如果客户端发送一个比较大的头，nginx将返回”Request URI too large” (414)，请求的头部最长字段不能大于一个缓冲区，否则服务器将返回”Bad request” (400)</p><p>同时需要修改几个超时时间的配置</p><pre><code>client_body_timeout   10;client_header_timeout 10;keepalive_timeout     5 5;send_timeout          10;</code></pre><p><strong>client_body_timeout：</strong>表示读取请求body的超时时间，如果连接超过这个时间而客户端没有任何响应，Nginx将返回”Request time out” (408)错误</p><p><strong>client_header_timeout：</strong>表示读取客户端请求头的超时时间，如果连接超过这个时间而客户端没有任何响应，Nginx将返回”Request time out” (408)错误</p><p><strong>keepalive_timeout：</strong>参数的第一个值表示客户端与服务器长连接的超时时间，超过这个时间，服务器将关闭连接，可选的第二个参数参数表示Response头中Keep-Alive: timeout&#x3D;time的time值，这个值可以使一些浏览器知道什么时候关闭连接，以便服务器不用重复关闭，如果不指定这个参数，nginx不会在应Response头中发送Keep-Alive信息</p><p><strong>send_timeout：</strong>表示发送给客户端应答后的超时时间，Timeout是指没有进入完整established状态，只完成了两次握手，如果超过这个时间客户端没有任何响应，nginx将关闭连接</p><h3 id="0x09-Header头设置"><a href="#0x09-Header头设置" class="headerlink" title="0x09 Header头设置"></a>0x09 Header头设置</h3><p>通过以下设置可有效防止XSS攻击</p><pre><code>add_header X-Frame-Options &quot;SAMEORIGIN&quot;;add_header X-XSS-Protection &quot;1; mode=block&quot;;add_header X-Content-Type-Options &quot;nosniff&quot;;</code></pre><p><strong>X-Frame-Options：</strong>响应头表示是否允许浏览器加载frame等属性，有三个配置<code>DENY</code>禁止任何网页被嵌入,<code>SAMEORIGIN</code>只允许本网站的嵌套,<code>ALLOW-FROM</code>允许指定地址的嵌套</p><p><strong>X-XSS-Protection：</strong>表示启用XSS过滤（禁用过滤为<code>X-XSS-Protection: 0</code>），<code>mode=block</code>表示若检查到XSS攻击则停止渲染页面</p><p><strong>X-Content-Type-Options：</strong>响应头用来指定浏览器对未指定或错误指定<code>Content-Type</code>资源真正类型的猜测行为，nosniff 表示不允许任何猜测</p><p>在通常的请求响应中，浏览器会根据<code>Content-Type</code>来分辨响应的类型，但当响应类型未指定或错误指定时，浏览会尝试启用MIME-sniffing来猜测资源的响应类型，这是非常危险的</p><p>例如一个.jpg的图片文件被恶意嵌入了可执行的js代码，在开启资源类型猜测的情况下，浏览器将执行嵌入的js代码，可能会有意想不到的后果</p><p>另外还有几个关于请求头的安全配置需要注意</p><p><strong>Content-Security-Policy：</strong>定义页面可以加载哪些资源，</p><pre><code>add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;;</code></pre><p>上边的配置会限制所有的外部资源，都只能从当前域名加载，其中<code>default-src</code>定义针对所有类型资源的默认加载策略，<code>self</code>允许来自相同来源的内容</p><p><strong>Strict-Transport-Security：</strong>会告诉浏览器用HTTPS协议代替HTTP来访问目标站点</p><pre><code>add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot;;</code></pre><p>上边的配置表示当用户第一次访问后，会返回一个包含了<code>Strict-Transport-Security</code>响应头的字段，这个字段会告诉浏览器，在接下来的31536000秒内，当前网站的所有请求都使用https协议访问，参数<code>includeSubDomains</code>是可选的，表示所有子域名也将采用同样的规则</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得算法（Lisp）</title>
      <link href="/posts/2019-06-24-exgcd.html"/>
      <url>/posts/2019-06-24-exgcd.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="lisp">(defun ex-gcd (a b)    (if (= b 0) (values 1 0 a)        (let ((x 0) (y 0) (r 0) (tmp 0))            (multiple-value-bind (x y r) (ex-gcd b (mod a b))                (setf                    tmp y                    y   (- x (* (floor (/ a b)) y))                    x   tmp)                (values x y r)))))(let ((x 0) (y 0) (r 0))    (multiple-value-bind (x y r) (ex-gcd 72 98)        (format t &quot;X:~D Y:~D R:~D~%&quot; x y r)        (format t &quot;~D~%&quot; (+ (* 15 72) (* -11 98)))))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fibonacci 序列通项公式推导</title>
      <link href="/posts/2019-06-22-fibonacci-sequence-general-term-derivation.html"/>
      <url>/posts/2019-06-22-fibonacci-sequence-general-term-derivation.html</url>
      
        <content type="html"><![CDATA[<p>Fibonacci sequence: $a_1 &#x3D; 1, a_2 &#x3D; 1, a_n &#x3D; a_{n-1} + a_{n-2}$</p><p>Derivation:</p><p>Let $a_n + x a_{n-1} &#x3D; y(a_{n-1} + x a_{n-2})$</p><p>$a_n + x a_{n - 1} &#x3D; y a_{n-1} + xya_{n-2}$</p><p>$a_{n} &#x3D; (y-x) a_{n-1} + x y a_{n-2}$</p><p>Then:</p><p>$\begin{cases} y - x &#x3D; 1 \ xy &#x3D; 1 \end{cases} \Rightarrow \begin{cases} x &#x3D; \frac{\sqrt{5} - 1}{2} \ y &#x3D; \frac{\sqrt{5} + 1}{2} \end{cases}$</p><p>$a_n + \frac{\sqrt{5} - 1}{2} a_{n-1} &#x3D;\frac{\sqrt{5} + 1}{2} (a_{n-1} + \frac{\sqrt{5} - 1}{2} a_{n-2})$</p><p>Let: $b_n &#x3D; a_n + \frac{\sqrt{5} - 1}{2} a_{n-1}$</p><p>Then: $b_n &#x3D; \frac{\sqrt{5}+1}{2}b_{n-1}$</p><p>And: $b_2 &#x3D; a_2 + \frac{\sqrt{5} - 1}{2} a_1 &#x3D; 1 + \frac{\sqrt{5} - 1}{2} &#x3D; \frac{\sqrt{5} + 1}{2}$</p><p>So: $b_n &#x3D; (\frac{\sqrt{5} + 1}{2}) ^ {n-1}$</p><p>$b_n &#x3D; \frac{(\frac{\sqrt{5} + 1}{2}) ^ {n-1} \sqrt{5}}{\sqrt{5}} \ &#x3D; \frac{(\frac{\sqrt{5} + 1}{2}) ^ {n-1} \frac{2\sqrt{5}}{2}}{\sqrt{5}} \ &#x3D; \frac{(\frac{\sqrt{5} + 1}{2}) ^ {n-1} (\frac{1 + \sqrt{5}}{2} - \frac{1 - \sqrt{5}}{2}))}{\sqrt{5}} \ &#x3D; \frac{(\frac{1 + \sqrt{5}}{2}) ^ {n} - (\frac{1 - \sqrt{5}}{2})(\frac{\sqrt{5} + 1}{2}) ^ {n-1}}{\sqrt{5}} &#x3D; \frac{(\frac{1 + \sqrt{5}}{2}) ^ {n}}{\sqrt{5}} - \frac{(\frac{1 - \sqrt{5}}{2})(\frac{1 + \sqrt{5}}{2}) ^ {n-1}}{\sqrt{5}}$</p><p>$\because b_n &#x3D; a_n + \frac{\sqrt{5} - 1}{2} a_{n-1}$</p><p>$\therefore a_n -\frac{(\frac{1 + \sqrt{5}}{2}) ^ {n}}{\sqrt{5}} &#x3D; \frac{1 - \sqrt{5}}{2} a_{n-1} - \frac{(\frac{1 - \sqrt{5}}{2})(\frac{1 + \sqrt{5}}{2})^{n-1}}{\sqrt{5}}$</p><p>$a_n -\frac{(\frac{1 + \sqrt{5}}{2}) ^ {n}}{\sqrt{5}} &#x3D; \frac{1 - \sqrt{5}}{2} ( a_{n-1} - \frac{(\frac{1 + \sqrt{5}}{2})^{n-1}}{\sqrt{5}} )$</p><p>Let: $C_n &#x3D; a_n - \frac{(\frac{1 + \sqrt{5}}{2}) ^ {n}}{\sqrt{5}}$</p><p>$C_1 &#x3D; a_1 - \frac{(\frac{1 + \sqrt{5}}{2}) ^ {1}}{\sqrt{5}} &#x3D; \frac{\sqrt{5} - 1}{2\sqrt{5}}$</p><p>$C_n &#x3D; \frac{\sqrt{5} - 1}{2\sqrt{5}} (\frac{1 - \sqrt{5}}{2})^{n-1}$</p><p>Then:</p><p>$a_n &#x3D; \frac{(\frac{1 + \sqrt{5}}{2}) ^ {n}}{\sqrt{5}} + C_n \ &#x3D; \frac{(\frac{1 + \sqrt{5}}{2}) ^ {n}}{\sqrt{5}} + \frac{\sqrt{5} - 1}{2\sqrt{5}} (\frac{1 - \sqrt{5}}{2})^{n-1} \ &#x3D; \frac{(\frac{1+\sqrt{5}}{2})^{n} - (\frac{1-\sqrt{5}}{2})^{n}}{\sqrt{5}}$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>So you want to be a functional programmer</title>
      <link href="/posts/2019-06-11-so-you-want-to-be-a-functional-programmer.html"/>
      <url>/posts/2019-06-11-so-you-want-to-be-a-functional-programmer.html</url>
      
        <content type="html"><![CDATA[<p>Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step. But it doesn’t have to be. Not with the right perspective.</p><h4 id="Learning-to-Drive"><a href="#Learning-to-Drive" class="headerlink" title="Learning to Drive"></a>Learning to Drive</h4><p>When we first learned to drive, we struggled. It sure looked easy when we saw other people doing it. But it turned out to be harder than we thought.</p><p>We practiced in our parent’s car and we really didn’t venture out on the highway until we had mastered the streets in our own neighborhood.</p><p>But through repeated practice and some panicky moments that our parents would like to forget, we learned to drive and we finally got our license.</p><p>With our license in hand, we’d take the car out any chance we could. With each trip, we got better and better and our confidence went up. Then came the day when we had to drive someone else’s car or our car finally gave up the ghost and we had to buy a new one.</p><p>What was it like that first time behind the wheel of a <strong>different car</strong>? Was it like the <strong>very first time</strong> behind the wheel? Not even close. The first time, it was all so foreign. We’ve been in a car before that, but only as a passenger. This time we were in the driver seat. The one with all the controls.</p><p>But when we drove our second car, we simply asked ourselves a few simple questions like, where does the key go, where are the lights, how do you use the turn signals and how do you adjust the side mirrors.</p><p>After that, it was pretty smooth sailing. But why was this time so easy compared to the first time?</p><p>That’s because the new car was pretty much like the old car. It had all the same basic things that a car needs and they were pretty much in the same place.</p><p>A few things were implemented differently and maybe it had a few additional features, but we didn’t use them the first time we drove or even the second. Eventually, we learned all the new features. At least the ones we cared about.</p><p>Well, learning programming languages is sort of like this. The first is the hardest. But once you have one under your belt, subsequent ones are easier.</p><p>When you first start a second language, you ask questions like, “How do I create a module? How do you search an array? What are the parameters of the substring function?”</p><p>You’re confident that you can learn to drive this new language because it reminds you of your old language with maybe a few new things to hopefully make your life easier.</p><h4 id="Your-First-Spaceship"><a href="#Your-First-Spaceship" class="headerlink" title="Your First Spaceship"></a>Your First Spaceship</h4><p>Whether you’ve been driving one car your whole life or dozens of cars, imagine that you’re about to get behind the wheel of a spaceship.</p><p>If you were going to fly a spaceship, you wouldn’t expect your driving ability on the road to help you much. You’d be starting over from square zero. (<em>We are programmers after all. We count starting at zero.</em>)</p><p>You would begin your training with the expectation that things are very different in space and that flying this contraption is very different than driving on the ground.</p><p>Physics hasn’t changed. Just the way you navigate within that same Universe.</p><p>And it’s the same with learning Functional Programming. You should expect that things will be very different. And that much of what you know about programming will <strong>not</strong> translate.</p><p>Programming is thinking and Functional Programming will teach you to think very differently. So much so, that you’ll probably never go back to the old way of thinking.</p><h4 id="Forget-Everything-You-Know"><a href="#Forget-Everything-You-Know" class="headerlink" title="Forget Everything You Know"></a>Forget Everything You Know</h4><p>People love saying this phrase, but it’s sort of true. <strong>Learning functional programming is like starting from scratch.</strong> Not completely, but effectively. There are lots of similar concepts but it’s best if you just expect that you have to <strong>relearn everything</strong>.</p><p>With the right perspective you’ll have the right expectations and with the right expectations you won’t quit when things get hard.</p><p>There are all kinds of things that you’re used to doing as a programmer that you cannot do any more with Functional Programming.</p><p>Just like in your car, you used to backup to get out of the driveway. But in a spaceship, there is no reverse. Now you may think, “WHAT? NO REVERSE?! HOW THE HELL AM I SUPPOSED TO DRIVE WITHOUT REVERSE?!”</p><p>Well, it turns out that you don’t need reverse in a spaceship because of its ability to maneuver in three dimensional space. Once you understand this, you’ll never miss reverse again. In fact, someday, you’ll think back at how limiting the car really was.</p><blockquote><p>Learning Functional Programming takes a while. So be patient.</p></blockquote><p>So let’s exit the cold world of Imperative Programming and take a gentle dip into the hot springs of Functional Programming.</p><p>What follows in this multi-part article are Functional Programming Concepts that will help you before you dive into your first Functional Language. Or if you’ve already taken the plunge, this will help round out your understanding.</p><p>Please don’t rush. Take your time reading from this point forward and take the time to understand the coding examples. You may even want to stop reading after each section to let the ideas sink in. Then return later to finish.</p><p>The most important thing is that you <strong>understand</strong>.</p><h4 id="Purity"><a href="#Purity" class="headerlink" title="Purity"></a>Purity</h4><p>When Functional Programmers talk of Purity, they are referring to Pure Functions.</p><p>Pure Functions are very simple functions. They only operate on their input parameters.</p><p>Here’s an example in Javascript of a Pure Function:</p><pre><code>var z = 10;function add(x, y) &#123;    return x + y;&#125;</code></pre><p>Notice that the <strong>add</strong> function does NOT touch the <strong>z</strong> variable. It doesn’t read from <strong>z</strong> and it doesn’t write to <strong>z</strong>. It only reads <strong>x</strong> and <strong>y</strong>, its inputs, and returns the result of adding them together.</p><p>That’s a pure function. If the <strong>add</strong> function did access <strong>z</strong>, it would no longer be pure.</p><p>Here’s another function to consider:</p><pre><code>function justTen() &#123;    return 10;&#125;</code></pre><p>If the function, <strong>justTen</strong>, is pure, then it can <em>only</em> return a constant. Why?</p><p>Because we haven’t given it any inputs. And since, to be pure, it cannot access anything other than its own inputs, the only thing it can return is a constant.</p><p>Since pure functions that take no parameters do no work, they aren’t very useful. It would be better if <strong>justTen</strong> was defined as a constant.</p><blockquote><p>Most <strong>useful</strong> Pure Functions must take at least one parameter.</p></blockquote><p>Consider this function:</p><pre><code>function addNoReturn(x, y) &#123;    var z = x + y&#125;</code></pre><p>Notice how this function doesn’t return anything. It adds <strong>x</strong> and <strong>y</strong> and puts it into a variable <strong>z</strong> but doesn’t return it.</p><p>It’s a pure function since it only deals with its inputs. It does add, but since it doesn’t return the results, it’s useless.</p><blockquote><p>All <strong>useful</strong> Pure Functions must return something.</p></blockquote><p>Let’s consider the first <strong>add</strong> function again:</p><pre><code>function add(x, y) &#123;    return x + y;&#125;console.log(add(1, 2)); // prints 3console.log(add(1, 2)); // still prints 3console.log(add(1, 2)); // WILL ALWAYS print 3</code></pre><p>Notice that <strong>add(1, 2)</strong> is always <strong>3</strong>. Not a huge surprise but only because the function is pure. If the <strong>add</strong> function used some outside value, then you could <strong>never</strong> predict its behavior.</p><blockquote><p>Pure Functions will <strong>always</strong> produce the same output given the same inputs.</p></blockquote><p>Since Pure Functions cannot change any external variables, all of the following functions are <strong>impure</strong>:</p><pre><code>writeFile(fileName);updateDatabaseTable(sqlCmd);sendAjaxRequest(ajaxRequest);openSocket(ipAddress);</code></pre><p>All of these function have what are called <strong>Side Effects</strong>. When you call them, they change files and database tables, send data to a server or call the OS to get a socket. They do more than just operate on their inputs and return outputs. Therefore, you can <em>never</em> predict what these functions will return.</p><blockquote><p>Pure functions have <strong>no</strong> side effects.</p></blockquote><p>In Imperative Programming Languages such as Javascript, Java, and C#, Side Effects are <strong>everywhere</strong>. This makes debugging very difficult because a variable can be changed <strong>anywhere</strong> in your program. So when you have a bug because a variable is changed to the wrong value at the wrong time, where do you look? Everywhere? That’s not good.</p><p>At this point, you’re probably thinking, “HOW THE HELL DO I DO ANYTHING WITH <strong>ONLY</strong> PURE FUNCTIONS?!”</p><p>In Functional Programming, you don’t just write Pure Functions.</p><p>Functional Languages cannot eliminate Side Effects, they can only confine them. Since programs have to interface to the real world, some parts of every program must be impure. The goal is to minimize the amount of impure code and segregate it from the rest of our program.</p><h4 id="Immutability"><a href="#Immutability" class="headerlink" title="Immutability"></a>Immutability</h4><p>Do you remember when you first saw the following bit of code:</p><pre><code>var x = 1;x = x + 1;</code></pre><p>And whoever was teaching you told you to forget what you learned in math class? In math, <strong>x</strong> can never be equal to <strong>x + 1</strong>.</p><p>But in Imperative Programming, it means, take the current value of <strong>x</strong> add <strong>1</strong> to it and put that result <em>back into</em> <strong>x</strong>.</p><p>Well, in functional programming, <strong>x &#x3D; x + 1</strong> is illegal. So you have to <strong>remember</strong> what you <strong>forgot</strong> in math… Sort of.</p><blockquote><p>There are <strong>no</strong> variables in Functional Programming.</p></blockquote><p>Stored values are still called variables because of history but they are constants, i.e. once <strong>x</strong> takes on a value, it’s that value for life.</p><p>Don’t worry, <strong>x</strong> is usually a local variable so its life is usually short. But while it’s alive, it can never change.</p><p>Here’s an example of constant variables in Elm, a Pure Functional Programming Language for Web Development:</p><pre><code>addOneToSum y z =    let        x = 1    in        x + y + z</code></pre><p>If you’re not familiar with ML-Style syntax, let me explain. <strong>addOneToSum</strong> is a function that takes 2 parameters, <strong>y</strong> and <strong>z</strong>.</p><p>Inside the <strong>let</strong> block, <strong>x</strong> is bound to the value of <strong>1</strong>, i.e. it’s equal to <strong>1</strong> for the rest of its life. Its life is over when the function exits or more accurately when the <strong>let</strong> block is evaluated.</p><p>Inside the <strong>in</strong> block, the calculation can include values defined in the <strong>let</strong> block, viz. <strong>x</strong>. The result of the calculation <strong>x + y + z</strong> is returned or more accurately, <strong>1 + y + z</strong> is returned since <strong>x &#x3D; 1</strong>.</p><p>Once again, I can hear you ask “HOW THE HELL AM I SUPPOSED TO DO ANYTHING WITHOUT VARIABLES?!”</p><p>Let’s think about when we want to modify variables. There are 2 general cases that come to mind: multi-valued changes (e.g. changing a single value of an object or record) and single-valued changes (e.g. loop counters).</p><p>Functional Programming deals with changes to values in a record by making a copy of the record with the values changed. It does this efficiently without having to copy all parts of the record by using data structures that makes this possible.</p><p>Functional programming solves the single-valued change in exactly the same way, by making a copy of it.</p><p>Oh, yes and by <strong>not</strong> having loops.</p><p>“WHAT NO VARIABLES AND NOW NO LOOPS?! I HATE YOU!!!”</p><p>Hold on. It’s not like we can’t do loops (no pun intended), it’s just that there are no specific loop constructs like <strong>for</strong>, <strong>while</strong>, <strong>do</strong>, <strong>repeat</strong>, etc.</p><blockquote><p>Functional Programming uses recursion to do looping.</p></blockquote><p>Here are two ways you can do loops in Javascript:</p><pre><code>// simple loop constructvar acc = 0;for (var i = 1; i &lt;= 10; ++i)    acc += i;console.log(acc); // prints 55// without loop construct or variables (recursion)function sumRange(start, end, acc) &#123;    if (start &gt; end)        return acc;    return sumRange(start + 1, end, acc + start)&#125;console.log(sumRange(1, 10, 0)); // prints 55</code></pre><p>Notice how recursion, the functional approach, accomplishes the same as the <strong>for</strong> loop by calling itself with a <em>new</em> start (<strong>start + 1</strong>) and a <em>new</em> accumulator (<strong>acc + start</strong>). It doesn’t modify the old values. Instead it uses new values calculated from the old.</p><p>Unfortunately, this is hard to see in Javascript even if you spend a little time studying it, for two reasons. One, the syntax of Javascript is noisy and two, you’re probably not used to thinking recursively.</p><p>In Elm, it’s easier to read and, therefore, understand:</p><pre><code>sumRange start end acc =    if start &gt; end then        acc    else        sumRange (start + 1) end (acc + start) </code></pre><p>Here’s how it runs:</p><pre><code>sumRange 1 10 0 =      -- sumRange (1 + 1)  10 (0 + 1)sumRange 2 10 1 =      -- sumRange (2 + 1)  10 (1 + 2)sumRange 3 10 3 =      -- sumRange (3 + 1)  10 (3 + 3)sumRange 4 10 6 =      -- sumRange (4 + 1)  10 (6 + 4)sumRange 5 10 10 =     -- sumRange (5 + 1)  10 (10 + 5)sumRange 6 10 15 =     -- sumRange (6 + 1)  10 (15 + 6)sumRange 7 10 21 =     -- sumRange (7 + 1)  10 (21 + 7)sumRange 8 10 28 =     -- sumRange (8 + 1)  10 (28 + 8)sumRange 9 10 36 =     -- sumRange (9 + 1)  10 (36 + 9)sumRange 10 10 45 =    -- sumRange (10 + 1) 10 (45 + 10)sumRange 11 10 55 =    -- 11 &gt; 10 =&gt; 5555</code></pre><p>You’re probably thinking that <strong>for</strong> loops are easier to understand. While that’s debatable and more likely an issue of <strong>familiarity</strong>, non-recursive loops require Mutability, which is bad.</p><p>I haven’t entirely explained the benefits of Immutability here but check out the <strong>Global Mutable State</strong> section in <a href="https://medium.com/@cscalfani/why-programmers-need-limits-3d96e1a0a6db">Why Programmers Need Limits</a> to learn more.</p><p>One obvious benefit is that if you have access to a value in your program, you only have read access, which means that no one else can change that value. Even you. So no accidental mutations.</p><p>Also, if your program is multi-threaded, then no other thread can pull the rug out from under you. That value is constant and if another thread wants to change it, it’ll have create a new value from the old one.</p><p>Back in the mid 90s, I wrote a Game Engine for <a href="https://www.youtube.com/watch?v=uIOYSjBRORM">Creature Crunch</a> and the biggest source of bugs was multithreading issues. I wish I knew about immutability back then. But back then I was more worried about the difference between a 2x or 4x speed CD-ROM drives on game performance.</p><blockquote><p>Immutability creates simpler and safer code.</p></blockquote><hr><p>Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step. But it doesn’t have to be. Not with the right perspective.</p><p>Previous parts: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">Part 1</a></p><h4 id="Friendly-Reminder"><a href="#Friendly-Reminder" class="headerlink" title="Friendly Reminder"></a>Friendly Reminder</h4><p>Please read through the code slowly. Make sure you understand it before moving on. Each section builds on top of the previous section.</p><p>If you rush, you may miss some nuance that will be important later.</p><h4 id="Refactoring"><a href="#Refactoring" class="headerlink" title="Refactoring"></a>Refactoring</h4><p>Let’s think about refactoring for a minute. Here’s some Javascript code:</p><pre><code>function validateSsn(ssn) &#123;    if (/^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/.exec(ssn))        console.log(&#39;Valid SSN&#39;);    else        console.log(&#39;Invalid SSN&#39;);&#125;function validatePhone(phone) &#123;    if (/^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/.exec(phone))        console.log(&#39;Valid Phone Number&#39;);    else        console.log(&#39;Invalid Phone Number&#39;);&#125;</code></pre><p>We’ve all written code like this before and over time, we start to recognize that these two functions are practically the same and only differ by a few things (shown in <strong>bold</strong>).</p><p>Instead of copying <strong>validateSsn</strong> and pasting and editing to create <strong>validatePhone</strong>, we should create a single function and parameterize the things that we edited after pasting.</p><p>In this example, we would parameterize the <strong>value</strong>, the <strong>regular expression</strong>and the <strong>message</strong> printed (at least the last part of the message printed).</p><p>The refactored code:</p><pre><code>function validateValue(value, regex, type) &#123;    if (regex.exec(value))        console.log(&#39;Invalid &#39; + type);    else        console.log(&#39;Valid &#39; + type);&#125;</code></pre><p>The parameters <strong>ssn</strong> and <strong>phone</strong> in the old code are now represented by <strong>value</strong>.</p><p>The regular expressions <strong>&#x2F;^\d{3}-\d{2}-\d{4}$&#x2F;</strong> and <strong>&#x2F;^(\d{3})\d{3}-\d{4}$&#x2F;</strong> are represented by <strong>regex</strong>.</p><p>And finally, the last part of the message <strong>‘SSN’</strong> and <strong>‘Phone Number’</strong> are represented by <strong>type</strong>.</p><p>Having one function is much better than having two functions. Or worse three, four or ten functions. This keeps your code clean and maintainable.</p><p>For example, if there’s a bug, you only have to fix it in one place versus searching through your whole codebase to find where this function MAY have been pasted and modified.</p><p>But what happens when you have the following situation:</p><pre><code>function validateAddress(address) &#123;    if (parseAddress(address))        console.log(&#39;Valid Address&#39;);    else        console.log(&#39;Invalid Address&#39;);&#125;function validateName(name) &#123;    if (parseFullName(name))        console.log(&#39;Valid Name&#39;);    else        console.log(&#39;Invalid Name&#39;);&#125;</code></pre><p>Here <strong>parseAddress</strong> and <strong>parseFullName</strong> are functions that take a <strong>string</strong> and return <strong>true</strong> if it parses.</p><p>How do we refactor this?</p><p>Well, we can use <strong>value</strong> for <strong>address</strong> and <strong>name,</strong> and <strong>type</strong> for <strong>‘Address’</strong> and<strong>‘Name’</strong> like we did before but there’s a function where our regular expression used to be.</p><p>If only we could pass a function as a parameter…</p><h4 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher-Order Functions"></a>Higher-Order Functions</h4><p>Many languages do not support passing functions as parameters. Some do but they don’t make it easy.</p><blockquote><p>In Functional Programming, a function is a first-class citizen of the language. In other words, a function is just another value.</p></blockquote><p>Since functions are just values, we can pass them as parameters.</p><p>Even though Javascript is not a Pure Functional language, you can do some functional operations with it. So here’s the last two functions refactored into a single function by passing the <strong>parsing function</strong> as a parameter called <strong>parseFunc</strong>:</p><pre><code>function validateValueWithFunc(value, parseFunc, type) &#123;    if (parseFunc(value))        console.log(&#39;Invalid &#39; + type);    else        console.log(&#39;Valid &#39; + type);&#125;</code></pre><p>Our new function is called a <strong>Higher-order Function</strong>.</p><blockquote><p>Higher-order Functions either take functions as parameters, return functions or both.</p></blockquote><p>Now we can call our higher-order function for the four previous functions (this works in Javascript because <strong>Regex.exec</strong> returns a truthy value when a match is found):</p><pre><code>validateValueWithFunc(&#39;123-45-6789&#39;, /^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/.exec, &#39;SSN&#39;);validateValueWithFunc(&#39;(123)456-7890&#39;, /^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/.exec, &#39;Phone&#39;);validateValueWithFunc(&#39;123 Main St.&#39;, parseAddress, &#39;Address&#39;);validateValueWithFunc(&#39;Joe Mama&#39;, parseName, &#39;Name&#39;);</code></pre><p>This is so much better than having four nearly identical functions.</p><p>But notice the regular expressions. They’re a bit verbose. Let’s clean up our a code by factoring them out:</p><pre><code>var parseSsn = /^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/.exec;var parsePhone = /^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/.exec;validateValueWithFunc(&#39;123-45-6789&#39;, parseSsn, &#39;SSN&#39;);validateValueWithFunc(&#39;(123)456-7890&#39;, parsePhone, &#39;Phone&#39;);validateValueWithFunc(&#39;123 Main St.&#39;, parseAddress, &#39;Address&#39;);validateValueWithFunc(&#39;Joe Mama&#39;, parseName, &#39;Name&#39;);</code></pre><p>That’s better. Now when we want to parse a phone number, we don’t have to copy and paste the regular expression.</p><p>But imagine we have more regular expressions to parse, not just <strong>parseSsn</strong> and <strong>parsePhone</strong>. Each time we create a regular expression parser, we have to remember to add the <strong>.exec</strong> to the end. And trust me, this is easy to forget.</p><p>We can guard against this by creating a high-order function that returns the <strong>exec</strong> function:</p><pre><code>function makeRegexParser(regex) &#123;    return regex.exec;&#125;var parseSsn = makeRegexParser(/^\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;$/);var parsePhone = makeRegexParser(/^\(\d&#123;3&#125;\)\d&#123;3&#125;-\d&#123;4&#125;$/);validateValueWithFunc(&#39;123-45-6789&#39;, parseSsn, &#39;SSN&#39;);validateValueWithFunc(&#39;(123)456-7890&#39;, parsePhone, &#39;Phone&#39;);validateValueWithFunc(&#39;123 Main St.&#39;, parseAddress, &#39;Address&#39;);validateValueWithFunc(&#39;Joe Mama&#39;, parseName, &#39;Name&#39;);</code></pre><p>Here, <strong>makeRegexParser</strong> takes a regular expression and returns the <strong>exec</strong>function, which takes a string. <strong>validateValueWithFunc</strong> will pass the string, <strong>value</strong>, to the parse function, i.e. <strong>exec</strong>.</p><p><strong>parseSsn</strong> and <strong>parsePhone</strong> are effectively the same as before, the regular expression’s <strong>exec</strong> function.</p><p>Granted, this is a marginal improvement but is shown here to give an example of a high-order function that returns a function.</p><p>However, you can imagine the benefits of making this change if <strong>makeRegexParser</strong> was much more complex.</p><p>Here’s another example of a higher-order function that returns a function:</p><pre><code>function makeAdder(constantValue) &#123;    return function adder(value) &#123;        return constantValue + value;    &#125;;&#125;</code></pre><p>Here we have <strong>makeAdder</strong> that takes <strong>constantValue</strong> and returns <strong>adder</strong>, a function that will add that constant to any value it gets passed.</p><p>Here’s how it can be used:</p><pre><code>var add10 = makeAdder(10);console.log(add10(20)); // prints 30console.log(add10(30)); // prints 40console.log(add10(40)); // prints 50</code></pre><p>We create a function, <strong>add10</strong>, by passing the constant <strong>10</strong> to <strong>makeAdder</strong> which returns a function that will add <strong>10</strong> to everything.</p><p>Notice that the function <strong>adder</strong> has access to <strong>constantValue</strong> even after <strong>makeAddr</strong> returns. That’s because <strong>constantValue</strong> was in its scope when <strong>adder</strong> was created.</p><p>This behavior is very important because without it, functions that return functions wouldn’t be very useful. So it’s important we understand how they work and what this behavior is called.</p><p>This behavior is called a <strong>Closure</strong>.</p><h4 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h4><p>Here’s a contrived example of functions that use closures:</p><pre><code>function grandParent(g1, g2) &#123;    var g3 = 3;    return function parent(p1, p2) &#123;        var p3 = 33;        return function child(c1, c2) &#123;            var c3 = 333;            return g1 + g2 + g3 + p1 + p2 + p3 + c1 + c2 + c3;        &#125;;    &#125;;&#125;</code></pre><p>In this example, <strong>child</strong> has access to its variables, the <strong>parent’s</strong> variables and the <strong>grandParent’s</strong> variables.</p><p>The <strong>parent</strong> has access to its variables and <strong>grandParent’s</strong> variables.</p><p>The <strong>grandParent</strong> only has access to its variables.</p><p>(See pyramid above for clarification.)</p><p>Here’s an example of its use:</p><pre><code>var parentFunc = grandParent(1, 2); // returns parent()var childFunc = parentFunc(11, 22); // returns child()console.log(childFunc(111, 222)); // prints 738// 1 + 2 + 3 + 11 + 22 + 33 + 111 + 222 + 333 == 738</code></pre><p>Here, <strong>parentFunc</strong> keeps the <strong>parent’s</strong> scope alive since <strong>grandParent</strong> returns <strong>parent</strong>.</p><p>Similarly, <strong>childFunc</strong> keeps the <strong>child’s</strong> scope alive since <strong>parentFunc,</strong> which is just <strong>parent,</strong> returns <strong>child</strong>.</p><p>When a function is created, all of the variables in its scope <strong>at the time of creation</strong> are accessible to it for the lifetime of the function. A function exists as long as there still a reference to it. For example, <strong>child</strong>’s scope exists as long as <strong>childFunc</strong> still references it.</p><blockquote><p>A closure is a function’s scope that’s kept alive by a reference to that function.</p></blockquote><p>Note that in Javascript, closures are problematic since the variables are mutable, i.e. they can change values from the time they were <em>closed over</em> to the time the returned function is called.</p><p>Thankfully, variables in Functional Languages are Immutable eliminating this common source of bugs and confusion.</p><hr><p>Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step. But it doesn’t have to be. Not with the right perspective.</p><p>Previous parts: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">Part 1</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">Part 2</a></p><h4 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h4><p>As programmers, we are lazy. We don’t want to build, test and deploy code that we’ve written over and over and over again.</p><p>We’re always trying to figure out ways of doing the work once and how we can reuse it to do something else.</p><p>Code reuse sounds great but is difficult to achieve. Make the code too specific and you can’t reuse it. Make it too general and it can be too difficult to use in the first place.</p><p>So what we need is a balance between the two, a way to make smaller, reusable pieces that we can use as building blocks to construct more complex functionality.</p><p>In Functional Programming, functions are our building blocks. We write them to do very specific tasks and then we put them together like Lego™ blocks.</p><p>This is called <strong>Function Composition</strong>.</p><p>So how does it work? Let’s start with two Javascript functions:</p><pre><code>var add10 = function(value) &#123;    return value + 10;&#125;;var mult5 = function(value) &#123;    return value * 5;&#125;;</code></pre><p>This is too verbose so let’s rewrite it using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions"><strong>fat arrow</strong></a> notation:</p><pre><code>var add10 = value =&gt; value + 10;var mult5 = value =&gt; value * 5;</code></pre><p>That’s better. Now let’s imagine that we also want to have a function that takes a value and adds 10 to it and then multiplies the result by 5. We <em>could</em>write:</p><pre><code>var mult5AfterAdd10 = value =&gt; 5 * (value + 10)</code></pre><p>Even though this is a very simple example, we still don’t want to have to write this function from scratch. First, we could make a mistake like forget the parentheses.</p><p>Second, we already have a function that adds 10 and another that multiplies by 5. We’re writing code that we’ve already written.</p><p>So instead, let’s use <strong>add10</strong> and <strong>mult5</strong> to build our new function:</p><pre><code>var mult5AfterAdd10 = value =&gt; mult5(add10(value));</code></pre><p>We just used existing functions to create <strong>mult5AfterAdd10</strong>, but there’s a better way.</p><p>In math, <strong>f ∘ g</strong> is functional composition and is read <strong>“f composed with g”</strong> or, more commonly, <strong>“f after g”</strong>. So <strong>(f ∘ g)(x)</strong> is equivalent to calling <strong>f</strong> after calling <strong>g</strong> with <strong>x</strong> or simply, <strong>f(g(x))</strong>.</p><p>In our example, we have <strong>mult5 ∘ add10</strong> or <strong>“mult5 after add10”</strong>, hence the name of our function, <strong>mult5AfterAdd10</strong>.</p><p>And that’s exactly what we did. We called <strong>mult5</strong> after we called <strong>add10</strong> with <strong>value</strong> or simply, <strong>mult5(add10(value))</strong>.</p><p>Since Javascript doesn’t do Function Composition natively, let’s look at Elm:</p><pre><code>add10 value =    value + 10mult5 value =    value * 5mult5AfterAdd10 value =    (mult5 &lt;&lt; add10) value</code></pre><p>The <strong>&lt;&lt;</strong> infixed operator is how you <em>compose</em> functions in Elm. It gives us a visual sense of how the data is flowing. First, <strong>value</strong> is passed to <strong>add10</strong> then its results are passed to <strong>mult5</strong>.</p><p>Note the parentheses in <strong>mult5AfterAdd10</strong>, i.e. <strong>(mult5 &lt;&lt; add10)</strong>. They are there to make sure that the functions are composed first before applying <strong>value</strong>.</p><p>You can compose as many functions as you like this way:</p><pre><code>f x =   (g &lt;&lt; h &lt;&lt; s &lt;&lt; r &lt;&lt; t) x</code></pre><p>Here <strong>x</strong> is passed to function <strong>t</strong> whose result is passed to <strong>r</strong> whose result is passed to <strong>s</strong> and so on. If you did something similar in Javascript it would look like <strong>g(h(s(r(t(x)))))</strong>, a parenthetical nightmare</p><h4 id="Point-Free-Notation"><a href="#Point-Free-Notation" class="headerlink" title="Point-Free Notation"></a>Point-Free Notation</h4><p>There is a style of writing functions without having to specify the parameters called <strong>Point-Free Notation</strong>. At first, this style will seem odd but as you continue, you’ll grow to appreciate the brevity.</p><p>In <strong>mult5AfterAdd10</strong>, you’ll notice that <strong>value</strong> is specified twice. Once in the parameter list and once when it’s used.</p><pre><code>-- This is a function that expects 1 parametermult5AfterAdd10 value =    (mult5 &lt;&lt; add10) value</code></pre><p>But this parameter is unnecessary since <strong>add10,</strong> the rightmost function in the composition, expects the same parameter. The following point-free version is equivalent:</p><pre><code>-- This is also a function that expects 1 parametermult5AfterAdd10 =    (mult5 &lt;&lt; add10)</code></pre><p>There are many benefits from using the point-free version.</p><p>First, we don’t have to specify redundant parameters. And since we don’t have to specify them, we don’t have to think up names for all of them.</p><p>Second, it’s easier to read and reason about since it’s less verbose. This example is simple, but imagine a function that took more parameters.</p><h4 id="Trouble-in-Paradise"><a href="#Trouble-in-Paradise" class="headerlink" title="Trouble in Paradise"></a>Trouble in Paradise</h4><p>So far we’ve seen how Function Composition works and how we should specify our functions in Point-Free Notation for brevity, clarity and flexibility.</p><p>Now, let’s try to use these ideas in a slightly different scenario and see how they fare. Imagine we replace <strong>add10</strong> with <strong>add</strong>:</p><pre><code>add x y =    x + ymult5 value =    value * 5</code></pre><p>How do we write <strong>mult5After10</strong> with just these 2 functions?</p><p>Think about it for a bit before reading on. No seriously. Think about. Try and do it.</p><p>Okay, so if you actually spent time thinking about it, you may have come up with a solution like:</p><pre><code>-- This is wrong !!!!mult5AfterAdd10 =    (mult5 &lt;&lt; add) 10 </code></pre><p>But this wouldn’t work. Why? Because <strong>add</strong> takes 2 parameters.</p><p>If this isn’t obvious in Elm, try to write this in Javascript:</p><pre><code>var mult5AfterAdd10 = mult5(add(10)); // this doesn&#39;t work</code></pre><p>This code is wrong but why?</p><p>Because the <strong>add</strong> function is only getting 1 of its 2 parameters here then its <em>incorrect results</em> are passed to <strong>mult5</strong>. This will produce the wrong results.</p><p>In fact, in Elm, the compiler won’t even let you write such mis-formed code (which is one of the great things about Elm).</p><p>Let’s try again:</p><pre><code>var mult5AfterAdd10 = y =&gt; mult5(add(10, y)); // not point-free</code></pre><p>This isn’t point-free but I could probably live with this. But now I’m no longer just combining functions. I’m writing a new function. Also, if this gets more complicated, e.g. if I want to compose <strong>mult5AfterAdd10</strong> with something else, I’m going to get into real trouble.</p><p>So it would appear that Function Composition has limited usefulness since we cannot marry these two functions. That’s too bad since it’s so powerful.</p><p>How could we solve this? What would we need to make this problem go away?</p><p>Well, what would be really great is if we had some way of giving our <strong>add</strong>function only one of its parameters <em>ahead of time</em> and then it would get its second parameter <em>later</em> when <strong>mult5AfterAdd10</strong> is called.</p><p>Turns out there is way and it’s called <strong>Currying</strong>.</p><hr><p>Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step. But it doesn’t have to be. Not with the right perspective.</p><p>Previous parts: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">Part 1</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">Part 2</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">Part 3</a></p><h4 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h4><p>If you remember from <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">Part 3</a>, the reason that we were having problems composing <strong>mult5</strong> and <strong>add</strong> (in ) is because <strong>mult5</strong> takes 1 parameter and <strong>add</strong>takes 2.</p><p>We can solve this easily by just restricting all functions to take only 1 parameter.</p><p>Trust me. It’s not as bad as it sounds.</p><p>We simply write an add function that uses 2 parameters but only takes 1 parameter at a time. <strong>Curried</strong> functions allow us to do this.</p><blockquote><p>A Curried Function is a function that only takes a single parameter at a time.</p></blockquote><p>This will let us give <strong>add</strong> its first parameter before we compose it with <strong>mult5</strong>. Then when <strong>mult5AfterAdd10</strong> is called, <strong>add</strong> will get its second parameter.</p><p>In Javascript, we can accomplish this by rewriting <strong>add</strong>:</p><pre><code>var add = x =&gt; y =&gt; x + y</code></pre><p>This version of <strong>add</strong> is a function that takes one parameter now and then another one later.</p><p>In detail, the <strong>add</strong> function takes a single parameter, <strong>x</strong>, and returns a <strong>function</strong>that takes a single parameter, <strong>y</strong>, which will ultimately return the <strong>result of adding x and y</strong>.</p><p>Now we can use this version of <strong>add</strong> to build a working version of <strong>mult5AfterAdd10</strong>:</p><pre><code>var compose = (f, g) =&gt; x =&gt; f(g(x));var mult5AfterAdd10 = compose(mult5, add(10));</code></pre><p>The compose function takes 2 parameters, <strong>f</strong> and <strong>g</strong>. Then it returns a function that takes 1 parameter, <strong>x</strong>, which when called will apply <strong>f after g</strong> to <strong>x</strong>.</p><p>So what did we do exactly? Well, we converted our plain old <strong>add</strong> function into a curried version. This made <strong>add</strong> more flexible since the first parameter, 10, can be passed to it up front and the final parameter will be passed when <strong>mult5AfterAdd10</strong> is called.</p><p>At this point, you may be wondering how to rewrite the add function in Elm. Turns out, you don’t have to. In Elm and other Functional Languages, all functions are curried automatically.</p><p>So the <strong>add</strong> function looks the same:</p><pre><code>add x y =    x + y</code></pre><p>This is how <strong>mult5AfterAdd10</strong> should have been written back in <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">Part 3</a>:</p><pre><code>mult5AfterAdd10 =    (mult5 &lt;&lt; add 10)</code></pre><p>Syntactically speaking, Elm beats Imperative Languages like Javascript because it’s been optimized for Functional things like currying and composition.</p><h4 id="Currying-and-Refactoring"><a href="#Currying-and-Refactoring" class="headerlink" title="Currying and Refactoring"></a>Currying and Refactoring</h4><p>Another time currying shines is during refactoring when you create a generalized version of a function with lots of parameters and then use it to create specialized versions with fewer parameters.</p><p>For example, when we have the following functions that put brackets and double brackets around strings:</p><pre><code>bracket str =    &quot;&#123;&quot; ++ str ++ &quot;&#125;&quot;doubleBracket str =    &quot;&#123;&#123;" ++ str ++ "&#125;&#125;&quot;</code></pre><p>Here’s how we’d use it:</p><pre><code>bracketedJoe =    bracket &quot;Joe&quot;doubleBracketedJoe =    doubleBracket &quot;Joe&quot;</code></pre><p>We can generalize <strong>bracket</strong> and <strong>doubleBracket</strong>:</p><pre><code>generalBracket prefix str suffix =    prefix ++ str ++ suffix</code></pre><p>But now every time we use <strong>generalBracket</strong> we have to pass in the brackets:</p><pre><code>bracketedJoe =    generalBracket &quot;&#123;&quot; &quot;Joe&quot; &quot;&#125;&quot;doubleBracketedJoe =    generalBracket &quot;&#123;&#123;" "Joe" "&#125;&#125;&quot;</code></pre><p>What we really want is the best of both worlds.</p><p>If we reorder the parameters of <strong>generalBracket</strong>, we can create <strong>bracket</strong> and <strong>doubleBracket</strong> by leveraging the fact that functions are curried:</p><pre><code>generalBracket prefix suffix str =    prefix ++ str ++ suffixbracket =    generalBracket &quot;&#123;&quot; &quot;&#125;&quot;doubleBracket =    generalBracket &quot;&#123;&#123;" "&#125;&#125;&quot;</code></pre><p>Notice that by putting the parameters that were most likely to be static first, i.e. <strong>prefix</strong> and <strong>suffix,</strong> and putting the parameters that were most likely to change last, i.e. <strong>str</strong>, we can easily create specialized versions of <strong>generalBracket</strong>.</p><blockquote><p>Parameter order is important to fully leverage currying.</p></blockquote><p>Also, notice that <strong>bracket</strong> and <strong>doubleBracket</strong> are written in point-free notation, i.e. the <strong>str</strong> parameter is implied. Both <strong>bracket</strong> and <strong>doubleBracket</strong>are functions waiting for their final parameter.</p><p>Now we can use it just like before:</p><pre><code>bracketedJoe =    bracket &quot;Joe&quot;doubleBracketedJoe =    doubleBracket &quot;Joe&quot;</code></pre><p>But this time we’re using a generalized curried function, <strong>generalBracket</strong>.</p><h4 id="Common-Functional-Functions"><a href="#Common-Functional-Functions" class="headerlink" title="Common Functional Functions"></a>Common Functional Functions</h4><p>Let’s look at 3 common functions that are used in Functional Languages.</p><p>But first, let’s look at the following Javascript code:</p><pre><code>for (var i = 0; i &lt; something.length; ++i) &#123;    // do stuff&#125;</code></pre><p>There’s one major thing wrong with this code. It’s not a bug. The problem is that this code is boilerplate code, i.e. code that is written over and over again.</p><p>If you code in Imperative Languages like Java, C#, Javascript, PHP, Python, etc., you’ll find yourself writing this boilerplate code more than any other.</p><p>That’s what’s wrong with it.</p><p>So let’s kill it. Let’s put it in a function (or a couple of functions) and never write a for-loop again. Well, almost never; at least until we move to a Functional Language.</p><p>Let’s start with modifying an array called <strong>things</strong>:</p><pre><code>var things = [1, 2, 3, 4];for (var i = 0; i &lt; things.length; ++i) &#123;    things[i] = things[i] * 10; // MUTATION ALERT !!!!&#125;console.log(things); // [10, 20, 30, 40]</code></pre><p>UGH!! Mutability!</p><p>Let’s try that again. This time we won’t mutate <strong>things</strong>:</p><pre><code>var things = [1, 2, 3, 4];var newThings = [];for (var i = 0; i &lt; things.length; ++i) &#123;    newThings[i] = things[i] * 10;&#125;console.log(newThings); // [10, 20, 30, 40]</code></pre><p>Okay, so we didn’t mutate <strong>things</strong> but technically we mutated <strong>newThings</strong>. For now, we’re going to overlook this. We are in Javascript after all. Once we move to a Functional Language, we won’t be able to mutate.</p><p>The point here is to understand how these functions work and help us to reduce noise in our code.</p><p>Let’s take this code and put it in a function. We’re going to call our first common function <strong>map</strong> since it maps each value in the old array to new values in the new array:</p><pre><code>var map = (f, array) =&gt; &#123;    var newArray = [];    for (var i = 0; i &lt; array.length; ++i) &#123;        newArray[i] = f(array[i]);    &#125;    return newArray;&#125;;</code></pre><p>Notice the function, <strong>f</strong>, is passed in so that our <strong>map</strong> function can do anything we want to each item of the <strong>array</strong>.</p><p>Now we can call rewrite our previous code to use <strong>map</strong>:</p><pre><code>var things = [1, 2, 3, 4];var newThings = map(v =&gt; v * 10, things);</code></pre><p>Look ma. No for-loops. And much easier to read and therefore reason about.</p><p>Well, technically, there are for-loops in the <strong>map</strong> function. But at least we don’t have to write that boilerplate code anymore.</p><p>Now let’s write another common function to <strong>filter</strong> things from an array:</p><pre><code>var filter = (pred, array) =&gt; &#123;    var newArray = [];for (var i = 0; i &lt; array.length; ++i) &#123;        if (pred(array[i]))            newArray[newArray.length] = array[i];    &#125;    return newArray;&#125;;</code></pre><p>Notice how the predicate function, <strong>pred</strong>, returns TRUE if we keep the item or FALSE if we toss it.</p><p>Here’s how to use <strong>filter</strong> to filter odd numbers:</p><pre><code>var isOdd = x =&gt; x % 2 !== 0;var numbers = [1, 2, 3, 4, 5];var oddNumbers = filter(isOdd, numbers);console.log(oddNumbers); // [1, 3, 5]</code></pre><p>Using our new <strong>filter</strong> function is so much simpler than hand-coding it with a for-loop.</p><p>The final common function is called <strong>reduce</strong>. Typically, it’s used to take a list and reduce it to a single value but it can actually do so much more.</p><p>This function is usually called <strong>fold</strong> in Functional Languages.</p><pre><code>var reduce = (f, start, array) =&gt; &#123;    var acc = start;    for (var i = 0; i &lt; array.length; ++i)        acc = f(array[i], acc); // f() takes 2 parameters    return acc;&#125;);</code></pre><p>The <strong>reduce</strong> function takes a reduction function, <strong>f</strong>, an initial <strong>start</strong> value and an <strong>array</strong>.</p><p>Notice that the reduction function, <strong>f</strong>, takes 2 parameters, the current item of the <strong>array</strong>, and the accumulator, <strong>acc</strong>. It will use these parameters to produce a new accumulator each iteration. The accumulator from the final iteration is returned.</p><p>An example will help us understand how it works:</p><pre><code>var add = (x, y) =&gt; x + y;var values = [1, 2, 3, 4, 5];var sumOfValues = reduce(add, 0, values);console.log(sumOfValues); // 15</code></pre><p>Notice that the <strong>add</strong> function takes 2 parameters and adds them. Our <strong>reduce</strong>function expects a function that takes 2 parameters so they work well together.</p><p>We start with a <strong>start</strong> value of zero and pass in our array, <strong>values</strong>, to be summed. Inside the <strong>reduce</strong> function, the sum is accumulated as it iterates over <strong>values</strong>. The final accumulated value is returned as <strong>sumOfValues</strong>.</p><p>Each of these functions, <strong>map</strong>, <strong>filter</strong> and <strong>reduce</strong> let us do common manipulation operations on arrays without having to write boilerplate for-loops.</p><p>But in Functional Languages, they are even more useful since there are no loop constructs just recursion. Iteration functions aren’t just extremely helpful. They’re necessary.</p><hr><p>Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step. But it doesn’t have to be. Not with the right perspective.</p><p>Previous parts: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">Part 1</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">Part 2</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">Part 3</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">Part 4</a></p><h4 id="Referential-Transparency"><a href="#Referential-Transparency" class="headerlink" title="Referential Transparency"></a>Referential Transparency</h4><p><strong>Referential Transparency</strong> is a fancy term to describe that a pure function can safely be replaced by its expression. An example will help illustrate this.</p><p>In Algebra when you had the following formula:</p><pre><code>y = x + 10</code></pre><p>And were told:</p><pre><code>x = 3</code></pre><p>You could substituted <strong>x</strong> back into the equation to get:</p><pre><code>y = 3 + 10</code></pre><p>Notice that the equation is still valid. We can do the same kind of substitution with pure functions.</p><p>Here’s a function in Elm that puts single quotes around the supplied string:</p><pre><code>quote str =    &quot;&#39;&quot; ++ str ++ &quot;&#39;&quot;</code></pre><p>And here’s some code that uses it:</p><pre><code>findError key =    &quot;Unable to find &quot; ++ (quote key)</code></pre><p>Here <strong>findError</strong> builds an error message when a search for <strong>key</strong> is unsuccessful.</p><p>Since the <strong>quote</strong> function is pure, we can simply replace the function call in <strong>findError</strong> with the body of the <strong>quote</strong> function (which is just an expression):</p><pre><code>findError key =   &quot;Unable to find &quot; ++ (&quot;&#39;&quot; ++ str ++ &quot;&#39;&quot;)</code></pre><p>This is what I call <strong>Reverse Refactoring</strong> (which makes more sense to me), a process that can be used by programmers or programs (e.g. compilers and test programs) to reason about code.</p><p>This can be especially helpful when reasoning about recursive functions.</p><h4 id="Execution-Order"><a href="#Execution-Order" class="headerlink" title="Execution Order"></a>Execution Order</h4><p>Most programs are single-threaded, i.e. one and only one piece of code is being executed at a time. Even if you have a multithreaded program, most of the threads are blocked waiting for I&#x2F;O to complete, e.g. file, network, etc.</p><p>This is one reason why we naturally think in terms of ordered steps when we write code:</p><pre><code>1. Get out the bread2. Put 2 slices into the toaster3. Select darkness4. Push down the lever5. Wait for toast to pop up6. Remove toast7. Get out the butter8. Get a butter knife9. Butter toast</code></pre><p>In this example, there are two independent operations: getting butter and toasting bread. They only become interdependent at step 9.</p><p>We could do steps 7 and 8 concurrently with steps 1 through 6 since they are independent from one another.</p><p>But the minute we do this, things get complicated:</p><pre><code>Thread 1--------1. Get out the bread2. Put 2 slices into the toaster3. Select darkness4. Push down the lever5. Wait for toast to pop up6. Remove toastThread 2--------1. Get out the butter2. Get a butter knife3. Wait for Thread 1 to complete4. Butter toast</code></pre><p>What happens to Thread 2 if Thread 1 fails? What is the mechanism to coordinate both threads? Who owns the toast: Thread 1, Thread 2 or both?</p><p>It’s easier to not think about these complexities and leave our program single threaded.</p><p>But when it’s worth squeezing out every possible efficiency of our program, then we must take on the monumental effort to write multithreading software.</p><p>However, there are 2 main problems with multithreading. First, multithreaded programs are difficult to write, read, reason about, test and debug.</p><p>Second, some languages, e.g. Javascript, don’t support multithreading and those that do, support it badly.</p><p>But what if order didn’t matter and everything was executed in parallel?</p><p>While this sounds crazy, it’s not as chaotic as it sounds. Let’s look at some Elm code to illustrate this:</p><pre><code>buildMessage message value =    let        upperMessage =            String.toUpper message        quotedValue =            &quot;&#39;&quot; ++ value ++ &quot;&#39;&quot;    in        upperMessage ++ &quot;: &quot; ++ quotedValue</code></pre><p>Here <strong>buildMessage</strong> takes <strong>message</strong> and <strong>value</strong> then produces an uppercased <strong>message,</strong> a colon and <strong>value</strong> in single quotes.</p><p>Notice how <strong>upperMessage</strong> and <strong>quotedValue</strong> are independent. How do we know this?</p><p>There are 2 things that must be true for independence. First, they must be pure functions. This is important because they must not be affected by the execution of the other.</p><p>If they were not pure, then we could never know that they’re independent. In that case, we’d have to rely on the order that they were called in the program to determine their execution order. This is how all Imperative Languages work.</p><p>The second thing that must be true for independence is that the output of one function is not used as the input of the other. If this was the case, then we’d have to wait for one to finish before starting the second.</p><p>In this case, <strong>upperMessage</strong> and <strong>quotedValue</strong> are both pure and neither requires the output of the other.</p><p>Therefore, these 2 functions can be executed in ANY ORDER.</p><p>The compiler can make this determination without any help from the programmer. This is only possible in a Pure Functional Language because it’s very difficult, if not impossible, to determine the ramifications of side-effects.</p><blockquote><p>The order of execution in a Pure Functional Language can be determined by the compiler.</p></blockquote><p>This is extremely advantageous considering that CPUs are not getting faster. Instead, manufactures are adding more and more cores. This means that code can execute in parallel at the hardware level.</p><p>Unfortunately, with Imperative Languages, we cannot take full advantage of these cores except at a very coarse level. But to do so requires drastically changing the architecture of our programs.</p><p>With Pure Functional Languages, we have the potential to take advantage of the CPU cores at a fine grained level automatically without changing a single line of code.</p><h4 id="Type-Annotations"><a href="#Type-Annotations" class="headerlink" title="Type Annotations"></a>Type Annotations</h4><p>In Statically Typed Languages, types are defined inline. Here’s some Java code to illustrate:</p><pre><code>public static String quote(String str) &#123;    return &quot;&#39;&quot; + str + &quot;&#39;&quot;;&#125;</code></pre><p>Notice how the typing is inline with the function definition. It gets even worse when you have generics:</p><pre><code>private final Map&lt;Integer, String&gt; getPerson(Map&lt;String, String&gt; people, Integer personId) &#123;   // ...&#125;</code></pre><p>I’ve bolded the types which makes them stand out but they still interfere with the function definition. You have to read it carefully to find the names of the variables.</p><p>With Dynamically Typed Languages, this is not a problem. In Javascript, we can write code like:</p><pre><code>var getPerson = function(people, personId) &#123;    // ...&#125;;</code></pre><p>This is so much easier to read without all of that nasty type information getting in the way. The only problem is that we give up the safety of typing. We could easily pass in these parameters backwards, i.e. a <em>Number</em> for <strong>people</strong>and an <em>Object</em> for <strong>personId</strong>.</p><p>We wouldn’t find out until the program executed, which could be months after we put it into production. This would not be the case in Java since it wouldn’t compile.</p><p>But what if we could have the best of both worlds. The syntactical simplicity of Javascript with the safety of Java.</p><p>It turns out that we can. Here’s a function in Elm with Type Annotations:</p><pre><code>add : Int -&gt; Int -&gt; Intadd x y =    x + y</code></pre><p>Notice how the type information is on a separate line. This separation makes a world of difference.</p><p>Now you may think that the type annotation has a typo. I know I did when I first saw it. I thought that the first <strong>-&gt;</strong> should be a comma. But there’s no typo.</p><p>When you see it with the implied parentheses it makes a bit more sense:</p><pre><code>add : Int -&gt; (Int -&gt; Int)</code></pre><p>This says that <strong>add</strong> is a function that takes a <em>single</em> parameter of type <strong>Int</strong> and returns a function that takes a <em>single</em> parameter <strong>Int</strong> and returns an <strong>Int</strong>.</p><p>Here’s another type annotation with the implied parentheses shown:</p><pre><code>doSomething : String -&gt; (Int -&gt; (String -&gt; String))doSomething prefix value suffix =    prefix ++ (toString value) ++ suffix</code></pre><p>This says that <strong>doSomething</strong> is a function that takes a <em>single</em> parameter of type <strong>String</strong> and returns a function that takes a <em>single</em> parameter of type <strong>Int</strong> and returns a function that takes a single parameter of type <strong>String</strong> and returns a <strong>String</strong>.</p><p>Notice how everything takes a <em>single</em> parameter. That’s because every function is curried in Elm.</p><p>Since parentheses are always implied to the right, they are not necessary. So we can simply write:</p><pre><code>doSomething : String -&gt; Int -&gt; String -&gt; String</code></pre><p>Parentheses are necessary when we pass functions as parameters. Without them, the type annotation would be ambiguous. For example:</p><pre><code>takes2Params : Int -&gt; Int -&gt; Stringtakes2Params num1 num2 =    -- do something</code></pre><p>is very different from:</p><pre><code>takes1Param : (Int -&gt; Int) -&gt; Stringtakes1Param f =    -- do something</code></pre><p><strong>takes2Param</strong> is a function that requires 2 parameters, an <strong>Int</strong> and another <strong>Int</strong>. Whereas, <strong>takes1Param</strong> requires 1 parameters a function that takes an <strong>Int</strong> and another <strong>Int</strong>.</p><p>Here’s the type annotation for <strong>map</strong>:</p><pre><code>map : (a -&gt; b) -&gt; List a -&gt; List bmap f list =    // ...</code></pre><p>Here parentheses are required because <strong>f</strong> is of type <strong>(a -&gt; b)</strong>, i.e. a function that takes a single parameter of type <strong>a</strong> and returns something of type <strong>b</strong>.</p><p>Here type <strong>a</strong> is any type. When a type is uppercased, it’s an explicit type, e.g. <strong>String</strong>. When a type is lowercased, it can be any type. Here <strong>a</strong> can be <strong>String</strong>but it could also be <strong>Int</strong>.</p><p>If you see <strong>(a -&gt; a)</strong> then that says that the input type and the output type MUST be the same. It doesn’t matter what they are but they must match.</p><p>But in the case of <strong>map</strong>, we have <strong>(a -&gt; b)</strong>. That means that it CAN return a different type but it COULD also return the same type.</p><p>But once the type for <strong>a</strong> is determined, <strong>a</strong> must be that type for the whole signature. For example, if <strong>a</strong> is <strong>Int</strong> and <strong>b</strong> is <strong>String</strong> then the signature is equivalent to:</p><pre><code>(Int -&gt; String) -&gt; List Int -&gt; List String</code></pre><p>Here all of the <strong>a</strong>’s have been replaced with <strong>Int</strong> and all of the <strong>b</strong>’s have been replaced with <strong>String</strong>.</p><p>The <strong>List Int</strong> type means that a list contains <strong>Int</strong>s and <strong>List String</strong> means that a list contains <strong>String</strong>s. If you’ve used generics in Java or other languages then this concept should be familiar.</p><hr><p>Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step. But it doesn’t have to be. Not with the right perspective.</p><p>Previous parts: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">Part 1</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-2-7005682cec4a">Part 2</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">Part 3</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">Part 4</a>, <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">Part 5</a></p><h4 id="Now-What"><a href="#Now-What" class="headerlink" title="Now What?"></a>Now What?</h4><p>Now that you’ve learned all this great new stuff, you’re probably thinking, “Now what? How can I use this in my everyday programming?”</p><p>It depends. If you can program in a Pure Functional Language like Elm or Haskell, then you can leverage all of these ideas. And these languages make it easy to do so.</p><p>If you can only program in an Imperative Language like Javascript, as many of us must, then you can still use a lot of what you’ve learned but there will be a great deal more discipline required.</p><h4 id="Functional-Javascript"><a href="#Functional-Javascript" class="headerlink" title="Functional Javascript"></a>Functional Javascript</h4><p>Javascript has many features that let you program in a more functional manner. It’s not pure but you can get some immutability in the language and even more with libraries.</p><p>It’s not ideal, but if you have to use it, then why not gain some of the benefits of a Functional Language?</p><p><strong>Immutability</strong></p><p>The first thing to consider is immutability. In ES2015, or ES6 as it was called, there is a new keyword called <strong>const</strong>. This means that once a variable is set, it cannot be reset:</p><pre><code>const a = 1;a = 2; // this will throw a TypeError in Chrome, Firefox or Node       // but not in Safari (circa 10/2016)</code></pre><p>Here <strong>a</strong> is defined to be a constant and therefore cannot be changed once set. This is why <strong>a &#x3D; 2</strong> throws an exception (except for Safari).</p><p>The problem with <strong>const</strong> in Javascript is that it doesn’t go far enough. The following example illustrates its limits:</p><pre><code>const a = &#123;    x: 1,    y: 2&#125;;a.x = 2; // NO EXCEPTION!a = &#123;&#125;; // this will throw a TypeError</code></pre><p>Notice how <strong>a.x &#x3D; 2</strong> does NOT throw an exception. The only thing that’s immutable with the <strong>const</strong> keyword is the variable <strong>a</strong>. Anything that <strong>a</strong> points to can be mutated.</p><p>This is terribly disappointing because it would have made Javascript so much better.</p><p>So how do we get immutability in Javascript?</p><p>Unfortunately, we can only do so via a library called <a href="https://facebook.github.io/immutable-js/">Immutable.js</a>. This may give us better immutability but sadly, it does so in a way that makes our code look more like Java than Javascript.</p><p><strong>Currying and Composition</strong></p><p>Earlier in this series, we learned how to write functions that are curried. Here’s a more complex example:</p><pre><code>const f = a =&gt; b =&gt; c =&gt; d =&gt; a + b + c + d</code></pre><p>Notice that we had to write the currying part by hand.</p><p>And to call <strong>f,</strong> we have to write:</p><pre><code>console.log(f(1)(2)(3)(4)); // prints 10</code></pre><p>But that’s enough parentheses to make a Lisp programmer cry.</p><p>There are many libraries which make this process easier. My favorite one is <a href="http://ramdajs.com/">Ramda</a>.</p><p>Using Ramda we can now write:</p><pre><code>const f = R.curry((a, b, c, d) =&gt; a + b + c + d);console.log(f(1, 2, 3, 4)); // prints 10console.log(f(1, 2)(3, 4)); // also prints 10console.log(f(1)(2)(3, 4)); // also prints 10</code></pre><p>The function definition isn’t much better but we’ve eliminated the need for all those parenthesis. Notice that we can apply as many or as few parameters as we want each time we invoke <strong>f</strong>.</p><p>By using Ramda, we can rewrite the <strong>mult5AfterAdd10</strong> function from <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">Part 3</a>and <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">Part 4</a>:</p><pre><code>const add = R.curry((x, y) =&gt; x + y);const mult5 = value =&gt; value * 5;const mult5AfterAdd10 = R.compose(mult5, add(10));</code></pre><p>It turns out that Ramda has a lot of helper functions for doing these sorts of things, e.g. <strong>R.add</strong> and <strong>R.multiply</strong>, which means we can write less code:</p><pre><code>const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));</code></pre><p><strong>Map, Filter and Reduce</strong></p><p>Ramda also has its own versions of <strong>map</strong>, <strong>filter</strong> and <strong>reduce</strong>. Although these functions exist in <strong>Array.prototype</strong> in vanilla Javascript, Ramda’s versions are curried:</p><pre><code>const isOdd = R.flip(R.modulo)(2);const onlyOdd = R.filter(isOdd);const isEven = R.complement(isOdd);const onlyEven = R.filter(isEven);const numbers = [1, 2, 3, 4, 5, 6, 7, 8];console.log(onlyEven(numbers)); // prints [2, 4, 6, 8]console.log(onlyOdd(numbers)); // prints [1, 3, 5, 7]</code></pre><p><strong>R.modulo</strong> takes 2 parameters. The first is the <strong>dividend</strong> (what’s being divided) and the second is the <strong>divisor</strong> (what we’re dividing by).</p><p>The <strong>isOdd</strong> function is just the remainder of dividing by 2. A remainder of 0 is <strong>falsy</strong>, not odd, and a remainder of 1 is <strong>truthy</strong>, odd. We flipped the first and second parameters of <strong>modulo</strong> so that we could specify 2 as the divisor.</p><p>The <strong>isEven</strong> function is just the <strong>complement</strong> of <strong>isOdd</strong>.</p><p>The <strong>onlyOdd</strong> function is the <strong>filter</strong> function with the <strong>predicate</strong> (a function that returns a boolean) of <strong>isOdd</strong>. It’s waiting for the list of numbers, its final parameter, before it executes.</p><p>The <strong>onlyEven</strong> function is a <strong>filter</strong> that uses <strong>isEven</strong> as its predicate.</p><p>When we pass <strong>numbers</strong> to <strong>onlyEven</strong> and <strong>onlyOdd,</strong> <strong>isEven</strong> and <strong>isOdd</strong> get their final parameters and can finally execute returning the numbers we’d expect.</p><h4 id="Javascript-Shortcomings"><a href="#Javascript-Shortcomings" class="headerlink" title="Javascript Shortcomings"></a>Javascript Shortcomings</h4><p>With all of the libraries and language enhancements that have gotten Javascript this far, it still suffers from the fact that it’s an Imperative Language that’s trying to be all things to all people.</p><p>Most front end developers are stuck using Javascript in the browser because it’s been the only choice for so long. But many developers are now moving away from writing Javascript directly.</p><p>Instead, they are writing in a different language and compiling, or more accurately, transpiling to Javascript.</p><p>CoffeeScript was one of the first of these languages. And now, Typescript has been adopted by Angular 2. Babel can also be considered a transpiler for Javascript.</p><p>More and more people are taking this approach in production.</p><p>But these languages started with Javascript and only made it slightly better. Why not go all the way and transpile to Javascript from a Pure Functional Language?</p><h4 id="Elm"><a href="#Elm" class="headerlink" title="Elm"></a>Elm</h4><p>In this series, we’ve looked at Elm to help understand Functional Programming.</p><p><strong>But what is Elm? And how can I use it?</strong></p><p>Elm is a Pure Functional Language that compiles to Javascript so you can use it to create Web Applications using <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>, aka TEA (this architecture inspired the developers of Redux).</p><p>Elm programs do NOT have any Runtime Errors.</p><p>Elm is being used in production at companies such as <a href="https://www.noredink.com/">NoRedInk</a>, where Evan Czapliki the creator of Elm now works (he previously worked for <a href="https://prezi.com/">Prezi</a>).</p><p>See this talk, <a href="https://www.youtube.com/watch?v=R2FtMbb-nLs">6 Months of Elm in Production</a>, by Richard Feldman from NoRedInk and Elm evangelist for more information.</p><p><strong>Do I have to replace all of my Javascript with Elm?</strong></p><p>No. You can incrementally replace parts. See this blog entry, <a href="http://elm-lang.org/blog/how-to-use-elm-at-work">How to use Elm at Work</a>, to learn more.</p><p><strong>Why learn Elm?</strong></p><ol><li>Programming in a Pure Functional Language is both limiting and freeing. It limits what you can do (mostly by keeping you from shooting yourself in the foot) but at the same time it frees you from bugs and bad design decisions since all Elm programs follow The Elm Architecture, a Functionally Reactive Model.</li><li>Functional Programming will make you a better programmer. The ideas in this article are only the tip of the iceberg. You really need to see them in practice to really appreciate how your programs will shrink in size and grow in stability.</li><li>Javascript was initially built in 10 days and then patched for the last two decades to become a somewhat functional, somewhat object-oriented and a fully imperative programming language.<br> Elm was designed using what has been learned in the last 30 years of work in the Haskell community, which draws from decades of work in mathematics and computer science.<br> The Elm Architecture (TEA) was designed and refined over the years and is a result of Evan’s thesis in Functional Reactive Programming. Watch <a href="https://www.youtube.com/watch?v=Agu6jipKfYw">Controlling Time and Space</a> to appreciate the level of thinking that went into the formulation of this design.</li><li>Elm is designed for front-end web developers. It’s aimed at making their lives easier. Watch <a href="https://www.youtube.com/watch?v=oYk8CKH7OhE">Let’s Be Mainstream</a> to better understand this goal.</li></ol><h4 id="The-Future"><a href="#The-Future" class="headerlink" title="The Future"></a>The Future</h4><p>It’s impossible to know what the future will hold, but we can make some educated guesses. Here are some of mine:</p><blockquote><p>There will be a clear move toward languages that compile to Javascript.</p></blockquote><blockquote><p>Functional Programming ideas that have been around for over 40 years will be rediscovered to solve our current software complexity problems.</p></blockquote><blockquote><p>The state of hardware, e.g. gigabytes of cheap memory and fast processors, will make functional techniques viable.</p></blockquote><blockquote><p>CPUs will not get faster but the number of cores will continue to increase.</p></blockquote><blockquote><p>Mutable state will be recognized as one of the biggest problems in complex systems.</p></blockquote><p>I wrote this series of articles because I believe that Functional Programming is the future and because I struggled over the last couple of years to learn it (I’m still learning).</p><p>My goal is to help others learn these concepts easier and faster than I did and to help others become better programmers so that they can have more marketable careers in the future.</p><p>Even if my prediction that Elm will be a huge language in the future is wrong, I can say with certainty that Functional Programming and Elm will be on the trajectory to whatever the future holds.</p><p>I hope that after reading this series, you feel more confident in your abilities and your understanding of these concepts.</p><p>I wish you luck in your future endeavors.</p><hr><p>Repost from <a href="https://medium.com/@cscalfani">https://medium.com/@cscalfani</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker下Alpine镜像</title>
      <link href="/posts/2019-06-10-docker-alpine-mirrors.html"/>
      <url>/posts/2019-06-10-docker-alpine-mirrors.html</url>
      
        <content type="html"><![CDATA[<p>Alpine 系统跟 Ubuntu 一样也有包管理器，为 <code>apk</code> ，正常通过 <code>apk</code> 安装软件速度都会比较慢，原因你懂的。</p><span id="more"></span><p><code>Dockerfile</code> 如下：</p><pre><code>FROM alpineMAINTAINER ismdeep ismdeep@protonmail.comRUN echo &quot;https://mirrors.aliyun.com/alpine/latest-stable/main/&quot; &gt; /etc/apk/repositoriesRUN apk --no-cache add python libsodium wgetENTRYPOINT [&quot;/sh&quot;]</code></pre><p>通过 <code>Docker</code> 构建如下：</p><pre><code>&gt; docker build -t alphine-mirror .Sending build context to Docker daemon  2.048kBStep 1/5 : FROM alpine ---&gt; 055936d39205Step 2/5 : MAINTAINER ismdeep ismdeep@protonmail.com ---&gt; Running in 9fd23d8dd442Removing intermediate container 9fd23d8dd442 ---&gt; 1f692ecb9ecbStep 3/5 : RUN echo &quot;https://mirrors.aliyun.com/alpine/latest-stable/main/&quot; &gt; /etc/apk/repositories ---&gt; Running in 7305f6170393Removing intermediate container 7305f6170393 ---&gt; 8036d7c7bcf6Step 4/5 : RUN apk --no-cache add python libsodium wget ---&gt; Running in 10620e66ed0efetch https://mirrors.aliyun.com/alpine/latest-stable/main/x86_64/APKINDEX.tar.gz(1/12) Installing libsodium (1.0.16-r0)(2/12) Installing libbz2 (1.0.6-r6)(3/12) Installing expat (2.2.6-r0)(4/12) Installing libffi (3.2.1-r6)(5/12) Installing gdbm (1.13-r1)(6/12) Installing ncurses-terminfo-base (6.1_p20190105-r0)(7/12) Installing ncurses-terminfo (6.1_p20190105-r0)(8/12) Installing ncurses-libs (6.1_p20190105-r0)(9/12) Installing readline (7.0.003-r1)(10/12) Installing sqlite-libs (3.28.0-r0)(11/12) Installing python2 (2.7.16-r1)(12/12) Installing wget (1.20.3-r0)Executing busybox-1.29.3-r10.triggerOK: 53 MiB in 26 packagesRemoving intermediate container 10620e66ed0e ---&gt; 1d9aecf539f2Step 5/5 : ENTRYPOINT [&quot;/sh&quot;] ---&gt; Running in 366c2b8bfa68Removing intermediate container 366c2b8bfa68 ---&gt; 41e3a76460bbSuccessfully built 41e3a76460bbSuccessfully tagged alphine-mirror:latest</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/posts/2019-06-10-docker-commands.html"/>
      <url>/posts/2019-06-10-docker-commands.html</url>
      
        <content type="html"><![CDATA[<p>Docker是容器的一种，容器是一种轻量级的虚拟技术。与容器不同，虚拟机是一种重量级的虚拟技术。Docker具有：</p><span id="more"></span><ul><li><p>跨平台的可移植性</p></li><li><p>面向应用</p></li><li><p>版本控制</p></li><li><p>组件复用</p></li><li><p>共享性</p></li><li><p>工具生态系统</p></li></ul><p>Docker作为一款容器，并且比传统的容器具有更多的改进和优点。以下是Docker的几种典型应用场景：</p><ul><li>加速本地开发。通过Docker能够快速搭建好开发和运行环境，并且该环境可以直接传递给测试和产品部署。</li><li>自动打包和部署应用。</li><li>创建轻量、私有的PaaS环境。</li><li>自动化测试和持续集成&#x2F;部署。</li><li>部署并扩展Web应用、数据库和后端服务器。</li><li>创建安全沙盒。</li><li>轻量级的桌面虚拟化。</li></ul><p>以下介绍几个Docker中常用的命令。</p><h3 id="0x01-获取镜像"><a href="#0x01-获取镜像" class="headerlink" title="0x01 获取镜像"></a>0x01 获取镜像</h3><pre><code>&gt; docker pull ubuntuUsing default tag: latestlatest: Pulling from library/ubuntu6abc03819f3e: Pulling fs layer05731e63f211: Pulling fs layer0bd67c50d6be: Download complete</code></pre><h3 id="0x02-查看镜像"><a href="#0x02-查看镜像" class="headerlink" title="0x02 查看镜像"></a>0x02 查看镜像</h3><pre><code>&gt; docker imagesREPOSITORY             TAG                 IMAGE ID            CREATED             SIZEalpine                 latest              055936d39205        4 weeks ago         5.53MBbusybox                latest              64f5d945efcc        4 weeks ago         1.2MBpython                 2.7                 3c01ed1c16af        4 weeks ago         914MBpython                 3.7                 a4cc999cf2aa        4 weeks ago         929MBredis                  latest              a4fe14ff1981        4 weeks ago         95MBnginx                  latest              53f3fd8007f7        4 weeks ago         109MBmongo                  latest              d98005b752b4        4 weeks ago         411MBmysql                  latest              d72169616e20        6 weeks ago         443MB</code></pre><h3 id="0x03-创建并启动容器"><a href="#0x03-创建并启动容器" class="headerlink" title="0x03 创建并启动容器"></a>0x03 创建并启动容器</h3><pre><code>&gt; docker run --name mysql-server -v /data/tmp/mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=53f3fd8007f7 -p 3392:3306 -d mysqlc22162c0ae39284591a4a0b1e4e724fb05c2455abd96f2862a12a3adbe293c8c</code></pre><p>以MySQL为例，对上述几个参数进行解释：</p><ul><li><code>--name mysql-server</code> 创建一个名称为 <code>mysql-server</code> 的容器。</li><li><code>-v /data/tmp/mysql-data:/var/lib/mysql</code> 对容器中的文件目录进行映射，将宿主机中的 <code>/data/tmp/mysql-data</code> 目录同容器中的 <code>/var/lib/mysql</code> 进行映射。</li><li><code>-e MYSQL_ROOT_PASSWORD=53f3fd8007f7</code> 传入参数</li><li><code>-p 3392:3306</code> 将宿主机的 <code>3392</code> 端口同容器中的 <code>3306</code> 进行映射。</li><li><code>-d</code> 容器后台运行</li><li><code>mysql</code> 运行容器的镜像，如果后面没有指明版本号则为 <code>latest</code>. 如果需要指明版本号可以通过 <code>:</code> 进行指明，如：<code>mysql:5.7</code></li></ul><h3 id="0x04-查看容器"><a href="#0x04-查看容器" class="headerlink" title="0x04 查看容器"></a>0x04 查看容器</h3><pre><code>&gt; docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMESc22162c0ae39        mysql               &quot;docker-entrypoint.s…&quot;   23 minutes ago      Up 23 minutes       33060/tcp, 0.0.0.0:3392-&gt;3306/tcp   mysql-server</code></pre><p><code>docker ps</code> 命令只查看正在运行的容器。</p><pre><code>&gt; docker ps -aCONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS                      PORTS                               NAMESc22162c0ae39        mysql                  &quot;docker-entrypoint.s…&quot;   24 minutes ago      Up 24 minutes               33060/tcp, 0.0.0.0:3392-&gt;3306/tcp   mysql-server0908250ff8d7        osminogin/tor-simple   &quot;/usr/bin/tor&quot;           2 weeks ago         Exited (0) 11 hours ago                                         tor53149e4d6a72        mongo                  &quot;docker-entrypoint.s…&quot;   2 weeks ago         Exited (0) 2 weeks ago                                          mongo-dbada3bd8fc57b        ssr                    &quot;python local.py -c …&quot;   3 weeks ago         Exited (137) 11 hours ago                                       ssrb506117c93e6        python:3.7             &quot;bash&quot;                   3 weeks ago         Exited (0) 2 weeks ago                                          python3cb2722de812e        redis                  &quot;docker-entrypoint.s…&quot;   3 weeks ago         Exited (0) 2 weeks ago                                          redis-server</code></pre><p><code>docker ps -a</code> 命令则可查看所有容器。</p><h3 id="0x05-删除镜像"><a href="#0x05-删除镜像" class="headerlink" title="0x05 删除镜像"></a>0x05 删除镜像</h3><pre><code>&gt; docker rmi alpineUntagged: alpine:latestUntagged: alpine@sha256:769fddc7cc2f0a1c35abb2f91432e8beecf83916c421420e6a6da9f8975464b6</code></pre><h3 id="0x06-启动、停止、重启容器"><a href="#0x06-启动、停止、重启容器" class="headerlink" title="0x06 启动、停止、重启容器"></a>0x06 启动、停止、重启容器</h3><ul><li><p>启动容器</p><pre><code>&gt; docker start mysql-servermysql-server</code></pre></li><li><p>停止容器</p><pre><code>&gt; docker stop mysql-servermysql-server</code></pre></li><li><p>重启容器</p><pre><code>&gt; docker restart mysql-servermysql-server</code></pre></li></ul><h3 id="0x07-删除容器"><a href="#0x07-删除容器" class="headerlink" title="0x07 删除容器"></a>0x07 删除容器</h3><pre><code>&gt; docker rm mysql-servermysql-server</code></pre><h3 id="0x08-查看容器信息"><a href="#0x08-查看容器信息" class="headerlink" title="0x08 查看容器信息"></a>0x08 查看容器信息</h3><pre><code>&gt; docker inspect redis-server[    &#123;        &quot;Id&quot;: &quot;cb2722de812e5491da0aad0d442940e344ac4e9712274fc0eae4bd8c2ff1e0d6&quot;,        &quot;Created&quot;: &quot;2019-05-14T13:32:48.1947863Z&quot;,        &quot;Path&quot;: &quot;docker-entrypoint.sh&quot;,        &quot;Args&quot;: [            &quot;redis-server&quot;        ],        ...        ...        ...        ,        &quot;Image&quot;: &quot;sha256:a4fe14ff19812e816e1b21f7daa5fa25ab9bff4365252fe38d8eef4bdf1150ee&quot;,        ...        ...        ...            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,            ...            &quot;Networks&quot;: &#123;                ...                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,                    ....                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,                    &quot;DriverOpts&quot;: null                &#125;            &#125;        &#125;    &#125;]</code></pre><p><code>docker inspect</code> 用于查看容器的配置信息，包含容器名、环境变量、运行命令、主机配置、网络配置和数据卷配置等。</p><h3 id="0x09-查看容器进程"><a href="#0x09-查看容器进程" class="headerlink" title="0x09 查看容器进程"></a>0x09 查看容器进程</h3><pre><code>&gt; docker top redis-serverPID                 USER                TIME                COMMAND3498                999                 0:00                redis-server *:6379</code></pre><h3 id="0x0a-查看容器日志"><a href="#0x0a-查看容器日志" class="headerlink" title="0x0a 查看容器日志"></a>0x0a 查看容器日志</h3><pre><code>&gt; docker logs -f --tail=5 redis-server1:M 10 Jun 2019 13:53:25.985 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.1:M 10 Jun 2019 13:53:25.985 # Server initialized1:M 10 Jun 2019 13:53:25.986 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#39; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.1:M 10 Jun 2019 13:53:25.986 * DB loaded from disk: 0.001 seconds1:M 10 Jun 2019 13:53:25.987 * Ready to accept connections</code></pre><p><code>-f</code> 使用此标志，之后的日志也会不断更新出来。</p><p><code>--tail=5</code> 首先输出日志的最后5行。</p><h3 id="0x0b-容器内执行命令"><a href="#0x0b-容器内执行命令" class="headerlink" title="0x0b 容器内执行命令"></a>0x0b 容器内执行命令</h3><pre><code>&gt; docker exec -it redis-server echo hellohello</code></pre><p>通过这种方式可以进入容器内的命令行。</p><pre><code>&gt; docker exec -it redis-server bashroot@cb2722de812e:/data#</code></pre><h3 id="0x0c-容器的导入与导出"><a href="#0x0c-容器的导入与导出" class="headerlink" title="0x0c 容器的导入与导出"></a>0x0c 容器的导入与导出</h3><ul><li><p>导出容器</p><pre><code>&gt; docker export redis-server &gt; redis-server.tar</code></pre></li><li><p>导入容器</p><pre><code>&gt; docker import redis-server.tar redis-serversha256:67b3ac0c90bbd9d5fd901331142abc544bef5f0f1ea345787353dda9a42bc4cc</code></pre></li></ul><h3 id="0x0d-使用Dockerfile创建镜像"><a href="#0x0d-使用Dockerfile创建镜像" class="headerlink" title="0x0d 使用Dockerfile创建镜像"></a>0x0d 使用Dockerfile创建镜像</h3><pre><code>&gt; docker build -t naive-honix .Sending build context to Docker daemon     64kBStep 1/10 : FROM python:3.7 ---&gt; a4cc999cf2aaStep 2/10 : MAINTAINER ismdeep@protonmail.com ---&gt; Using cache ---&gt; eb65fc3ae7a2Step 3/10 : RUN mkdir /root/.pip ---&gt; Using cache ---&gt; 9e25a8b6fa4fStep 4/10 : COPY ./pip.conf /root/.pip ---&gt; Using cache ---&gt; 5aa11374cc97Step 5/10 : COPY ./honix /opt/honix ---&gt; Using cache ---&gt; 3b3addd353d1Step 6/10 : COPY ./docker-entrypoint.sh / ---&gt; Using cache ---&gt; 21dda863be59Step 7/10 : RUN chmod +x /docker-entrypoint.sh ---&gt; Using cache ---&gt; af83ea0eadeeStep 8/10 : RUN pip install ismdeep-utils ---&gt; Using cache ---&gt; 25fe683853d1Step 9/10 : EXPOSE 80 ---&gt; Using cache ---&gt; 4dc7970daa32Step 10/10 : ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;] ---&gt; Using cache ---&gt; 9a6fea0eaeaaSuccessfully built 9a6fea0eaeaaSuccessfully tagged naive-honix:latest</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何参与linux内核开发</title>
      <link href="/posts/2019-06-06-how-to-join-linux-kernel-development.html"/>
      <url>/posts/2019-06-06-how-to-join-linux-kernel-development.html</url>
      
        <content type="html"><![CDATA[<p>如果想评论或更新本文的内容，请直接联系原文档的维护者。如果你使用英文交流有困难的话，也可以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版维护者。</p><p>英文版维护者： Greg Kroah-Hartman <a href="mailto:&#x67;&#114;&#101;&#103;&#x40;&#107;&#114;&#111;&#97;&#x68;&#x2e;&#99;&#x6f;&#109;">&#x67;&#114;&#101;&#103;&#x40;&#107;&#114;&#111;&#97;&#x68;&#x2e;&#99;&#x6f;&#109;</a></p><p>中文版维护者： 李阳 Li Yang <a href="mailto:&#x6c;&#x65;&#111;&#108;&#105;&#x40;&#102;&#x72;&#101;&#x65;&#x73;&#99;&#x61;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">&#x6c;&#x65;&#111;&#108;&#105;&#x40;&#102;&#x72;&#101;&#x65;&#x73;&#99;&#x61;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;</a></p><p>中文版翻译者： 李阳 Li Yang <a href="mailto:&#108;&#x65;&#111;&#108;&#105;&#64;&#102;&#114;&#101;&#x65;&#x73;&#99;&#x61;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#108;&#x65;&#111;&#108;&#105;&#64;&#102;&#114;&#101;&#x65;&#x73;&#99;&#x61;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></p><p>中文版校译者： 钟宇 TripleX Chung <a href="mailto:&#120;&#x78;&#x78;&#46;&#112;&#x68;&#121;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#120;&#x78;&#x78;&#46;&#112;&#x68;&#121;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></p><p>​               陈琦 Maggie Chen <a href="mailto:&#99;&#x68;&#101;&#x6e;&#x71;&#x69;&#x40;&#98;&#101;&#x79;&#111;&#x6e;&#100;&#115;&#111;&#102;&#x74;&#46;&#x63;&#111;&#x6d;">&#99;&#x68;&#101;&#x6e;&#x71;&#x69;&#x40;&#98;&#101;&#x79;&#111;&#x6e;&#100;&#115;&#111;&#102;&#x74;&#46;&#x63;&#111;&#x6d;</a></p><p>​               王聪 Wang Cong <a href="mailto:&#x78;&#x69;&#x79;&#111;&#117;&#46;&#119;&#97;&#110;&#103;&#99;&#111;&#110;&#x67;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;">&#x78;&#x69;&#x79;&#111;&#117;&#46;&#119;&#97;&#110;&#103;&#99;&#111;&#110;&#x67;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a></p><p>以下为正文</p><hr><p>如何参与Linux内核开发</p><hr><p>这是一篇将如何参与Linux内核开发的相关问题一网打尽的终极秘笈。它将指导你成为一名Linux内核开发者，并且学会如何同Linux内核开发社区合作。它尽可能不包括任何关于内核编程的技术细节，但会给你指引一条获得这些知识的正确途径。</p><p> 如果这篇文章中的任何内容不再适用，请给文末列出的文件维护者发送补丁。</p><p>入门</p><hr><p>你想了解如何成为一名Linux内核开发者？或者老板吩咐你“给这个设备写个Linux驱动程序”？这篇文章的目的就是教会你达成这些目标的全部诀窍，它将描述你需要经过的流程以及给出如何同内核社区合作的一些提示。它还将试图解释内核社区为何这样运作。</p><p>Linux内核大部分是由C语言写成的，一些体系结构相关的代码用到了汇编语言。要参与内核开发，你必须精通C语言。除非你想为某个架构开发底层代码，否则你并不需要了解（任何体系结构的）汇编语言。下面列举的书籍虽然不能替代扎实的C语言教育和多年的开发经验，但如果需要的话，做为参考还是不错的：</p><ul><li><p>“The C Programming Language” by Kernighan and Ritchie [Prentice Hall]</p><p> 《C程序设计语言（第2版·新版）》（徐宝文 李志 译）[机械工业出版社]</p></li><li><p>“Practical C Programming” by Steve Oualline [O’Reilly]</p><p> 《实用C语言编程（第三版）》（郭大海 译）[中国电力出版社]</p></li><li><p>“C: A Reference Manual” by Harbison and Steele [Prentice Hall]</p><p> 《C语言参考手册（原书第5版）》（邱仲潘 等译）[机械工业出版社]</p></li></ul><p>Linux内核使用GNU C和GNU工具链开发。虽然它遵循ISO C89标准，但也用到了一些标准中没有定义的扩展。内核是自给自足的C环境，不依赖于标准C库的支持，所以并不支持C标准中的部分定义。比如long long类型的大数除法和浮点运算就不允许使用。有时候确实很难弄清楚内核对工具链的要求和它所使用的扩展，不幸的是目前还没有明确的参考资料可以解释它们。请查阅gcc信息页（使用“info gcc”命令显示）获得一些这方面信息。</p><p> 请记住你是在学习怎么和已经存在的开发社区打交道。它由一群形形色色的人组成，他们对代码、风格和过程有着很高的标准。这些标准是在长期实践中总结出来的，适应于地理上分散的大型开发团队。它们已经被很好得整理成档，建议你在开发之前尽可能多的学习这些标准，而不要期望别人来适应你或者你公司的行为方式。</p><p>法律问题</p><hr><p>Linux内核源代码都是在GPL（通用公共许可证）的保护下发布的。要了解这种许可的细节请查看源代码主目录下的COPYING文件。如果你对它还有更深入问题请联系律师，而不要在Linux内核邮件组上提问。因为邮件组里的人并不是律师，不要期望他们的话有法律效力。</p><p> 对于GPL的常见问题和解答，请访问以下链接：</p><p><a href="http://www.gnu.org/licenses/gpl-faq.html">http://www.gnu.org/licenses/gpl-faq.html</a></p><p>文档</p><hr><p>Linux内核代码中包含有大量的文档。这些文档对于学习如何与内核社区互动有着不可估量的价值。当一个新的功能被加入内核，最好把解释如何使用这个功能的文档也放进内核。当内核的改动导致面向用户空间的接口发生变化时，最好将相关信息或手册页(manpages)的补丁发到<a href="mailto:&#x6d;&#x74;&#107;&#46;&#x6d;&#x61;&#x6e;&#x70;&#97;&#103;&#x65;&#115;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x6d;&#x74;&#107;&#46;&#x6d;&#x61;&#x6e;&#x70;&#97;&#103;&#x65;&#115;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a>，以向手册页(manpages)的维护者解释这些变化。</p><p>以下是内核代码中需要阅读的文档：</p><ul><li><p>README</p><ul><li>文件简要介绍了Linux内核的背景，并且描述了如何配置和编译内核。内核的新用户应该从这里开</li></ul></li><li><p>Documentation&#x2F;Changes</p></li><li><p>文件给出了用来编译和使用内核所需要的最小软件包列表。</p></li><li><p>Documentation&#x2F;CodingStyle</p></li><li><p>描述Linux内核的代码风格和理由。所有新代码需要遵守这篇文档中定义的规范。大多数维护者只会接收符合规定的补丁，很多人也只会帮忙检查符合风格的代码。</p></li><li><p>Documentation&#x2F;SubmittingPatches</p></li><li><p>Documentation&#x2F;SubmittingDrivers</p><ul><li><p>这两份文档明确描述如何创建和发送补丁，其中包括（但不仅限于)：</p><ul><li>邮件内容</li><li>邮件格式</li><li>选择收件人</li></ul></li><li><p>遵守这些规定并不能保证提交成功（因为所有补丁需要通过严格的内容和风格审查），但是忽视他们几乎就意味着失败。</p></li><li><p>其他关于如何正确地生成补丁的优秀文档包括：</p></li><li><p>“The Perfect Patch”</p><ul><li><a href="http://userweb.kernel.org/~akpm/stuff/tpp.txt">http://userweb.kernel.org/~akpm/stuff/tpp.txt</a></li></ul></li><li><p>“Linux kernel patch submission format”</p><ul><li><a href="http://linux.yyz.us/patch-format.html">http://linux.yyz.us/patch-format.html</a></li></ul></li></ul></li><li><p>Documentation&#x2F;stable_api_nonsense.txt</p><ul><li>论证内核为什么特意不包括稳定的内核内部API，也就是说不包括像这样的特性：<ul><li>子系统中间层（为了兼容性？）</li><li>在不同操作系统间易于移植的驱动程序</li><li>减缓（甚至阻止）内核代码的快速变化</li></ul></li><li>这篇文档对于理解Linux的开发哲学至关重要。对于将开发平台从其他操作系统转移到Linux的人来说也很重要。</li></ul></li><li><p>Documentation&#x2F;SecurityBugs</p><ul><li>如果你认为自己发现了Linux内核的安全性问题，请根据这篇文档中的步骤来提醒其他内核开发者并帮助解决这个问题。</li></ul></li><li><p>Documentation&#x2F;ManagementStyle</p><ul><li>描述内核维护者的工作方法及其共有特点。这对于刚刚接触内核开发（或者对它感到好奇）的人来说很重要，因为它解释了很多对于内核维护者独特行为的普遍误解与迷</li></ul></li><li><p>Documentation&#x2F;stable_kernel_rules.txt</p><ul><li>解释了稳定版内核发布的规则，以及如何将改动放入这些版本的步骤。</li></ul></li><li><p>Documentation&#x2F;kernel-docs.txt</p><ul><li>有助于内核开发的外部文档列表。如果你在内核自带的文档中没有找到你想找的内容，可以查看这些文档。</li></ul></li><li><p>Documentation&#x2F;applying-patches.txt</p><ul><li>关于补丁是什么以及如何将它打在不同内核开发分支上的好介绍</li></ul></li></ul><p> 内核还拥有大量从代码自动生成的文档。它包含内核内部API的全面介绍以及如何妥善处理加锁的规则。生成的文档会放在 Documentation&#x2F;DocBook&#x2F;目录下。在内核源码的主目录中使用以下不同命令将会分别生成PDF、Postscript、HTML和手册页等不同格式的文档：</p><ul><li>make pdfdocs</li><li>make psdocs</li><li>make htmldocs</li><li>make mandocs</li></ul><p>如何成为内核开发者</p><hr><p>如果你对Linux内核开发一无所知，你应该访问“Linux内核新手”计划：</p><p><a href="http://kernelnewbies.org/">http://kernelnewbies.org</a></p><p>它拥有一个可以问各种最基本的内核开发问题的邮件列表（在提问之前一定要记得查找已往的邮件，确认是否有人已经回答过相同的问题）。它还拥有一个可以获得实时反馈的IRC聊天频道，以及大量对于学习Linux内核开发相当有帮助的文档。</p><p>网站简要介绍了源代码组织结构、子系统划分以及目前正在进行的项目（包括内核中的和单独维护的）。它还提供了一些基本的帮助信息，比如如何编译内核和打补丁。</p><p>如果你想加入内核开发社区并协助完成一些任务，却找不到从哪里开始，可以访问“Linux内核房管员”计划：</p><p><a href="http://kernelnewbies.org/KernelJanitors">http://kernelnewbies.org/KernelJanitors</a></p><p>这是极佳的起点。它提供一个相对简单的任务列表，列出内核代码中需要被重新整理或者改正的地方。通过和负责这个计划的开发者们一同工作，你会学到将补丁集成进内核的基本原理。如果还没有决定下一步要做什么的话，你还可能会得到方向性的指点。</p><p> 如果你已经有一些现成的代码想要放到内核中，但是需要一些帮助来使它们拥有正确的格式。请访问“内核导师”计划。这个计划就是用来帮助你完成这个目标的。它是一个邮件列表，地址如下：</p><p><a href="http://selenic.com/mailman/listinfo/kernel-mentors">http://selenic.com/mailman/listinfo/kernel-mentors</a> </p><p>在真正动手修改内核代码之前，理解要修改的代码如何运作是必需的。要达到这个目的，没什么办法比直接读代码更有效了（大多数花招都会有相应的注释），而且一些特制的工具还可以提供帮助。例如，“Linux代码交叉引用”项目就是一个值得特别推荐的帮助工具，它将源代码显示在有编目和索引的网页上。其中一个更新及时的内核源码库，可以通过以下地址访问：</p><p><a href="http://sosdg.org/~coywolf/lxr/">http://sosdg.org/~coywolf/lxr/</a></p><p>开发流程</p><hr><p>目前Linux内核开发流程包括几个“主内核分支”和很多子系统相关的内核分支。这些分支包括：</p><ul><li>2.6.x主内核源码树</li><li>2.6.x.y -stable内核源码树</li><li>2.6.x -git内核补丁集</li><li>2.6.x -mm内核补丁集</li><li>子系统相关的内核源码树和补丁集</li></ul><p>2.6.x内核主源码树</p><hr><p>2.6.x内核是由Linus Torvalds（Linux的创造者）亲自维护的。你可以在kernel.org网站的pub&#x2F;linux&#x2F;kernel&#x2F;v2.6&#x2F;目录下找到它。它的开发遵循以下步骤：</p><ul><li>每当一个新版本的内核被发布，为期两周的集成窗口将被打开。在这段时间里维护者可以向Linus提交大段的修改，通常这些修改已经被放到-mm内核中几个星期了。提交大量修改的首选方式是使用git工具（内核的代码版本管理工具，更多的信息可以在 <a href="http://git.or.cz/">http://git.or.cz/</a> 获取），不过使用普通补丁也是可以的。</li><li>两个星期以后-rc1版本内核发布。之后只有不包含可能影响整个内核稳定性的新功能的补丁才可能被接受。请注意一个全新的驱动程序（或者文件系统）有可能在-rc1后被接受是因为这样的修改完全独立，不会影响其他的代码，所以没有造成内核退步的风险。在-rc1以后也可以用git向Linus提交补丁，不过所有的补丁需要同时被发送到相应的公众邮件列表以征询意见。</li><li>当Linus认为当前的git源码树已经达到一个合理健全的状态足以发布供人测试时，一个新的-rc版本就会被发布。计划是每周都发布新的-rc版本。</li><li>这个过程一直持续下去直到内核被认为达到足够稳定的状态，持续时间大概是6个星期。</li><li>以下地址跟踪了在每个-rc发布中发现的退步列表：<ul><li><a href="http://kernelnewbies.org/known_regressions">http://kernelnewbies.org/known_regressions</a></li></ul></li></ul><p> 关于内核发布，值得一提的是Andrew Morton在linux-kernel邮件列表中如是说：“没有人知道新内核何时会被发布，因为发布是根据已知bug的情况来决定的，而不是根据一个事先制定好的时间表。”</p><p>2.6.x.y -stable（稳定版）内核源码树</p><hr><p>由4个数字组成的内核版本号说明此内核是-stable版本。它们包含基于2.6.x版本内核的相对较小且至关重要的修补，这些修补针对安全性问题或者严重的内核退步。</p><p>这种版本的内核适用于那些期望获得最新的稳定版内核并且不想参与测试开发版或者实验版的用户。</p><p>如果没有2.6.x.y版本内核存在，那么最新的2.6.x版本内核就相当于是当前的稳定版内核。</p><p>2.6.x.y版本由“稳定版”小组（邮件地址<a href="mailto:&#115;&#116;&#x61;&#98;&#108;&#101;&#64;&#x6b;&#101;&#114;&#x6e;&#101;&#x6c;&#46;&#111;&#114;&#x67;">&#115;&#116;&#x61;&#98;&#108;&#101;&#64;&#x6b;&#101;&#114;&#x6e;&#101;&#x6c;&#46;&#111;&#114;&#x67;</a>）维护，一般隔周发布新版本。</p><p>内核源码中的Documentation&#x2F;stable_kernel_rules.txt文件具体描述了可被稳定版内核接受的修改类型以及发布的流程。</p><p>2.6.x -git补丁集</p><hr><p>Linus的内核源码树的每日快照，这个源码树是由git工具管理的（由此得名）。这些补丁通常每天更新以反映Linus的源码树的最新状态。它们比-rc版本的内核源码树更具试验性质，因为这个补丁集是全自动生成的，没有任何人来确认其是否真正健全。</p><p> 2.6.x -mm补丁集</p><hr><p>这是由Andrew Morton维护的试验性内核补丁集。Andrew将所有子系统的内核源码和补丁拼凑到一起，并且加入了大量从linux-kernel邮件列表中采集的补丁。这个源码树是新功能和补丁的试炼场。当补丁在-mm补丁集里证明了其价值以后Andrew或者相应子系统的维护者会将补丁发给Linus以便集成进主内核源码树。</p><p>在将所有新补丁发给Linus以集成到主内核源码树之前，我们非常鼓励先把这些补丁放在-mm版内核源码树中进行测试。</p><p>这些内核版本不适合在需要稳定运行的系统上运行，因为运行它们比运行任何其他内核分支都更具有风险。</p><p>如果你想为内核开发进程提供帮助，请尝试并使用这些内核版本，并在linux-kernel邮件列表中提供反馈，告诉大家你遇到了问题还是一切正常。</p><p>通常-mm版补丁集不光包括这些额外的试验性补丁，还包括发布时-git版主源码树中的改动。</p><p> -mm版内核没有固定的发布周期，但是通常在每两个-rc版内核发布之间都会有若干个-mm版内核发布（一般是1至3个）。</p><p>子系统相关内核源码树和补丁集</p><hr><p>相当一部分内核子系统开发者会公开他们自己的开发源码树，以便其他人能了解内核的不同领域正在发生的事情。如上所述，这些源码树会被集成到-mm版本内核中。</p><p>下面是目前可用的一些内核源码树的列表：</p><p>通过git管理的源码树：</p><ul><li><p>Kbuild开发源码树， Sam Ravnborg <a href="mailto:&#115;&#97;&#109;&#x40;&#x72;&#97;&#x76;&#110;&#x62;&#111;&#114;&#103;&#x2e;&#111;&#x72;&#x67;">&#115;&#97;&#109;&#x40;&#x72;&#97;&#x76;&#110;&#x62;&#111;&#114;&#103;&#x2e;&#111;&#x72;&#x67;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;sam&#x2F;kbuild.git</li></ul></li><li><p>ACPI开发源码树, Len Brown <a href="mailto:&#108;&#x65;&#110;&#x2e;&#x62;&#114;&#x6f;&#119;&#110;&#64;&#x69;&#x6e;&#x74;&#x65;&#108;&#46;&#x63;&#x6f;&#x6d;">&#108;&#x65;&#110;&#x2e;&#x62;&#114;&#x6f;&#119;&#110;&#64;&#x69;&#x6e;&#x74;&#x65;&#108;&#46;&#x63;&#x6f;&#x6d;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;lenb&#x2F;linux-acpi-2.6.git</li></ul></li><li><p>块设备开发源码树, Jens Axboe <a href="mailto:&#x61;&#x78;&#98;&#x6f;&#x65;&#64;&#115;&#x75;&#115;&#x65;&#x2e;&#x64;&#101;">&#x61;&#x78;&#98;&#x6f;&#x65;&#64;&#115;&#x75;&#115;&#x65;&#x2e;&#x64;&#101;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;axboe&#x2F;linux-2.6-block.git</li></ul></li><li><p>DRM开发源码树, Dave Airlie <a href="mailto:&#x61;&#105;&#x72;&#108;&#x69;&#x65;&#x64;&#64;&#108;&#x69;&#110;&#117;&#x78;&#46;&#x69;&#101;">&#x61;&#105;&#x72;&#108;&#x69;&#x65;&#x64;&#64;&#108;&#x69;&#110;&#117;&#x78;&#46;&#x69;&#101;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;airlied&#x2F;drm-2.6.git</li></ul></li><li><p>ia64开发源码树, Tony Luck <a href="mailto:&#116;&#x6f;&#110;&#x79;&#46;&#108;&#x75;&#x63;&#x6b;&#x40;&#x69;&#x6e;&#x74;&#101;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#116;&#x6f;&#110;&#x79;&#46;&#108;&#x75;&#x63;&#x6b;&#x40;&#x69;&#x6e;&#x74;&#101;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;aegl&#x2F;linux-2.6.git</li></ul></li><li><p>ieee1394开发源码树, Jody McIntyre <a href="mailto:&#x73;&#x63;&#106;&#x6f;&#x64;&#121;&#x40;&#x6d;&#111;&#x64;&#x65;&#x72;&#110;&#100;&#x75;&#99;&#x6b;&#x2e;&#x63;&#x6f;&#x6d;">&#x73;&#x63;&#106;&#x6f;&#x64;&#121;&#x40;&#x6d;&#111;&#x64;&#x65;&#x72;&#110;&#100;&#x75;&#99;&#x6b;&#x2e;&#x63;&#x6f;&#x6d;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;scjody&#x2F;ieee1394.git</li></ul></li><li><p>infiniband开发源码树, Roland Dreier <a href="mailto:&#x72;&#111;&#x6c;&#97;&#x6e;&#100;&#100;&#x40;&#99;&#105;&#115;&#99;&#x6f;&#46;&#x63;&#111;&#109;">&#x72;&#111;&#x6c;&#97;&#x6e;&#100;&#100;&#x40;&#99;&#105;&#115;&#99;&#x6f;&#46;&#x63;&#111;&#109;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;roland&#x2F;infiniband.git</li></ul></li><li><p>libata开发源码树, Jeff Garzik <a href="mailto:&#106;&#103;&#x61;&#x72;&#122;&#x69;&#107;&#x40;&#112;&#x6f;&#x62;&#x6f;&#120;&#46;&#99;&#x6f;&#109;">&#106;&#103;&#x61;&#x72;&#122;&#x69;&#107;&#x40;&#112;&#x6f;&#x62;&#x6f;&#120;&#46;&#99;&#x6f;&#109;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;jgarzik&#x2F;libata-dev.git</li></ul></li><li><p>网络驱动程序开发源码树, Jeff Garzik <a href="mailto:&#x6a;&#x67;&#97;&#114;&#122;&#105;&#x6b;&#64;&#x70;&#111;&#x62;&#x6f;&#x78;&#46;&#99;&#x6f;&#x6d;">&#x6a;&#x67;&#97;&#114;&#122;&#105;&#x6b;&#64;&#x70;&#111;&#x62;&#x6f;&#x78;&#46;&#99;&#x6f;&#x6d;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;jgarzik&#x2F;netdev-2.6.git</li></ul></li><li><p>pcmcia开发源码树, Dominik Brodowski <a href="mailto:&#x6c;&#105;&#x6e;&#117;&#120;&#64;&#100;&#111;&#x6d;&#x69;&#110;&#x69;&#107;&#98;&#114;&#x6f;&#x64;&#111;&#x77;&#115;&#107;&#x69;&#x2e;&#x6e;&#x65;&#x74;">&#x6c;&#105;&#x6e;&#117;&#120;&#64;&#100;&#111;&#x6d;&#x69;&#110;&#x69;&#107;&#98;&#114;&#x6f;&#x64;&#111;&#x77;&#115;&#107;&#x69;&#x2e;&#x6e;&#x65;&#x74;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;brodo&#x2F;pcmcia-2.6.git</li></ul></li><li><p>SCSI开发源码树, James Bottomley <a href="mailto:&#74;&#x61;&#109;&#x65;&#115;&#x2e;&#x42;&#x6f;&#x74;&#x74;&#x6f;&#109;&#108;&#101;&#121;&#64;&#83;&#116;&#x65;&#x65;&#x6c;&#x45;&#x79;&#101;&#46;&#x63;&#111;&#109;">&#74;&#x61;&#109;&#x65;&#115;&#x2e;&#x42;&#x6f;&#x74;&#x74;&#x6f;&#109;&#108;&#101;&#121;&#64;&#83;&#116;&#x65;&#x65;&#x6c;&#x45;&#x79;&#101;&#46;&#x63;&#111;&#109;</a></p><ul><li>git.kernel.org:&#x2F;pub&#x2F;scm&#x2F;linux&#x2F;kernel&#x2F;git&#x2F;jejb&#x2F;scsi-misc-2.6.git</li></ul></li></ul><p> 使用quilt管理的补丁集：</p><ul><li>USB, PCI, 驱动程序核心和I2C, Greg Kroah-Hartman <a href="mailto:&#103;&#114;&#x65;&#x67;&#x6b;&#x68;&#x40;&#x6c;&#x69;&#x6e;&#117;&#x78;&#102;&#111;&#117;&#110;&#x64;&#x61;&#116;&#x69;&#x6f;&#110;&#x2e;&#111;&#114;&#x67;">&#103;&#114;&#x65;&#x67;&#x6b;&#x68;&#x40;&#x6c;&#x69;&#x6e;&#117;&#x78;&#102;&#111;&#117;&#110;&#x64;&#x61;&#116;&#x69;&#x6f;&#110;&#x2e;&#111;&#114;&#x67;</a><ul><li>kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;people&#x2F;gregkh&#x2F;gregkh-2.6&#x2F;</li></ul></li><li>x86-64, 部分i386, Andi Kleen <a href="mailto:&#x61;&#x6b;&#x40;&#x73;&#117;&#x73;&#101;&#46;&#x64;&#101;">&#x61;&#x6b;&#x40;&#x73;&#117;&#x73;&#101;&#46;&#x64;&#101;</a><ul><li>ftp.firstfloor.org:&#x2F;pub&#x2F;ak&#x2F;x86_64&#x2F;quilt&#x2F;</li></ul></li></ul><p>其他内核源码树可以在<a href="http://git.kernel.org的列表中和maintainers文件里找到./">http://git.kernel.org的列表中和MAINTAINERS文件里找到。</a></p><p>报告bug</p><hr><p> bugzilla.kernel.org是Linux内核开发者们用来跟踪内核Bug的网站。我们鼓励用户在这个工具中报告找到的所有bug。如何使用内核bugzilla的细节请访问：<a href="http://test.kernel.org/bugzilla/faq.html">http://test.kernel.org/bugzilla/faq.html</a></p><p>内核源码主目录中的REPORTING-BUGS文件里有一个很好的模板。它指导用户如何报告可能的内核bug以及需要提供哪些信息来帮助内核开发者们找到问题的根源。</p><p>利用bug报告</p><hr><p>练习内核开发技能的最好办法就是修改其他人报告的bug。你不光可以帮助内核变得更加稳定，还可以学会如何解决实际问题从而提高自己的技能，并且让其他开发者感受到你的存在。修改bug是赢得其他开发者赞誉的最好办法，因为并不是很多人都喜欢浪费时间去修改别人报告的bug。</p><p>要尝试修改已知的bug，请访问<a href="http://bugzilla.kernel.org网址.如果你想获得最新bug的通知,可以订阅bugme-new邮件列表(只有新的bug报告会被寄到这里)或者订阅bugme-janitor邮件列表(所有bugzilla的变动都会被寄到这里)./">http://bugzilla.kernel.org网址。如果你想获得最新bug的通知，可以订阅bugme-new邮件列表（只有新的bug报告会被寄到这里）或者订阅bugme-janitor邮件列表（所有bugzilla的变动都会被寄到这里）。</a></p><p><a href="https://lists.linux-foundation.org/mailman/listinfo/bugme-new">https://lists.linux-foundation.org/mailman/listinfo/bugme-new</a></p><p><a href="https://lists.linux-foundation.org/mailman/listinfo/bugme-janitors">https://lists.linux-foundation.org/mailman/listinfo/bugme-janitors</a></p><p>邮件列表</p><hr><p>正如上面的文档所描述，大多数的骨干内核开发者都加入了Linux Kernel邮件列表。如何订阅和退订列表的细节可以在这里找到：</p><p><a href="http://vger.kernel.org/vger-lists.html#linux-kernel">http://vger.kernel.org/vger-lists.html#linux-kernel</a></p><p>网上很多地方都有这个邮件列表的存档(archive)。可以使用搜索引擎来找到这些存档。比如：</p><p><a href="http://dir.gmane.org/gmane.linux.kernel">http://dir.gmane.org/gmane.linux.kernel</a></p><p>在发信之前，我们强烈建议你先在存档中搜索你想要讨论的问题。很多已经被详细讨论过的问题只在邮件列表的存档中可以找到。</p><p> 大多数内核子系统也有自己独立的邮件列表来协调各自的开发工作。从MAINTAINERS文件中可以找到不同话题对应的邮件列表。</p><p>很多邮件列表架设在kernel.org服务器上。这些列表的信息可以在这里找到：</p><p><a href="http://vger.kernel.org/vger-lists.html">http://vger.kernel.org/vger-lists.html</a></p><p> 在使用这些邮件列表时，请记住保持良好的行为习惯。下面的链接提供了与这些列表（或任何其它邮件列表）交流的一些简单规则，虽然内容有点滥竽充数。</p><p><a href="http://www.albion.com/netiquette/">http://www.albion.com/netiquette/</a></p><p>当有很多人回复你的邮件时，邮件的抄送列表会变得很长。请不要将任何人从抄送列表中删除，除非你有足够的理由这么做。也不要只回复到邮件列表。请习惯于同一封邮件接收两次（一封来自发送者一封来自邮件列表），而不要试图通过添加一些奇特的邮件头来解决这个问题，人们不会喜欢的。</p><p>记住保留你所回复内容的上下文和源头。在你回复邮件的顶部保留“某某某说到……”这几行。将你的评论加在被引用的段落之间而不要放在邮件的顶部。</p><p>如果你在邮件中附带补丁，请确认它们是可以直接阅读的纯文本（如Documentation&#x2F;SubmittingPatches文档中所述）。内核开发者们不希望遇到附件或者被压缩了的补丁。只有这样才能保证他们可以直接评论你的每行代码。请确保你使用的邮件发送程序不会修改空格和制表符。一个防范性的测试方法是先将邮件发送给自己，然后自己尝试是否可以顺利地打上收到的补丁。如果测试不成功，请调整或者更换你的邮件发送程序直到它正确工作为止。</p><p>总而言之，请尊重其他的邮件列表订阅者。</p><p>同内核社区合作</p><hr><p> 内核社区的目标就是提供尽善尽美的内核。所以当你提交补丁期望被接受进内核的时候，它的技术价值以及其他方面都将被评审。那么你可能会得到什么呢？</p><ul><li>批评</li><li>评论</li><li>要求修改</li><li>要求证明修改的必要性</li><li>沉默</li></ul><p>要记住，这些是把补丁放进内核的正常情况。你必须学会听取对补丁的批评和评论，从技术层面评估它们，然后要么重写你的补丁要么简明扼要地论证修改是不必要的。如果你发的邮件没有得到任何回应，请过几天后再试一次，因为有时信件会湮没在茫茫信海中。</p><p>你不应该做的事情：</p><ul><li><p>期望自己的补丁不受任何质疑就直接被接受</p></li><li><p>翻脸</p></li><li><p>忽略别人的评论</p></li><li><p>没有按照别人的要求做任何修改就重新提交</p></li></ul><p>在一个努力追寻最好技术方案的社区里，对于一个补丁有多少好处总会有不同的见解。你必须要抱着合作的态度，愿意改变自己的观点来适应内核的风格。或者至少愿意去证明你的想法是有价值的。记住，犯错误是允许的，只要你愿意朝着正确的方案去努力。</p><p>如果你的第一个补丁换来的是一堆修改建议，这是很正常的。这并不代表你的补丁不会被接受，也不意味着有人和你作对。你只需要改正所有提出的问题然后重新发送你的补丁。</p><p>内核社区和公司文化的差异</p><hr><p> 内核社区的工作模式同大多数传统公司开发队伍的工作模式并不相同。下面这些例子，可以帮助你避免某些可能发生问题：</p><ul><li><p>用这些话介绍你的修改提案会有好处：</p><ul><li>它同时解决了多个问题</li><li>它删除了2000行代码</li><li>这是补丁，它已经解释了我想要说明的</li><li>我在5种不同的体系结构上测试过它……</li><li>这是一系列小补丁用来……</li><li>这个修改提高了普通机器的性能……</li></ul></li><li><p>应该避免如下的说法：</p><ul><li>我们在AIX&#x2F;ptx&#x2F;Solaris就是这么做的，所以这么做肯定是好的……</li><li>我做这行已经20年了，所以……</li><li>为了我们公司赚钱考虑必须这么做</li><li>这是我们的企业产品线所需要的</li><li>这里是描述我观点的1000页设计文档</li><li>这是一个5000行的补丁用来……</li><li>我重写了现在乱七八糟的代码，这就是……</li><li>我被规定了最后期限，所以这个补丁需要立刻被接受</li></ul></li></ul><p>另外一个内核社区与大部分传统公司的软件开发队伍不同的地方是无法面对面地交流。使用电子邮件和IRC聊天工具做为主要沟通工具的一个好处是性别和种族歧视将会更少。Linux内核的工作环境更能接受妇女和少数族群，因为每个人在别人眼里只是一个邮件地址。国际化也帮助了公平的实现，因为你无法通过姓名来判断人的性别。男人有可能叫李丽，女人也有可能叫王刚。大多数在Linux内核上工作过并表达过看法的女性对在linux上工作的经历都给出了正面的评价。</p><p>对于一些不习惯使用英语的人来说，语言可能是一个引起问题的障碍。在邮件列表中要正确地表达想法必需良好地掌握语言，所以建议你在发送邮件之前最好检查一下英文写得是否正确。</p><p>拆分修改</p><hr><p> Linux内核社区并不喜欢一下接收大段的代码。修改需要被恰当地介绍、讨论并且拆分成独立的小段。这几乎完全和公司中的习惯背道而驰。你的想法应该在开发最开始的阶段就让大家知道，这样你就可以及时获得对你正在进行的开发的反馈。这样也会让社区觉得你是在和他们协作，而不是仅仅把他们当作倾销新功能的对象。无论如何，你不要一次性地向邮件列表发送50封信，你的补丁序列应该永远用不到这么多。</p><p>将补丁拆开的原因如下：</p><ol><li>小的补丁更有可能被接受，因为它们不需要太多的时间和精力去验证其正确性。一个5行的补丁，可能在维护者看了一眼以后就会被接受。而500行的补丁则需要数个小时来审查其正确性（所需时间随补丁大小增加大约呈指数级增长）。当出了问题的时候，小的补丁也会让调试变得非常容易。一个一个补丁地回溯将会比仔细剖析一个被打上的大补丁（这个补丁破坏了其他东西）容易得多。</li><li>不光发送小的补丁很重要，在提交之前重新编排、化简（或者仅仅重新排列）补丁也是很重要的。</li></ol><p>这里有内核开发者Al Viro打的一个比方：</p><p>“想象一个老师正在给学生批改数学作业。老师并不希望看到学生为了得到正确解法所进行的尝试和产生的错误。他希望看到的是最干净最优雅的解答。好学生了解这点，绝不会把最终解决之前的中间方案提交上去。”</p><p>内核开发也是这样。维护者和评审者不希望看到一个人在解决问题时的思考过程。他们只希望看到简单和优雅的解决方案。</p><p> 直接给出一流的解决方案，和社区一起协作讨论尚未完成的工作，这两者之间似乎很难找到一个平衡点。所以最好尽早开始收集有利于你进行改进的反馈；同时也要保证修改分成很多小块，这样在整个项目都准备好被包含进内核之前，其中的一部分可能会先被接收。</p><p>必须了解这样做是不可接受的：试图将未完成的工作提交进内核，然后再找时间修复。</p><p>证明修改的必要性</p><hr><p>除了将补丁拆成小块，很重要的一点是让Linux社区了解他们为什么需要这样修改。你必须证明新功能是有人需要的并且是有用的。</p><p>记录修改</p><hr><p> 当你发送补丁的时候，需要特别留意邮件正文的内容。因为这里的信息将会做为补丁的修改记录(ChangeLog)，会被一直保留以备大家查阅。它需要完全地描述补丁，包括：</p><ul><li>为什么需要这个修改</li><li>补丁的总体设计</li><li>实现细节</li><li>测试结果</li></ul><p>想了解它具体应该看起来像什么，请查阅以下文档中的“ChangeLog”章节：</p><p>“The Perfect Patch”</p><p><a href="http://userweb.kernel.org/~akpm/stuff/tpp.txt">http://userweb.kernel.org/~akpm/stuff/tpp.txt</a></p><p>这些事情有时候做起来很难。要在任何方面都做到完美可能需要好几年时间。这是一个持续提高的过程，它需要大量的耐心和决心。只要不放弃，你一定可以做到。很多人已经做到了，而他们都曾经和现在的你站在同样的起点上。</p><hr><p>感谢Paolo Ciarrocchi允许“开发流程”部分基于他所写的文章(<a href="http://www.kerneltravel.net/newbie/2.6-development_process)%EF%BC%8C%E6%84%9F%E8%B0%A2Randy">http://www.kerneltravel.net/newbie/2.6-development_process)，感谢Randy</a> Dunlap和Gerrit Huizenga完善了应该说和不该说的列表。感谢Pat Mochel, Hanna Linder, Randy Dunlap, Kay Sievers, Vojtech Pavlik, Jan Kara, Josh Boyer, Kees Cook, Andrew Morton, Andi Kleen, Vadim Lobanov, Jesper Juhl, Adrian Bunk, Keri Harris, Frans Pop, David A. Wheeler, Junio Hamano, Michael Kerrisk和Alex Shepard的评审、建议和贡献。没有他们的帮助，这篇文档是不可能完成的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设置Linux操作系统中shell命令所使用的语言</title>
      <link href="/posts/2019-06-04-linux-command-line-languages.html"/>
      <url>/posts/2019-06-04-linux-command-line-languages.html</url>
      
        <content type="html"><![CDATA[<p>跟上篇文章一样，我们在Linux终端中执行命令或者shell脚本中写的一些命令，我们需要命令返回的内容是英文的或是其他特定语言。这样能够方便解析。但是又不想去更改系统中语言设置。</p><p>这样我们可以通过下面的命令去执行。而且这样执行的优势在于这条命令并不会改变上下文命令的语言设置。也就是说在执行完这条命令后再次单独执行其他语句，依旧会使用系统的语言设置。</p><pre><code>root@Ubuntu:~ # LANGUAGE=UTF-8.en_US ifconfigdocker0   Link encap:Ethernet  HWaddr 02:42:b2:02:ad:94          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0          inet6 addr: fe80::42:b2ff:fe02:ad94/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:1710847 errors:0 dropped:0 overruns:0 frame:0          TX packets:1866348 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:3582006491 (3.5 GB)  TX bytes:2946591020 (2.9 GB)eth0      Link encap:Ethernet  HWaddr c0:3f:d5:7e:ef:77          inet addr:218.87.136.149  Bcast:218.87.136.255  Mask:255.255.255.0          inet6 addr: fe80::c23f:d5ff:fe7e:ef77/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:31800898 errors:0 dropped:0 overruns:0 frame:0          TX packets:36529927 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000          RX bytes:18452250191 (18.4 GB)  TX bytes:31488753081 (31.4 GB)lo        Link encap:Local Loopback          inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:275598069 errors:0 dropped:0 overruns:0 frame:0          TX packets:275598069 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1          RX bytes:103171269005 (103.1 GB)  TX bytes:103171269005 (103.1 GB)veth167a874 Link encap:Ethernet  HWaddr ce:e0:00:e9:71:55          inet6 addr: fe80::cce0:ff:fee9:7155/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:6036069 errors:0 dropped:0 overruns:0 frame:0          TX packets:6420379 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:3917653147 (3.9 GB)  TX bytes:1267777009 (1.2 GB)vethf4c4a08 Link encap:Ethernet  HWaddr f2:04:05:bf:d7:0c          inet6 addr: fe80::f004:5ff:febf:d70c/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:8067819 errors:0 dropped:0 overruns:0 frame:0          TX packets:7841012 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:0          RX bytes:4866869981 (4.8 GB)  TX bytes:6762834339 (6.7 GB)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>让Windows命令提示符显示指定国家语言</title>
      <link href="/posts/2019-06-04-windows-command-line-languages.html"/>
      <url>/posts/2019-06-04-windows-command-line-languages.html</url>
      
        <content type="html"><![CDATA[<p>在不同的Windows环境下我们都不能直接确定服务器上默认语言是什么。也不能直接修改服务器的默认语言，这里我们为什么要说服务器呢？因为脚本这种工具大多时候都是为了解决服务器上的一些问题而存在的。至于为什么有些人要用Windows来作为服务器呢，这我就没法理解了，毕竟Windows作为服务器的话，虽然操作简单，但是如果是想要做分布式，还是比较麻烦的，软件安装不能自动化，软件配置也不能自动化。</p><p>这里我们需要解决的是 <strong>Windows上命令提示符指定显示的国家语言</strong>，但是这个解决方式也并不是完美的，首先指定指令有返回，而Windows上没有Linux那样的重定向黑洞（&#x2F;dev&#x2F;null）也就是需要生成一个新的文件来接收垃圾输出，而且由于系统默认的时间格式存在，导致部分程序的输出中还是带有中文。</p><h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>在编写脚本的时候，有时候需要特定的返回结果显示语言。这里我们就需要知道怎么在Windows命令提示符中指定显示语言了。</p><h3 id="0x01-解决方案"><a href="#0x01-解决方案" class="headerlink" title="0x01 解决方案"></a>0x01 解决方案</h3><p>就如下面</p><pre><code>C:\Users\ismdeep&gt;ping www.baidu.com正在 Ping www.baidu.com [14.215.177.38] 具有 32 字节的数据:来自 14.215.177.38 的回复: 字节=32 时间=22ms TTL=52来自 14.215.177.38 的回复: 字节=32 时间=22ms TTL=52来自 14.215.177.38 的回复: 字节=32 时间=22ms TTL=52来自 14.215.177.38 的回复: 字节=32 时间=22ms TTL=5214.215.177.38 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 22ms，最长 = 22ms，平均 = 22ms</code></pre><pre><code>下表列出了所有支持的代码页及其国家(地区)或者语言：代码页       国家(地区)或语言437          美国708          阿拉伯文(ASMO 708)720          阿拉伯文(DOS)850          多语言(拉丁文 I)852          中欧(DOS) - 斯拉夫语(拉丁文 II)855          西里尔文(俄语)857          土耳其语860          葡萄牙语861          冰岛语862          希伯来文(DOS)863          加拿大 - 法语865          日耳曼语866          俄语 - 西里尔文(DOS)869          现代希腊语874          泰文(Windows)932          日文(Shift-JIS)936          中国 - 简体中文(GB2312)949          韩文950          繁体中文(Big5)1200         Unicode1201         Unicode (Big-Endian)1250         中欧(Windows)1251         西里尔文(Windows)1252         西欧(Windows)1253         希腊文(Windows)1254         土耳其文(Windows)1255         希伯来文(Windows)1256         阿拉伯文(Windows)1257         波罗的海文(Windows)1258         越南文(Windows)20866        西里尔文(KOI8-R)21866        西里尔文(KOI8-U)28592        中欧(ISO)28593        拉丁文 3 (ISO)28594        波罗的海文(ISO)28595        西里尔文(ISO)28596        阿拉伯文(ISO)28597        希腊文(ISO)28598        希伯来文(ISO-Visual)38598        希伯来文(ISO-Logical)50000        用户定义的50001        自动选择50220        日文(JIS)50221        日文(JIS-允许一个字节的片假名)50222        日文(JIS-允许一个字节的片假名 - SO/SI)50225        韩文(ISO)50932        日文(自动选择)50949        韩文(自动选择)51932        日文(EUC)51949        韩文(EUC)52936        简体中文(HZ)65000        Unicode (UTF-7)65001        Unicode (UTF-8)</code></pre><pre><code>C:\Users\ismdeep&gt;mode con cp select=437 &gt; log.txt &amp;&amp; ping www.baidu.comPinging www.baidu.com [14.215.177.39] with 32 bytes of data:Reply from 14.215.177.39: bytes=32 time=31ms TTL=52Reply from 14.215.177.39: bytes=32 time=30ms TTL=52Reply from 14.215.177.39: bytes=32 time=31ms TTL=52Reply from 14.215.177.39: bytes=32 time=30ms TTL=52Ping statistics for 14.215.177.39:    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),Approximate round trip times in milli-seconds:    Minimum = 30ms, Maximum = 31ms, Average = 30ms</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据预备知识</title>
      <link href="/posts/2019-05-16-big-data-prerequisite-knowledge.html"/>
      <url>/posts/2019-05-16-big-data-prerequisite-knowledge.html</url>
      
        <content type="html"><![CDATA[<p>大图</p><span id="more"></span><p><a href="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/5b05fd7e86866441aeb728f7f598f251-a23239.png">点击下载</a></p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/5b05fd7e86866441aeb728f7f598f251-a23239.png" alt="BigData"></p>]]></content>
      
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to write git commit message</title>
      <link href="/posts/2019-04-21-how-to-write-a-git-commit-message.html"/>
      <url>/posts/2019-04-21-how-to-write-a-git-commit-message.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/451016cbf7ad1b82b51fe0d26765b57d-292339.png" alt="img"></p><hr><p><a href="https://chris.beams.io/posts/git-commit/#intro">Introduction</a> | <a href="https://chris.beams.io/posts/git-commit/#seven-rules">The Seven Rules</a> | <a href="https://chris.beams.io/posts/git-commit/#tips">Tips</a></p><hr><h2 id="Introduction-Why-good-commit-messages-matter"><a href="#Introduction-Why-good-commit-messages-matter" class="headerlink" title="Introduction: Why good commit messages matter"></a>Introduction: Why good commit messages matter</h2><p>If you browse the log of any random Git repository, you will probably find its commit messages are more or less a mess. For example, take a look at <a href="https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams">these gems</a> from my early days committing to Spring:</p><pre><code>$ git log --oneline -5 --author cbeams --before &quot;Fri Mar 26 2009&quot;e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)147709f Tweaks to package-info.java files22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils7f96f57 polishing</code></pre><p>Yikes. Compare that with these <a href="https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb">more recent</a> commits from the same repository:</p><pre><code>$ git log --oneline -5 --author pwebb --before &quot;Sat Aug 30 2014&quot;5ba3db6 Fix failing CompositePropertySourceTests84564a0 Rework @PropertySource early parsing logice142fd1 Add tests for ImportSelector meta-data887815f Update docbook dependency and generate epubac8326d Polish mockito usage</code></pre><p>Which would you rather read?</p><p>The former varies in length and form; the latter is concise and consistent.<br>The former is what happens by default; the latter never happens by accident.</p><p>While many repositories’ logs look like the former, there are exceptions. The <a href="https://github.com/torvalds/linux/commits/master">Linux kernel</a> and <a href="https://github.com/git/git/commits/master">Git itself</a> are great examples. Look at <a href="https://github.com/spring-projects/spring-boot/commits/master">Spring Boot</a>, or any repository managed by <a href="https://github.com/tpope/vim-pathogen/commits/master">Tim Pope</a>.</p><p>The contributors to these repositories know that a well-crafted Git commit message is the best way to communicate <em>context</em> about a change to fellow developers (and indeed to their future selves). A diff will tell you <em>what</em> changed, but only the commit message can properly tell you <em>why</em>. Peter Hutterer <a href="http://who-t.blogspot.co.at/2009/12/on-commit-messages.html">makes this point</a> well:</p><blockquote><p>Re-establishing the context of a piece of code is wasteful. We can’t avoid it completely, so our efforts should go to <a href="http://www.osnews.com/story/19266/WTFs_m">reducing it</a>[as much] as possible. Commit messages can do exactly that and as a result, <em>a commit message shows whether a developer is a good collaborator</em>.</p></blockquote><p>If you haven’t given much thought to what makes a great Git commit message, it may be the case that you haven’t spent much time using <code>git log</code> and related tools. There is a vicious cycle here: because the commit history is unstructured and inconsistent, one doesn’t spend much time using or taking care of it. And because it doesn’t get used or taken care of, it remains unstructured and inconsistent.</p><p>But a well-cared for log is a beautiful and useful thing. <code>git blame</code>, <code>revert</code>, <code>rebase</code>, <code>log</code>, <code>shortlog</code> and other subcommands come to life. Reviewing others’ commits and pull requests becomes something worth doing, and suddenly can be done independently. Understanding why something happened months or years ago becomes not only possible but efficient.</p><p>A project’s long-term success rests (among other things) on its maintainability, and a maintainer has few tools more powerful than his project’s log. It’s worth taking the time to learn how to care for one properly. What may be a hassle at first soon becomes habit, and eventually a source of pride and productivity for all involved.</p><p>In this post, I am addressing just the most basic element of keeping a healthy commit history: how to write an individual commit message. There are other important practices like commit squashing that I am not addressing here. Perhaps I’ll do that in a subsequent post.</p><p>Most programming languages have well-established conventions as to what constitutes idiomatic style, i.e. naming, formatting and so on. There are variations on these conventions, of course, but most developers agree that picking one and sticking to it is far better than the chaos that ensues when everybody does their own thing.</p><p>A team’s approach to its commit log should be no different. In order to create a useful revision history, teams should first agree on a commit message convention that defines at least the following three things:</p><p><strong>Style.</strong> Markup syntax, wrap margins, grammar, capitalization, punctuation. Spell these things out, remove the guesswork, and make it all as simple as possible. The end result will be a remarkably consistent log that’s not only a pleasure to read but that actually <em>does get read</em> on a regular basis.</p><p><strong>Content.</strong> What kind of information should the body of the commit message (if any) contain? What should it <em>not</em> contain?</p><p><strong>Metadata.</strong> How should issue tracking IDs, pull request numbers, etc. be referenced?</p><p>Fortunately, there are well-established conventions as to what makes an idiomatic Git commit message. Indeed, many of them are assumed in the way certain Git commands function. There’s nothing you need to re-invent. Just follow the <a href="https://chris.beams.io/posts/git-commit/#seven-rules">seven rules</a> below and you’re on your way to committing like a pro.</p><h2 id="The-seven-rules-of-a-great-Git-commit-message"><a href="#The-seven-rules-of-a-great-Git-commit-message" class="headerlink" title="The seven rules of a great Git commit message"></a>The seven rules of a great Git commit message</h2><blockquote><p><em>Keep in mind: This has all been said before.</em></p></blockquote><ol><li><a href="https://chris.beams.io/posts/git-commit/#separate">Separate subject from body with a blank line</a></li><li><a href="https://chris.beams.io/posts/git-commit/#limit-50">Limit the subject line to 50 characters</a></li><li><a href="https://chris.beams.io/posts/git-commit/#capitalize">Capitalize the subject line</a></li><li><a href="https://chris.beams.io/posts/git-commit/#end">Do not end the subject line with a period</a></li><li><a href="https://chris.beams.io/posts/git-commit/#imperative">Use the imperative mood in the subject line</a></li><li><a href="https://chris.beams.io/posts/git-commit/#wrap-72">Wrap the body at 72 characters</a></li><li><a href="https://chris.beams.io/posts/git-commit/#why-not-how">Use the body to explain <em>what</em> and <em>why</em> vs. <em>how</em></a></li></ol><p>For example:</p><pre><code>Summarize changes in around 50 characters or lessMore detailed explanatory text, if necessary. Wrap it to about 72characters or so. In some contexts, the first line is treated as thesubject of the commit and the rest of the text as the body. Theblank line separating the summary from the body is critical (unlessyou omit the body entirely); various tools like `log`, `shortlog`and `rebase` can get confused if you run the two together.Explain the problem that this commit is solving. Focus on why youare making this change as opposed to how (the code explains that).Are there side effects or other unintuitive consequences of thischange? Here&#39;s the place to explain them.Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded   by a single space, with blank lines in between, but conventions   vary hereIf you use an issue tracker, put references to them at the bottom,like this:Resolves: #123See also: #456, #789</code></pre><h3 id="1-Separate-subject-from-body-with-a-blank-line"><a href="#1-Separate-subject-from-body-with-a-blank-line" class="headerlink" title="1. Separate subject from body with a blank line"></a>1. Separate subject from body with a blank line</h3><p>From the <code>git commit</code> <a href="https://www.kernel.org/pub/software/scm/git/docs/git-commit.html#_discussion">manpage</a>:</p><blockquote><p>Though not required, it’s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, Git-format-patch(1) turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</p></blockquote><p>Firstly, not every commit requires both a subject and a body. Sometimes a single line is fine, especially when the change is so simple that no further context is necessary. For example:</p><pre><code>Fix typo in introduction to user guide</code></pre><p>Nothing more need be said; if the reader wonders what the typo was, she can simply take a look at the change itself, i.e. use <code>git show</code> or <code>git diff</code> or <code>git log -p</code>.</p><p>If you’re committing something like this at the command line, it’s easy to use the <code>-m</code> option to <code>git commit</code>:</p><pre><code>$ git commit -m&quot;Fix typo in introduction to user guide&quot;</code></pre><p>However, when a commit merits a bit of explanation and context, you need to write a body. For example:</p><pre><code>Derezz the master control programMCP turned out to be evil and had become intent on world domination.This commit throws Tron&#39;s disc into MCP (causing its deresolution)and turns it back into a chess game.</code></pre><p>Commit messages with bodies are not so easy to write with the <code>-m</code> option. You’re better off writing the message in a proper text editor. If you do not already have an editor set up for use with Git at the command line, read <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration">this section of Pro Git</a>.</p><p>In any case, the separation of subject from body pays off when browsing the log. Here’s the full log entry:</p><pre><code>$ git logcommit 42e769bdf4894310333942ffc5a15151222a87beAuthor: Kevin Flynn &lt;kevin@flynnsarcade.com&gt;Date:   Fri Jan 01 00:00:00 1982 -0200 Derezz the master control program MCP turned out to be evil and had become intent on world domination. This commit throws Tron&#39;s disc into MCP (causing its deresolution) and turns it back into a chess game.</code></pre><p>And now <code>git log --oneline</code>, which prints out just the subject line:</p><pre><code>$ git log --oneline42e769 Derezz the master control program</code></pre><p>Or, <code>git shortlog</code>, which groups commits by user, again showing just the subject line for concision:</p><pre><code>$ git shortlogKevin Flynn (1):      Derezz the master control programAlan Bradley (1):      Introduce security program &quot;Tron&quot;Ed Dillinger (3):      Rename chess program to &quot;MCP&quot;      Modify chess program      Upgrade chess programWalter Gibbs (1):      Introduce protoype chess program</code></pre><p>There are a number of other contexts in Git where the distinction between subject line and body kicks in—but none of them work properly without the blank line in between.</p><h3 id="2-Limit-the-subject-line-to-50-characters"><a href="#2-Limit-the-subject-line-to-50-characters" class="headerlink" title="2. Limit the subject line to 50 characters"></a>2. Limit the subject line to 50 characters</h3><p>50 characters is not a hard limit, just a rule of thumb. Keeping subject lines at this length ensures that they are readable, and forces the author to think for a moment about the most concise way to explain what’s going on.</p><blockquote><p><em>Tip: If you’re having a hard time summarizing, you might be committing too many changes at once. Strive for atomic commits(a topic for a separate post).</em></p></blockquote><p>GitHub’s UI is fully aware of these conventions. It will warn you if you go past the 50 character limit:</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/b9f649e265c04102449bf16b6929472e-78c8c1.png" alt="gh1"></p><p>And will truncate any subject line longer than 72 characters with an ellipsis:</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/8da62d7b9cc5f5c1b12270b1c4ee66b9-4bb1a6.png" alt="gh2"></p><p>So shoot for 50 characters, but consider 72 the hard limit.</p><h3 id="3-Capitalize-the-subject-line"><a href="#3-Capitalize-the-subject-line" class="headerlink" title="3. Capitalize the subject line"></a>3. Capitalize the subject line</h3><p>This is as simple as it sounds. Begin all subject lines with a capital letter.</p><p>For example:</p><ul><li>Accelerate to 88 miles per hour</li></ul><p>Instead of:</p><ul><li>accelerate to 88 miles per hour</li></ul><h3 id="4-Do-not-end-the-subject-line-with-a-period"><a href="#4-Do-not-end-the-subject-line-with-a-period" class="headerlink" title="4. Do not end the subject line with a period"></a>4. Do not end the subject line with a period</h3><p>Trailing punctuation is unnecessary in subject lines. Besides, space is precious when you’re trying to keep them to <a href="https://chris.beams.io/posts/git-commit/#limit-50">50 chars or less</a>.</p><p>Example:</p><ul><li>Open the pod bay doors</li></ul><p>Instead of:</p><ul><li>Open the pod bay doors.</li></ul><h3 id="5-Use-the-imperative-mood-in-the-subject-line"><a href="#5-Use-the-imperative-mood-in-the-subject-line" class="headerlink" title="5. Use the imperative mood in the subject line"></a>5. Use the imperative mood in the subject line</h3><p><em>Imperative mood</em> just means “spoken or written as if giving a command or instruction”. A few examples:</p><ul><li>Clean your room</li><li>Close the door</li><li>Take out the trash</li></ul><p>Each of the seven rules you’re reading about right now are written in the imperative (“Wrap the body at 72 characters”, etc.).</p><p>The imperative can sound a little rude; that’s why we don’t often use it. But it’s perfect for Git commit subject lines. One reason for this is that <strong>Git itself uses the imperative whenever it creates a commit on your behalf</strong>.</p><p>For example, the default message created when using <code>git merge</code> reads:</p><pre><code>Merge branch &#39;myfeature&#39;</code></pre><p>And when using <code>git revert</code>:</p><pre><code>Revert &quot;Add the thing with the stuff&quot;This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d.</code></pre><p>Or when clicking the “Merge” button on a GitHub pull request:</p><pre><code>Merge pull request #123 from someuser/somebranch</code></pre><p>So when you write your commit messages in the imperative, you’re following Git’s own built-in conventions. For example:</p><ul><li>Refactor subsystem X for readability</li><li>Update getting started documentation</li><li>Remove deprecated methods</li><li>Release version 1.0.0</li></ul><p>Writing this way can be a little awkward at first. We’re more used to speaking in the <em>indicative mood</em>, which is all about reporting facts. That’s why commit messages often end up reading like this:</p><ul><li>Fixed bug with Y</li><li>Changing behavior of X</li></ul><p>And sometimes commit messages get written as a description of their contents:</p><ul><li>More fixes for broken stuff</li><li>Sweet new API methods</li></ul><p>To remove any confusion, here’s a simple rule to get it right every time.</p><p><strong>A properly formed Git commit subject line should always be able to complete the following sentence</strong>:</p><ul><li>If applied, this commit will <em>your subject line here</em></li></ul><p>For example:</p><ul><li>If applied, this commit will <em>refactor subsystem X for readability</em></li><li>If applied, this commit will <em>update getting started documentation</em></li><li>If applied, this commit will <em>remove deprecated methods</em></li><li>If applied, this commit will <em>release version 1.0.0</em></li><li>If applied, this commit will <em>merge pull request #123 from user&#x2F;branch</em></li></ul><p>Notice how this doesn’t work for the other non-imperative forms:</p><ul><li>If applied, this commit will <em>fixed bug with Y</em></li><li>If applied, this commit will <em>changing behavior of X</em></li><li>If applied, this commit will <em>more fixes for broken stuff</em></li><li>If applied, this commit will <em>sweet new API methods</em></li></ul><blockquote><p><em>Remember: Use of the imperative is important only in the subject line. You can relax this restriction when you’re writing the body.</em></p></blockquote><h3 id="6-Wrap-the-body-at-72-characters"><a href="#6-Wrap-the-body-at-72-characters" class="headerlink" title="6. Wrap the body at 72 characters"></a>6. Wrap the body at 72 characters</h3><p>Git never wraps text automatically. When you write the body of a commit message, you must mind its right margin, and wrap text manually.</p><p>The recommendation is to do this at 72 characters, so that Git has plenty of room to indent text while still keeping everything under 80 characters overall.</p><p>A good text editor can help here. It’s easy to configure Vim, for example, to wrap text at 72 characters when you’re writing a Git commit. Traditionally, however, IDEs have been terrible at providing smart support for text wrapping in commit messages (although in recent versions, IntelliJ IDEA has <a href="https://youtrack.jetbrains.com/issue/IDEA-53615">finally</a> <a href="https://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-448299">gotten</a> <a href="https://youtrack.jetbrains.com/issue/IDEA-53615#comment=27-446912">better</a>about this).</p><h3 id="7-Use-the-body-to-explain-what-and-why-vs-how"><a href="#7-Use-the-body-to-explain-what-and-why-vs-how" class="headerlink" title="7. Use the body to explain what and why vs. how"></a>7. Use the body to explain what and why vs. how</h3><p>This <a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6">commit from Bitcoin Core</a> is a great example of explaining what changed and why:</p><pre><code>commit eb0b56b19017ab5c16c745e6da39c53126924ed6Author: Pieter Wuille &lt;pieter.wuille@gmail.com&gt;Date:   Fri Aug 1 22:57:55 2014 +0200   Simplify serialize.h&#39;s exception handling   Remove the &#39;state&#39; and &#39;exceptmask&#39; from serialize.h&#39;s stream   implementations, as well as related methods.   As exceptmask always included &#39;failbit&#39;, and setstate was always   called with bits = failbit, all it did was immediately raise an   exception. Get rid of those variables, and replace the setstate   with direct exception throwing (which also removes some dead   code).   As a result, good() is never reached after a failure (there are   only 2 calls, one of which is in tests), and can just be replaced   by !eof().   fail(), clear(n) and exceptions() are just never called. Delete   them.</code></pre><p>Take a look at the <a href="https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6">full diff</a> and just think how much time the author is saving fellow and future committers by taking the time to provide this context here and now. If he didn’t, it would probably be lost forever.</p><p>In most cases, you can leave out details about how a change has been made. Code is generally self-explanatory in this regard (and if the code is so complex that it needs to be explained in prose, that’s what source comments are for). Just focus on making clear the reasons why you made the change in the first place—the way things worked before the change (and what was wrong with that), the way they work now, and why you decided to solve it the way you did.</p><p>The future maintainer that thanks you may be yourself!</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="Learn-to-love-the-command-line-Leave-the-IDE-behind"><a href="#Learn-to-love-the-command-line-Leave-the-IDE-behind" class="headerlink" title="Learn to love the command line. Leave the IDE behind."></a>Learn to love the command line. Leave the IDE behind.</h3><p>For as many reasons as there are Git subcommands, it’s wise to embrace the command line. Git is insanely powerful; IDEs are too, but each in different ways. I use an IDE every day (IntelliJ IDEA) and have used others extensively (Eclipse), but I have never seen IDE integration for Git that could begin to match the ease and power of the command line (once you know it).</p><p>Certain Git-related IDE functions are invaluable, like calling <code>git rm</code> when you delete a file, and doing the right stuff with <code>git</code> when you rename one. Where everything falls apart is when you start trying to commit, merge, rebase, or do sophisticated history analysis through the IDE.</p><p>When it comes to wielding the full power of Git, it’s command-line all the way.</p><p>Remember that whether you use Bash or Zsh or Powershell, there are <a href="https://git-scm.com/book/en/v2/Appendix-A%3A-Git-in-Other-Environments-Git-in-Bash">tab</a><a href="https://git-scm.com/book/en/v2/Appendix-A%3A-Git-in-Other-Environments-Git-in-Zsh">completion</a> <a href="https://git-scm.com/book/en/v2/Appendix-A%3A-Git-in-Other-Environments-Git-in-Powershell">scripts</a> that take much of the pain out of remembering the subcommands and switches.</p><h3 id="Read-Pro-Git"><a href="#Read-Pro-Git" class="headerlink" title="Read Pro Git"></a>Read Pro Git</h3><p>The <a href="https://git-scm.com/book/en/v2">Pro Git</a> book is available online for free, and it’s fantastic. Take advantage!</p><hr><p>Repost from: <a href="https://github.com/cbeams/chris.beams.io/commits/master/_posts/2014-08-31-git-commit.md">https://github.com/cbeams/chris.beams.io/commits/master/_posts/2014-08-31-git-commit.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学数学不好或许是数学教材的锅</title>
      <link href="/posts/2019-04-21-not-goog-at-math-maybe-it-is-lectures-fault.html"/>
      <url>/posts/2019-04-21-not-goog-at-math-maybe-it-is-lectures-fault.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>高数就不行了，我努力多时也没法把那些公式定理形象化理解，貌似只能死记硬背。所以直接导致大学物理、电磁场电磁波等科目成绩也相当一般。是不是我的脑子学到高中就是极限了？直说也无妨，因为我发现我现在干的这活其实学到初中就能做了，赚的貌似也还可以。。。囧。。。</p></blockquote><p> <strong>上了大学，为什么看不懂大学数学</strong></p><p>因为教材太差？</p><p>一个国家的教学水平，一定程度可以体现在教材的水平上；一个大学的教学水平，更似乎反应在教材水平上。我国绝大多数学校的数学课程都是直接从苏联数学继承过来的，三十多年来，变革的速度还是比较慢的。如果你看过美国的教材，或许可以从不同角度理解国内考研学生数学平均分的不及格，可能是题目太难，也可能是教材太差，真的太差。如果数学教材存在一个鄙视链，那可以说国内985比211好了一点点，但是常青藤系列比国内985好了一个几何量。</p><p>例如，同济版《高数》、浙大《概率统计》、同济《线代》这三套经典教材其实存在着巨大不足。他们表面听起来很高大，实际上继承了苏联空洞抽象的模式，以至于内容设置非常不合理，如果是属于应用型的《微积分》，国内的《高数》明显偏难，而且联系实际的题目太少；但是如果属于分析型的《微积分》，那内容又略显得简单和臃肿。以至于绝大部分学生毕业后基本完全忘记《高数》到底是什么，我不是说学生不认真学习或者老师差，而是教材的因素，教材，教材，真的太差了。因为《微积分》是学习《概率统计》和《线性代数》的必备条件，因此直接导致整体考研数学成绩非常差，而实际上目前考研的数学题目都是非常基础的，是教材上例题的加强版，合理的学习安排下，应该能考到120分左右。但因为教材的巨大诱导性，让学生产生了严重的恐惧心理和不满情绪，这又反作用了对数学的害怕和反感，真是一件很悲哀的事情。</p><p><strong>对《同济高数》的意见</strong></p><p>实际上，《同济高数》是非常抽象的，而且脱离实际的。从目录来看，似乎完整的覆盖了整个《CALCULUS》体系，但是在几乎所有的关键点上，同济的编者并没有用心处理，或者说，至少没有从学生的角度去思考。可以说一切知识都是：“点到为止，泛而不精”。全书语言都过于机械数字化，当然内容都是正确的，也没有明显错误，但正是这种”中庸精神“，少了一份灵气，少了一份让学生加深理解的辅助材料。要复制公式谁不会，我可以用几页A4纸把所有公式都写出来，难道这样就代表整个《微积分》了吗？往往是在公式之外的地方，在书本留白的边缘，在最细节的地方，最难的地方，最抽象的地方，最需要descriptive statement 的地方才能看出一个作者的功力是否深厚，学问是否到家。“举重若轻”，是对一个学者的最高的赞誉和评价，可惜国内教材和教授们在这个方面，还有很长的路要走呢。</p><p>《同济高数》用很准确的语言把极限“D-E”定义摆出来，但是没有说明这个定义的来龙去脉，因此很多学生都看不懂，甚至相当一部分学生都无法准确发音 delta -epislon，更别说理解到“为什么要用D-E来代表极限？不能用其他符号吗？”。而实际上 D-E 在古希腊字母中仅仅表示字母表的第四个和第五个字母，没有任何特殊的含义，主要是ABC 都被欧几里得霸占在几何学里，没办法用了，被迫无奈采用了 D-E。</p><p>而在美国教材中，原作者用了一大段很简单的语言和几幅图片，将极限进行了解释“Limit is an active approachingprocess, it is not a still real-valued number nor variable, no matter how closeyou are, you will never reach that target ”。极限这个概念在牛顿—莱布尼茨的时代还没有出现，因为极限涉及到的数学原理其实很复杂，仅仅是“连续性”和“光滑性”这两个看起来很简单的名词，就让整整一个世纪的数学家废寝忘食，夜以继日，才得出结论。</p><p>而至于我们今天看到的D-E定义，更是牛顿死后近两百年才被德国数学家威尔斯特拉斯提出，因此美版教材普遍都不要求“证明”，只要求“了解”极限的意识形态。《同济高数》对于一元微积分几乎完全没有实例，而对于极端重要的sinhx，coshx，更是只有寥寥几页纸，并且还带了一个星号，给人一种“欲练此功，必先自宫”的恐惧，sinhx,coshx 就是由 E^X 跟它的反函数E^(-X)进行线性组合得到的，简单吧？但是同济直接忽略了 y&#x3D;e^x 的教学，实际上 y&#x3D;e^x 是微积分中最简单，也是最重要的函数族。正因为这个特点，对它们的求导&#x2F;求积就非常简单，特别是后期学习无穷级数，泰勒展开式，向量微积分，开普勒三大定理，概率的MGF，都时时刻刻体现出 y&#x3D;e^x 的巨大威力。</p><p>更严重的问题是，同济和浙大的编者，都用了反人类的思维方法来开展教学。比如对y&#x3D;x^n的求导教学，同济是直接拿定义出来，先把它证明了，再举例告诉学生这个定理可以直接使用。台下的学生一脸问好……</p><p>难道大家不会觉得这是跟正常思维相反吗？美版教材就是先带领我们学会y&#x3D;1的求导，然后y&#x3D;x的求导，然后y&#x3D;x^2的求导，然后y&#x3D;x^3的求导，然后作者Stewart循循善诱地问同学说”nowdo you see any pattern among these process ? Can you GUESS what maybe thederivative of y&#x3D;x^5 ? And what about y&#x3D;x^n?”最后他才会摆出严密的定义，并证明。此时，学生也在过程之中学会了<strong>“<strong><strong>由特殊到一般，再由一般到特殊</strong></strong>”</strong>这样一个非常重要的数学思维。相对应的求积也一样，先计算y&#x3D;1的积分，然后y&#x3D;x的积分，然后y&#x3D;x^2的积分，然后y&#x3D;x^3的积分，最后再问学生”now do you see any pattern among these process ?Can you GUESS what maybe the antiderivative of y&#x3D;x^8, and what abouty&#x3D;x^n?”  Stewart从来不会直接甩出一堆晦涩的证明，而是先从几个简单的例子，引导学生去 GUESS 这样的结论是否具有一般性，并且证明自己的GUESS 是对的还是错的。Stewart 所用的例子都很简单，并没有太多的技巧和套路，但是这样的效果却非常好，由浅入深的帮助学生”explore the unknown”，这才是一名优秀的老师所应有的态度和水平。</p><p><strong>多年后，或许你会忘记多元积分的公式，你也会忘记<strong><strong>Laplace</strong></strong>，</strong> <strong>Fourier<strong><strong>，</strong></strong>Taylor****的公式，但只要你还记得推理的方法，你就很容易在几分钟内完成这一个过程。</strong>李开复曾经说到“忘掉你所学的一切公式和定理，如果你还能利用自己的理解去推理出来，那就说明你的学问已经到家了。” 对这句话，本人无比赞同。</p><p>美版教材同时附带了大量的一元微积分习题，只列举简单的入门习题：</p><p>（1）固定的鱼塘里放入一定数量的鱼苗，在足够营养下，鱼苗不会无限增长，而是指数增长，利用微积分知识，就可以求的相应的增长数量。     </p><p>（2）博尔特在一次110米栏比赛中，总用时12秒，那么问你，他在4.5秒的时候，具体的瞬间速度是多少？同样前提条件下，博尔特在8.5秒的时候，已经总共跑了多少米？最后就会问，有什么方式把上面两个不相干的问题联系起来？        </p><p>（3）某降血压的药物，给高血压病人吃了后，检测得血压下降的速度与药物浓度有直接关系，利用微积分就可以求得，吃多少的药物，才是有效的安全范围。        </p><p>（4）化学反应中，某元素反应时间跟元素浓度呈正比关系，但是明显不是普通的线性关系，利用微积分，就可以求的某时间的浓度，或者完全反应所需的时间。      </p><p>（5）发射地球同步卫星，需要多少做功，某瞬间需要多大的速度，如何确定速度跟做功之间的关系，在简易条件下如何检验相对论的正确性。      </p><p>（6）水面的波浪从中心点向外扩张，呈 sinhx 的轨迹；而悬链线的受力情况，却是呈coshx的轨迹，试用微积分知识进行简单说明。      </p><p>（7）流体通过某管道时，其靠近管壁的流体速度会因为阻力二减慢，中心部分由于阻力较小而速度加快，试用微积分知识来解释为什么。</p><p>当然还有大量的变速的位移，变力做工，经济学的边际效应，价格弹性，资产定价模型（CAPM, WACC），旋转体的体积，等等都是《同济高数》所缺少的实际应用。正是因为这些栩栩如生的例子，学生才能深刻理解到微积分对于现代生活的巨大改变和意义。</p><p>否则，假如仅仅是把纯粹的数字翻来翻去，求导&#x2F;求积，学生都会了，那然后呢？难道学了微积分就是来做一个人工计算器吗？国内教材总是直接叫学生套用某某公式解题目，而忽略了公式之外的逻辑理解和推到能力，美版教材就基本相反，很强调对基本公式的推到和归纳能力，而降低对公式本身的依耐性。这是两种截然不同教育理念的冲突。</p><p>国内教材就像（<strong>授人与鱼</strong>），给你一堆公式和定理，让你照着用。美版教材就像（<strong>授人与渔</strong>）给你一种发现公式和定理的思维，让你学会自己归纳总结。它首先就会告诉我们：《微分学》研究“instantaneous,incremental and related changes” 的问题；而《积分学》研究“outputfrom irregular input ”的问题。《微积分》的本质就是研究”activevariable”的问题，教材特别多次强调“thesignificant difference between calculus and algebra and geometry is thatcalculus is dealing with ACTIVE&#x2F;MOVING variable and algebra&#x2F;geometry is workingon still variable”.</p><p><strong>对同济《线性代数》，浙大《概率统计》的意见</strong></p><p>这两套教材也是被国人视为瑰宝，敬而远之，但是相当大量的学生反映：“《概率统计》由于比较具体，还勉强看得懂。但是《现代》实在太抽象，所以很多学生反应无法理解”。因为这两套教材也十分抽象和理论化，缺少很重要的PREFACE，让学生在学习之前能对本学科有一个 FRAMEWORK 上的把握和掌控，基本上看完了也不知所云。</p><p>美版教材无论如何都会有这些东西，并且开篇就告诉你《线代》研究的对象是“vector, especially COLUMN vector”，并不是所谓的“matrix”或者“determinant”或者“eigenvalue”，并在一开始就对向量进行了细致的教学，从加法、减法，二维图示，三维图示，到dotproduct，到cross product，到matrix，到determinant，最后才是水到渠成地引入matrix as linear transformation。非理工科的学生，学到这里就差不多了，后面vector space 和 orthogonallity ,比较抽象，难度也大，可以有选择地放弃。</p><p>至于最重要的rank , nuliity , dimension ,同济并没有说清楚。如果是一维的，那就是两个向量共线；二维的，那就是两个向量形成一个四边形；三维的，那就是三个向量形成一个体积；四维以上的，照样是体积，但是一般不讨论。而所有的“行列式”、“矩阵”、“秩”、“通解”、“特解”、“特征向量”，“特征值”，等等名词，都是rref 后围绕COLUMNvector 展开的运算而已。但是由于《同济线代》根本没有这些基础知识做铺垫，导致学生基本看不懂教材的内容。就相当于：让学生去建造一栋摩天大楼，但是不让你打地基，直接就在平地施工建造第一层。实际上非理工类本科阶段的《线性代数》是非常简单的，是最基础的加减乘而已，但是（很多）学生却说不清楚 columnspace  和 row space 的区别，这就直接导致后期学习捉襟见肘，举步维艰。</p><p>浙大的《概率统计》相对来说比同济优秀太多了，但还是存在非常致命的缺点。首先，是体系太混乱，竟然对于discrete&#x2F;continuous RV 的最基础术语(pmf, pdf,cdf)都欠缺完整。其次，是教学太浅显，所有的实例都是一笔带过，对于大名鼎鼎的Poisson（），和Exponential () 甚至都没有说明白之间的微妙关系，简直不如维基百科。</p><p>美版的《概率与统计》对一维的变量分布进行了非常细致的教学，五种discrete&#x2F;continuous RV ，及其相关的mean，variance，median, skewness。每一种分布都配了至少五道例题，每到例题都有详细的解答思路和完整的mathmatical induction，几乎占据了一半的教材内容，并附带有非常丰富的课后练习。而对于更加复杂的二维变量，及其mean，cor-variance，co-relation,教材反而用了较少的版面，因为二维不过是两个一维变量围成的一个面积而已，其他并无明显差异，只要先扎扎实实学好一维的，二维的问题就变得很简单。美版教材特别说明了几个问题“Poissondistribution looks very complicated at first, but it is actually the discreteversion of Exponential distribution, which is very easy to calculate. ButExponential distribution, together with its brother Erlang distribution, isalso a simplified version of Gamma distribution. But the most interestingfinding is that the Chi-squared distribution is a special case of Gammadistribution as well as a special case of Norma distribution, which means tosome extent, all the important distributions can be related to Normaldistribution ! ” 其实越是学到后面，越会发现“向量”的重要性，它即出现在《线代》，也出现在《概率》，更出现在《高等微积分》中，可以说“向量”，是连接“可感知世界”与“不可感知世界”的桥梁，是数学的“核武器”。</p><p>看完美国教材只有一个感受：<strong>真正好的教育是将复杂的东西简化，强化基础概念和实际应用，弱化具体计算和逻辑证明，最终让普通学生也可掌握相对深奥的理论知识，并迅速转入实际应用。国内的教育正好相反：强化具体计算和逻辑证明，却弱化了基础概念和实际应用，最终生产了许多解题高手，但他们完全不懂这些数学<strong><strong>“</strong></strong>有什么用？<strong><strong>”</strong></strong>。</strong></p><p><strong>教材推荐</strong></p><p>以下教材是全英文的，对英语有较高的要求。当然，优秀的教材有很多，我只列举自己看过，并且给予好评的三本基础教材。他们难度适中，编写合理，循循渐进，很适合基础较差的经管类、或者理工科的大学生。</p><p>如果是初学者，请一定按照“微积分—概率论—线性代数”的流程来学习，因为“求导&#x2F;求积”的运算是后期概率运算的基础。但是在《概率统计》和《线代》中，后面几章难度大，并且跟其他学科联系较少，所以一般学生看看即可，不需深入。由于《微积分》彻底催化了物理学和化学，因此顺带推荐三套优秀的理科教材。如果把《微积分》学好，再去学物理学或者化学，那几乎是摧枯拉朽、风卷残云一般的容易。我是人大毕业的，看到母校引进并且出版了如此优秀的数学基础教材，感到非常高兴和自豪。可见，不仅仅是我一个人，而是更多专家学者，都深深感到了中美高等教育的巨大差距。感谢母校提供的双语教材，高瞻远瞩，可谓居功至伟。</p><p>《微积分》  </p><p>《概率论与数理统计》</p><p>《线性代数</p><p>《基础物理学》  </p><p>《大学物理》  </p><p>《基础化学》</p><p>《大学化学》</p><p>《基础生物学》</p><p>《大学生物学》</p><p>同时推荐一套相对来说比较“偏门的”书，是因为这些书虽然对考试没用，但是对于理解本学科，具有巨大的意义。对于特别重要的核心内容有深刻的解释，从时间轨迹来说明科学家是如何把生活中的“现象”，高度提炼成为具体的“公式”，并用这些公式来改变了整个世界。推荐给有志于深入学习的学生看一看，虽然数字论证比较晦涩，但是可以不看数学证明，仅看发展过程，当作小说读一遍也会受益匪浅。</p><p>《数学史》</p><p>《化学简史》</p><p>《物理学史》</p><p>《科学史》</p><p>《科学发现者：物理原理与问题》</p><p>《科学发现者：化学概念与应用》</p><p>《科学发现者：生物生命的动力》</p><p>《科学发现者：地理环境与宇宙》</p><p><strong>结语</strong></p><p>由于能力有限，小生不可能几句话就总结大学数学，不可能告诉别人如何短期内成为学霸，因为《大学数学》作为一门高度完整严谨的学科，终究要靠埋头苦读和日夜刷题才能学到真功夫。小生衷心地希望这篇短文能改变你们对数学的偏见和仇恨，为你们提供一个可以前进的方向，让高数不再那么高不可攀，让所有人都感受到数学之艺术和威力。</p><p>倘若将学习比作练武的话，那么教材就是练功秘籍，老师就是练功师傅。优秀的秘籍和师傅能让你事半功倍、文武双全，而劣质的秘籍和师傅则让你走火入魔、身败名裂。好了，写到这也差不多了。秘籍已经给你们提供在上面，但路始终在自己脚下，最终修炼成为丐帮帮主，亦或星宿老仙，就看各位自己了。</p><p>我在毕业后的工作里，大学数学并没有太多直接发挥的途径。几乎所有的计算和设计，都交给了计算机处理。但是在学习数学的过程中所得到的“严密的推理”和“精确的结构”和“顽强的意志”，这三样东西将会在你们的职业生涯发挥巨大的无形价值，无论你的职业，专业，性别，年纪，当你以后遇到困难和挫折，静下来想一想，当年数学都可以掌握，难道还会惧怕眼前的苟且吗？</p><p>说到底，数学给你带来的，其实是众神之上的“信心”。</p><p>英雄们，再会！</p><hr><p>转载自：【公众号：算法与数学之美】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统中进程打开文件(进程)数量的限制问题</title>
      <link href="/posts/2019-04-16-the-limit-problem-of-process-open-file-in-operating-system.html"/>
      <url>/posts/2019-04-16-the-limit-problem-of-process-open-file-in-operating-system.html</url>
      
        <content type="html"><![CDATA[<p>前段时间写了一个测试程序，每次都在第430个测试用例左右就会出现异常，然后程序终止。一开始还以为是使用的内存没有释放导致系统内存占用过多而出现问题。在一通调试（比如老老实实写一下释放内存的代码）之后，发现还是没有什么作用。最后干脆把测试的核心功能代码（也就是我要测试的真正功能代码）删掉，只保留了用于控制测试的代码，最后发现我把打开文件的代码关掉之后，就没有出现问题了。一看，惊了，每次打开的文件没有关闭操作。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;    for (int i = 0; i &lt; 20000; ++i) &#123;        printf(&quot;%d\n&quot;, i);        FILE *f = fopen(&quot;/data/in.txt&quot;, &quot;w&quot;);        fprintf(f, &quot;%d\n&quot;, i);    &#125;    return 0;&#125;</code></pre><pre><code class="text">012.........4858485948604861[1]    24575 segmentation fault  cmake-build-debug/open_file_limits_test</code></pre><p>而加上 <code>fclose(f);</code> 问题就解决了。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123;    for (int i = 0; i &lt; 20000; ++i) &#123;        printf(&quot;%d\n&quot;, i);        FILE *f = fopen(&quot;/data/in.txt&quot;, &quot;w&quot;);        fprintf(f, &quot;%d\n&quot;, i);        fclose(f);    &#125;    return 0;&#125;</code></pre><p>当然，事情到这里并没有结束，为什么之前我测试的时候是430左右，这里却是4861呢？因为这里是打开了文件，而之前写的是打开进程管道。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123;    for (int i = 0; i &lt; 20000; ++i) &#123;        char *cmd = (char *) malloc(sizeof(char) * 65535);        memset(cmd, 0, sizeof(char) * 65535);        sprintf(cmd, &quot;python3 -c \&quot;print(1 == 1)\&quot;&quot;);        FILE *f = popen(cmd, &quot;r+&quot;);        char *res = (char *) malloc(sizeof(char) * 1024);        memset(res, 0, sizeof(char) * 1024);        fscanf(f, &quot;%s&quot;, res);        printf(&quot;%d =&gt; %s\n&quot;, i, res);    &#125;    return 0;&#125;</code></pre><pre><code class="text">0 =&gt; True1 =&gt; True2 =&gt; True.........525 =&gt; True526 =&gt; True527 =&gt; True528 =&gt; True529 =&gt; True530 =&gt; True531 =&gt; True[1]    38030 segmentation fault  cmake-build-debug/open_file_limits_test</code></pre><p>而且这里如果要关闭这个文件不能使用 <code>fclose(f)&#39;</code> 不然在运行第二个开始都读取不了数据。</p><pre><code class="text">&gt; cmake-build-debug/open_file_limits_test0 =&gt; True1 =&gt;2 =&gt;3 =&gt;4 =&gt;5 =&gt;</code></pre><p>这里应该使用 <code>pclose(f);</code> ，当然动态分配的内存需要释放掉。</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123;    for (int i = 0; i &lt; 20000; ++i) &#123;        char *cmd = (char *) malloc(sizeof(char) * 65535);        memset(cmd, 0, sizeof(char) * 65535);        sprintf(cmd, &quot;python3 -c \&quot;print(1 == 1)\&quot;&quot;);        FILE *f = popen(cmd, &quot;r+&quot;);        char *res = (char *) malloc(sizeof(char) * 1024);        memset(res, 0, sizeof(char) * 1024);        fscanf(f, &quot;%s&quot;, res);        printf(&quot;%d =&gt; %s\n&quot;, i, res);        pclose(f);        free(cmd);        free(res);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Linux </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下安装最新版本的 Python 3.7</title>
      <link href="/posts/2019-04-10-install-the-latest-version-python-3-7-on-linux.html"/>
      <url>/posts/2019-04-10-install-the-latest-version-python-3-7-on-linux.html</url>
      
        <content type="html"><![CDATA[<p>本教程将教你如何在 Linux 环境下通过 Python 官方发布的源码安装包进行安装 Python 3.7 环境。本教程编写时（2018-04-10） Python 官网发布的 Python 3 最新版本为 3.7.3，本教程是在 CentOS 系统中测试安装的。其他 Linux 发行版应该也适用。</p><h3 id="0x00-准备工作"><a href="#0x00-准备工作" class="headerlink" title="0x00 准备工作"></a>0x00 准备工作</h3><p>首先需要通过安装一些依赖。</p><ol><li>CentOS 环境下</li></ol><pre><code class="bash">sudo yum -y install epel-releasesudo yum -y install axelsudo yum -y install gcc openssl-devel bzip2-devel libffi-devel</code></pre><ol start="2"><li>Ubuntu 环境下</li></ol><pre><code class="bash">sudo apt-get install -y axel make gcc \    g++ openssl bzip2 libffi-dev zlib1g-dev \    libssl-dev libsqlite3-devsudo apt install build-essential zlib1g-dev \    libncurses5-dev libgdbm-dev libnss3-dev \    libssl-dev libreadline-dev libffi-dev curl</code></pre><ol start="3"><li>FreeBSD 环境下</li></ol><p>虽然从严格意义上来说，FreeBSD 不应该算在 Linux，但这里顺便把 FreeBSD 下的也顺便说一下吧。</p><pre><code class="bash">pkg install -y vim axel gcc openssl bzip2 libffi</code></pre><h3 id="0x01-下载-Python-源码包"><a href="#0x01-下载-Python-源码包" class="headerlink" title="0x01 下载 Python 源码包"></a>0x01 下载 Python 源码包</h3><p>本教程提供两种源码包的下载方式。（原因你懂的）</p><ol><li>从官方下载<br>访问 <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> 找到最新版的 Python 版本，本教程用的是 Python 3.7.3，点击相应的链接（本教程为 <a href="https://www.python.org/downloads/release/python-373/%EF%BC%89%E3%80%82">https://www.python.org/downloads/release/python-373/）。</a></li></ol><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/c8ca6b9500aec89151fd0adf88ee5c21-0ef35c.png" alt="XZ compressed source tarball"></p><p>继续往下翻，在 Files 中找到 XZ compressed source tarball，在链接上右键获取链接。</p><pre><code>https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz</code></pre><p>获得地址之后就可以通过 curl 进行下载了。并且为了防止出现其他文件名的干扰，也为了方便安装后清理无用的文件，本人比较习惯创建一个新的临时目录来进行接下来的操作。</p><pre><code>[root@CentOS ~]# pwd/root[root@CentOS ~]# lsanaconda-ks.cfgmkdir tmp[root@CentOS ~]# cd tmp[root@CentOS tmp]# pwd/root/tmp[root@CentOS tmp]# curl https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tar.xz -o Python-3.7.3.tar.xz  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed 37 16.3M   37 6343k    0     0  37509      0  0:07:36  0:02:53  0:04:43     0</code></pre><p>很明显，这里下载速度真的是辣眼睛，如果有足够的时间就慢慢等吧。</p><ol start="2"><li>从笔者上传的地址下载。</li></ol><p>访问网址： <a href="https://download.ismdeep.com/python/">https://download.ismdeep.com/python/</a> 找到最新的 Python 3.7 版本.</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/07/af56ddba4199ce1494858e2371975384-222e29.png" alt="python download folder on download.ismdeep.com"></p><pre><code class="bash">https://download.ismdeep.com/python/Python-3.7.3.tar.xz</code></pre><pre><code class="bash">mkdir tmpcd tmpaxel -n 20 https://download.ismdeep.com/python/Python-3.7.3.tar.xz</code></pre><h3 id="0x02-安装"><a href="#0x02-安装" class="headerlink" title="0x02 安装"></a>0x02 安装</h3><h4 id="CentOS-Ubuntu"><a href="#CentOS-Ubuntu" class="headerlink" title="CentOS&#x2F;Ubuntu"></a>CentOS&#x2F;Ubuntu</h4><p>接上面下载目录继续使用下面命令进行安装 Python.</p><pre><code class="bash">xz -d Python-3.7.3.tar.xztar -xvf Python-3.7.3.tarcd Python-3.7.3./configure --prefix=/usr/local/python-3.7.3 --enable-optimizations --enable-loadable-sqlite-extensionssudo make -j8 build_allsudo make -j8 altinstall</code></pre><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>通过 brew 安装 xz ，sqlite3 以及 gdbm<br>Install xz and sqlite3 through brew</p><pre><code class="bash">brew install xzbrew install sqlite3brew install gdbm</code></pre><p>编译 openssl 1.0.2</p><pre><code class="bash">./Configure darwin64-x86_64-cc --prefix=/Users/ismdeep/Build/openssl-1.0.2u-binarymakemake install</code></pre><p>编译 Python 3.7.3</p><pre><code class="bash">./configure --prefix=/Users/ismdeep/Apps/python-3.7.3 \    --with-openssl=&quot;/Users/ismdeep/Build/openssl-1.0.2u-binary&quot; \    --enable-optimizations \    --enable-loadable-sqlite-extensionsmake -j8 build_allmake -j8 altinstall</code></pre><p>至此，我们的 Python 3.7 就已经安装完毕了。</p><p>看到网上很多教程，在最后都会去 &#x2F;usr&#x2F;bin 目录下做软链接，个人不太喜欢弄这个，并不想去影响系统已有的环境。那么我们该怎么使用我们的 python 呢。我们可以通过绝对路径去调用 python 和 pip.</p><p>比如：</p><pre><code class="bash">/usr/local/python-3.7.3/bin/pip3.7 install requests</code></pre><pre><code class="bash">/usr/local/python-3.7.3/bin/python3.7 main.py</code></pre><h3 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h3><p>很明显，我们在国内环境下使用 pip 安装包，速度是很慢的，慢到有时候根本就不动了。嗨呀，没办法，我们只能配置国内镜像源来安装包了。</p><p>在用户目录下的 <code>.pip/pip.conf</code> 文件中加入以下代码，比如用户目录是 <code>/root</code>，则为 <code>/root/.pip/pip.conf</code> 如果 <code>.pip</code> 目录不存在，则需要自己手动创建，这里就不再赘述了：</p><pre><code class="text">[global]index-url = https://mirrors.huaweicloud.com/repository/pypi/simpletrusted-host = mirrors.huaweicloud.comtimeout = 120</code></pre><p>各个系统的 pip 配置文件不定相同：</p><p>Windows: <code>C:\Users\xxxx\pip\pip.ini</code> (xxxx 表示用户名)</p><p>Linux: <code>~/.pip/pip.conf</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次神奇的杭电刷题体验</title>
      <link href="/posts/2019-04-08-a-magical-experience-with-hdu.html"/>
      <url>/posts/2019-04-08-a-magical-experience-with-hdu.html</url>
      
        <content type="html"><![CDATA[<p>先交代一下这次提交代码所用次数吧。一共显示我提交了77次。题号：HDU 2687</p><p>具体事情就是每次提交的代码都会被截断，Chrome 浏览器下提交代码直接返回 <code>ERR_CONNECTION_RESET</code>, 多次提交总结：大部分时候截断的地方是一样的，略有几次截断地方不一样。仔细查看自己的代码并没有发现什么问题，而且也不算大吧。我记得杭电提交的代码限制是 65535B，于是考虑是不是本地网络的问题，切换代理提交，也是一样的效果。然而 vjudge 竟然可以提交，于是想起，是不是我被杭电针对了，切换小号提交代码，也是一样的，看样子是我想多了。然后尝试了一下其他题目，发现 HDU 1000 的 Java 代码是可以提交的。可能是因为代码量小的缘故吧。</p><p>说了这么多，先上代码吧。</p><pre><code class="java">import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Scanner;/** * Built using CHelper plug-in * Actual solution is at the top * * @author ismdeep */public class Main &#123;    public static void main(String[] args) &#123;        InputStream inputStream = System.in;        OutputStream outputStream = System.out;        Scanner in = new Scanner(inputStream);        PrintWriter out = new PrintWriter(outputStream);        HDU2687 solver = new HDU2687();        solver.solve(1, in, out);        out.close();    &#125;    static class HDU2687 &#123;        public static int[][] rotate(int a[][], int n) &#123;            int[][] b = new int[n][n];            for (int i = 0; i &lt; n; ++i) &#123;                for (int j = 0; j &lt; n; ++j) &#123;                    b[n - j - 1][i] = a[i][j];                &#125;            &#125;            return b;        &#125;        public void solve(int testNumber, Scanner in, PrintWriter out) &#123;            while (in.hasNext()) &#123;                int n = in.nextInt();                int[][] a = new int[n][n];                for (int i = 0; i &lt; n; ++i) &#123;                    for (int j = 0; j &lt; n; ++j) &#123;                        a[i][j] = in.nextInt();                    &#125;                &#125;                int k = in.nextInt();                int[][] b0 = a;                int[][] b1 = rotate(rotate(rotate(b0, n), n), n);                int[][] b2 = rotate(rotate(rotate(b1, n), n), n);                int[][] b3 = rotate(rotate(rotate(b2, n), n), n);                long[][] ans = new long[n][n];                for (int i = 0; i &lt; n; ++i) &#123;                    for (int j = 0; j &lt; n; ++j) &#123;                        ans[i][j] = b0[i][j] + b1[i][j] + b2[i][j] + b3[i][j];                        ans[i][j] *= ((k + 1) / 4);                    &#125;                &#125;                if ((k + 1) % 4 == 1) &#123;                    for (int i = 0; i &lt; n; ++i) &#123;                        for (int j = 0; j &lt; n; ++j) &#123;                            ans[i][j] += b0[i][j];                        &#125;                    &#125;                &#125;                if ((k + 1) % 4 == 2) &#123;                    for (int i = 0; i &lt; n; ++i) &#123;                        for (int j = 0; j &lt; n; ++j) &#123;                            ans[i][j] += b0[i][j] + b1[i][j];                        &#125;                    &#125;                &#125;                if ((k + 1) % 4 == 3) &#123;                    for (int i = 0; i &lt; n; ++i) &#123;                        for (int j = 0; j &lt; n; ++j) &#123;                            ans[i][j] += b0[i][j] + b1[i][j] + b2[i][j];                        &#125;                    &#125;                &#125;                for (int i = 0; i &lt; n; ++i) &#123;                    for (int j = 0; j &lt; n; ++j) &#123;                        if (j != 0) &#123;                            out.write(&quot; &quot;);                        &#125;                        out.write(Long.toString(ans[i][j]));                    &#125;                    out.write(&quot;\n\n&quot;);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>后来想是不是浏览器的问题，于是开虚拟机，把 IE，FireFox 都尝试了也还是不能正常提交。这个时候基本上心态已经崩了。后来问了一下 Isun ，知道了 waf 的存在，很多学校都会有这么东西，类似一个入口的防火墙，在入口检测入侵攻击代码。可能是这个东西把我提交的代码数据当作入侵代码处理了。毕竟差不多 3KB，还是挺大的。</p><p>当时当时还没有想着去缩小代码量，而是用python动手写了一个模拟登录并提交代码的小程序。果然并没有让我失望，还是没能提交成功。</p><pre><code class="text">Traceback (most recent call last):  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 600, in urlopen    chunked=chunked)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 384, in _make_request    six.raise_from(e, None)  File &quot;&lt;string&gt;&quot;, line 2, in raise_from  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 380, in _make_request    httplib_response = conn.getresponse()  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py&quot;, line 1321, in getresponse    response.begin()  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py&quot;, line 296, in begin    version, status, reason = self._read_status()  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py&quot;, line 257, in _read_status    line = str(self.fp.readline(_MAXLINE + 1), &quot;iso-8859-1&quot;)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/socket.py&quot;, line 589, in readinto    return self._sock.recv_into(b)ConnectionResetError: [Errno 54] Connection reset by peerDuring handling of the above exception, another exception occurred:Traceback (most recent call last):  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/requests/adapters.py&quot;, line 449, in send    timeout=timeout  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 638, in urlopen    _stacktrace=sys.exc_info()[2])  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/util/retry.py&quot;, line 367, in increment    raise six.reraise(type(error), error, _stacktrace)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/packages/six.py&quot;, line 685, in reraise    raise value.with_traceback(tb)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 600, in urlopen    chunked=chunked)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 384, in _make_request    six.raise_from(e, None)  File &quot;&lt;string&gt;&quot;, line 2, in raise_from  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/urllib3/connectionpool.py&quot;, line 380, in _make_request    httplib_response = conn.getresponse()  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py&quot;, line 1321, in getresponse    response.begin()  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py&quot;, line 296, in begin    version, status, reason = self._read_status()  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/http/client.py&quot;, line 257, in _read_status    line = str(self.fp.readline(_MAXLINE + 1), &quot;iso-8859-1&quot;)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/socket.py&quot;, line 589, in readinto    return self._sock.recv_into(b)urllib3.exceptions.ProtocolError: (&#39;Connection aborted.&#39;, ConnectionResetError(54, &#39;Connection reset by peer&#39;))During handling of the above exception, another exception occurred:Traceback (most recent call last):  File &quot;/data/code-practice/python-practice/crawlers/hdu-submit.py&quot;, line 109, in &lt;module&gt;    main()  File &quot;/data/code-practice/python-practice/crawlers/hdu-submit.py&quot;, line 105, in main    submit_code(username, cookie, pid, langs[lang], open(code_path, &#39;r&#39;).read())  File &quot;/data/code-practice/python-practice/crawlers/hdu-submit.py&quot;, line 79, in submit_code    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&#39;  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/requests/api.py&quot;, line 116, in post    return request(&#39;post&#39;, url, data=data, json=json, **kwargs)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/requests/api.py&quot;, line 60, in request    return session.request(method=method, url=url, **kwargs)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/requests/sessions.py&quot;, line 533, in request    resp = self.send(prep, **send_kwargs)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/requests/sessions.py&quot;, line 646, in send    r = adapter.send(request, **kwargs)  File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/requests/adapters.py&quot;, line 498, in send    raise ConnectionError(err, request=request)requests.exceptions.ConnectionError: (&#39;Connection aborted.&#39;, ConnectionResetError(54, &#39;Connection reset by peer&#39;))Process finished with exit code 1</code></pre><p>于是接下来想着怎么缩小代码量，首当其冲的就是删除没用的空格和换行。</p><pre><code class="java">import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Scanner;public class Main &#123;public static void main(String[] args) &#123;InputStream inputStream = System.in;OutputStream outputStream = System.out;Scanner in = new Scanner(inputStream);PrintWriter out = new PrintWriter(outputStream);HDU2687 solver = new HDU2687();solver.solve(1, in, out);out.close();&#125;static class HDU2687 &#123;public static int[][] rotate(int a[][], int n) &#123;int[][] b = new int[n][n];for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;b[n - j - 1][i] = a[i][j];&#125;&#125;return b;&#125;public void solve(int testNumber, Scanner in, PrintWriter out) &#123;while (in.hasNext()) &#123;int n = in.nextInt();int[][] a = new int[n][n];for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;a[i][j] = in.nextInt();&#125;&#125;int k = in.nextInt();int[][] b0 = a;int[][] b1 = rotate(rotate(rotate(b0, n), n), n);int[][] b2 = rotate(rotate(rotate(b1, n), n), n);int[][] b3 = rotate(rotate(rotate(b2, n), n), n);long[][] ans = new long[n][n];for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] = b0[i][j] + b1[i][j] + b2[i][j] + b3[i][j];ans[i][j] *= ((k + 1) / 4);&#125;&#125;if ((k + 1) % 4 == 1) &#123;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] += b0[i][j];&#125;&#125;&#125;if ((k + 1) % 4 == 2) &#123;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] += b0[i][j] + b1[i][j];&#125;&#125;&#125;if ((k + 1) % 4 == 3) &#123;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] += b0[i][j] + b1[i][j] + b2[i][j];&#125;&#125;&#125;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;if (j != 0) &#123;out.write(&quot; &quot;);&#125;out.write(Long.toString(ans[i][j]));&#125;out.write(&quot;\n\n&quot;);&#125;&#125;&#125;&#125;&#125;</code></pre><p>这个时候代码量已经缩小到了 1705B 了，然而还是不能提交。发现代码竟然被截断到了 985 B，这个东西让我突发奇想：“其实我可以把代码量弄大再提交。只要截断部分保留我原有的代码就行。” 于是往结尾添加了大量的无用注释。再次提交，终于提交成功，让我看到了久违的 <code>Accepted</code>.</p><pre><code class="java">import java.io.OutputStream;import java.io.IOException;import java.io.InputStream;import java.io.PrintWriter;import java.util.Scanner;public class Main &#123;public static void main(String[] args) &#123;InputStream inputStream = System.in;OutputStream outputStream = System.out;Scanner in = new Scanner(inputStream);PrintWriter out = new PrintWriter(outputStream);HDU2687 solver = new HDU2687();solver.solve(1, in, out);out.close();&#125;static class HDU2687 &#123;public static int[][] rotate(int a[][], int n) &#123;int[][] b = new int[n][n];for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;b[n - j - 1][i] = a[i][j];&#125;&#125;return b;&#125;public void solve(int testNumber, Scanner in, PrintWriter out) &#123;while (in.hasNext()) &#123;int n = in.nextInt();int[][] a = new int[n][n];for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;a[i][j] = in.nextInt();&#125;&#125;int k = in.nextInt();int[][] b0 = a;int[][] b1 = rotate(rotate(rotate(b0, n), n), n);int[][] b2 = rotate(rotate(rotate(b1, n), n), n);int[][] b3 = rotate(rotate(rotate(b2, n), n), n);long[][] ans = new long[n][n];for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] = b0[i][j] + b1[i][j] + b2[i][j] + b3[i][j];ans[i][j] *= ((k + 1) / 4);&#125;&#125;if ((k + 1) % 4 == 1) &#123;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] += b0[i][j];&#125;&#125;&#125;if ((k + 1) % 4 == 2) &#123;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] += b0[i][j] + b1[i][j];&#125;&#125;&#125;if ((k + 1) % 4 == 3) &#123;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;ans[i][j] += b0[i][j] + b1[i][j] + b2[i][j];&#125;&#125;&#125;for (int i = 0; i &lt; n; ++i) &#123;for (int j = 0; j &lt; n; ++j) &#123;if (j != 0) &#123;out.write(&quot; &quot;);&#125;out.write(Long.toString(ans[i][j]));&#125;out.write(&quot;\n\n&quot;);&#125;&#125;&#125;&#125;&#125;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Python中pip安装包速度慢的问题</title>
      <link href="/posts/2019-03-14-too-slow-to-install-package-using-pip-solve-it.html"/>
      <url>/posts/2019-03-14-too-slow-to-install-package-using-pip-solve-it.html</url>
      
        <content type="html"><![CDATA[<p>Life is short, I use python. Python 的优势就不多说了，包有很多很多。截至笔者写此篇文章时候，pypi官网 (<a href="https://pypi.org/">https://pypi.org</a>) 就已经有 171921 个项目了。然而在某些环境下，我们需要花费非常长非常长的时间去下载一个包，甚至最后而不可得。那么我们可以通过第三方镜像来安装我们所需要的包。</p><pre><code class="bash">pip install numpy</code></pre><p>根据这个命令，我们加上镜像地址即可。</p><pre><code class="bash">pip install -i https://mirrors.huaweicloud.com/repository/pypi/simple numpy</code></pre><p>这样的镜像地址国内还有很多，最早的时候豆瓣源是最出名的。</p><pre><code class="text">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple豆瓣(douban) http://pypi.douban.com/simple清华大学 https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>当然也可以将镜像地址设置为默认，pip的配置文件在用户根目录下的 <code>~/.pip/pip.conf</code> 文件，Windows 环境下文件地址为： <code>C:\Users\&lt;UserName&gt;\pip\pip.ini</code> ，如果目录不存在的话，手动创建即可。</p><pre><code class="text">[global]index-url = https://mirrors.huaweicloud.com/repository/pypi/simpletrusted-host = mirrors.huaweicloud.comtimeout = 120</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下杀死进程</title>
      <link href="/posts/2019-03-01-kill-process-in-linux.html"/>
      <url>/posts/2019-03-01-kill-process-in-linux.html</url>
      
        <content type="html"><![CDATA[<p>首先，我们需要了解一个命令 <code>kill -9 23499</code> ，这就是常见的 <code>kill</code> 命令，其中后面 <code>-9</code> 表示给 <code>23499</code> 这个 PID 的进程发送信号 <code>9</code> ，表示强制、尽快终止进程。</p><pre><code class="text">[root@CentOS ~]# ps auxUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot         1  1.0  0.3 129096  6480 ?        Ss   22:59   0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root         2  0.0  0.0      0     0 ?        S    22:59   0:00 [kthreadd]root         3  0.0  0.0      0     0 ?        S    22:59   0:00 [ksoftirqd/0]root         4  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/0:0]root         5  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kworker/0:0H]root         6  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:0]root         7  0.0  0.0      0     0 ?        S    22:59   0:00 [migration/0]root         8  0.0  0.0      0     0 ?        S    22:59   0:00 [rcu_bh]root         9  0.2  0.0      0     0 ?        S    22:59   0:00 [rcu_sched]root        10  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [lru-add-drain]root        11  0.0  0.0      0     0 ?        S    22:59   0:00 [watchdog/0]root        12  0.0  0.0      0     0 ?        S    22:59   0:00 [watchdog/1]root        13  0.0  0.0      0     0 ?        S    22:59   0:00 [migration/1]root        14  0.0  0.0      0     0 ?        S    22:59   0:00 [ksoftirqd/1]root        15  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/1:0]root        16  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kworker/1:0H]root        18  0.0  0.0      0     0 ?        S    22:59   0:00 [kdevtmpfs]root        19  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [netns]root        20  0.0  0.0      0     0 ?        S    22:59   0:00 [khungtaskd]root        21  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [writeback]root        22  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kintegrityd]root        23  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root        24  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root        25  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root        26  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kblockd]root        27  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [md]root        28  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [edac-poller]root        29  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [watchdogd]root        30  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/0:1]root        35  0.0  0.0      0     0 ?        S    22:59   0:00 [kswapd0]root        36  0.0  0.0      0     0 ?        SN   22:59   0:00 [ksmd]root        37  0.0  0.0      0     0 ?        SN   22:59   0:00 [khugepaged]root        38  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [crypto]root        46  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kthrotld]root        47  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:1]root        48  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kmpath_rdacd]root        49  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/0:2]root        50  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kaluad]root        51  0.0  0.0      0     0 ?        R    22:59   0:00 [kworker/1:1]root        52  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kpsmoused]root        53  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/1:2]root        54  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [ipv6_addrconf]root        67  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [deferwq]root        99  0.0  0.0      0     0 ?        S    22:59   0:00 [kauditd]root       216  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/1:3]root      1061  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [ata_sff]root      1095  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_0]root      1110  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_0]root      1116  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_1]root      1122  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_1]root      1132  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:2]root      1133  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_2]root      1139  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_2]root      1140  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:3]root      1145  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_3]root      1152  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_3]root      1159  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_4]root      1166  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_4]root      1171  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_5]root      1184  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_5]root      1189  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_6]root      1196  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_6]root      1204  0.0  0.0      0     0 ?        S    22:59   0:00 [scsi_eh_7]root      1209  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [scsi_tmf_7]root      1215  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:4]root      1222  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:5]root      1227  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:6]root      1232  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:7]root      1237  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:8]root      1246  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/u64:9]root      1664  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kworker/0:1H]root      1671  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kworker/1:1H]root      1711  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kdmflush]root      1714  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root      1726  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kdmflush]root      1729  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root      1747  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root      1749  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfsalloc]root      1755  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs_mru_cache]root      1760  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-buf/dm-0]root      1764  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-data/dm-0]root      1765  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-conv/dm-0]root      1766  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-cil/dm-0]root      1767  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-reclaim/dm-]root      1768  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-log/dm-0]root      1769  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-eofblocks/d]root      1770  0.0  0.0      0     0 ?        S    22:59   0:00 [xfsaild/dm-0]root      1840  0.2  0.1  38804  2496 ?        Ss   22:59   0:00 /usr/lib/systemd/systemd-journaldroot      1862  0.0  0.1 193424  3640 ?        Ss   22:59   0:00 /usr/sbin/lvmetad -froot      1873  0.0  0.0      0     0 ?        S    22:59   0:00 [kworker/0:3]root      1874  0.4  0.1  45920  2276 ?        Ss   22:59   0:00 /usr/lib/systemd/systemd-udevdroot      2972  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-buf/sda1]root      2973  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-data/sda1]root      2974  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-conv/sda1]root      2976  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-cil/sda1]root      2977  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-reclaim/sda]root      2978  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-log/sda1]root      2979  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-eofblocks/s]root      2984  0.0  0.0      0     0 ?        S    22:59   0:00 [xfsaild/sda1]root      3484  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [kdmflush]root      3487  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [bioset]root      3496  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-buf/dm-2]root      3497  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-data/dm-2]root      3498  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-conv/dm-2]root      3499  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-cil/dm-2]root      3500  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-reclaim/dm-]root      3501  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-log/dm-2]root      3502  0.0  0.0      0     0 ?        S&lt;   22:59   0:00 [xfs-eofblocks/d]root      3503  0.0  0.0      0     0 ?        S    22:59   0:00 [xfsaild/dm-2]root      3524  0.0  0.0  55248   900 ?        S&lt;sl 22:59   0:00 /sbin/auditdroot      3546  0.0  0.0  26104  1740 ?        Ss   22:59   0:00 /usr/lib/systemd/systemd-logindpolkitd   3548  0.0  0.6 611976 12128 ?        Ssl  22:59   0:00 /usr/lib/polkit-1/polkitd --no-debugroot      3549  0.0  0.0  21260  1232 ?        Ss   22:59   0:00 /usr/sbin/irqbalance --foregrounddbus      3552  0.1  0.1  66208  2580 ?        Ssl  22:59   0:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activationchrony    3555  0.0  0.0 117804  1704 ?        S    22:59   0:00 /usr/sbin/chronydroot      3566  0.1  0.5 547192 10636 ?        Ssl  22:59   0:00 /usr/sbin/NetworkManager --no-daemonroot      3596  0.4  0.0 123848  1600 ?        Ss   22:59   0:00 /usr/sbin/crond -nroot      3600  0.0  0.0 110092   860 tty1     Ss+  22:59   0:00 /sbin/agetty --noclear tty1 linuxroot      3616  0.0  0.2 107204  5452 ?        S    22:59   0:00 /sbin/dhclient -d -q -sf /usr/libexec/nm-dhcp-helper -pf /var/run/dhclient-eth0.pid -lf /var/lib/NetworkManager/dhclroot      3856  0.0  0.2 112604  4308 ?        Ss   22:59   0:00 /usr/sbin/sshd -Droot      3857  0.3  0.9 573676 17108 ?        Ssl  22:59   0:00 /usr/bin/python2 -Es /usr/sbin/tuned -l -Proot      3861  0.1  0.2 285896  3968 ?        Ssl  22:59   0:00 /usr/sbin/rsyslogd -nmysql     3932  0.5  9.3 1119716 176176 ?      Sl   22:59   0:00 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidroot      4252  0.0  0.1  90252  2184 ?        Ss   22:59   0:00 /usr/libexec/postfix/master -wpostfix   4271  0.0  0.2  90356  4264 ?        S    22:59   0:00 pickup -l -t unix -upostfix   4272  0.0  0.2  90424  4288 ?        S    22:59   0:00 qmgr -l -t unix -uroot      4428  0.3  0.3 158608  5760 ?        Ds   22:59   0:00 sshd: root@pts/0root      4431  0.0  0.1 115544  2152 pts/0    Ss   22:59   0:00 -bashroot      4467  0.0  0.0  18904   896 ?        Ss   23:01   0:00 nginx: master process nginxnginx     4468  0.0  0.0  19360  1628 ?        S    23:01   0:00 nginx: worker processroot      4470  0.0  0.2 231100  5068 ?        Ss   23:01   0:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)www-data  4471  0.0  0.2 231100  4612 ?        S    23:01   0:00 php-fpm: pool wwwwww-data  4472  0.0  0.2 231100  4612 ?        S    23:01   0:00 php-fpm: pool wwwroot      4474  0.0  0.0 155080  1808 pts/0    R+   23:01   0:00 ps aux</code></pre><p>在这么多进程中，我们可以通过 <code>grep</code> 进行筛选。比如我们想找到所有的 php-fpm 进程。</p><pre><code>[root@CentOS ~]# ps aux | grep php-fpmroot      4470  0.0  0.2 231100  5068 ?        Ss   23:01   0:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)www-data  4471  0.0  0.2 231100  4612 ?        S    23:01   0:00 php-fpm: pool wwwwww-data  4472  0.0  0.2 231100  4612 ?        S    23:01   0:00 php-fpm: pool wwwroot      4477  0.0  0.0 110248   668 pts/0    S+   23:02   0:00 grep --color=auto php-fpm</code></pre><p>在输出结果中第二列就是我们所需要的进程 PID，但是似乎多了一行，也就是最后一行。</p><pre><code>[root@CentOS ~]# ps aux | grep php-fpm | grep -v greproot      4470  0.0  0.2 231100  5068 ?        Ss   23:01   0:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)www-data  4471  0.0  0.2 231100  4612 ?        S    23:01   0:00 php-fpm: pool wwwwww-data  4472  0.0  0.2 231100  4612 ?        S    23:01   0:00 php-fpm: pool www</code></pre><p><code>grep -v grep</code> 表示取消包含 grep 字符串的行。</p><p>接下来就要去获取我们所需要的PID了。</p><pre><code>[root@CentOS ~]# ps aux | grep php-fpm | grep -v grep | awk &#39;&#123;print $2&#125;&#39;447044714472</code></pre><p>再把获取的 PID 传给 <code>kill</code> 命令进行杀死。</p><pre><code>[root@CentOS ~]# ps aux | grep php-fpm | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9</code></pre><p>这样就杀掉了所有 php-fpm 的进程。</p><p>另附上一个简单的脚本，另脚本名称： <code>kill-by-key.sh</code></p><pre><code class="bash">#!/bin/bashkill_by_key()&#123;    ps aux | grep &quot;$2&quot; | grep -v grep | grep -v &quot;$1&quot; | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9&#125;ps aux | grep &quot;$1&quot; | grep -v grep | grep -v &quot;$0&quot;read -r -p &quot;Are You Sure To Kill These Processes? [Y/n] &quot; inputcase $input in    [yY][eE][sS]|[yY])        kill_by_key $0 $1        ;;    [nN][oO]|[nN])               ;;    *)    echo &quot;Invalid input...&quot;    exit 1    ;;esac</code></pre><p>使用方法很简单。</p><pre><code>./kill-by-key.sh php-fpm</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iStat Menus Active Key</title>
      <link href="/posts/2019-02-23-iStat-Menus-Active-Key.html"/>
      <url>/posts/2019-02-23-iStat-Menus-Active-Key.html</url>
      
        <content type="html"><![CDATA[<p>iStat Menus for mac是一款Mac OS电脑硬件信息监控软件，提供的信息包括 CPU 使用情形、内存用量、硬盘使用情形、网络传输、机器温度、风扇转速等等。应用可以让你监测系统的各项丰富资讯，又不会占用使用者太大的桌面空间。</p><p>iStat Menus Mac版需要存在于Dashboard，这是一款常驻菜单栏右侧的小工具，我们可以时刻了解自己 Mac 电脑上发生各种情况，比如查看硬件温度，查看即时网速以及查看内存和硬盘使用率等。</p><p>CPU——监视CPU使用情况。7显示模式，多核心支持。</p><p>内存——监视内存使用情况。4种显示模式、页面输入输出和交换使用显示。</p><p>磁盘——监视磁盘的使用和活动。6种显示模式，能够隐藏你不想看到的磁盘。</p><p>网络——监视当前和总带宽、峰值带宽、IP地址，以及隐藏您不想看到的网络连接的能力。</p><p>临时工——监视你的Mac的温度。2种显示模式，能够隐藏你不想看到的传感器。</p><p>风扇——监视Mac中的风扇速度。2种显示模式，能够隐藏你不想看到的传感器。</p><p>蓝牙——控制蓝牙状态，监控苹果无线键盘或鼠标的电池电量。</p><p>日期和时间–在你的菜单栏的日期和时间。世界时钟显示让你看到时间在世界各地的多个地点。</p><pre><code>Email: 982092332@qq.com SN: GAWAE-FCWQ3-P8NYB-C7GF7-NEDRT-Q5DTB-MFZG6-6NEQC-CRMUD-8MZ2K-66SRB-SU8EW-EDLZ9-TGH3S-8SGA1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Keys </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 命令行到底有多糟糕？</title>
      <link href="/posts/2019-02-23-how-bad-windows-command-line-is.html"/>
      <url>/posts/2019-02-23-how-bad-windows-command-line-is.html</url>
      
        <content type="html"><![CDATA[<p>Kevin Gallo 刚刚宣布在 Windows 上支持 bash.</p><p>如果你从来就没有在Windows上通过批处理语言进行交互的话似乎并没有什么大的问题。当然，批处理并不会比 Bash 差很多，对吗？</p><p>Bash：一种既不是设计也不是进化的语言。对问题的充分解决方案已经变得难以达到数量级。虽然它是有用的，但是危险无处不在。bash：为了方便起见，我们有多想放弃这门语言？</p><p>当然，可能 Bash 更加糟糕。但是，真的有那么糟糕吗？Bash 有一个价值：这够好了。很难想象它会这么繁荣。</p><p>但是事实是什么呢？Batch 是真的糟糕。以及他们的信仰是多糟糕呢？比如：</p><ul><li>批处理脚本执行的时间复杂度至少是O(n*(n-1)&#x2F;2) (即：O($n^2$))，其中 n 是文件的行数（包括注释）。原因是批处理引擎会读取整个文件，然后执行一行，然后再一次读取这个文件，然后执行下一行，往复如此。</li><li>习惯性地使用 GOTO 去跳过相当大的注释块，这样你就不需要去“执行”它们。</li><li>像 for 这样循环语句的词法块是不会分开来解释的。他们被组合在一起然后一次性全部解释。也就是说在 for 循环中加上本来没什么关系的 <code>::</code> 注释或是 <code>if</code> 语句，结尾 <code>)</code> 会丢失，然后批处理就不知道要做什么了。它会像你可能忘记加上 <code>)</code> 去结束 <code>for</code> 循环。</li><li>永远不要注释代码。如果你做了，迟早会出问题的。例如：在一些 Windows 系统中，<code>REM</code>形式注释，如 <code>REM Ensure &gt; true</code> ， 实际上会通过管道把注释输出到 <code>true</code> 文件。由于注释是没有输出的，效果就是生成了一个文件名为 <code>true</code> 的空文件。</li><li>如果你在 <code>for</code> 代码块中添加两个 <code>::</code> 注释，你可能会得到 <code>The system cannot find the drive specified</code> 这样的错误，并且有可能你的脚本会出现错误代码123. 这样的情况是因为 <code>::</code> 这样的注释格式根本并不被视为注释。而且在标签格式中，<code>::</code> 必须在行首，而且不可以有前导空格符。并且连续两个标签也会出问题，因为批处理将其视为同一行。</li></ul><p>这样的例子数不胜数。</p><p>几年前我还在学校的时候，我觉得PowerShell可能是一个有趣的现代化的shell吧。然后并不是，PowerShell只不过是一个治疗小儿麻痹症的东西而已。毕竟 Jeffrey Snover 是Windows 生态系统中的 Jonas Salk.</p><p>批处理像是一个出现在地球上的外星设备。起初你觉得这是一个礼物，但后来你会发现这是一个用来毁灭世界的机器。唯一的解决办法就是彻底摆脱它。</p><p>就像《死灵之书》或是其他撒旦书中一样，Batch 一开始看起来并不那么糟糕，但是当媒介（这里指计算机）读取它之时，你会发现地狱之门已经打开。你会被电脑的屏幕吸引过去，然后深思自己10分钟之前犯了些什么恐怖的错误。于是你会抓狂，只想知道这个地方为什么会有警告或是错误。</p><p>Bash 就像是一个看起来美好而甜蜜的邻居，但也许他们没有你想拥有的生活。他们有一些相当严重的性格缺陷，显然会犯错误，但最终他们是一个很好的人，他们努力确保依赖他们的人做得很好。</p><p>批量是看起来像那个邻居的人，但后来证明是一个连环杀手。</p><p>所以，这是 Windows 环境的现实。做题你选择 批处理 或是 PowerShell，今天你可以选择 批处理，PowerShell 或是 Bash. （反正，你懂的。）</p><p>当你做出选择时，值得参观堕落者的坟墓。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Windows </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to install htop on CentOS</title>
      <link href="/posts/2019-02-06-how-to-install-htop-on-CentOS.html"/>
      <url>/posts/2019-02-06-how-to-install-htop-on-CentOS.html</url>
      
        <content type="html"><![CDATA[<p>htop is an interactive process viewer and manager for UNIX&#x2F;Linux systems. It is a text-mode application and easy to use.</p><p>I usually use htop to show running process on my Linux servers even on my MacBook Pro.</p><p>Recently I turn my Linux server from Ubuntu distribution to CentOS distribution. And I found when I use <code>yum install -y htop</code> to install htop on CentOS, it failed.</p><p>After search on web, the commands below may be help.</p><pre><code>yum install epel-release -yyum install htop -y</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中创建动态数组</title>
      <link href="/posts/2019-01-28-creating-dynamic-array-in-c.html"/>
      <url>/posts/2019-01-28-creating-dynamic-array-in-c.html</url>
      
        <content type="html"><![CDATA[<p>还是先上代码吧。</p><span id="more"></span><pre><code class="c">//// Created by ismdeep on 2019-01-28.//#ifndef ISMDEEP_ARRAY_H#define ISMDEEP_ARRAY_H#include &lt;stdint.h&gt;void * create_1d_arr(size_t size, size_t sizeof_item) &#123;    void * arr = malloc(sizeof_item * size);    return arr;&#125;void ** create_2d_arr(size_t rows, size_t cols, size_t sizeof_item) &#123;    void ** arr = (void **)malloc(sizeof(size_t) * rows);    for (size_t row_id = 0; row_id &lt; rows; ++row_id) &#123;        arr[row_id] = malloc(sizeof_item * cols);    &#125;    return arr;&#125;#endif //ISMDEEP_ARRAY_H</code></pre><p>另附上CLion下查看动态数组的方法</p><pre><code class="text">(uint64_t (*)[10])arr(uint64_t (**)[10][10])arr2</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算排列数</title>
      <link href="/posts/2019-01-26-calculate-permutation-count.html"/>
      <url>/posts/2019-01-26-calculate-permutation-count.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="lisp">(defun permutation-count (n c)    (let ((ans 1))        (loop for i from (- n (1- c)) upto n do (setf ans (* ans i))) ans))(format t &quot;~D~%&quot; (permutation-count 6 5))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Common Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git commit 规范指南</title>
      <link href="/posts/2019-01-12-git-commit-standard-manual.html"/>
      <url>/posts/2019-01-12-git-commit-standard-manual.html</url>
      
        <content type="html"><![CDATA[<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。</p><p>目前，社区有多种 Commit message 的写法规范。本文介绍<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>是目前使用最广的写法，比较合理和系统化，并且有配套的工具。前前端框架<a href="https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#toc10">Angular.js</a>采用的就是该规范。</p><h3 id="Commit-message-的格式"><a href="#Commit-message-的格式" class="headerlink" title="Commit message 的格式"></a>Commit message 的格式</h3><p>每次提交，Commit message 都包括三个部分：header，body 和 footer。</p><pre><code class="xml">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></pre><p>其中，header 是必需的，body 和 footer 可以省略。<br>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>用于说明 commit 的类别，只允许使用下面7个标识。</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p><h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><p>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p>例如在<code>Angular</code>，可以是<code>$location</code>, <code>$browser</code>, <code>$compile</code>, <code>$rootScope</code>, <code>ngHref</code>, <code>ngClick</code>, <code>ngView</code>等。</p><p>如果你的修改影响了不止一个<code>scope</code>，你可以使用<code>*</code>代替。</p><h5 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h5><p><code>subject</code>是 commit 目的的简短描述，不超过50个字符。</p><p>其他注意事项：</p><ul><li><p>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</p></li><li><p>第一个字母小写</p></li><li><p>结尾不加句号（.）</p></li></ul><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><pre><code>More detailed explanatory text, if necessary.  Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent</code></pre><p>有两个注意点:</p><ul><li>使用第一人称现在时，比如使用change而不是changed或changes。</li><li>永远别忘了第2行是空行</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><p>Footer 部分只用于以下两种情况：</p><h5 id="不兼容变动"><a href="#不兼容变动" class="headerlink" title="不兼容变动"></a>不兼容变动</h5><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p><pre><code>BREAKING CHANGE: isolate scope bindings definition has changed.    To migrate the code follow the example below:    Before:    scope: &#123;      myAttr: &#39;attribute&#39;,    &#125;    After:    scope: &#123;      myAttr: &#39;@&#39;,    &#125;    The removed `inject` wasn&#39;t generaly useful for directives so there should be no code using it.</code></pre><h5 id="关闭-Issue"><a href="#关闭-Issue" class="headerlink" title="关闭 Issue"></a>关闭 Issue</h5><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><pre><code>Closes #234</code></pre><h5 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h5><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p><pre><code>revert: feat(pencil): add &#39;graphiteWidth&#39; optionThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.</code></pre><p>Body部分的格式是固定的，必须写成<code>This reverts commit &amp;lt;hash&gt;</code>.，其中的hash是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p><p>repost from: <a href="https://segmentfault.com/a/1190000009048911">https://segmentfault.com/a/1190000009048911</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Development </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45句话读懂《高效程序员的45个习惯》</title>
      <link href="/posts/2018-12-27-45-sentences-about-practices-of-an-agile-developer.html"/>
      <url>/posts/2018-12-27-45-sentences-about-practices-of-an-agile-developer.html</url>
      
        <content type="html"><![CDATA[<p>1、不要抱怨，把注意力集中到解决问题上来。</p><p>2、了解清楚情况，比如团队风格，业务需求等，才动手编码。</p><p>3、指出问题，当然，更好的做法是礼貌一点。</p><p>4、勇敢的说出实情，然后努力的去解决问题。</p><p>5、用邓公的话来说：与时俱进，开拓进取。</p><p>6、提倡团队成员之间的分享精神，比如搞个午餐会议（虽然听起来很蛋疼）。</p><p>7、抛弃旧习惯很难，这需要勇气，但是想要与时俱进，这是必须要做的，想想改革开放前后的对比。</p><p>8、对于一个问题，不满足于表象，不断追问’为什么’，当然，也要问到点子上。</p><p>9、把握开发的节奏，固定的时间做固定的事情，就像跳舞和演奏一样，一个节拍一动，充满韵味。（不只是开发，适用于一切工作。）</p><p>10、让需求方决定需求，而且描述越清楚越好，不然返修就是必然的。</p><p>11、设计和开发交替进行，不要被一开始的设计图牵着鼻子走。</p><p>12、根据需要选择技术，问自己为什么需要这种技术，其中一个标准是使用新技术是否无需时间成本。</p><p>13、使用版本管理工具，以免引入破坏性的修改导致系统死掉。</p><p>14、子系统频繁集成，有助于提早发现问题，以免后期隐藏的问题滚起雪球。</p><p>15、从一开始就使用自动化部署应用和环境，还是那个早期不做准备后期问题被滚雪球无限放大。</p><p>16、需求的变化是人的天性，如果不想在最后软件交付时才去面对用户的变化，那么就该使用演示获得频繁的反馈。</p><p>17、小步前进，使用短迭代、增量发布的方式开发大型系统，而且这也能避免跳票，还能根据用户的反馈及时修正方向。</p><p>18、固定的项目报价有悖于敏捷开发的原则，合理的做法是短迭代，由用户去评估每次迭代的成果并决定是否继续做下去。</p><p>19、使用自动化单元测试工具，每次构建和编译时都会运行之前留下的测试代码，能帮助发现新修改带来的错误。</p><p>20、测试驱动开发，即：在编写之前，先编写测试用例去使用它，出现问题是就马上针对问题去做开发。</p><p>21、使用持续集成工具，周期性的从源码控制系统中取得代码，并运行代码。这种方式能够帮助发现不同平台（操作系统）下的兼容问题。</p><p>22、使用FIT，即集成测试框架，使用户参与到验收测试的用例设计上来。</p><p>23、度量本次工作的时间花费，如果有错误，那么在下一次度量的时候就有了修改的依据。</p><p>24、倾听真实用户的声音，查看一下找出真正的问题所在。</p><p>25、代码要清晰地表达意图，比如说使用枚举来代替不明意义的数字，应该努力的增加代码的表现力。</p><p>26、保持良好的命名规范，使用代码来进行沟通，必要时加上注释，但是也请不要添加无意义的注释。</p><p>27、动态的评估各种因素：性能、成本、可移植性等，然后做出取舍，不要去追求不可达的“完美”。</p><p>28、编程如开车，不可能能一路踩着油门到达终点，使用增量编程的方式，分阶段去添加新的特性进来。</p><p>29、代码设计应该保持简单，在几百行代码中使用十几个设计模式是不可取的。</p><p>30、保持代码的高内聚，意味着一个模块内部所有函数都是为了齐心协力完成同一个功能，这呼应了第29条保持简单。</p><p>31、划分各自的职责范围，封装修改为命令，封装读取为查询，并设置一定的访问控制防止意外发生。</p><p>32、编程时需要更多的考虑程序语义，比如继承要求子类和父类是is-a的关系，如果不是is-a的关系可以考虑用聚合的方式做代码重用。</p><p>33、可以把每日日报当做解决方案日志来做，碰到问题就把解决思路记录下来并做成可搜索的方式，这样再次碰到时就能亡羊补牢。</p><p>34、调高编译器的提示级别，把警告当做错误来处理，不要忽略它。</p><p>35、分离开模块做单元测试，对发现的问题做逐个击破。</p><p>36、抛出所有异常，除非你确实想好了怎么处理，不然与其让问题藏着掖着不如在发生的时候爆发出来留个全尸。</p><p>37、提供有用的错误信息给用户，比如说：[问题摘要][详细细节]。</p><p>38、提倡“每日立会”，并回答三个问题：1、昨天有什么收获？2、今天有什么计划？3、未来有什么障碍？</p><p>39、架构师必须写代码，原理阵线的将军难以成为合格的战役指挥者。</p><p>40、实行代码集体所有制，互相之间轮换维护各自的代码，这将提高代码的整体质量、易于维护、降低出错率。（极客与团队中也提倡代码不署名，方便他人作改动。）</p><p>41、与团队分享知识和经验，知识并不像金钱，给了别人自己就没有了，知识分享了之后就从一份变成了两份。</p><p>42、帮助他人可以不直接提供解决方法，而且告知如何去解决问题，相信别人也有这种能力，授人以鱼不如授人以渔。</p><p>43、向源码控制系统提交代码时，所有单元测试都是可以通过的，而且应该与一个特定的任务或是一个bug的解决相关，并注有日志信息。</p><p>44、在代码刚刚完成时，做代码复查能够很好的发现大部分BUG，复查的方式可以是轮换复查或者结对编程。内容可以是：1、可读性 2、明显的错误 3、对其他部分的影响 4、重复代码 5、可改进和重构</p><p>45、积极的通报进展和问题，不要等到时间截止的时候才来做这件事，也不要等别人来询问进展，积极主动才够敏捷。</p><p>Repost from: <a href="https://www.jianshu.com/p/7f4a2369199a">https://www.jianshu.com/p/7f4a2369199a</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Lisp 矩阵的逆</title>
      <link href="/posts/2018-11-16-inverse-a-matrix-with-common-lisp.html"/>
      <url>/posts/2018-11-16-inverse-a-matrix-with-common-lisp.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="lisp">(defun mmul (A B)  (let* ((m (car (array-dimensions A)))         (n (cadr (array-dimensions A)))         (l (cadr (array-dimensions B)))         (C (make-array `(,m ,l) :initial-element 0)))    (loop for i from 0 to (- m 1) do              (loop for k from 0 to (- l 1) do                    (setf (aref C i k)                          (loop for j from 0 to (- n 1)                                sum (* (aref A i j)                                       (aref B j k))))))    C));; Cofactor i j(defun matrix-cofactor (A i j)    (let* (        (tmp 0)        (n (car (array-dimensions A)))        (ans (make-array `(,(- n 1) ,(- n 1)) :initial-element 0)))    (loop for ii from 0 to (- i 1) do         (loop for jj from 0 to (- j 1) do (setf (aref ans ii jj) (aref A ii jj)))        (loop for jj from (+ j 1) to (- n 1) do (setf (aref ans ii (- jj 1)) (aref A ii jj))))    (loop for ii from (+ i 1) to (- n 1) do         (loop for jj from 0 to (- j 1) do (setf (aref ans (- ii 1) jj) (aref A ii jj)))        (loop for jj from (+ j 1) to (- n 1) do (setf (aref ans (- ii 1) (- jj 1)) (aref A ii jj))))    ans));; Calculate det value of matrix A(defun matrix-det (A)    (let* ((n (car (array-dimensions A))) (tmp 0))    (if (= n 1)        (aref A 0 0)        (let ((tmp 0) (MA 0))            (loop for j from 0 to (- n 1) do                (setf MA (matrix-cofactor A 0 j))                (if (= (mod j 2) 0)                    (setf tmp (+ tmp (* (aref A 0 j) (matrix-det MA))))                    (setf tmp (- tmp (* (aref A 0 j) (matrix-det MA))))))            tmp))));; Calculate inverse matrix of matrix A(defun matrix-inverse (A)    (let* ((n (car (array-dimensions A))) (tmp 0) (inv-A (make-array `(,n ,n) :initial-element 0)) (det-val 0))        (setf det-val (matrix-det A))        (loop for i from 0 to (- n 1) do            (loop for j from 0 to (- n 1) do                (setf (aref inv-A j i) (/ (matrix-det (matrix-cofactor A i j)) det-val))))        inv-A))(let ((g 0) (g0 0))  (setf g (make-array &#39;(3 3) :initial-contents &#39;((1 0 0) (2 2 0) (3 4 5))))  (setf g0 (make-array &#39;(1 1) :initial-contents &#39;((2))))  ; (matrix-cofactor g 1 1)  (format t &quot;~A~%&quot; (matrix-inverse g)))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Common Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LU分解之doolittle算法</title>
      <link href="/posts/2018-11-14-LU-Decompression-doolittle-algorithm.html"/>
      <url>/posts/2018-11-14-LU-Decompression-doolittle-algorithm.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="lisp">;; author: ismdeep;; blog: https://ismdeep.github.io;; blog entry: https://ismdeep.github.io/238;; doolittle algorithm to decompose a square matrix(defun mmul (A B)  (let* ((m (car (array-dimensions A)))         (n (cadr (array-dimensions A)))         (l (cadr (array-dimensions B)))         (C (make-array `(,m ,l) :initial-element 0)))    (loop for i from 0 to (- m 1) do              (loop for k from 0 to (- l 1) do                    (setf (aref C i k)                          (loop for j from 0 to (- n 1)                                sum (* (aref A i j)                                       (aref B j k))))))    C)) ;; Using doolittle algorithm to decomposes a square matrix A for LU = A and LDV = A(defun doolittle-lu (A)  (let* ((n (car (array-dimensions A))) (tmp 0)         (L (make-array `(,n ,n) :initial-element 0))         (U (make-array `(,n ,n) :initial-element 0))         (D (make-array `(,n ,n) :initial-element 0))         (V (make-array `(,n ,n) :initial-element 0))         (lu-mmul 0)         (ldv-mmul 0))    (loop for j from 0 to (- n 1) do (setf (aref U 0 j) (aref A 0 j)))    (loop for i from 0 to (- n 1) do (setf (aref L i i) 1))    (loop for i from 1 to (- n 1) do       ; generate L      (loop for j from 0 to (- i 1) do        (setf tmp (aref A i j))        (loop for k from 0 to (- j 1) do (setf tmp (- tmp (* (aref L i k) (aref U k j)))))        (setf (aref L i j) (/ tmp (aref U j j)))        )      ; generate U      (loop for j from i to (- n 1) do        (setf tmp (aref A i j ))        (loop for k from 0 to (- i 1) do (setf tmp (- tmp (* (aref L i k) (aref U k j)))))        (setf (aref U i j) tmp)        )      )    ; output A    (format t &quot;---------- A ------------------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref A i j)))      (format t &quot;~%&quot;))        ; output L    (format t &quot;~%~%---------- L ------------------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref L i j)))      (format t &quot;~%&quot;))    ; output U    (format t &quot;~%~%---------- U ------------------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref U i j)))      (format t &quot;~%&quot;))    ; output L * U    (setf lu-mmul (mmul L U))    (format t &quot;~%~%---------- L * U --------------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref lu-mmul i j)))      (format t &quot;~%&quot;))    ; generate D    (loop for i from 0 to (- n 1) do      (setf (aref D i i) (aref U i i)))    ; generate V    (loop for i from 0 to (- n 1) do      (loop for j from i to (- n 1) do        (setf (aref V i j) (/ (aref U i j) (aref U i i)))))    ; output D    (format t &quot;~%~%---------- D ------------------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref D i j)))      (format t &quot;~%&quot;))    ; output V    (format t &quot;~%~%---------- V ------------------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref V i j)))      (format t &quot;~%&quot;))    ; output L * D * V    (setf ldv-mmul (mmul (mmul L D) V))    (format t &quot;~%~%---------- L * D * V ----------~%&quot;)    (loop for i from 0 to (- n 1) do      (loop for j from 0 to (- n 1) do         (format t &quot;~4A &quot; (aref ldv-mmul i j)))      (format t &quot;~%&quot;))  ;; Return L and U  (values L U)))(let ((g 0))  (setf g (make-array &#39;(4 4) :initial-contents &#39;((2 1 -5 1) (1 -3 0 -6) (0 2 -1 2) (1 4 -7 6))))   (doolittle-lu g))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Hacker </tag>
            
            <tag> Common Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数拆分算法（递归实现）</title>
      <link href="/posts/2018-11-14-integer-split-algorithm-recursive-implementation.html"/>
      <url>/posts/2018-11-14-integer-split-algorithm-recursive-implementation.html</url>
      
        <content type="html"><![CDATA[<p>对于输入的数字n，那么要解决的问题就是(n,n)，对于第一个n是表示要拆分的数字n，第二个n表示拆分当前数字能使用的最大数字。</p><p>那么 (n,m) 可以表示成 $ \sum_{cur &#x3D; 1}^{m} cur + (n - i, max(m, n - i)) $</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MIN(a,b) ((a) &lt; (b)) ? (a) : (b)#define MAX_VAL 1024int a[MAX_VAL];int cur_index;void do_print() &#123;    for (int i = 0; i &lt;= cur_index; ++i) &#123;        printf(&quot;%d &quot;, a[i]);    &#125;    printf(&quot;\n&quot;);&#125;void split(int val, int max_item) &#123;    if (val &lt;= 0) &#123;        do_print();        return;    &#125;    for (int cur_item = MIN(max_item, val); cur_item &gt;= 1; --cur_item) &#123;        ++cur_index;        a[cur_index] = cur_item;        split(val - cur_item, cur_item);        --cur_index;    &#125;&#125;int main() &#123;    memset(a, 0, sizeof(int));    int val;    scanf(&quot;%d&quot;, &amp;val);    if (val &gt; MAX_VAL) &#123;        fprintf(stderr, &quot;Can not process input value with is bigger than 1024.\n&quot;);        return 0;    &#125;    cur_index = -1;    split(val, val);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 通过 OpenMP 实现并行编程</title>
      <link href="/posts/2018-10-03-linux-openmp-parallel-programming.html"/>
      <url>/posts/2018-10-03-linux-openmp-parallel-programming.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="c++">#include &lt;iostream&gt;using namespace std;#define PARALLEL_SIZE 4int fibonacci(int n)&#123;    return n &lt;= 2 ? 1 : fibonacci (n - 1) + fibonacci (n - 2);&#125;int main()&#123;    #pragma omp parallel for    for (int i = 0; i &lt; PARALLEL_SIZE; i++)    &#123;        cout &lt;&lt; fibonacci(50) &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><pre><code>build:    g++ -std=c++11 -c main.cpp -o main.o -fopenmp    g++ main.o -o main -fopenmp -lpthreadrun:    export OMP_NUM_THREADS=4    ./main</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老男孩Python全栈工程师教程第9期</title>
      <link href="/posts/2018-09-24-oldboy-python-fullstack-developer-season-9.html"/>
      <url>/posts/2018-09-24-oldboy-python-fullstack-developer-season-9.html</url>
      
        <content type="html"><![CDATA[<p>全栈9期（第一部分）：基础+模块+面向对象+网络编程</p><p>全栈9期（第二部分）：并发编程+数据库+前端</p><p>全栈9期（第三部分）：django基础</p><p>全栈9期（第四部分）：django进阶</p><p>全栈9期（第五部分）：django高级</p><p>Python是一种解释型、面向对象、动态数据类型的高级程序设计语言。Python由Guido van Rossum于1989年底发明，第一个公开发行版发行于1991年。像Perl语言一样, Python 源代码同样遵循 GPL(GNU General Public License)协议。</p><p>链接: <a href="https://pan.baidu.com/s/1-IPXJRRbEoFrG9Sl-ihn6A">https://pan.baidu.com/s/1-IPXJRRbEoFrG9Sl-ihn6A</a> 提取码: dnsz</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5点提升你的编程逻辑能力</title>
      <link href="/posts/2018-09-12-5-points-to-improve-your-programming-logic.html"/>
      <url>/posts/2018-09-12-5-points-to-improve-your-programming-logic.html</url>
      
        <content type="html"><![CDATA[<p>在编程中，逻辑能力是成为一个好的开发者的<strong>关键</strong>。或许，根据你的工作内容，你有可能会用到比较多的算法，也有可能比较少。如果你是个web设计者，或许你很少会处理复杂的算法。但是如果你是个前端开发者就会稍微有一些了。甚至如果你是个后端开发者将会更多。</p><p>在这里，我列了5点我觉得还可以的，来帮你提高编程逻辑。</p><p>这篇文章适用于<strong>任何人</strong>。如果我们打算培养好的逻辑思维的话，我们将<strong>能够比较自由地切换开发语言</strong>。<strong>尽量不要依赖于某种语言</strong>。</p><h2 id="1-思考如何解决问题"><a href="#1-思考如何解决问题" class="headerlink" title="1.- 思考如何解决问题"></a>1.- 思考如何解决问题</h2><p>编程是关于解决问题的。一个好的技巧就是将大的问题分解成一个一个小的问题，于是可以专注于一个一个小的问题上。你可以在代码中或纸上写伪代码。</p><h2 id="2-练习"><a href="#2-练习" class="headerlink" title="2.- 练习"></a>2.- 练习</h2><p>最重要的一点就是：<strong>练习</strong>。一个算法不过就是我们为了达到某个目标而找到解决某个问题的由一系列有序的有限指令操作。所以，尝试练习一些简单的问题。</p><h2 id="3-学习数据结构和算法"><a href="#3-学习数据结构和算法" class="headerlink" title="3.- 学习数据结构和算法"></a>3.- 学习数据结构和算法</h2><p>学习数据结构能帮你更好的设计解决问题或设计高效软件的方法。</p><h2 id="4-学习编程范式"><a href="#4-学习编程范式" class="headerlink" title="4.- 学习编程范式"></a>4.- 学习编程范式</h2><p>一个非常好的方式就是学习编程范式。或许最具有编程范式之一的就是<strong>面向对象范式(OOP)</strong>.编程范式就像是我们创建一个项目的蓝图。你可以学习函数式编程，在函数式编程下又有着不同的方式去开发程序和解决问题。</p><h2 id="5-阅读他人的代码"><a href="#5-阅读他人的代码" class="headerlink" title="5.- 阅读他人的代码"></a>5.- 阅读他人的代码</h2><p>在编程中我们有很多不同的方法去解决问题，也许另一个人以最佳的最简单的方法解决了你遇到的问题。学习他人的思想对一个程序员的进步至关重要。你可以在<a href="https://github/">GitHub</a>上看到非常多的好的项目。</p><p><em>记住，你无法解决问题是完全正常的，但是你得知道从社区里能获得很多帮助。</em></p><h4 id="练习资源："><a href="#练习资源：" class="headerlink" title="练习资源："></a>练习资源：</h4><p>◾ <a href="https://www.codewars.com/">Codewars</a><br>◾ <a href="https://codefights.com/">CodeFights</a><br>◾ <a href="https://www.hackerrank.com/">HackerRank </a><br>◾ <a href="https://www.codingame.com/start">CodinGame</a></p><p>希望你能喜欢！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊【折腾】的重要性</title>
      <link href="/posts/2018-08-04-talking-about-the-importance-of-toss.html"/>
      <url>/posts/2018-08-04-talking-about-the-importance-of-toss.html</url>
      
        <content type="html"><![CDATA[<p>作者&#x2F;编程随想</p><p>★引子</p><p>前不久写了篇关于 Linux 的博文。看到博客评论区中有一些“关于折腾的抱怨”。之前俺写其它教程（比如：翻墙、操作系统虚拟机），也看到过类似的抱怨。</p><p>关于折腾的抱怨，俺总结下来有两类：</p><p>其一，“从不折腾的人”抱怨折腾太麻烦（这类抱怨往往是泛泛的）</p><p>其二，“有过折腾经历的人”抱怨折腾太麻烦（这类抱怨往往是有具体所指的）</p><p>所以今天就来聊聊“折腾”这个话题。</p><p>★名词定义：何为“折腾”</p><p>为了避免某些人抬杠，先界定一下关键术语——“折腾”一词指的是啥？</p><p>在下面的讨论中，“折腾”一词指的是：</p><p>在你【不熟悉】的领域中干某些事情（如果是你【熟悉】的领域，那属于“轻车熟路”，不能算“折腾”）</p><p>这些事情通常带有某种“探索&#x2F;钻研”的性质（通常颇费周折）</p><p>这些事情通常要耗费一定的时间和精力（能很快搞定的，就不能算“折腾”）</p><p>这些事情通常具有不确定的结果（你不清楚是否能得到期望的结果）。</p><p>举例：</p><p>针对软件的折腾（比如：Linux）</p><p>针对硬件的折腾（比如：树莓派）</p><p>针对网络的折腾（比如：翻墙）</p><p>……</p><p>★“折腾”与“自学能力”</p><p>◇“自学能力”的重要性</p><p>博客的读者们应该都明白这玩意儿的重要性吧？俺随便说几点：</p><p>比如：信息时代会有很多新生事物。你以前在学校课堂里学到的知识&#x2F;技能已经无法应对这些新生事务，你需要通过自学来搞定它们。</p><p>比如：在信息时代，知识的半衰期会变短。你以前在学校课堂里学到的知识&#x2F;技能，等到你工作时，有些已经过时（失效）了。你需要通过自学来更新这部分过时的知识。</p><p>比如：如今的职场竞争会比以往更激烈（信息流动加快使得人才流动加快）。自学能力强的人无疑会有更大的优势。</p><p>……</p><p>◇两者的关系</p><p>前面俺强调了：折腾的前提是——在你【不熟悉】的领域。</p><p>在这种领域中，你多半要通过自学，掌握某些知识或技能，让“不熟悉的领域”变为“熟悉的领域”。</p><p>所以，喜欢折腾的人，他&#x2F;她的自学能力会经常得到锻炼。</p><p>当然啦，“经常锻炼自学能力”不一定就表示“自学能力很强”，但至少好于那些“从来没有得到锻炼的人”。</p><p>★“折腾”与“解决问题能力”</p><p>◇“解决问题能力”的重要性</p><p>说到这个，俺又要趁机来恶毒攻击一下咱们天朝的教育体制了 :)</p><p>如果你回顾一下学校（小学&#x2F;中学&#x2F;大学）里面的考试或课后作业，大部分的题目都有标准答案（理工科尤其明显）。</p><p>但是当你进入职场后，很多工作中的问题，其解决方法是多种多样的，【没有标准答案】。</p><p>这两类问题的解题思路是完全不同滴 ——</p><p>【有】标准答案的问题，解题的思维过程通常是【收敛式】；</p><p>【没有】标准答案的问题，解体的思维过程通常是【发散式】。</p><p>有很多学校中的优秀生，他们很擅长于考试，但是在工作中的表现却令人难以恭维。因为他们擅长的【收敛式思维】，在工作中通常用不上。</p><p>◇两者的关系</p><p>“折腾”与“解题能力”有哪些关系捏？</p><p>当你在不熟悉的领域中折腾，通常不会一帆风顺——整个过程必然会碰到各种各样的问题（困难和障碍），这些问题往往是没有标准答案滴。换句话说，折腾中碰到问题，【不同于】你在学校中碰到的考题，而【更接近于】你在实际工作中碰到问题。</p><p>所以，经常折腾的人，会有更多的机会去锻炼他&#x2F;她的【发散思维能力】。也就可以更多地弥补学校教育在这方面的缺陷。</p><p>★“折腾”与“知识面&#x2F;知识结构”</p><p>◇知识面的重要性</p><p>如今这个信息时代，【复合型人才】更有竞争优势。所谓的“复合型”，其主要特征【之一】就是“知识面比较广”。这类人往往兼具多个不同领域的技能。</p><p>就拿自己来现身说法——简述一下：维护目前这个博客，大概需要哪些技能？</p><p>基本的写作能力是必不可少滴——如果写出来的文章狗屁不通，就没人看了；</p><p>翻墙是必不可少滴——俺必须把博客搭建在墙外，才能防止真理部的和谐；</p><p>信息安全也是必不可少滴——否则早就被跨省追捕了；</p><p>懂一些 Web 开发的技能（CSS 和 JS）是有好处滴——有助于俺把博客界面搞得好看&#x2F;好用；</p><p>除了上面这些，因为俺博客聊到了“政治、历史、心理学、管理、编程”这几类话题，所以俺在这几个领域多少还算略懂（不敢妄称精通）。</p><p>◇什么样的知识结构才是合理的（有优势的）</p><p>前面提到了“知识面的广度”。但仅仅有广度是【不够】滴。良好的知识结构，应该兼具【广度】与【深度】。</p><p>至于“深度”与“广度”要如何搭配才比较好，可以看俺多年前的一篇博文《如何完善自己的知识结构》。</p><p>◇两者的关系</p><p>那么，“折腾”与“知识面&#x2F;知识结构”有啥关系捏？</p><p>比如说：你正在折腾 A领域 的某个事物，在折腾的过程中可能会依赖到相关领域的知识（比如说 B领域 和 C领域）。而 B领域 和 C领域 可能是你之前所不了解的。为了搞定 A领域，你就需要顺便去了解 B领域 和 C领域。无形中，你的知识面就拓宽了。</p><p>举个栗子：</p><p>某个技术菜鸟去折腾翻墙，当此人搞定之后，通常也顺便学会了一些网络相关的知识（比如：代理、VPN …）</p><p>如果此人是通过 VPS 来搭建翻墙代理，说不定还顺便学会了一些 Linux 系统管理方面的知识。</p><p>★“折腾”与“动手实践能力”</p><p>◇两种不同的领域</p><p>所有的领域可以分为两类——“记忆型”与“实践型”。</p><p>（注：这两个术语是俺拍脑袋临时起的名儿，如果你有更恰当的叫法，欢迎告知俺）</p><p>所谓的“记忆型”，意思就是说：你只需要依靠记忆力就可以掌握该领域。</p><p>而“实践型”则完全不同——要掌握这种类型的领域，光靠记忆力是肯定不够滴，一定要经过动手实践。</p><p>举例：</p><p>“记忆型”的例子比较少：历史、艺术鉴赏…</p><p>“实践型”的例子比较多：所有的体育项目、所有的棋牌游戏和电子游戏、烹调、编程、管理、艺术创作……</p><p>对于“实践型”的领域，不管你看了多少相关的书籍，记住了多少相关的知识，最后都要经过实践，才能最终掌握该领域。套用一句古话就是：</p><p>纸上得来终觉浅，绝知此事要躬行。</p><p>举例：</p><p>比如说下围棋——如果某人从来没有实际下过，即使此人看了 N 多的棋谱，看了 N 多的围棋理论书籍，也不能算是“会下棋”。</p><p>学编程也类似——俺一直强调学编程（尤其是新人学编程）要：一边看书一边动手写点小程序练手。</p><p>◇两者的关系</p><p>俺个人认为：凡是需要折腾的领域，都是实践型的领域。</p><p>而经常折腾的好处在于：每次折腾都是在锻炼你的动手实践能力。</p><p>★“折腾”与“心理舒适区”</p><p>◇啥是“心理舒适区”？</p><p>两年前（2015）写过一篇《什么是【真正的】兴趣爱好？以及它有啥好处？》，其中正好聊过“心理舒适区”这个概念。下面这段直接引用那篇博文。</p><p>首先来解释一下，何为“心理舒适区”。这玩意儿，洋文称之为“Comfort Zone”，用来描述一种“心理状态”。处于这种状态，你会感觉到放松，没有压力和焦虑。</p><p>如果你处于某个环境中，在该环境下所需要的行为你都可以轻松搞定。那么，你就处于“心理舒适区”。</p><p>举例：</p><p>上网闲逛</p><p>看电视剧</p><p>看娱乐节目</p><p>◇“走出心理舒适区”的重要性</p><p>几乎所有的个人能力，如果要想得到提升，都需要你跳出“心理舒适区”。</p><p>比如说那些优秀的体操运动员，他们需要不断练习自己【不熟悉】的动作，这样才能提高；反之，如果某个体操运动员总是练习自己最拿手的动作，那是没有长进的（或者说，长进非常有限）。</p><p>◇为啥大部分人都【无法】走出心理舒适区？</p><p>首先，人都是惰性的。</p><p>停留在心理舒适区，极大地满足了人的惰性。</p><p>要离开心理舒适区，就要克服这种惰性；这通常需要动用意志力，而且需要一定的技巧。</p><p>大多数人的意志力是偏弱的；即使是少数意志力较强的人，其中还有一定比例是缺乏运用技巧的。</p><p>如果你对这个结论有所怀疑，不妨去观察一下：大部分人在闲暇时间都在干嘛。你就会发现：大部分人都在用一些【轻松的&#x2F;消遣性的&#x2F;娱乐性的】活动来打发时光。</p><p>◇两者的关系</p><p>前面说过：折腾的往往是自己不熟悉的领域，所以折腾的过程往往会碰到一些障碍和困难。</p><p>而搞定这些障碍和困难，通常需要你跳到“心理舒适区”【之外】。</p><p>所以，经常折腾的人，就经常需要挑战困难和障碍，于是也就有更多机会去练习——如何跳出心理舒适区。</p><p>★聊聊那些“不折腾”的理由或借口</p><p>说完了“心理舒适区”，顺便列几个反面教材——关于“不折腾的理由或借口”。</p><p>常见的理由&#x2F;借口有如下几种：</p><p>◇抱怨“无用功”</p><p>很多人觉得：如果折腾某个东西，最后没有搞出来（失败了），那就白白浪费了时间，成为“无用功”。</p><p>这个理由非常有迷惑性（尤其是在天朝这个功利主义非常盛行的社会）。</p><p>实际情况是：即使你折腾某个东西最后失败了，也【不会】是无用功。</p><p>因为在这个过程中，你会有很多收获——包括前面提到的几种能力提升和知识面的拓展。</p><p>◇抱怨“时间不够”</p><p>这可能是最常见的一种抱怨（借口）——说自己工作太忙，没有空闲的时间去折腾其它东西。</p><p>首先，拿网上流传的一句话来反驳此借口——时间就像乳沟，只要你愿意挤，总是有的。</p><p>然后，来分析一下俺博客的读者群，应该大部分是学生或者白领&#x2F;蓝领。</p><p>对于在校的学生</p><p>（不管是大学生还是中学生）肯定是是有闲暇时间的（比如寒暑假）。</p><p>即使是高三年很忙，只要等高考结束，之后那个假期总归是空闲的。</p><p>对于工作中的上班族</p><p>很多人抱怨“加班”占用时间。</p><p>试问：有多少公司是一年365天，天天都加班（完全没有周末和节假日）；而且每天（无一例外）都加班到深夜，一回家就上床睡觉，然后一觉醒来就又去上班。这样的公司，就算有，占总体的比例肯定也是微乎其微的。</p><p>还有一些人抱怨“养小孩”占用时间。</p><p>这种借口同样是站不住脚滴。“养小孩”确实会占用一些业余时间，但比例肯定达不到100%；而且特别占时间的，通常是小孩刚出生的开头三五年。</p><p>所以，绝大部分上班族肯定是有闲暇时间的。</p><p>◇抱怨“精力不够”</p><p>另一种常见的抱怨是：上班已经很累，下班回家哪还有精力去折腾其它东西。</p><p>首先，很多人发这种抱怨是有夸大其辞的嫌疑。</p><p>其次，退一步讲，就算有【少数工作】是每天都很累以至于每天下班回家都精疲力竭。但你至少还有周末的双休日可用啊。每年有52个星期，单算双休日就有一百多天呢！（这还没算上国定假日）</p><p>◇抱怨“技能不够”</p><p>有这种抱怨的人，要么是找借口，要么是太缺乏自信。</p><p>在如今这个互联网很普及的时代（天朝网民据说已经6亿或7亿了），很多需要折腾的事物，都可以在网上找到教程，甚至是手把手的傻瓜教程。有了教程（尤其是傻瓜教程），折腾的门槛已经大大降低了。</p><p>（至于如何在网上找到教程，可以参考《如何挖掘网络资源》系列博文）</p><p>当然啦，即使有了再完备的教程，你依然会在折腾的过程中碰到一些困难和障碍。所以“教程的存在”并【不会】影响你锻炼“解决问题的能力”。</p><p>◇小结</p><p>上述所有这些，如果是【理由】的话，那都是不成立的；如果是【借口】的话，那都可以归咎于——不愿意离开心理舒适区。</p><p>为啥很多人都在找借口捏？因为大部分人【不】愿意承认：自己总是停留在心理舒适区；并且大部分人更【不】愿意承认：自己无法离开心理舒适区。所以，他们需要找各种借口来掩饰。</p><p>★俺写本文的目的</p><p>在本文最后，稍微透露一下俺写本文的动机。</p><p>可能大多数读者会【误以为】：俺写这篇是想劝那些不喜欢折腾的人改变习惯，多多折腾。</p><p>NO，NO，NO！这不是俺的本意。</p><p>前面说了：那些不喜欢折腾的人，无法（难以）跳出心理舒适区。这是由他们的本性（意志力、观念、性格 …）决定的。</p><p>而一个人的本性，是【无法】轻易改变滴。</p><p>所以，俺当然【不指望】：靠这样一篇短短的博文，就能改变他们的本性。</p><p>那俺为啥还要写这篇博文捏？写此文的目的是：鼓励那些已经走上折腾之路的同学们，希望他们能在这条路上走得足够远。【好好折腾，天天向上】</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在水上的字</title>
      <link href="/posts/2018-07-27-wirte-words-on-water.html"/>
      <url>/posts/2018-07-27-wirte-words-on-water.html</url>
      
        <content type="html"><![CDATA[<p>文&#x2F;林清玄</p><p>生命的历程就像是写在水上的字，顺流而下，想回头寻找的时候总是失去了痕迹，因为在水上写字，无论多么的费力，那水都不能永恒，甚至是不能成型的。</p><p>如果我们企图要停驻在过去的快乐里，那真是自寻烦恼，而我们不时从记忆中想起苦难，反而使苦难加倍。 生命历程中的快乐和痛苦，欢欣和悲叹水只是写在水上的字，一定会在时光里流走。</p><p>身如流水，日夜不停流去，使人在闪灭中老去。</p><p>心如流水，没有片刻静止，使人在散乱中活着。</p><p>身心俱幻正如在流水上写字，第二笔未写，第一笔就流到远方。</p><p>爱，也是流水上写字，当我们说爱的时候，爱之念已流到远处。</p><p>美丽的爱是写在水上的诗，平凡的爱是写在水上的公文，爱的誓言是流水上偶尔飘过的枯叶，落下时，总是无声的流走。</p><p>既然是生活在水上，且让我们顺着水的因缘自然地流下去，看见花开，知道是花的因缘具足了，花朵才得以绽放；看见落叶，知道是落叶的因缘足了，树叶才会掉下。 在一群陌生人之间，我们总是会遇见那些有缘的人，等到缘尽了，我们就会如梦一样忘记他的名字和脸孔，他也如写在水上的一个字，在因缘中散灭了。</p><p>我们生活着为什么会感觉到恐惧、惊怖、忧伤与苦恼，那是由于我们只注视写下的字句，却忘记字是写在一条源源不断的水上。 水上的草木一一排列，它们互相并不顾望，顺势流去，人的痛苦是前面的浮草只是思念着后面的浮木，后面的水泡又想看看前面的浮枢。 只要我们认清字是写在水上，就能够心无挂碍，没有恐惧，远离颠倒梦想。</p><p>在汹涌的波涛与急速的旋涡中，顺流而下的人，是不是偶尔抬起头来，发现自己原是水上的一个字呢？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>永远不要在 MySQL 中使用utf8</title>
      <link href="/posts/2018-07-24-never-use-utf8-in-mysql.html"/>
      <url>/posts/2018-07-24-never-use-utf8-in-mysql.html</url>
      
        <content type="html"><![CDATA[<p>本文出自极客邦「聊聊架构」公众号的编译。我自己当年也被这个问题坑过，当时并没有如此详细的分析文章。我觉得有责任再次分享一下，让更多人知道这个事情。程序员不帮助程序员，还能指望谁呢？</p><p>最近我遇到了一个 bug，我试着通过 Rails 在以「utf8」编码的 MariaDB 中保存一个 UTF-8 字符串，然后出现了一个离奇的错误：</p><pre><code>Incorrect string value: ‘\xF0\x9F\x98\x83 &lt;…’ for column ‘summary’ at row 1</code></pre><p>我用的是 UTF-8 编码的客户端，服务器也是 UTF-8 编码的，数据库也是，就连要保存的这个字符串「 &lt;…」也是合法的 UTF-8。</p><p>问题的症结在于，MySQL 的「utf8」实际上不是真正的 UTF-8。</p><p>「utf8」只支持每个字符最多三个字节，而真正的 UTF-8 是每个字符最多四个字节。MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作「utf8mb4」的字符集，绕过了这个问题。当然，他们并没有对新的字符集广而告之（可能是因为这个 bug 让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用「utf8」，但这些建议都是错误的。</p><p>简单概括如下：</p><p>1、MySQL 的「utf8mb4」是真正的「UTF-8」。</p><p>2、MySQL 的「utf8」是一种「专属的编码」，它能够编码的 Unicode 字符并不多。</p><p>我要在这里澄清一下：所有在使用「utf8」的 MySQL 和 MariaDB 用户都应该改用「utf8mb4」，永远都不要再使用「utf8」。</p><h3 id="什么是编码？什么是-UTF-8？"><a href="#什么是编码？什么是-UTF-8？" class="headerlink" title="什么是编码？什么是 UTF-8？"></a>什么是编码？什么是 UTF-8？</h3><p>我们都知道，计算机使用 0 和 1 来存储文本。比如字符「C」被存成「01000011」，那么计算机在显示这个字符时需要经过两个步骤：</p><p>1、计算机读取「01000011」，得到数字 67，因为 67 被编码成「01000011」。</p><p>2、计算机在 Unicode 字符集中查找 67，找到了「C」。</p><p>同样的：</p><p>1、我的电脑将「C」映射成 Unicode 字符集中的 67。</p><p>2、我的电脑将 67 编码成「01000011」，并发送给 Web 服务器。</p><p>几乎所有的网络应用都使用了 Unicode 字符集，因为没有理由使用其他字符集。</p><p>Unicode 字符集包含了上百万个字符。最简单的编码是 UTF-32，每个字符使用 32 位。这样做最简单，因为一直以来，计算机将 32 位视为数字，而计算机最在行的就是处理数字。但问题是，这样太浪费空间了。</p><p>UTF-8 可以节省空间，在 UTF-8 中，字符「C」只需要 8 位，一些不常用的字符，比如「」需要 32 位。其他的字符可能使用 16 位或 24 位。一篇类似本文这样的文章，如果使用 UTF-8 编码，占用的空间只有 UTF-32 的四分之一左右。</p><p>MySQL 的「utf8」字符集与其他程序不兼容，它所谓的字符集，可能真的是一坨……</p><h3 id="MySQL-简史"><a href="#MySQL-简史" class="headerlink" title="MySQL 简史"></a>MySQL 简史</h3><p>为什么 MySQL 开发者会让「utf8」失效？我们或许可以从提交日志中寻找答案。</p><p>MySQL 从 4.1 版本开始支持 UTF-8，也就是 2003 年，而今天使用的 UTF-8 标准（RFC 3629）是随后才出现的。<br>旧版的 UTF-8 标准（RFC 2279）最多支持每个字符 6 个字节。2002 年 3 月 28 日，MySQL 开发者在第一个 MySQL 4.1 预览版中使用了 RFC 2279。</p><p>同年 9 月，他们对 MySQL 源代码进行了一次调整：「UTF8 现在最多只支持 3 个字节的序列」。是谁提交了这些代码？他为什么要这样做？这个问题不得而知。在迁移到 Git 后（MySQL 最开始使用的是 BitKeeper），MySQL 代码库中的很多提交者的名字都丢失了。2003 年 9 月的邮件列表中也找不到可以解释这一变更的线索。</p><p>不过我可以试着猜测一下。</p><p>2002 年，MySQL 做出了一个决定：如果用户可以保证数据表的每一行都使用相同的字节数，那么 MySQL 就可以在性能方面来一个大提升。为此，用户需要将文本列定义为「CHAR」，每个「CHAR」列总是拥有相同数量的字符。如果插入的字符少于定义的数量，MySQL 就会在后面填充空格，如果插入的字符超过了定义的数量，后面超出部分会被截断。</p><p>MySQL 开发者在最开始尝试 UTF-8 时使用了每个字符 6 个字节，CHAR(1) 使用 6 个字节，CHAR(2) 使用 12 个字节，并以此类推。</p><p>应该说，他们最初的行为才是正确的，可惜这一版本一直没有发布。但是文档上却这么写了，而且广为流传，所有了解 UTF-8 的人都认同文档里写的东西。不过很显然，MySQL 开发者或厂商担心会有用户做这两件事：</p><p>1 使用 CHAR 定义列（在现在看来，CHAR 已经是老古董了，但在那时，在 MySQL 中使用 CHAR 会更快，不过从 2005 年以后就不是这样子了）。<br>2 将 CHAR 列的编码设置为「utf8」。</p><p>我的猜测是 MySQL 开发者本来想帮助那些希望在空间和速度上双赢的用户，但他们搞砸了「utf8」编码。</p><p>所以结果就是没有赢家。那些希望在空间和速度上双赢的用户，当他们在使用「utf8」的 CHAR 列时，实际上使用的空间比预期的更大，速度也比预期的慢。而想要正确性的用户，当他们使用「utf8」编码时，却无法保存像「」这样的字符。</p><p>在这个不合法的字符集发布了之后，MySQL 就无法修复它，因为这样需要要求所有用户重新构建他们的数据库。最终，MySQL 在 2010 年重新发布了「utf8mb4」来支持真正的 UTF-8。</p><h3 id="为什么这件事情会让人如此抓狂"><a href="#为什么这件事情会让人如此抓狂" class="headerlink" title="为什么这件事情会让人如此抓狂"></a>为什么这件事情会让人如此抓狂</h3><p>因为这个问题，我整整抓狂了一个礼拜。我被「utf8」愚弄了，花了很多时间才找到这个 bug。但我一定不是唯一的一个，网络上几乎所有的文章都把「utf8」当成是真正的 UTF-8。「utf8」只能算是个专有的字符集，它给我们带来了新问题，却一直没有得到解决。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果你在使用 MySQL 或 MariaDB，不要用「utf8」编码，改用「utf8mb4」。这里提供了一个指南用于将现有数据库的字符编码从「utf8」转成「utf8mb4」：</p><p><a href="https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4">https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4</a></p><p>这篇文章的英文原文：<br><a href="https://medium.com/@adamhooper/in-mysql-never-use-utf8-use-utf8mb4-11761243e434">https:&#x2F;&#x2F;medium.com&#x2F;@adamhooper&#x2F;in-mysql-never-use-utf8-use-utf8mb4-11761243e434</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows XP SP3下载（附激活码）</title>
      <link href="/posts/2018-04-19-Windows-XP-SP3-Download-Link-with-active-keys.html"/>
      <url>/posts/2018-04-19-Windows-XP-SP3-Download-Link-with-active-keys.html</url>
      
        <content type="html"><![CDATA[<p>Windows XP是美国微软公司研发的基于X86、X64架构的PC和平板电脑使用的操作系统，于2001年8月24日发布RTM版本，并于2001年10月25日开始零售。 [1-2]  其名字中“XP”的意思来自英文中的“体验（Experience）”。</p><p>该系统是继Windows 2000及Windows ME之后的下一代Windows操作系统，也是微软首个面向消费者且使用Windows NT5.1架构的操作系统。</p><p>2014年4月8日，微软终止对该系统的技术支持，但在此之后仍在一些重大计算机安全事件中对该系统发布了补丁。</p><p>ed2k链接（官方镜像）：</p><pre><code>ed2k://|file|zh-hans_windows_xp_professional_with_service_pack_3_x86_cd_vl_x14-74070.iso|630237184|EC51916C9D9B8B931195EE0D6EE9B40E|/</code></pre><p>激活码：</p><pre><code>MRX3F-47B9T-2487J-KWKMF-RPWBY</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯问题</title>
      <link href="/posts/2018-04-19-stair-problems-common-lisp.html"/>
      <url>/posts/2018-04-19-stair-problems-common-lisp.html</url>
      
        <content type="html"><![CDATA[<p>题意： 有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？</p><p>这个题目是经典的递归、递推问题。</p><p>这里先说说递归的思想吧。</p><p>我们令f(n)表示n步台阶的走法。那么要走到n步之前只有两种情况。一种是走到了n-1步台阶上，另一种是走到了n-2步台阶上。</p><p>于是我们有了方程： f(n) &#x3D; f(n-1) + f(n-2)</p><p>这个时候我们只需要手算一下n&#x3D;1有几种走法，显然一种。手算一下n&#x3D;2有几种走法，显然两种。</p><pre><code class="lisp">(defun step-method (n)    (if (= n 1)        1        (if (= n 2)            2            (+ (step-method (- n 1)) (step-method (- n 2))))))(format t &quot;~D~%&quot; (step-method 10))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Common Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大整数加法</title>
      <link href="/posts/2018-04-18-bigint-addition.html"/>
      <url>/posts/2018-04-18-bigint-addition.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int main() &#123;    // 1. 开始程序，输入两个字符串    string str1, str2;    cin &gt;&gt; str1 &gt;&gt; str2;    // 2. 初始化一个数组，并每个元素初始化为0    int a[1000];    for (int i = 0; i &lt; 1000; ++i) a[i] = 0;    // 3. 把str1的每一位从最后开始拿（依次为str[str1.length()-1],str[str1.length()-2],...,str1[0]&#125;），依次累加到a[0],a[1],a[2]...,a[str1.length()-1]    for (int i = 0; i &lt; str1.length(); ++i) &#123;        a[i] += ( str1[str1.length()-i-1] - &#39;0&#39; ); // 把对应位置字符拿出来，然后-&#39;0&#39;则是字符对应的数字    &#125;    // 4. 把str2的每一个从最后开始拿，同3操作。    for (int i = 0; i &lt;str2.length(); ++i) &#123;        a[i] += ( str2[str2.length()-i-1] - &#39;0&#39; );    &#125;    // 5. 从最低位，也就是0下标开始对数组a进行整理（也是就我们加法的时候所谓的进位。）    for (int i = 0; i &lt; 999; ++i) &#123;        int tmp = a[i] / 10; // 拿出除去个位的部分，如：a[i] = 23;则tmp为2,进位操作的时候3保留下来，2,加到高位去。        a[i+1] += tmp; // 进位操作        a[i] %= 10;    &#125;    // 6. 寻找最高位不为零的位置。当所有数字都为0时，high会为-1，则需要将high赋值为0    int high = 999;    while (0 == a[high]) --high;    high = high &gt; 0 ? high : 0; // 不想用if-else来操作。    // 7. 从最高位开始输出    for (int i = high; i &gt;= 0; --i) cout &lt;&lt; a[i];    cout &lt;&lt; endl;    return 0;&#125;</code></pre><p>Common Lisp代码</p><pre><code class="lisp">(let ((a (read)) (b (read)))    (format t &quot;~D~%&quot; (+ a b)))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Common Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/posts/2018-04-17-fast-power.html"/>
      <url>/posts/2018-04-17-fast-power.html</url>
      
        <content type="html"><![CDATA[<p>我们从一个简单的问题开始。 $ 6^{208}%23 $等于多少。解这个题目最笨的方法是把$6^{208}$算出来，然后再算$6^{208}%23$。接下来我们讲解一种快速计算的方法。此方法在ACM-ICPC中非常重要，在密码学考试中一样相当重要。</p><p>首先我们来计算一下$6^{208}$是多少吧。</p><p>先上幂运算代码(clisp)：</p><pre><code class="lisp">(defun pow (x n)    (if (= n 0)        1        (* x (pow x (1- n)))))</code></pre><p>运行结果</p><pre><code class="text">* (defun pow (x n)    (if (= n 0)        1        (* x (pow x (1- n)))))POW* (pow 6 208)716902475118262214817011779393196661223001384517326117611478588644678638278414107572257870390965072733283553862876694482148415089417201250632070732438043011055616* (mod (pow 6 208) 23)4</code></pre><p>接下来上快速幂代码(clisp)：</p><pre><code class="lisp">;;;; pow_mod function(defun pow_mod (x n mod_value)    (if (= n 0)        1        (if (= n 1)            (mod x mod_value)            (mod                (*                    (mod (pow (pow_mod x (floor (/ n 2)) mod_value) 2) mod_value)                    (pow_mod x (mod n 2) mod_value)                )                mod_value))))</code></pre><p>最后计算出来等于4</p><p>那么接下来在说快速幂之前我们先讲一个公式： $ (a \times b) % n &#x3D; [ (a % n) \times (b % n) ] % n $</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Number Theory </tag>
            
            <tag> Common Lisp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础教程</title>
      <link href="/posts/2018-04-17-linux-basic-manual.html"/>
      <url>/posts/2018-04-17-linux-basic-manual.html</url>
      
        <content type="html"><![CDATA[<p>为了今天讲课我特意搞了这份讲义，以为待会车速太快没办法平稳停车。</p><p>我是在2005年，那年我读初中二年级，在学校发读信息技术教科书上看到Linux这个词的。我知道大部分初高中同学在拿到信息技术这类教材的时候都是直接塞桌底的。高中Linux用得少，没什么机会搞事情。到了高三毕业的时候，好友给我一个上网本，他自己安装的Linux系统。别以为是什么好事情，这货自己把上网本搞出问题来，让我帮忙修来着，我修不了，顺带手自己在U盘里搞了一个Linux，然后从U盘启动，他电脑硬件没坏。到了大学，大一大二我都是用Ubuntu，刚开始来大一的时候还是用雨林木风的，大三的时候用Slackware，大四用FreeBSD，现在滚到macOS了。但是就是觉得用Linux很爽，写代码在命令行下编译，不用纠结用那个IDE环境，各个IDE环境的界面还不一样，尤其是编译运行调试的快捷键都不一样，搞得我差不多需要写个纸条贴在屏幕边上告诉我哪个快捷键是哪个IDE下编译的快捷键。大一下学期我就在蓄谋我们学校OJ的事情了。当时还是在自己笔记本电脑上安装环境，然后在上面导入一些大佬分享出来的题目数据。这样我回家的时候就能正常刷题了。理解一下山区孩子没网但要刷题的迫切需要。</p><p>大二下学期，我刚好加入了学校信安实践工作室，那里刚好有一台指导老师用的服务器，于是我跟老师申请在上面安装学校OJ，于是就有了JustOJ v0.1. 后来折腾服务器，多次把老师的服务器搞崩，导致老师上课的学生无法正常提交作业。但是服务器崩了，老师自己又修复不了，只能让我来，所以老师也不好说我什么。</p><p>本科毕业以后，当时正好学校把信息学院从原来的学院楼搬到了新的学院楼，服务器被停了。后来我找到学院老师，又把服务器恢复起来了。当时还申请了22，80端口的，后来学校又把端口给封了。导致现在学校OJ这个样子了。只能内网访问。今年我争取把OJ对公网端口给申请下来。</p><h2 id="0x00-什么是Linux"><a href="#0x00-什么是Linux" class="headerlink" title="0x00 什么是Linux"></a>0x00 什么是Linux</h2><p>Linux内核最初只是由芬兰人李纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p><p>Linux能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h2 id="0x01-Linux发行版"><a href="#0x01-Linux发行版" class="headerlink" title="0x01 Linux发行版"></a>0x01 Linux发行版</h2><p>Linux的发行版说简单点就是将Linux内核与应用软件做一个打包。</p><p>Linux有很多发行版，发行版之间大同小异。就跟现在的Android智能手机一样，大家用的都是Google家的Android系统，然后自己再定制一下，于是就有了MiUI，Flyme，锤子系统等。那么在Linux下发行版就有很多了，国外比较出名的有Ubuntu、RedHat、CentOS、Debian、openSUSE、Slackware等。国内也有做得比较好的，比如早期，大概是2011年的时候有雨林木风还是不错的，目前国内比较不错的就算deepin了。</p><h2 id="0x02-Linux和ACM-ICPC"><a href="#0x02-Linux和ACM-ICPC" class="headerlink" title="0x02 Linux和ACM-ICPC"></a>0x02 Linux和ACM-ICPC</h2><p>在ACM-ICPC正式比赛的现场赛，所有赛点提供给选手使用的电脑上都只安装Ubuntu系统。所以ACM选手或多或少都需要了解Linux并学会简单使用。</p><p>现场赛提供的环境大致如下：</p><p>操作系统：Ubuntu 14.04 LTS 64-bit<br>判题系统：PC^2 9.2.4<br>支持语言：C&#x2F;C++ 4.8.2, Java 1.7.0_65<br>提供的IDE：Code::Blocks 13.12 &#x2F; Eclipse JDT &amp; CDT 3.8.1 &#x2F; Netbeans 7.0.1<br>(这是我最后一场比赛上海赛区提供的比赛环境。)</p><h2 id="0x03-Linux基本使用"><a href="#0x03-Linux基本使用" class="headerlink" title="0x03 Linux基本使用"></a>0x03 Linux基本使用</h2><p>桌面环境的话，大致上跟大家使用手机使用电脑都没有什么太大差别，都是哪里不会点哪里。在座的各位，你们在第一次使用手机之前应该没有谁是会去看操作手册&#x2F;使用说明书的吧。</p><h2 id="0x04-Linux命令行"><a href="#0x04-Linux命令行" class="headerlink" title="0x04 Linux命令行"></a>0x04 Linux命令行</h2><p>在大部分人看来，会玩Linux的都是不需要鼠标的，一个命令行窗口一顿噼里啪啦乱敲，然后屏幕上一堆代码闪过，然后远看对面政府大楼就停电了。</p><h3 id="无参数命令"><a href="#无参数命令" class="headerlink" title="无参数命令"></a>无参数命令</h3><p>ls &#x2F; ps &#x2F; ll &#x2F; top &#x2F; htop &#x2F; date &#x2F; ifconfig &#x2F; history</p><h3 id="带参数命令"><a href="#带参数命令" class="headerlink" title="带参数命令"></a>带参数命令</h3><p>Linux下命令基本上都是带参数的。Linux环境下的命令大致上和编程的时候的函数&#x2F;方法差不多一个意思。都是完成某种功能。函数也有参数，比如 int sum (int a, int b)表示将两个数字进行加和，int max(int a, int b)表示比较两个数字，并返回其中较大的数字。</p><p>cd</p><p>cp</p><p>echo</p><p>ping</p><p>ps -ef</p><p>ls -l</p><p>ls -Slh</p><p>ls -a</p><h3 id="Ubuntu常用的软件命令"><a href="#Ubuntu常用的软件命令" class="headerlink" title="Ubuntu常用的软件命令"></a>Ubuntu常用的软件命令</h3><p>应用管理命令apt&#x2F;apt-get，用来安装软件的。</p><pre><code>apt-get install clispapt-get remove clisp</code></pre><h2 id="0x05-Linux命令原理"><a href="#0x05-Linux命令原理" class="headerlink" title="0x05 Linux命令原理"></a>0x05 Linux命令原理</h2><p>在0x04中我们讲解了Linux下常用命令的使用。我们首先了解了一些不带参数的命令，一下可以加参数的命令。而Linux中的命令都是一些程序，基本上在&#x2F;bin、&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;sbin等目录中可以看到。在这些目录下的文件都是可执行文件（这里稍微解释一下，Linux下的文件基本上可执行文件是不需要后缀名的，这点和Windows程序不同，因为Windows可执行文件大都都是.exe后缀）。</p><p>接下来我将带领大家写一个简单的Linux命令。</p><pre><code class="c">/** * file name : addsum.cpp * description : Add numbers * author : ismdeep */#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;using namespace std;int string_2_int (string str) &#123;    stringstream ss;    ss &lt;&lt; str &lt;&lt; endl;    int ans;    ss &gt;&gt; ans;    return ans;&#125;int main(int argc, char const *argv[]) &#123;    int sum = 0;    for (int i = 1; i &lt; argc; ++i) &#123;        sum += string_2_int ( argv[i] );    &#125;    cout &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;</code></pre><p>在这个程序中，程序的main函数跟我们之前写题目的时候的main函数似乎有一些不同。这个地方是用来接收程序在启动时传入的参数。</p><p>在执行这个程序的时候我们就可以加上参数了。</p><pre><code>addsum 1 2 3 4 5 6 7 8</code></pre><p>输出的结果是36</p><h2 id="再来讲讲命令组合吧"><a href="#再来讲讲命令组合吧" class="headerlink" title="再来讲讲命令组合吧"></a>再来讲讲命令组合吧</h2><p>命令组合就是将几个命令结合起来使用并实现强大的功能。在Linux下，程序尽可能小，用途单一。然后将程序连接起来，共同完成复杂功能。比如你需要判断一堆数字加起来的和是否是偶数。这个时候你可以使用两个程序来完成，一个程序把这些数字进行加和，一个数字用来判断某数字是否为偶数。</p><pre><code>echo 12 3 4 5 6 | addsum | is_even</code></pre><h2 id="bash脚本"><a href="#bash脚本" class="headerlink" title="bash脚本"></a>bash脚本</h2><p>bash脚本就是将很多Linux上面的命令组合在一个文件中，然后按顺序执行。</p><h2 id="如何执行远程服务器上的bash脚本"><a href="#如何执行远程服务器上的bash脚本" class="headerlink" title="如何执行远程服务器上的bash脚本"></a>如何执行远程服务器上的bash脚本</h2><h2 id="0x06-ACM-ICPC在需要用到的命令"><a href="#0x06-ACM-ICPC在需要用到的命令" class="headerlink" title="0x06 ACM-ICPC在需要用到的命令"></a>0x06 ACM-ICPC在需要用到的命令</h2><h3 id="gcc-g"><a href="#gcc-g" class="headerlink" title="gcc&#x2F;g++"></a>gcc&#x2F;g++</h3><p>这两个命令是分别用来编译C代码和C++代码的。后面使用的参数格式是一样的。常用的参数有：-g -W -D -o<br>-g 表示开启gdb调试信息，通过-g编译出来的exe文件会带上调试信息，可以使用gdb对生成的可执行文件进行调试。<br>-W 表示编译过程中提示那些错误信息，强迫症患者一般开启所有，也就是-Wall<br>-D 表示编译时带入的宏定义，比如编译的时候使用-DLOCALTEST<br>-o 表示输出文件到哪里，所以-o后面还需要加一个文件名。</p><p>如下代码：</p><pre><code class="c">#include &lt;iostream&gt;using namespace std;int main() &#123;    int a, b;    while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF) &#123;        #ifdef LOCALTEST        printf(&quot;The a and b you have just inputed are : %d and %d\n&quot;, a, b);        #endif        printf(&quot;%d\n&quot;, a + b);    &#125;    return 0;&#125;</code></pre><p>编译指令</p><pre><code>g++ -g -Wall -DLOCALTEST main.cpp -o main</code></pre><p>运行命令：</p><pre><code>echo 1 2 | ./main</code></pre><p>输出</p><pre><code>ismdeep@MacBookPro: ~/Desktop $ echo 1 2 | ./mainThe a and b you have just inputed are : 1 and 23</code></pre><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><p>java就没有什么好说的了，在ACM-ICPC中java代码文件都必须是Main.java，自然类名也需要是Main了。编译命令也就是</p><pre><code>javac Main.java</code></pre><p>运行命令：</p><pre><code>java Main</code></pre><h3 id="time命令"><a href="#time命令" class="headerlink" title="time命令"></a>time命令</h3><p>time .&#x2F;main &lt; in.txt &gt; out.txt</p><h2 id="接下来讲讲ACM刷题流程吧"><a href="#接下来讲讲ACM刷题流程吧" class="headerlink" title="接下来讲讲ACM刷题流程吧"></a>接下来讲讲ACM刷题流程吧</h2><p>以杭电上 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5585">http://acm.hdu.edu.cn/showproblem.php?pid=5585</a> 为例</p><p>输入输出不需要等输入全部结束然后最后才来输出。</p><h2 id="推荐一个网站"><a href="#推荐一个网站" class="headerlink" title="推荐一个网站"></a>推荐一个网站</h2><p>很多同学的电脑上都是没有安装Linux的，下面推荐大家一个网站：<a href="https://coding.net/">https://coding.net</a></p><p>有时候如果突然想写一个题目，自己电脑或者在网吧清流的时候，又没有好的环境。而且虽然Windows上可以使用MinGW，但是有时候自己还是倾向用纯正的UNIX&#x2F;Linux环境。</p><p>在coding.net上注册账号之后，可以找到这网站的IDE功能。网址：<a href="https://ide.coding.net/">https://ide.coding.net</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态方法和方法重写</title>
      <link href="/posts/2018-04-17-static-function-and-function-rewrite.html"/>
      <url>/posts/2018-04-17-static-function-and-function-rewrite.html</url>
      
        <content type="html"><![CDATA[<p>Have you ever found yourself in a situation where you have to optimize a piece of code(code with lots of objects) ? Well, don’t worry if you haven’t encountered yet, eventually you will. This post will be about a confusing scenario of Static methods and method overriding.</p><p>Static is a keyword in Java which is helpful in memory management. It can be used with classes, variables, methods and blocks.</p><p>Static members belong to the class instead of a specific instance, this means if you make a member static, you have the option to optimize and access it without object(You can also access it with objects). Only one instance of a static field exists even if you create a million instances of the class. It will be shared by all instances in memory. On the other hand, for non-static methods, we must need to create an object of the class in order to call it. Below example will help you understand the concept better:</p><pre><code class="java">class TestA &#123;    public static int sum(int a, int b) &#123;        return a+b;    &#125;    public int foo(int a, int b) &#123;        return a+b;    &#125;&#125;class TestB extends TestA &#123;    public static int sum(int a, int b) &#123;        return a-b;    &#125;    public int foo(int a, int b) &#123;        return a-b;    &#125;&#125;public class TestRunner &#123;    public static void main(String[] args) &#123;        //Section 1        System.out.println(“Calling the static methods without object creation”);        System.out.println(TestA.sum(1,2));        System.out.println(TestB.sum(1,2));        TestB test1 = new TestB();        TestA test2 = new TestB(); // Notice the reference variable and actual reference are of different classes        TestA test3 = new TestA();        //Section 2        System.out.println(“Calling the non-static methods with object creation and method overriding”);        System.out.println(test1.foo(1,2));        System.out.println(test2.foo(1,2)); // line 1        System.out.println(test3.foo(1,2));        //Section 3        System.out.println(“Calling the static methods with object creation and method overriding”);        System.out.println(test1.sum(1,2));        System.out.println(test2.sum(1,2)); // line 2        System.out.println(test3.sum(1,2));    &#125;&#125;</code></pre><p>Output:</p><pre><code>Calling the static methods without object creation3-1Calling the non-static methods with object creation and method overriding-1-13Calling the static methods with object creation and method overriding-133</code></pre><p>Lets see what’s happening here.</p><p>test1 and test3 are objects of classes TestB and TestA respectively whereas test2 is variable of class TestA but it holds the reference of class TestB.</p><p>Section 1 : This section of code shows you how to call static methods with objects. They are directly called using the class name.</p><p>Section 2 : This section of code shows you how to call non-static methods and their behavior in the case of method overriding. If we call non static method foo() from test2 object(see comment &#x2F;&#x2F;line 1), it will be handled by actual reference i.e. TestB. This is the reason why the output here is -1</p><p>Section 3 : This section of code shows you how to call static methods without creating objects and their behavior in the case of method overriding. If we call static method sum() from test2 object(see comment &#x2F;&#x2F;line 2), it will be handled by the class of reference variable i.e. TestA. This is the reason why the output here is 3</p><p>source: <a href="https://codeburst.io/static-methods-and-method-overriding-d810f30f3c18">https://codeburst.io/static-methods-and-method-overriding-d810f30f3c18</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不是被雇来写代码的</title>
      <link href="/posts/2018-04-17-you-are-not-paid-to-write-code.html"/>
      <url>/posts/2018-04-17-you-are-not-paid-to-write-code.html</url>
      
        <content type="html"><![CDATA[<p>成为一个软件开发者不仅仅是写代码。在创业公司如雨后春笋的时代，软技能变得越来越重要了。</p><p><img src="https://raw.githubusercontent.com/ismdeep/upload/main/images/2020/08/24/44660f869af47569738a1c954c47137c-de135a.jpeg" alt="img"></p><h1 id="什么是软技能"><a href="#什么是软技能" class="headerlink" title="什么是软技能?"></a>什么是软技能?</h1><p>首先我们来说说什么是硬技能。硬技能主要就是你的职位需要的技术技能。软件开发者必须知道如何编程，这就是硬技能。</p><p>另一方面，软技能主要是与社会相关的。每项软技能都以某种方式与你工作中的硬技能相关。下面列举几点网络开发者的软技能：</p><ul><li>沟通： 对一个开发者来说，最重要的软技能就是你必须知道如何表达自己的想法，和你的团队成员进行沟通。</li><li>批判性思维： 在代码审查中，这将是你要一直保持的技能。质疑所有的东西。</li><li>适应性： 技术每天 都在变化。新的框架，新的产品，新的团队成员等。你必须不断学习新的语言和库以适应不断的变化。</li></ul><h1 id="所以，我不是被雇来写代码的？"><a href="#所以，我不是被雇来写代码的？" class="headerlink" title="所以，我不是被雇来写代码的？"></a>所以，我不是被雇来写代码的？</h1><p>当然没有。你是被雇来解决问题的。编程只是你解决问题的一个工具。</p><p>程序员的软技能正在变得越来越重要。作为一名软件开发者，我学会了我必须知道我在写什么东西，我交付的又是什么东西，我写的产品有什么价值。</p><p>你是被雇来用你的专业知识来解决业务问题。业务问题就是产品问题。该产品的责任就是提供价值，这也是你的工作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言之排序并输出</title>
      <link href="/posts/2017-10-22-sort-and-output-in-asm.html"/>
      <url>/posts/2017-10-22-sort-and-output-in-asm.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="asm">;--------------------------------------------DATA  SEGMENT    BUF  DB  10H, 25H, 32H, 13H, 43HDATA  ENDS;--------------------------------------------STACK  SEGMENT  STACK  &#39;STACK&#39;    SB  DB  100  DUP(?)STACK  ENDS;--------------------------------------------CODE  SEGMENT    ASSUME  CS:CODE, DS:DATA, SS:STACKSTART:    MOV  AX, STACK    MOV  SS, AX    MOV  AX, DATA    MOV  DS, AX    LEA  DI, BUF    MOV  BL, 5AGN:    MOV  SI, DI    MOV  CL, BLAGN2:    MOV  AL, [SI]    CMP  AL, [SI + 1]    JNC  AGN3    XCHG [SI + 1], AL    MOV  [SI], ALAGN3:    INC  SI    DEC  CL    JNZ  AGN2    DEC  BL    JNZ  AGN;-------------------------    MOV  CH, 06H    MOV  CL, 04H    MOV  AH, 02HNEXT:    MOV  DL, [DI]    ROL  DL, CL    AND  DL, 0FH    CMP  DL, 0AH    JB   STORE    ADD  DL, 07HSTORE:    ADD  DL, 30H    INT  21H;---------------    MOV  DL, [DI]    AND  DL, 0FH    CMP  DL, 0AH    JB   STORE2    ADD  DL, 07HSTORE2:    ADD  DL, 30H    INT  21H    MOV  DL, &#39; &#39;    INT  21H    INC  DI    DEC  CH    JNE  NEXT;-------------------------    MOV  AH, 4CH    INT  21HCODE  ENDS;--------------------------------------------    END  START</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux创建内存目录</title>
      <link href="/posts/2017-05-11-creating-memory-directory-in-linux.html"/>
      <url>/posts/2017-05-11-creating-memory-directory-in-linux.html</url>
      
        <content type="html"><![CDATA[<p>创建内存目录的目的在于减少不必要的磁盘操作，加速软件的启动速度。</p><p>&#x2F;etc&#x2F;fstab</p><pre><code class="bash">tmpfs /tmp tmpfs defaults,noexec,nosuid 0 0</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top 10: Windows Firewall Netsh Commands</title>
      <link href="/posts/2017-03-20-Top-10-Windows-Firewall-Netsh-Commands.html"/>
      <url>/posts/2017-03-20-Top-10-Windows-Firewall-Netsh-Commands.html</url>
      
        <content type="html"><![CDATA[<p>Configure Windows Server networking and firewall functions from the command line Everyone has probably heard that <a href="http://windowsitpro.com/windows-server-2012">Windows Server 2012</a> will add around 2,300 new <a href="http://windowsitpro.com/article/windows-powershell/introducing-windows-powershell">Windows PowerShell</a> commands. Today, however, PowerShell still works with just a subset of the Windows Server management functions. One area that it doesn’t directly touch is the ability to configure Windows Server networking and firewall functions, for which you need to use the venerable netsh commands. Even with the advent of PowerShell, netsh has continued to evolve, and it’s particularly useful for configuring Windows Server Core.</p><p><strong>Related:</strong> <a href="http://windowsitpro.com/article/dhcp2/network-configuration-tasks-with-netsh-103027">Network Configuration Tasks with Netsh</a></p><p>In this column, I’ll show you 10 <a href="http://windowsitpro.com/article/task-scheduling/netsh-tricks-50425">handy netsh commands</a> you can use to query and configure your Windows Firewall settings. It’s worth noting that you can call these netsh commands from within your PowerShell scripts.</p><p><strong>10. Query firewall rules:</strong> One of the first things you’ll probably need to use netsh for is to discover Windows Firewall’s current configuration properties. You can query Windows Firewall settings using the following netsh command:</p><pre><code class="bash">netsh advfirewall firewall show rule name=all</code></pre><p><strong>9. Enable and disable Windows Firewall:</strong> It’s typically a best practice to leave Windows Firewall enabled, but sometimes when you’re performing testing or setting up new applications, you need to turn Windows Firewall off for a period. The following commands illustrate how to turn Windows Firewall off and then back on:</p><pre><code class="bash">netsh advfirewall set allprofiles state onnetsh advfirewall set allprofiles state off</code></pre><p><strong>8. Reset Windows Firewall:</strong> If you make a mistake configuring Windows Firewall, you might want to use the following netsh command to reset it back to its default settings:</p><pre><code class="bash">netsh advfirewall reset</code></pre><p><strong>7. Set logging:</strong> The default path for the Windows Firewall log files is \Windows\system32\LogFiles\Firewall\pfirewall.log. The netsh command below changes the location of the log file to the C:\temp directory:</p><pre><code class="bash">netsh advfirewall set currentprofile logging filename &quot;C:\temp\pfirewall.log&quot;</code></pre><p><strong>6. Allow and prevent ping:</strong> You can use netsh to control how and if a given system responds to ping requests. The following two netsh commands show how you can block and then open Windows Firewall to ping requests:</p><pre><code class="bash">netsh advfirewall firewall add rule name=&quot;All ICMP V4&quot; dir=in action=block protocol=icmpv4netsh advfirewall firewall add rule name=&quot;All ICMP V4&quot; dir=in action=allow protocol=icmpv4</code></pre><p><strong>5. Enable and delete a port:</strong> One of the most common things you need to do with Windows Firewall is open ports that are used by different programs. The following examples show how to use netsh to create a rule to open and then close port 1433, which is used by Microsoft SQL Server:</p><pre><code class="bash">netsh advfirewall firewall add rule name=&quot;Open SQL Server Port 1433&quot; dir=in action=allow protocol=TCP localport=1433netsh advfirewall firewall delete rule name=&quot;Open SQL Server Port 1433&quot; protocol=tcp localport=1433</code></pre><p><strong>4. Enable a program:</strong> Another common task is opening Windows Firewall for a given program. The following example illustrates how to add a rule that enables <a href="http://windowsitpro.com/article/tips/windows-live-messenger-is-the-next-generation-of-msn-messenger-">Windows Live Messenger</a> to work through Windows Firewall:</p><pre><code class="bash">netsh advfirewall firewall add rule name=&quot;Allow Messenger&quot; dir=in action=allow program=&quot;C:\programfiles\messenger\msnmsgr.exe&quot;</code></pre><p><strong>3. Enable remote management:</strong> Another common requirement, especially when you’re setting up new systems, is to enable remote management so that tools such as the Microsoft Management Console can connect to remote systems. To open Windows Firewall for remote management, you can use the following command:</p><pre><code class="bash">netsh advfirewall firewall set rule group=&quot;remote administration&quot; new enable=yes</code></pre><p><strong>2. Enable Remote Desktop Connection:</strong> One of the first things I do with most of the server systems I set up is enable Remote Desktop Connection for easy remote systems management. The following command shows how to use netsh to open Windows Firewall for Remote Desktop Connections:</p><pre><code class="bash">netsh advfirewall firewall set rule group=&quot;remote desktop&quot; new enable=Yes</code></pre><p><strong>1. Export and import firewall settings:</strong> After you get Windows Firewall configured, it’s a good idea to export your settings so that you can easily reapply them later or import them into another system. In the following netsh commands, you can see how to export and then import your Windows Firewall configuration:</p><pre><code class="bash">netsh advfirewall export &quot;C:\temp\WFconfiguration.wfw&quot;netsh advfirewall import &quot;C:\temp\WFconfiguration.wfw&quot;</code></pre><p><strong>Learn more:</strong> <a href="http://windowsitpro.com/article/tips/jsi-tip-7908-netsh-command-syntax-for-the-netsh-firewall-context--80601">Netsh Command Syntax for the Netsh Firewall Context</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>enable/disable Windows firewall rules</title>
      <link href="/posts/2017-03-20-enable-disable-Windows-firewall-rules.html"/>
      <url>/posts/2017-03-20-enable-disable-Windows-firewall-rules.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p>enable firewall rule:</p><pre><code class="bash">run, netsh advfirewall firewall set rule name=&quot;NameOfFirewallRule&quot; new enable=yes</code></pre><p>disable firewall rule:</p><pre><code class="bash">run, netsh advfirewall firewall set rule name=&quot;NameOfFirewallRule&quot; new enable=no</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git设置代理</title>
      <link href="/posts/2017-02-08-setting-git-proxy.html"/>
      <url>/posts/2017-02-08-setting-git-proxy.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p>修改~&#x2F;.gitconfig文件<br>增加如下代码：</p><pre><code class="bash">[http]    proxy = socks5://127.0.0.1:1080</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 FreeBSD 10.1中安装 Mate 桌面</title>
      <link href="/posts/2017-01-08-install-mate-desktop-on-freebsd-10-1.html"/>
      <url>/posts/2017-01-08-install-mate-desktop-on-freebsd-10-1.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><p>编译自：<a href="http://www.unixmen.com/install-mate-desktop-freebsd-10-1/">http://www.unixmen.com/install-mate-desktop-freebsd-10-1/</a><br>作者： M.el Khamlichi    <br>原创：<a href="http://lctt.github.io/">LCTT</a> <a href="https://linux.cn/article-5385-1.html">https://linux.cn/article-5385-1.html</a><br>译者： geekpi    <br>本文地址：<a href="https://linux.cn/article-5385-1.html">https://linux.cn/article-5385-1.html</a></p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201505/04/220515m790kl2qp910o5ol.jpg"></p><p>FreeBSD是全文本模式的系统，然而有些新用户想要使用GUI桌面环境。这个教程就是帮助你在Freebsd 10.1中安装Mate桌面。</p><p>下面是我的系统细节：</p><pre><code class="bash">root@Freebsd-unixmen:~ \# uname -aFreeBSD Freebsd-unixmen 10.1-RELEASE FreeBSD 10.1-RELEASE \#0 r274401: Tue Nov 11 21:02:49 UTC 2014     root@releng1.nyi.freebsd.org:/usr/obj/usr/src/sys/GENERIC  amd64root@Freebsd-unixmen:~</code></pre><p>要在FreeBSD 10.1 中开始安装Mate桌面，按照下面的步骤。</p><pre><code class="bash">pkg install xf86-video-fbdev mate-desktop mate xorg</code></pre><h3 id="0x01-在-etc-rc-conf-中加入下面的行"><a href="#0x01-在-etc-rc-conf-中加入下面的行" class="headerlink" title="0x01 在 &#x2F;etc&#x2F;rc.conf 中加入下面的行"></a>0x01 在 &#x2F;etc&#x2F;rc.conf 中加入下面的行</h3><pre><code class="bash">moused_enable=&quot;YES&quot;dbus_enable=&quot;YES&quot;hald_enable=&quot;YES&quot;</code></pre><h3 id="0x02-测试安装"><a href="#0x02-测试安装" class="headerlink" title="0x02 测试安装"></a>0x02 测试安装</h3><pre><code class="bash">xinit mate-session</code></pre><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201505/04/220538dby0rtzzfx0yyegt.png"></p><p>Mate本身没有显示管理器。因此我们会使用其他的显示管理器如XDM、GDM、slim等等来作为登录管理器。这里让我们看看如何在Mate桌面中配置Slim DM</p><h3 id="0x03-安装-Slim"><a href="#0x03-安装-Slim" class="headerlink" title="0x03 安装 Slim"></a>0x03 安装 Slim</h3><pre><code class="bash">pkg install slim</code></pre><p>在**&#x2F;etc&#x2F;rc.conf**中加入下面的行：</p><pre><code class="bash">slim_enable=&quot;YES&quot;</code></pre><p>在用户的家目录下的.xinitrc文件加入下面的行。</p><pre><code class="bash">exec mate-session</code></pre><p>重启电脑。现在在你登录Mate时就会进入Slim登录界面了。</p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201505/04/220639iw1woom3jhpgz3dd.png"></p><p><img src="https://dn-linuxcn.qbox.me/data/attachment/album/201505/04/220655e2fg9p3z3iuimzu7.png"></p><p>就是这样。干杯！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> FreeBSD </tag>
            
            <tag> UNIX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让Ubuntu显示开关机详情</title>
      <link href="/posts/2016-12-29-show-detail-while-booting-and-shutting-down-on-ubuntu.html"/>
      <url>/posts/2016-12-29-show-detail-while-booting-and-shutting-down-on-ubuntu.html</url>
      
        <content type="html"><![CDATA[<p>修改   &#x2F;etc&#x2F;default&#x2F;grub</p><p>把GRUB_CMDLINE_LINUX_DEFAULT后面的quiet splash参数删除掉.当然你也可以注销掉这一行.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能的豆神(题解)</title>
      <link href="/posts/2016-12-18-wan-neng-de-dou-shen.html"/>
      <url>/posts/2016-12-18-wan-neng-de-dou-shen.html</url>
      
        <content type="html"><![CDATA[<p>在每次放进去的时候直接和前一个进行比较，然后拿最小值作为放进去的即可。比如放进去的是5 4 6 3，那么从杯底到杯口的数值应该是5 4 4 3，以后每一次删除就只要删除一个即可。</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int a[3000000];int flag_ = -1;int main ()&#123;    int n, value;    cin &gt;&gt; n;    char ch;    while (n--)&#123;        cin &gt;&gt; ch;        if (&#39;+&#39; == ch)&#123;            cin &gt;&gt; value;            flag_++;            if (0 == flag_)&#123;                a[flag_] = value;            &#125;else&#123;                a[flag_] = min(a[flag_-1], value);            &#125;            cout &lt;&lt; a[flag_] &lt;&lt; endl;        &#125;else&#123;            if (flag_ &gt;= 0)&#123;                flag_--;            &#125;            if (flag_ &gt;= 0)&#123;                cout &lt;&lt; a[flag_] &lt;&lt; endl;            &#125;else&#123;                cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python初学者（零基础学习Python、Python入门）书籍、视频、资料、社区推荐</title>
      <link href="/posts/2016-11-20-python-beginners-books-videos-materials-recommened.html"/>
      <url>/posts/2016-11-20-python-beginners-books-videos-materials-recommened.html</url>
      
        <content type="html"><![CDATA[<p>本文 <strong>主要</strong> 针对 <strong>零基础</strong> 想学习Python者。本文本文由@史江歌（<a href="mailto:&#x73;&#x68;&#x69;&#x6a;&#105;&#x61;&#x6e;&#x67;&#x67;&#101;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x73;&#x68;&#x69;&#x6a;&#105;&#x61;&#x6e;&#x67;&#x67;&#101;&#x40;&#103;&#109;&#x61;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;</a>  QQ:499065469）根据互联网资料收集整理而成，感谢互联网，感谢各位的分享。鸣谢！本文会不断更新。</p><h2 id="一、学会使用搜索引擎，尤其是Google。推荐阅读文章"><a href="#一、学会使用搜索引擎，尤其是Google。推荐阅读文章" class="headerlink" title="一、学会使用搜索引擎，尤其是Google。推荐阅读文章"></a>一、学会使用搜索引擎，尤其是Google。推荐阅读文章</h2><p>  <a href="http://www.zhihu.com/question/20161362">《如何用好Google搜索引擎？》</a> 知乎问答@崔凯  </p><p>  <a href="http://www.williamlong.info/archives/728.html">《十大高明的Google搜索技巧》</a>by-雪影蓝风  </p><p>  <a href="http://wordpress.lixiaolai.com/archives/992.html">《如何用好Google》</a> by-李笑来    </p><h2 id="二、学会提问"><a href="#二、学会提问" class="headerlink" title="二、学会提问"></a>二、学会提问</h2><p>推荐阅读 <a href="http://wiki.woodpecker.org.cn/moin/AskForHelp">《提问的智慧》</a> by-啄木鸟社区</p><p><a href="https://gist.github.com/zer4tul/95ffaa741c836dc6ab3b">《提问的智慧》</a> 务必请读完！</p><h2 id="三、书籍推荐"><a href="#三、书籍推荐" class="headerlink" title="三、书籍推荐"></a>三、书籍推荐</h2><h3 id="零基础"><a href="#零基础" class="headerlink" title="零基础"></a>零基础</h3><ol start="0"><li><p>Python官方文档 <a href="http://docs.python.org/2/tutorial/index.html">点击打开链接</a> 英语不好的，暂时就先别看了，以后一定肯定要加强英语学习哦;)。</p></li><li><p>推荐<a href="http://www.greenteapress.com/thinkpython/thinkCSpy.pdf">《How to think like a computer scientist》</a>，对应中文版本《Python学习笔记–皮大庆》，非常适合零基础入门。</p></li><li><p>推荐 [《Python编程实践》] (<a href="http://book.douban.com/subject/7059900/">http://book.douban.com/subject/7059900/</a>)</p></li><li><p>推荐 <a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/">《简明Python教程》</a></p></li><li><p>推荐<a href="http://learn-python-the-hard-way-zh_cn-translation.readthedocs.org/en/1.0/">《笨办法学 Python （Learn Python The Hard Way）》</a></p></li></ol><h3 id="有其他编程语言基础"><a href="#有其他编程语言基础" class="headerlink" title="有其他编程语言基础"></a>有其他编程语言基础</h3><ol start="0"><li><p>推荐<a href="http://book.douban.com/subject/4866934/">《Python基础教程》</a></p></li><li><p>推荐<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">Python入门教程-By廖雪峰</a></p></li></ol><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ol start="0"><li><p>推荐<a href="https://github.com/wangshunping/read_requests">Requests 源码阅读</a></p></li><li><p><a href="https://github.com/eastlakeside/interpy-zh">《Python进阶》（Intermediate Python 中文版）</a></p></li></ol><h3 id="更多书籍推荐"><a href="#更多书籍推荐" class="headerlink" title="更多书籍推荐"></a>更多书籍推荐</h3><ol start="0"><li><p><strong>知乎问答</strong>：<a href="http://www.zhihu.com/question/19593179">关于 Python 的经典入门书籍有哪些？</a></p></li><li><p><strong>V2EX问答</strong>： <a href="http://www.v2ex.com/t/40397">文科生想学Python</a></p></li><li><p><a href="http://www.cnblogs.com/vamei/archive/2012/09/13/2682778.html">Python快速教程</a></p></li></ol><h2 id="四、视频推荐"><a href="#四、视频推荐" class="headerlink" title="四、视频推荐"></a>四、视频推荐</h2><p>麻省理工公开课《计算机科学及编程导论》，该课程针对零基础者 <a href="http://v.163.com/special/opencourse/bianchengdaolun.html">网易公开课</a> 。  </p><p>课程介绍<br>这门课程适用于那些拥有 <strong>很少或没有编程经验</strong>  的学生,它致力于使学生理解计算机在解决问题中的作用,并且帮助学生，  <strong>不论其专业</strong>，使他们对于能够完成有用的小程序的目标充满信心。</p><h2 id="五、学习方法"><a href="#五、学习方法" class="headerlink" title="五、学习方法"></a>五、学习方法</h2><h3 id="知乎问答：零基础，应当如何开始学习-Python-？-by-黎敏"><a href="#知乎问答：零基础，应当如何开始学习-Python-？-by-黎敏" class="headerlink" title="知乎问答：零基础，应当如何开始学习 Python ？--by@黎敏"></a><em>知乎问答</em>：<a href="http://www.zhihu.com/question/20039623?nr=1">零基础，应当如何开始学习 Python ？</a>--by@黎敏</h3><p>虽然我不是Python高手，但我是零基础，之前会的都是软件PS，PPT之类。</p><p>如果目的是想成为程序员，参考教学大纲。</p><p>如果只是学程序，理解科技，解决工作问题，我的方式可以参考使用：</p><ol><li><p>找到合适的入门书籍，大致读一次，循环啊判断啊，常用类啊，搞懂（太难的跳过）</p></li><li><p>做些简单习题，字符串比较，读取日期之类<br>《Python Cookbook》不错（太难太无趣的，再次跳过，保持兴趣是最重要的，不会的以后可以再学）</p></li><li><p>加入Python讨论群，态度友好笑眯眯（很重要，这样高手才会耐心纠正你错误常识）。<br>   很多小问题，纠结许久，对方一句话点播思路，真的节约你很多时间。耐心指教我的好人，超级超级多谢。</p></li><li><p>解决自己电脑问题。<br>   比如下载美剧，零散下载了2，4，5，8集，而美剧共12集，怎样找出漏下的那几集？然后问题分解，1读取全部下载文件名，2提取集的数字，3数字排序和（1–12）对比，找出漏下的。</p></li><li><p>时刻记住目的，不是为了当程序员，是为了解决问题。</p></li></ol><p>  比如，想偷懒抓网页内容，用urllib不行，用request也不行，才发现抓取内容涉及那么多方面（cookie，header，SSL，url，javascript等等），当然可以听人家劝，回去好好读书，从头读。</p><p>  或者，不求效率，只求解决，用ie打开网页再另存为行不行？ie已经渲染过全部结果了。</p><p>  问题变成：1–打开指定的10个网页（一行代码就行）。更复杂的想保存呢？利用已经存在的包，比如PAM30（我的是Python3），直接打开ie，用函数outHTML另存为文本，再用搜索函数（str搜索也行，re正则也行） 找到数据。简单吧？而且代码超级短。</p><ol start="6"><li><p>保持兴趣，用最简单的方式解决问题，什么底层驱动，各种交换，留给大牛去写吧。我们利用已经有的包完成。</p></li><li><p>耐心读文档，并且练习快速读文档。拿到新包，找到自己所需要的函数，是需要快速读一次的。这个不难，读函数名，大概能猜到是干嘛的，然后看看返回值，能判断是不是自己需要的。</p></li><li><p>写帮助文件和学习笔记，并发布共享。教别人的时候，其实你已经自己再次思考一次了。</p></li></ol><p>  我觉得学程序就像学英文，把高频率的词（循环，判断，常用包，常用函数）搞懂，就能拼装成自己想要的软件。</p><p>  然后，<a href="http://stackoverflow.com/">http://stackoverflow.com</a> 和 <a href="http://google.com/">http://Google.com</a> 是很好用的。</p><p>  然后，坚持下去。</p><p>  一定要保持兴趣，太复杂的跳过，就像小学数学，小学英语，都是由简入深。</p><p>  网络很平面，无数国际大牛著作好书，关于Python，算法，电脑，网络，或者程序员思路，或者商业思维（浪潮之巅是本好书）等等，还有国际名校的网络公开课（中英文字幕翻译完毕，观看不是难事），讲计算机，网络，安全，或者安卓系统，什么都有，只要能持续保持兴趣，一点点学习下去，不是难事。</p><p>  所有天才程序员，都曾是儿童，回到儿童思维来理解和学习。觉得什么有趣，先学，不懂的，先放着，遇到问题再来学，效果更好。</p><p>  唯一建议是，不要太贪心，耐心学好一门优雅的语言，再学其它。虽然Javascript做特效很炫，或提某问题时，有大牛建议，用Ruby来写更好之类，不要改方向。就像老笑话：“要学习递归，必须首先理解递归。”然后死循环一直下去。坚持学好一门语言，再研究其他。</p><p>  即使一门语言，跟网络，数据库等等相关的部分，若都能学好，再学其他语言，是很快的事情。</p><p>  另外就是，用学英文的耐心来学计算机，英文遇到不懂的词，抄下，查询。</p><p>  python里，看到Http，查查定义，看到outHtml，查查定义，跟初学英语时候一样，不要直接猜意思，因为精确描述性定义，跟含糊自然语有区别的。而新人瞎猜，很容易错误理解，wiki，google很有用。</p><h3 id="芝麻问答：如何学习Python-点击打开链接作者：-halida"><a href="#芝麻问答：如何学习Python-点击打开链接作者：-halida" class="headerlink" title="芝麻问答：如何学习Python 点击打开链接作者：@halida"></a><em>芝麻问答</em>：如何学习Python <a href="http://www.zhimaq.com/questions/70/python">点击打开链接</a>作者：@halida</h3><h4 id="如何学习python"><a href="#如何学习python" class="headerlink" title="如何学习python"></a>如何学习python</h4><p>我们假设你是一个初级程序员, 只懂得一点点的基础知识, 希望能够用python来做开发. 这篇文档就是为了满足以上目标而写的.</p><p><strong>大纲</strong> </p><p>按照这篇文档所指示的任务过一遍, 你就能够做到:</p><p>熟悉python语言, 以及学会python的编码方式. 熟悉python库, 遇到开发任务的时候知道如何去找对应的模块. 知道如何查找和获取第三方的python库, 以应付开发任务. 学习步骤</p><p><strong>安装开发环境</strong></p><p>如果你在window下, 去下载pythonxy安装起来, 然后运行python, 进入python解释环境.</p><p>如果你在ubuntu下, 执行: sudo apt-get install python, 然后在命令行下运行python, 进入python解释环境.</p><p><strong>学习方法</strong></p><p>作为一名成熟的开发人员, 我学习新东西(假设是pyqt)的习惯方式是:</p><p>直接用google搜索pyqt的官方网站. 按照官方网站的说明, 下载pyqt. (如果是用ubuntu, 看看软件库里面是否有足够新的版本) 下载过程中, 开始阅读官方网站上面的教程. 一边看教程, 一遍按照教程使用pyqt. 如果发现教程不够全面, 用google搜索是否有对应的教学书籍可以看. 示例学习完毕, 开发一个玩具程序, 用来检验自己是否需要用到的功能. 开始学习python</p><p>我建议你学习的过程也按照上面来, 首先过一遍python官方文档:</p><p><a href="http://docs.python.org/tutorial/index.html">http://docs.python.org/tutorial/index.html</a></p><p>然后做 <a href="http://www.pythonchallenge.com/">http://www.pythonchallenge.com/</a> 这个网站上面的题目.</p><p>如果卡在某一关太久, 可以看答案(google python challenge answer), 做完后看看别人的编码方式和自己有什么区别.</p><p><strong>小项目</strong></p><p>做完一遍后, 你会发现已经熟悉了基本的python开发. 然后做点小项目吧. 这里是一些题目, 挑感兴趣的去做.</p><ul><li>写一个简单的计算器&#x2F;记账软件&#x2F;扫雷游戏(用pyqt库做界面)</li><li>写一个聊天室网站(用webpy框架, jquery刷新新的回复)</li><li>写一个爬虫, 获取douban上面所有用户的地点, 画地点分布的直方图(用lxml解析, 保存数据到sqlite里面去, 用matplotlib画图)</li></ul><p><strong>FAQ</strong></p><p>Q: 遇到了问题, 到哪里求助?</p><p>A: 上 <a href="http://groups.google.com/group/python-cn">http://groups.google.com/group/python-cn</a> (需要翻墙) 或者 <a href="http://stackoverflow.com/">http://stackoverflow.com</a> 提问就可以了.</p><p>Q: 如何查找python的某个功能?</p><p>A: 看官方文档. <a href="http://docs.python.org/library/index.html">http://docs.python.org/library/index.html</a></p><p>Q: 如何用python完成一个任务(比如写网站)?</p><p>A: google: python 写网站, 或者 google: python web development.</p><h3 id="知乎问答：你是如何自学-Python-的？点击打开链接-作者-成增存"><a href="#知乎问答：你是如何自学-Python-的？点击打开链接-作者-成增存" class="headerlink" title="知乎问答：你是如何自学 Python 的？点击打开链接  作者:@成增存"></a><em>知乎问答</em>：你是如何自学 Python 的？<a href="http://www.zhihu.com/question/20702054">点击打开链接</a>  作者:@成增存</h3><p><strong>阶段一</strong>：前辈领进门。<br>第一眼是一个前辈给我看了看Python的代码，因为自己最早学习的是Java语言，第一眼看到Python的时候，前辈说，“Python是面向对象的”，然后就 打印了几句代码。可我怎么也看不出到底哪里是“面向对象”的。前辈说“在Python里，一切皆对象”，我才有点领悟的说道：“原来把什么看成对象，就是面向对象”，哈哈。</p><p><strong>阶段二</strong>：开始看的是《Dive into Python》、《Leaning python》、《Python Doc》。<br>因为有很多语言学习经历，很快就完成了初步语法和使用学习。太复杂的特性还是在使用中逐步掌握的。</p><p><strong>阶段三</strong>：开始使用Python做自己的一些日常工作。<br>比如Python搜索文件，Python批量处理等，使用最多的还是re模块和socket相关模块。写了大量的例子，让自己对Python更加喜爱，也更加熟悉。此时翻阅最多的是《Python Doc》的指南。不管是语言参考、库参考、Demo参考，都有大量可使用的内容，内容质量很高堪比JDK。</p><p><strong>阶段四</strong>：生产上马。<br>开始使用Django，Flask，Tornado开发一些web应用，写一些日常使用的工具包等。逐步提升设计能力，和整体代码的管理能力。</p><p><strong>阶段五</strong>：更合理的分配好C，Java，Python三门语言各自擅长的部分。<br>把合适的语言用到合适的地方。尽管一门语言有时候可以搞定所有的，但用擅长的语言解决合适的问题才是效率最高的。这也是“Python的大道至简”的理念带给我的帮助和认识。</p><p>PS：其中过程中主要的一些 <strong>方法</strong> :  </p><ol><li><p>看书。学习的基础。</p></li><li><p>自己本地练习。编程还是要实践出真知。</br>  </p></li><li><p>资料查询。google，stackoverflow等多关注。</br>  </p></li><li><p>交流。各种论坛上的python group，论坛。最早去的CU，JavaEye，不过现在貌似去的少了。<strong>google group</strong> 必须订阅。</br>  </p><p>学习+实践+总结，掌握语言的法宝。</p></li></ol><h2 id="六、Just-Do-It"><a href="#六、Just-Do-It" class="headerlink" title="六、Just Do It"></a>六、Just Do It</h2><p>看了这么多资料了，还没动手敲代码？</p><p>好吧，最好一篇文章《我在学习编程中犯的两个 <strong>最大错误</strong> 》<a href="http://blog.jobbole.com/26552/">点击打开链接</a></p><p>Just do it 。动手敲代码吧。</p><p>注：本文由@史江歌（<a href="mailto:&#115;&#104;&#105;&#x6a;&#x69;&#97;&#x6e;&#103;&#103;&#x65;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#115;&#104;&#105;&#x6a;&#x69;&#97;&#x6e;&#103;&#103;&#x65;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#x6d;</a>）根据互联网资料收集整理而成。</p><h2 id="七、更新"><a href="#七、更新" class="headerlink" title="七、更新"></a>七、更新</h2><p> <a href="http://simple-is-better.com/sites/">Python技术博客、招聘、开源软件、Python中文网站导航</a></p><p> <a href="http://blog.csdn.net/xiaowanggedege/article/details/8753013">遇到python问题怎么样解决？python help dir stackoverflow docs google</a></p><p> <a href="http://www.codecademy.com/zh/tracks/python">在线视频教学(英文)codecademy</a></p><p> <a href="http://www.pythonforbeginners.com/">英文Python for beginners</a></p><p>英文How do I learn Python from zero to web development?（各种电子书推荐）<a href="http://programmers.stackexchange.com/questions/12189/how-do-i-learn-python-from-zero-to-web-development">点击打开链接</a></p><p><a href="http://www.cnblogs.com/skynet/archive/2013/05/06/3063245.html">Python应用与实践</a> Python是什么？谁在用它？相关工具？作者：@吴秦</p><p><a href="http://blog.csdn.net/JGood/article/category/554799/4">Python模块学习</a> 相当于翻译官网文档</p><p>针对有其他语言经验的人，英文：<a href="http://learnxinyminutes.com/docs/python/">Learn X in Y minutes</a> 中文翻译<a href="http://youngsterxyf.github.io/2013/06/29/learn-python-in-y-minutes/">Y分钟学会Python（译）</a></p><p><a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html">PyCoder’s Weekly 中文翻译</a> 说明：文章质量很高</p><p><a href="http://artifex.org/~hblanks/talks/2011/pep20_by_example.html">PEP 20 (Python之禅) 的实例</a>  说明：code_stype</p><p><a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue5/unipain.html">Unicode之痛</a> 必读</p><p><a href="http://v2ex.com/t/163786#reply12">有关 Python 2 和 Sublime Text 中文 Unicode 编码问题的分析与理解</a> 必读</p><p><a href="https://github.com/wklken/stackoverflow-py-top-qa">stackoverflow上Python相关回答整理翻译</a></p><p><a href="http://www.crifan.com/files/doc/docbook/python_summary/release/html/python_summary.html">Python语言总结-初级中级高级教程</a> 作者：@Crifan Li</p><p><a href="http://docs.python-guide.org/en/latest/?utm_campaign=Manong_Weekly_Issue_10&utm_medium=EDM&utm_source=Manong_Weekly">Python Guide Python 最佳实践</a> 英文</p><h2 id="《码农周刊》干货精选（Python-篇）-精选总结八、爬虫以及模拟登陆新浪微博"><a href="#《码农周刊》干货精选（Python-篇）-精选总结八、爬虫以及模拟登陆新浪微博" class="headerlink" title="《码农周刊》干货精选（Python 篇） 精选总结八、爬虫以及模拟登陆新浪微博"></a><a href="http://baoz.me/446252">《码农周刊》干货精选（Python 篇）</a> 精选总结<br>八、爬虫以及模拟登陆新浪微博</h2><p><a href="http://www.zhihu.com/question/20899988">知乎：Python 爬虫如何入门学习</a></p><p><a href="http://cuiqingcai.com/1052.html">Python爬虫学习系列教程 @崔庆才</a>系列教程，入门、实战、爬虫利器介绍、进阶</p><p><a href="http://yoyzhou.github.io/blog/2013/03/18/sina-weibo-login-simulator-in-python/">Python模拟登录新浪微薄（使用RSA加密方式和Cookies文件）</a></p><p><a href="http://uliweb.clkg.org/tutorial/view_chapter/240">http://uliweb.clkg.org/tutorial/view_chapter&#x2F;240</a></p><p><a href="http://qinxuye.me/article/a-distributed-weibo-crawler/">一个简单的分布式新浪微博爬虫</a></p><p><a href="http://obmem.info/?p=476">用python爬虫抓站的一些技巧总结</a></p><p><a href="http://obmem.info/?p=753">使用python爬虫抓站的一些技巧总结：进阶篇</a></p><p><a href="http://blog.csdn.net/pleasecallmewhy/article/details/8922826">网络爬虫系列</a></p><h2 id="九、工具"><a href="#九、工具" class="headerlink" title="九、工具"></a>九、工具</h2><p>Windows系统下，Python相关包<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">Windows Binaries for Python Extension Packages</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有了这个列表，程序员不愁没练手的小项目了</title>
      <link href="/posts/2016-11-04-programmers-trainning-projects.html"/>
      <url>/posts/2016-11-04-programmers-trainning-projects.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><h3 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h3><p>这个列表原本首发在伯乐在线的一篇译文：<a href="http://blog.jobbole.com/49762/">http://blog.jobbole.com/49762/</a>。2016年9月21日，该文章推送到微信公众号 程序员的那些事 （ID: iProgrammer ) 后，<a href="https://github.com/BleethNie">@BleethNie</a> 留言建议把这 120+ 练手小项目统一放在一个地方，同时其他人可以把自己完成项目提交合并到一起，相互参考学习。于是我们在 GitHub 创建了这个项目。后续会以超链的形式合并大家提交的成果到这个列表。欢迎 fork &amp; star，并扩散给更多人。</p><p>下面列出 120 多个项目构思，根据主题分成了 10 个分类。</p><h3 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h3><ul><li>逆转字符串——输入一个字符串，将其逆转并输出。</li><li>拉丁猪文字游戏——这是一个英语语言游戏。基本规则是将一个英语单词的第一个辅音音素的字母移动到词尾并且加上后缀-ay（譬如“banana”会变成“anana-bay”）。可以在维基百科上了解更多内容。</li><li>统计元音字母——输入一个字符串，统计处其中元音字母的数量。更复杂点的话统计出每个元音字母的数量。</li><li>判断是否为回文——判断用户输入的字符串是否为回文。回文是指正反拼写形式都是一样的词，譬如“racecar”。</li><li>统计字符串中的单词数目——统计字符串中单词的数目，更复杂的话从一个文本中读出字符串并生成单词数目统计结果。</li><li>文本编辑器——记事本类型的应用，可以打开、编辑、保存文本文档。可以增加单词高亮和其它的一些特性。</li><li>RSS源创建器——可以从其它来源读取文本并将其以RSS或者Atom的格式发布出去。</li><li>实时股价——可以查询股票当前价格。用户可以设定数据刷新频率，程序会用绿色和红色的箭头表示股价走势。</li><li>访客留言簿&#x2F;日志——允许人们添加评论或者日记，可以设置开启&#x2F;关闭评论，并且可以记录下每一条目的时间。也可以做成喊话器。</li><li>新闻和比分播报器——一个桌面应用，可以从网上收集新闻和比赛分数，将结果在屏幕上滚动播出。</li><li>占星罗盘——用占星术来预测每天的运程。</li><li>密码短信——可以将数据加密解密，并能将其发送给朋友。</li><li>帮你挑礼物——输入一堆你可能会送的礼物，当有人过生日时，该程序会随机选择一样礼物。也可以加上一个额外功能，可以告知哪里可以弄到这个礼物。</li><li>HTML生成器——将 TEXT 文档转换成HTML文件，对制作网页HTML文档很有用。</li><li>CD-Key生成器——利用某种算法生成一个唯一的key。软件开发者可以用它来作为软件的激活器。</li><li>正则表达式查询工具——用户可以输入一段文本，在另外的控件里输入一个正则表达式。运行以后会返回匹配的内容或者正则表达式中的错误。</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>FTP工具——与远程网络服务器交互文件。</li><li>原子钟校时——从网上同步原子钟时间。全世界有很多原子钟，可以把它们都列出来。</li><li>聊天应用（IRC或者MSN风格的）——像IRC那样的聊天室软件或者MSN那样的实时聊天软件。更复杂一点的话，可以为聊天制定一套你自己的传输协议。</li><li>获取当前天气——获取某个地区当前的天气情况。</li><li>P2P文件共享应用——像LimeWire、FrostWire、Bearshare或者torrent风格的应用。</li><li>端口扫描器——输入某个ip地址和端口区间，程序会逐个尝试区间内的端口，如果能成功连接的话就将该端口标记为open。</li><li>邮件检查工具（POP3&#x2F;IMAP）——用户输入一些账号信息，包括服务器、ip、协议类型（POP3或者IMAP），应用每隔一段时间就会检查下该账号下的邮箱。</li><li>数据包嗅探器——侦测电脑上进出的数据包，获取诸如目的地和大小之类的信息。</li><li>IP注册地查询——输入ip地址，查询该ip是在哪注册的。</li><li>Whois查询工具——输入一个ip或者主机地址，通过whois查询并将结果返回。</li><li>邮编查询——输入邮编，返回使用该邮编的地区名称。</li><li>远程登入——远程登入桌面类型的应用，可以查看和控制远程电脑（假如你已经获得权限）。可能需要你自己的网络和两台电脑来进行测试。</li><li>网站定时检查器——每隔一段时间或者在预定的时间尝试连接某个网站或者服务器，来检查它是否可以连上，如果连不上了会通过邮件或者桌面通知来告知你。</li><li>小型网页服务器——简易版的网页服务器，可以存放包含Javascript和其它形式代码的HTML文件。复杂一点的话可以尝试流媒体视频、创建一种服务器端语言或者其它类型的流媒体。</li><li>网络蜘蛛——一个可以自动执行网页上各种任务的程序，任务包括网站检查、页面抓取、数据摘要以及网络邮务。</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>产品库存管理——创建一个管理产品库存的应用。建立一个产品类，包含价格、id、库存数量。然后建立一个库存类，记录各种产品并能计算库存的总价值。</li><li>电影商店——管理录像带租借，记录借出时间、到期时间、逾期费用。复杂一点可以生成逾期用户的账号报告。</li><li>航空&#x2F;酒店预订系统——创建一套预订航班或酒店的预订系统。不同的航班座位和酒店房间收费不一样。譬如头等舱要比经济舱贵。带阁楼的套间要更贵些。记录下何时有空房可供预订。</li><li>学生成绩管理器——记录一个班级的学生（创建一个Student类，记录他们的名字、平均分和考试分数）和他们的成绩等级。根据学生的测验和作业的分数计算出平均分和成绩等级。复杂一点可以将数据画在贝尔曲线上。</li><li>银行账户管家——创建一个名为“Account”的抽象类，有三个为“CheckingAccount”、“SavingsAccount”和“BusinessAccount”的子类。通过类似ATM的程序来管理这些账户的借贷。</li><li>馆藏目录——创建一个图书类，记录书名、页数、国际标准书号、是否借出。用它来管理各种书籍，允许用户进行借出和归还操作。复杂一点的话，可以生成逾期图书和逾期费用的报告。也可以让用户进行预约操作。</li></ul><h3 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h3><ul><li>下载进度条——创建一个表示下载进度的进度条。进度条由独立的线程操作，通过委托来和主线程进行通讯。</li><li>下载管理器——允许程序同时下载数个文件，每个都用单独的线程进行背景下载。主线程会关注下载进度并且在下载完成时通知用户。</li><li>聊天软件（远程聊天）——做一个聊天软件，允许你通过ip直接连接到另一台电脑，也允许你的“服务器”程序处理多个请求连接。</li><li>批量缩略图生成器——在进行图片转换的处理时会需要很多时间，尤其是图片很大时。做一个图片处理程序，能让你在做其它事的时候在后台线程里将数百张图片转换成某个大小的图片。复杂一点的话可以用一个线程来缩放，用另一个线程来为缩略图重命名。</li></ul><h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><ul><li>所见即所得编辑器——创建一个在线编辑器，允许用户移动元素、创建表格、书写文本、设置颜色，而用户不必懂HTML。就像Dreamweaver或者FrontPage。如果需要例子的话，可以参看DIC。</li><li>分页浏览器——创建一个可以分页的小型网页浏览器，可以同时浏览几个网页。简化一点的话不要考虑Javascript或者其它客户端代码。</li><li>文件下载器——该程序可以从网页上下载各种资源，包括视频和其它文件。用于有很多下载链接的网页。</li><li>远程登录——创建一个远程登录的应用，可以通过网络登录服务器并能执行一些基本命令。</li><li>在线白板——做一个在线白板程序，你和朋友们可以一起在白板上进行一些操作，画图、写字等等。</li><li>带宽监视器——这个小工具可以记录你已经在网上上传和下载多少数据流量了。可以试着做份报告或者图表来展示各时段的使用情况。</li><li>书签搜集管理器——该程序可以让用户上传书签并将它们排序，去掉重复的，并能生成书签文件以供Firefox&#x2F;IE&#x2F;Safari等使用。复杂一点的话可以试着将书签整理进不同的文件夹。</li><li>密码保险箱——用来记录各种密码，并且将它们加密，这样别人就看不到了。</li><li>iGoogle媒体播放器小部件——做一个iGoogle小部件，可以用来播放本地音乐列表，也可以每天分享一首歌。也许还可以让别人看到你最近听了些什么歌。</li><li>基于文本的游戏——做一个像Utopia那样的文本RPG，游戏中，你可以创建一个文明、收集资源、共铸联盟、施放法术、回合制系统。看看是否能够统一王国。</li><li>定时自动登录——做一个程序可以在预定的时间登录进某个指定的网页并且执行特定的动作，然后在登出。可以用来检查邮箱、发布常规内容、为其它程序获取信息。</li><li>电子卡片生成器——可以让用户制作自己的电子卡片并发送给其他人。可以使用flash也可以不用。可以使用图片库，也可以加上深刻的格言警句。</li><li>内容管理系统——像Joomala、Drupal、PHP Nuke这样的内容管理系统。从简单的做起，慢慢增加其它功能。</li><li>模板制作器——该网站应用允许用户输入各种颜色代码、元素、尺寸，来为PHPBB、Invision Board、MySpace之类的应用创建模板文件。</li><li>验证码生成器——应该在登录时见过有数字有字母的验证码图片吧？这可以防止自动登录和垃圾广告。试着自己做一个，如果使用PHP的话，看下GD的图片函数。</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>试卷生成器——该程序可以从文件中随机挑选出不同的题目生成一份试卷。每份试卷可以不一样，通过读取答案来给打分。</li><li>快速启动——该工具可以添加各个程序的小图标，点击小图标就可以运行程序。和Windows的快速启动类似。</li><li>文件管理器——做一个文件管理器，要加些新特性，更佳的搜索功能、新图标、新外观。</li><li>文件记录排序工具——从文件中读取记录，将其排序并写回文件中。允许用户选择排序风格以及排序关键字。</li><li>生成财务交易文件并且算出平均值——将财务交易读进文件，按照账户分类、算出各项目的总量或平均值、理清各账户的借贷数据。</li><li>Zip文件生成器——用户输入不同文件夹的文件，也许还包括其他电脑中的文件，然后程序将这些文件打包成zip文件。复杂一点的话，打包时对这些文件进行压缩。</li><li>PDF生成器——从txt、html或其它文件中读取数据生成PDF文件。可以做成一个网页服务，用户上传文件，返回一个pdf版本。</li><li>批量文件命名器——程序批量处理一些文件，将根据用户提供的过滤器为它们重命名。譬如用户输入的过滤器为myimage###.jpg，那么会生成至少包含3位数的文件名，譬如myimage001.jpg、myimage145.jpg，甚至是myimage1987.jpg，因为1987也满足了至少包含3位数的条件。</li><li>MP3标签生成器——修改MP3文件的id3v1标签。还可以试着在MP3文件的头部加入id3v2的标签，譬如album art标签。</li><li>日志文件生成器——该程序可以记录指定事件的日志。譬如程序做了什么、系统在干什么、文件什么时候被修改了。</li><li>Excel分页输出器——做一个在线程序，可以读取文件内容生成一个excel分页。可以通过CVS或者其它文件格式来做。复杂一点的话看看是否能创建公式字段。</li><li>RPG角色属性生成器——做一个程序来给RPG角色随机分配属性点数，可以由用户制定一些分配规则。可以生成职业、性别、力量&#x2F;魔法&#x2F;敏捷点数、额外能力或者贸易技能。把结果保存成文件，这样跑团的时候地下城主可以把它打印出来。</li><li>文件复制工具——该工具可以批量处理文件复制和备份操作。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>SQL查询分析器——该工具可以让用户输入一条查询命令，让其运行于本地数据库中。尽量让它运行得更高效。</li><li>远程SQL工具——该工具能让你通过网络在远程服务器上执行查询操作。它能接收远程主机地址、验证用户名和密码、执行查询并返回结果。</li><li>卡片整理器——创建一个在线应用，用来记录搜集到的卡片。可以让用户输入整套卡片，查看哪些已经有了，哪些还需要搜集。要增加复杂度的话，还可以让用户知道还差多少可以完成，或者已经收集卡片的价值。</li><li>报告生成器——该工具可以根据数据库中的表格生成一份报告。譬如根据订单表格生成销售报告。</li><li>数据库备份脚本制作器——该程序可以读取数据库的对象、关系、记录和步骤，生成一个sql文件，该文件可以导入另一个数据库或者作为备份文件。</li><li>备忘录——该程序可以让用户设置一个日期和某个事件的时间、事件备注并将它们放到日历上。用户可以查看日历、搜索特定的事件。复杂一点的话，可以让用户设置重复发生的事件，譬如每天、每周、每月、每年等等。</li><li>预算记录器——该程序可以记录家庭预算。用户可以添加支出、收入，计算一段时间内的收入和支出。复杂一点的话，让用户指定一个时间段，显示该时间段内的家庭收支情况。</li><li>电话簿——记录各种联系人和他们的号码、邮箱、备注。复杂一点的话可以让用户连上网将电话簿发布到设置好的网站上。</li><li>电视节目记录器——你是否有不想错过的电视节目？但没有录像机或者想之后能找到该电视节目然后录下来，那么可以做个程序寻找各种在线电视导航网站，记录下电视节目名称、播放时间、播放频道，存在数据库中。数据库或者网站到时就会发邮件提醒你，节目就快在某个频道开始了。</li><li>旅行计划系统——该系统可以让用户管理旅行路线，记录下航班和酒店安排、感兴趣的地方、预算和时间表。</li><li>实体关系图生成器——该程序可以让用户整合实体关系图，并将其保存起来，也可以用它来生成一些基础SQL语句。</li><li>数据库翻译器（MySQL&lt;-&gt;SQL Server）——该工具可以从数据库A读取数据，生成数据库B使用的SQL语句，将数据存入数据库B。比较常用的是SQL Server和Oracle使用的MySQL服务器。</li><li>BBS论坛——为你和小伙伴们做一个论坛，可以发帖、管理、分享想法和构思。</li></ul><h3 id="图像和多媒体"><a href="#图像和多媒体" class="headerlink" title="图像和多媒体"></a>图像和多媒体</h3><ul><li>幻灯片——做一个以幻灯片形式显示各种图片的程序。为了增加难度可以做些额外的效果，譬如渐进检出、星型擦除、窗口渐隐。</li><li>思维导图——允许用户记录下各种构思并且快速地进行头脑风暴将这些构思整合到一张思维导图中。越快越好，因此要让用户能迅速地写下构思，然后将其拖到可视的导图中去，将构思之间的关系展现出来。</li><li>导入图片并存成灰度图——该工具将图片上的彩色除尽并保存。可以增加对比度调整、色化等额外功能以增加复杂度。</li><li>在线流媒体视频——试着自己做一个在线流媒体视频播放器。</li><li>MP3播放器（以及其他格式的音乐播放器）——该小程序用来播放你最爱的音乐文件。复杂一点的话看看能否加个播放列表功能和均衡器。</li><li>批量图片处理——该程序可以将一个文件夹内的图片进行统一的处理，譬如降低图片色调、转换格式或者修改文件属性。还可以尝试给图片增加标签。</li><li>CD烧录器——可以轻松烧录CD的工具。</li><li>YouTube下载器——可以从Youtube.com上下载视频到硬盘中，要支持包括FLV和AVI在内的文件格式。</li><li>墙纸管理工具——做一个管理墙纸的程序，可以定时更换刷新墙纸，也可以针对分辨率进行缩放。</li><li>截屏程序——做一个可以截屏的工具，复杂一点可以增加一个转发邮件的功能。</li><li>图片浏览器——该程序可以查看电脑上各种格式的图片，譬如PNG、GIF、JPG、BMP、TIFF等等。</li><li>交通信号灯——试着做一个交通信号灯并且把它放到可以互动的场景中。不要让汽车闯红灯或者撞到其它车。</li><li>MP3-WAV转换器——MP3格式本质上就是压缩版的WAV。试着将MP3转换成WAV格式以供可以处理WAV格式的程序使用。请记住1MB的MP3大约等于10MB的WAV。</li><li>签名生成器——是否在网上见过有人的留言后面有条生成的签名？试着做个程序让用户可以指定背景、文字、颜色和对齐方式来定制一个签名档。</li><li>屏保——电脑空闲时会运行的屏保程序。简单版的可以使用一些标准图片，复杂版的可以做出能在屏幕上转来转去的3D物体。</li><li>水印——你是否想保护你图片的版权？在图片上加上标志或者文字，这样别人就不能轻易地从你网站上盗图了。做一个程序来给你的图片加上水印吧。</li><li>海龟图——创建一个20*20的格子，用命令让一只海龟在格子上画线。可以前进、左转、右转，拿起或放下笔等等。复杂一点的话，允许程序从文件中读取命令列表。可以在网上了解到更多关于“海龟图”的信息。</li></ul><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li>战船——创建两块游戏面板，玩家各占一边，在上面放置一些战船，玩家看不到对方的面板。每艘船都占几个格子，玩家轮流攻击某个格子，如果格子上有船，那就命中目标，否则就是未命中。当一艘船所占的所有格子都被攻击命中了，那么船就被击沉。谁先将对方战船全部击沉就获胜。</li><li>象棋跳棋——象棋或者跳棋游戏。可以试着做成可以联网玩，用图形用户界面来实现悔棋、保存走棋过程并且可以回放。</li><li>刽子手——从文件中随机选择一个单词，让玩家猜单词中的字母。旁边是一幅隐藏的行绞刑的画，猜错一个单词，画就显示出一部分。画全部显示出来时还没能猜全的话玩家就输了。</li><li>填字游戏——创建一个填字游戏，并为每个词提供一个提示信息，让玩家填上所有正确的单词。</li><li>青蛙跳——让青蛙跳过河或者马路，过河的话要跳在顺流而下速度各异的木头或者睡莲叶子上，过马路的话要避开速度各异的车子。</li></ul><hr><p>文章转发自：<a href="http://blog.jobbole.com/49762/">伯乐在线</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈C语言中的回调函数</title>
      <link href="/posts/2016-08-22-talking-about-callback-function-in-c-lang.html"/>
      <url>/posts/2016-08-22-talking-about-callback-function-in-c-lang.html</url>
      
        <content type="html"><![CDATA[<p>一言不合直接上代码。</p><pre><code class="c">#include &lt;stdio.h&gt;int get_value(int a[], int n, bool (*fp)(int,int))&#123;    int value = a[0];    for (int i = 1; i &lt; n; i++)&#123;        if ((*fp)(a[i],value))&#123;            value = a[i];        &#125;    &#125;    return value;&#125;bool cmp(int a, int b)&#123;    return a &lt; b;&#125;int main()&#123;    int a[4] = &#123;1,2,4,5&#125;;    int value = get_value(a, 4, cmp);    printf(&quot;%d\n&quot;, value);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速 Fibonacci 数列</title>
      <link href="/posts/2016-05-20-fast-fibonacci.html"/>
      <url>/posts/2016-05-20-fast-fibonacci.html</url>
      
        <content type="html"><![CDATA[<p>Fibonacci 数列是一个非常经典的例子，说得最通俗易懂的话就是： 1, 1, 2, 3, 5, 8, … 这样的一个数列，在数学上用数列形式表示为：$a_0 &#x3D; 1$, $a_1 &#x3D; 1$, $a_n &#x3D; a_{n - 1} + a_{n - 2}$.</p><p>那么在计算 Fibonacci 数列这个问题上，当然大家应该都知道可以通过递推的方式来计算。</p><pre><code class="c">/* Fibonacci 下标从 0 开始 */int fib(int n) &#123;    if (n &lt;= 1) &#123;        return 1;    &#125;    int f0 = 1;    int f1 = 1;    int t;    for (int i = 2; i &lt;= n; i++) &#123;        t = f0 + f1;        f0 = f1;        f1 = t;    &#125;    return f1;&#125;</code></pre><p>当然，以上的程序效率非常高，复杂度很明显就是：$O(n)$ .</p><p>以下我们来看看 Fibonacci 数列通过递归方式实现：</p><pre><code class="c">/* Fibonacci 下标从 0 开始 */int fib(int n) &#123;    if (n &lt;= 1) &#123;        return 1;    &#125;    return fib(n - 1) + fib(n - 2);&#125;</code></pre><p>当然，递归实现方式效率很慢，复杂度是：$O(2^n)$</p><p>那么本文后面将通过<strong>增加一张记录表</strong>的方式来实现递归搜索的时候能够避免重复子程序搜索。</p><pre><code class="c">/**  * 快速 fibonacci 数列  *  * Author: L. Jiang &lt;l.jiang.1024@gmail.com&gt;  */#include &lt;iostream&gt;using namespace std;/* MAXN 给1000肯定是会溢出的，这里只是给一个例子，快速 fibonacci */#define MAXN 1000int fib[MAXN];/* 初始化 */void init() &#123;    for (int i = 0; i &lt; MAXN; i++) &#123;        fib[i] = -1; // 因为fibonacci数列里面不可能出现-1，所以这里给每个数值都赋值为-1作为是否计算出结果的标记    &#125;    fib[0] = 0;    fib[1] = 1;&#125;// 递归去搜索// 这里不需要递归的临界判断，因为下标0和下标1都一定不为-1，一定可以return结果的。int search_fib(int index) &#123;    if (-1 != fib[index]) &#123;        return fib[index];    &#125; else &#123;        fib[index] = search_fib(index - 1) + search_fib(index - 2);        return fib[index];    &#125;&#125;int main() &#123;    init();    int n;    while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123;        int ans = search_fib(n);        printf(&quot;%d\n&quot;, ans);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛选算法</title>
      <link href="/posts/2016-05-19-prime-filter-algorithm.html"/>
      <url>/posts/2016-05-19-prime-filter-algorithm.html</url>
      
        <content type="html"><![CDATA[<p>一个快速的筛选从0到一个数字之前所有素数的方法，思路比较简单：先把所有数字都标记为素数，然后从2开始一直到n，当这个数字i的标记为素数，就把 i * i, i * (i+1), i * (i+2), … , 全部标记为非素数即可。</p><pre><code class="c">#include &lt;iostream&gt;using namespace std;// max number#define MAXN 1024int main () &#123;    bool is_prime[MAXN+1];    for (int i = 0; i &lt;= MAXN; i++)&#123;        is_prime[i] = true;    &#125;    is_prime[0] = false;    is_prime[1] = false;    for (int i = 2; i &lt;= MAXN; i++)&#123;        if (is_prime[i])&#123;            for (int j = i * i; j &lt;= MAXN; j += i)&#123;                is_prime[j] = false;            &#125;        &#125;    &#125;    // done for judge all number wether it is a prime.    // ----------------------------------------------    // output all prime number between 0-MAXN    for (int i = 0; i &lt;= MAXN; i++)&#123;        if(is_prime[i])&#123;            printf(&quot;%d &quot;, i);        &#125;    &#125;    printf(&quot;\n&quot;);    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Number Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdownpad2激活密钥</title>
      <link href="/posts/2016-04-05-markdownpad2-active-keys.html"/>
      <url>/posts/2016-04-05-markdownpad2-active-keys.html</url>
      
        <content type="html"><![CDATA[<p>MarkdownPad是Windows下的一个多功能Markdown编辑器。即时看到你的Markdown文件，当你创建它们的时候，看起来就像是在HTML中的一样。当您输入时，LivePreview会自动滚动到你正在编辑的当前位置。</p><p>MarkdownPad is currently available in the following languages:</p><p>English (United States, en-US)</p><p>Chinese (China, zh-CN)</p><p>Chinese (Taiwan, zh-TW</p><p>Portuguese (Portugal, pt-PT)</p><p>German (Germany, de-DE)</p><p>Polish (Poland, pl-PL)</p><p>Russian (Russia, ru-RU)</p><p>Finnish (finland, fi-FI)</p><p>Italian (Italy, it-IT)</p><p>Korean (Korea, ko-KR)</p><p>Japanese (Japan, ja-JP)</p><p>French (France, fr-FR)</p><p>Danish (Denmark, da-DK)</p><p>Swedish (Sweden, sv-SE)</p><p>Catalan (ca-ES)</p><p>Spanish (Spain, es-ES)</p><p>Romanian (ro-RO)</p><p>Many additional languages are currently in development</p><p>邮箱：</p><pre><code>Soar360@live.com</code></pre><p>授权秘钥：</p><pre><code>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Hacker </tag>
            
            <tag> Keys </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinGW下载</title>
      <link href="/posts/2016-04-03-download-mingw.html"/>
      <url>/posts/2016-04-03-download-mingw.html</url>
      
        <content type="html"><![CDATA[<p>MinGW 官网网址：<a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p><p><strong>注</strong>： 由于下载资源并不在境内，所以正常下载速度很慢。笔者建议大家使用 IDM （<a href="http://www.internetdownloadmanager.com/download.html">官网下载页面</a>）进行下载。</p><p>最新64位下载：<a href="https://nchc.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z">x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z</a></p><p>最新32位下载：<a href="https://nchc.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/8.1.0/threads-posix/dwarf/i686-8.1.0-release-posix-dwarf-rt_v6-rev0.7z">i686-8.1.0-release-posix-dwarf-rt_v6-rev0.7z</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蔡勒（Zeller）公式</title>
      <link href="/posts/2015-08-22-zeller-formula.html"/>
      <url>/posts/2015-08-22-zeller-formula.html</url>
      
        <content type="html"><![CDATA[<p>蔡勒（Zeller）公式</p><p>历史上的某一天是星期几？未来的某一天是星期几？关于这个问题，有很多计算公式（两个通用计算公式和一些分段计算公式），其中最著名的是蔡勒（Zeller）公式。即w&#x3D;y+[y&#x2F;4]+[c&#x2F;4]-2c+[26(m+1)&#x2F;10]+d-1<br>公式中的符号含义如下，w：星期；c：世纪-1；y：年（两位数）；m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）；d：日；[ ]代表取整，即只要整数部分。(C是世纪数减一，y是年份后两位，M是月份，d是日数。1月和2月要按上一年的13月和 14月来算，这时C和y均按上一年取值。)<br>算出来的W除以7，余数是几就是星期几。如果余数是0，则为星期日。<br>以2049年10月1日（100周年国庆）为例，用蔡勒（Zeller）公式进行计算，过程如下：<br>蔡勒（Zeller）公式：w&#x3D;y+[y&#x2F;4]+[c&#x2F;4]-2c+[26(m+1)&#x2F;10]+d-1<br>&#x3D;49+[49&#x2F;4]+[20&#x2F;4]-2×20+[26× (10+1)&#x2F;10]+1-1<br>&#x3D;49+[12.25]+5-40+[28.6]<br>&#x3D;49+12+5-40+28<br>&#x3D;54 (除以7余5)<br>即2049年10月1日（100周年国庆）是星期5。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015 ACM-ICPC 上海邀请赛 – B题 – hdu – 5237</title>
      <link href="/posts/2015-08-20-2015-ACM-ICPC-Aisa-Shanghai-Invitation-Contest-B-hdu-5237.html"/>
      <url>/posts/2015-08-20-2015-ACM-ICPC-Aisa-Shanghai-Invitation-Contest-B-hdu-5237.html</url>
      
        <content type="html"><![CDATA[<p>Problem Description<br>Mike does not want others to view his messages, so he find a encode method Base64.<br>Here is an example of the note in Chinese Passport.</p><p>The Ministry of Foreign Affairs of the People’s Republic of China requests all civil and military authorities of foreign countries to allow the bearer of this passport to pass freely and afford assistance in case of need.</p><p>When encoded by $\texttt{Base64}$, it looks as follows</p><p>VGhlIE1pbmlzdHJ5IG9mIEZvcmVpZ24gQWZmYWlycyBvZiB0aGUgUGVvcGxlJ3MgUmVwdWJsaWMgb2Yg<br>Q2hpbmEgcmVxdWVzdHMgYWxsIGNpdmlsIGFuZCBtaWxpdGFyeSBhdXRob3JpdGllcyBvZiBmb3JlaWdu<br>IGNvdW50cmllcyB0byBhbGxvdyB0aGUgYmVhcmVyIG9mIHRoaXMgcGFzc3BvcnQgdG8gcGFzcyBmcmVl<br>bHkgYW5kIGFmZm9yZCBhc3Npc3RhbmNlIGluIGNhc2Ugb2YgbmVlZC4&#x3D;</p><p>In the above text, the encoded result of $\texttt{The}$ is $\texttt{VGhl}$. Encoded in ASCII, the characters $\texttt{T}$ , $\texttt{h}$, and $\texttt{e}$ are stored as the bytes 84, 104, and 101, which are the 8-bit binary values 01010100, 01101000, and 01100101. These three values are joined together into a 24-bit string, producing 010101000110100001100101.<br>Groups of 6 bits (6 bits have a maximum of 26&#x3D;64 different binary values) are converted into individual numbers from left to right (in this case, there are four numbers in a 24-bit string), which are then converted into their corresponding Base64 encoded characters. The Base64 index table is</p><p>0123456789012345678901234567890123456789012345678901234567890123<br>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;</p><p>In the above example, the string 010101000110100001100101 is divided into four parts 010101, 000110, 100001 and 100101, and converted into integers 21,6,33 and 37. Then we find them in the table, and get V, G, h, l.</p><p>When the number of bytes to encode is not divisible by three (that is, if there are only one or two bytes of input for the last 24-bit block), then the following action is performed:</p><p>Add extra bytes with value zero so there are three bytes, and perform the conversion to base64. If there was only one significant input byte, only the first two base64 digits are picked (12 bits), and if there were two significant input bytes, the first three base64 digits are picked (18 bits). ‘&#x3D;’ characters are added to make the last block contain four base64 characters.</p><p>As a result, when the last group contains one bytes, the four least significant bits of the final 6-bit block are set to zero; and when the last group contains two bytes, the two least significant bits of the final 6-bit block are set to zero.</p><p>For example, base64(A) &#x3D; QQ&#x3D;&#x3D;, base64(AA) &#x3D; QUE&#x3D;.</p><p>Now, Mike want you to help him encode a string for k times. Can you help him?</p><p>For example, when we encode A for two times, we will get base64(base64(A)) &#x3D; UVE9PQ&#x3D;&#x3D;.</p><p>Input<br>The first line contains an integer T(T≤20) denoting the number of test cases.<br>In the following T lines, each line contains a case. In each case, there is a number k(1≤k≤5) and a string s. s only contains characters whose ASCII value are from 33 to 126(all visible characters). The length of s is no larger than 100.</p><p>Output<br>For each test case, output Case #t:, to represent this is t-th case. And then output the encoded string.</p><p>Sample Input</p><pre><code>21 Mike4 Mike</code></pre><p>Sample Output</p><pre><code>Case #1: TWlrZQ==Case #2: Vmtaa2MyTnNjRkpRVkRBOQ==</code></pre><p>Source<br>The 2015 ACM-ICPC China Shanghai Metropolitan Programming Contest</p><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;string table = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;string base64encode(string str) &#123;    int cnt = str.length() / 3;    if (str.length() % 3 != 0) cnt++;    cnt *= 24;    bool *bin = new bool[cnt];    for (int i = 0; i &lt; cnt; i++) &#123;        bin[i] = 0;    &#125;    memset(bin, 0, sizeof(bin));    for (int i = 0; i &lt; str.length(); i++) &#123;        int tmp = str[i];        int top_index = (i + 1) * 8 - 1;        for (int j = 0; j &lt; 8; j++) &#123;            bin[top_index] = tmp % 2;            tmp /= 2;            top_index--;        &#125;    &#125;    string ans = &quot;&quot;;    for (int i = 0; i &lt; cnt; i = i) &#123;        int tmp = 0;        tmp *= 2;        tmp += bin[i];        i++;        tmp *= 2;        tmp += bin[i];        i++;        tmp *= 2;        tmp += bin[i];        i++;        tmp *= 2;        tmp += bin[i];        i++;        tmp *= 2;        tmp += bin[i];        i++;        tmp *= 2;        tmp += bin[i];        i++;        ans += table[tmp];    &#125;    if (str.length() % 3 == 1) &#123;        ans[ans.length() - 1] = &#39;=&#39;;        ans[ans.length() - 2] = &#39;=&#39;;    &#125;    if (str.length() % 3 == 2) &#123;        ans[ans.length() - 1] = &#39;=&#39;;    &#125;    return ans;&#125;int main() &#123;    int t;    cin &gt;&gt; t;    for (int tt = 1; tt &lt;= t; tt++) &#123;        int n;        string str;        cin &gt;&gt; n &gt;&gt; str;        while (n--) &#123;            str = base64encode(str);        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; tt &lt;&lt; &quot;: &quot; &lt;&lt; str &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql命令行备份数据库</title>
      <link href="/posts/2015-08-20-backup-mysql-database-with-command-line.html"/>
      <url>/posts/2015-08-20-backup-mysql-database-with-command-line.html</url>
      
        <content type="html"><![CDATA[<p>MySQL数据库使用命令行备份|MySQL数据库备份命令</p><p>例如：</p><p>数据库地址：127.0.0.1</p><p>数据库用户名：root</p><p>数据库密码：pass</p><p>数据库名称：myweb</p><p>备份数据库到D盘跟目录</p><pre><code class="bash">mysqldump -h127.0.0.1 -uroot -ppass myweb &gt; backupfile.sql</code></pre><p>备份到当前目录 备份MySQL数据库为带删除表的格式，能够让该备份覆盖已有数据库而不需要手动删除原有数据库</p><pre><code class="bash">mysqldump --add-drop-table -h127.0.0.1 -uroot -ppass myweb &gt; backupfile.sql</code></pre><p>直接将MySQL数据库压缩备份  备份到D盘跟目录</p><pre><code class="bash">mysqldump -h127.0.0.1 -uroot -ppass myweb | gzip &gt; d:/backupfile.sql.gz</code></pre><p>备份MySQL数据库某个(些)表。此例备份table1表和table2表。备份到linux主机的&#x2F;home下</p><pre><code class="bash">mysqldump -h127.0.0.1 -uroot -ppass myweb table1 table2 &gt; /home/backupfile.sql</code></pre><p>同时备份多个MySQL数据库</p><pre><code class="bash">mysqldump -h127.0.0.1 -uroot -ppass --databases myweb myweb2 &gt; multibackupfile.sql</code></pre><p>仅仅备份数据库结构。同时备份名为myweb数据库和名为myweb2数据库</p><pre><code class="bash">mysqldump --no-data -h127.0.0.1 -uroot -ppass --databases myweb myweb2 &gt; structurebackupfile.sql</code></pre><p>备份服务器上所有数据库</p><pre><code class="bash">mysqldump --all-databases -h127.0.0.1 -uroot -ppass &gt; allbackupfile.sql</code></pre><p>还原MySQL数据库的命令。还原当前备份名为backupfile.sql的数据库</p><pre><code class="bash">mysql -h127.0.0.1 -uroot -ppass myweb &lt; backupfile.sql</code></pre><p>还原压缩的MySQL数据库</p><pre><code class="bash">gunzip &lt; backupfile.sql.gz | mysql -h127.0.0.1 -uroot -ppass myweb</code></pre><p>将数据库转移到新服务器。此例为将本地数据库myweb复制到远程数据库名为serweb中，其中远程数据库必须有名为serweb的数据库</p><pre><code class="bash">mysqldump -h127.0.0.1 -uroot -ppass myweb | mysql --host=***.***.***.*** -u数据库用户名 -p数据库密码 -C serweb</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环问题</title>
      <link href="/posts/2015-08-20-josephus-problem.html"/>
      <url>/posts/2015-08-20-josephus-problem.html</url>
      
        <content type="html"><![CDATA[<p>这算是一个非常简单的模拟题。</p><p>在大家学习数据结构的课程中，都会有这个问题。</p><p>在计算机上先输入两个正整数N和K，其中N为将要输入的正整数的个数，K为步长。请编写一个程序，首先用循环链接表储存这N个正整数。然后，首先删除第一个正整数，接着删除循环链表从当前删除节点开始步长走K个的正整数，依次类推，直至表空为止。如下所示，N&#x3D;10,K&#x3D;3,输入的10个正整数为1，2，3，4，5，6，7，8，9，10。则被删除的次序为：1，4，7，10，5，9，6，3，8，2。</p><p>直接上代码吧。</p><pre><code class="C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXN 10000struct Node&#123;    struct Node* next;    int value;&#125;;struct Node link[MAXN];int n,k;struct Node *pre, *cur;void make_link ()&#123;    int i;    for (i = 0; i &lt; n-1; i++)    &#123;        link[i].next = &amp;link[i+1];        scanf (&quot;%d&quot;, &amp;link[i].value);        //cin &gt;&gt; link[i].value;    &#125;    link[n-1].next = &amp;link[0];    scanf(&quot;%d&quot;, &amp;link[n-1].value);    // cin &gt;&gt; link[n-1].value;    cur = &amp;link[0];    pre = &amp;link[n-1];&#125;/*cur指针移动cnt步*/void move_cur_index (int cnt)&#123;    int i;    for (i = 0; i &lt; cnt-1; i++)    &#123;        pre = cur;        cur = (*cur).next;    &#125;&#125;/*删除当前指向的节点*/void del_cur_node ()&#123;    printf(&quot;%d &quot;, (*cur).value);    // cout &lt;&lt; (*cur).value &lt;&lt; &quot; &quot;;    (*pre).next = (*cur).next;    cur = (*cur).next;&#125;int main ()&#123;    int i;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    //cin &gt;&gt; n &gt;&gt; k;    make_link();    for (i = 0; i &lt; n; i++)    &#123;        del_cur_node();        move_cur_index(k);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ACM-ICPC </tag>
            
            <tag> Easy </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java DES简单实现</title>
      <link href="/posts/2015-08-20-simple-des-demo-in-java.html"/>
      <url>/posts/2015-08-20-simple-des-demo-in-java.html</url>
      
        <content type="html"><![CDATA[<p>&nbsp;</p><span id="more"></span><pre><code class="java">package com.lemox.security;import java.security.SecureRandom;import javax.crypto.spec.DESKeySpec;import javax.crypto.SecretKeyFactory;import javax.crypto.SecretKey;import javax.crypto.Cipher;/** * DES加密介绍 DES是一种对称加密算法，所谓对称加密算法即：加密和解密使用相同密钥的算法。DES加密算法出自IBM的研究， * 后来被美国政府正式采用，之后开始广泛流传，但是近些年使用越来越少，因为DES使用56位密钥，以现代计算能力， * 24小时内即可被破解。虽然如此，在某些简单应用中，我们还是可以使用DES加密算法，本文简单讲解DES的JAVA实现 。 * 注意：DES加密和解密过程中，密钥长度都必须是8的倍数 */public class DES&#123;    public DES()    &#123;    &#125;    // 测试    public static void main(String args[])    &#123;        // 待加密内容        String str = &quot;测试内容&quot;;        // 密码，长度要是8的倍数        String password = &quot;958802882010913257074332531189842634785729877354946875887501857953775777216308447887369944730603446620061641196057412243405946910023589270273686087290124712345600&quot;;        byte[] result = DES.encrypt(str.getBytes(), password);        System.out.println(&quot;加密后：&quot; + new String(result));        // 直接将如上内容解密        try        &#123;            byte[] decryResult = DES.decrypt(result, password);            System.out.println(&quot;解密后：&quot; + new String(decryResult));        &#125; catch (Exception e1)        &#123;            e1.printStackTrace();        &#125;    &#125;    /**     * 加密     *      * @param datasource     *            byte[]     * @param password     *            String     * @return byte[]     */    public static byte[] encrypt(byte[] datasource, String password)    &#123;        try        &#123;            SecureRandom random = new SecureRandom();            DESKeySpec desKey = new DESKeySpec(password.getBytes());            // 创建一个密匙工厂，然后用它把DESKeySpec转换成            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);            SecretKey securekey = keyFactory.generateSecret(desKey);            // Cipher对象实际完成加密操作            Cipher cipher = Cipher.getInstance(&quot;DES&quot;);            // 用密匙初始化Cipher对象            cipher.init(Cipher.ENCRYPT_MODE, securekey, random);            // 现在，获取数据并加密            // 正式执行加密操作            return cipher.doFinal(datasource);        &#125; catch (Throwable e)        &#123;            e.printStackTrace();        &#125;        return null;    &#125;    /**     * 解密     *      * @param src     *            byte[]     * @param password     *            String     * @return byte[]     * @throws Exception     */    public static byte[] decrypt(byte[] src, String password) throws Exception    &#123;        // DES算法要求有一个可信任的随机数源        SecureRandom random = new SecureRandom();        // 创建一个DESKeySpec对象        DESKeySpec desKey = new DESKeySpec(password.getBytes());        // 创建一个密匙工厂        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);        // 将DESKeySpec对象转换成SecretKey对象        SecretKey securekey = keyFactory.generateSecret(desKey);        // Cipher对象实际完成解密操作        Cipher cipher = Cipher.getInstance(&quot;DES&quot;);        // 用密匙初始化Cipher对象        cipher.init(Cipher.DECRYPT_MODE, securekey, random);        // 真正开始解密操作        return cipher.doFinal(src);    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
