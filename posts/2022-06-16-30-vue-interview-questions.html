<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="ismdeep">
<meta name="author" content="ismdeep">
<meta name="subtitle" content="Enjoy programming and build awesome stuff.">




<title>30道常见Vue面试题 | ismdeep</title>



<link rel="icon" href="/hacker.svg">



<style>
/* 立即隐藏侧边栏和顶部栏，防止闪烁 */
#column-one, #p-personal {
    visibility: hidden;
    opacity: 0;
}

/* 页面加载完成后显示 */
body.loaded #column-one,
body.loaded #p-personal {
    visibility: visible;
    opacity: 1;
    transition: opacity 0.2s ease-in-out;
}

/* 确保在JavaScript未执行时也能正常显示（降级方案） */
.no-js #column-one,
.no-js #p-personal {
    visibility: visible !important;
    opacity: 1 !important;
}
</style>


<script>
(function() {
    // 立即添加loaded类，不等待DOM加载
    document.documentElement.className += ' no-js';
    
    function showElements() {
        document.body.className = (document.body.className + ' loaded').trim();
        document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '').trim();
    }
    
    // 尝试多种方式确保元素显示
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', showElements);
        // 备用方案：在短延迟后也执行
        setTimeout(showElements, 100);
    } else {
        showElements();
    }
    
    // 最后的保障：在窗口加载完成后也执行
    window.addEventListener('load', showElements);
})();
</script>


<link rel="stylesheet" href="/css/style.css">


<script src="/js/script.js"></script>
<script src="/js/tocbot.min.js"></script>



    
    
        
    


  <meta name="generator" content="Hexo 6.3.0"></head>

  <body class="mediawiki ltr sitedir-ltr mw-underline-never mw-hide-empty-elt ns-0 ns-subject mw-editable skin-monobook action-view skin--responsive">
    <div id="globalWrapper">
      <div id="column-content">
        <div id="content" class="mw-body ve-init-mw-desktopArticleTarget-targetContainer" role="main">
          <a id="top"></a>

          
            <h1 id="firstHeading" class="firstHeading mw-first-heading" lang="zh-Hans-CN" dir="ltr">
              <span class="mw-page-title-main">30道常见Vue面试题</span>
            </h1>
          

          <div id="bodyContent" class="monobook-body">
            <div id="contentSub" lang="zh-Hans-CN" dir="ltr">
              <div id="mw-content-subtitle" lang="zh-Hans-CN" dir="ltr"></div>
            </div>
            <!-- start content -->
            <div id="mw-content-text" class="mw-body-content">
              <div class="mw-content-ltr mw-parser-output" lang="zh-Hans-CN" dir="ltr">
                <div id="noteTA-cab67cdc" class="noteTA">
                  <div class="noteTA-group">
                    <div data-noteta-group-source="module" data-noteta-group="USState"></div>
                    <div data-noteta-group-source="module" data-noteta-group="PresidentsUS"></div>
                    <div data-noteta-group-source="module" data-noteta-group="People"></div>
                  </div>
                </div>
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9SPA%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1. 说说你对SPA单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-v-show%E4%B8%8Ev-if%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2. v-show与v-if有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-class%E4%B8%8Estyle%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-text">3. class与style如何动态绑定？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%80%8E%E6%A0%B7%E7%90%86%E8%A7%A3Vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F"><span class="toc-text">4. 怎样理解Vue的单向数据流？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-text">5. computed和watch的区别和运用的场景？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%9B%B4%E6%8E%A5%E7%BB%99%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E9%A1%B9%E8%B5%8B%E5%80%BC%EF%BC%8CVue%E8%83%BD%E6%A3%80%E6%B5%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="toc-text">6. 直接给一个数组项赋值，Vue能检测到变化吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">7. 谈谈你对Vue生命周期的理解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Vue%E7%9A%84%E7%88%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">8. Vue的父组件和子组件生命周期钩子函数执行顺序？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-text">9. 在哪个生命周期内调用异步请求？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%9C%A8%E4%BB%80%E4%B9%88%E9%98%B6%E6%AE%B5%E6%89%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9CDOM%EF%BC%9F"><span class="toc-text">10. 在什么阶段才能访问操作DOM？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="toc-text">11. 父组件可以监听到子组件的生命周期吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9keep-alive%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">12. 谈谈你对keep-alive的了解？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%BB%84%E4%BB%B6%E4%B8%AD-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">13. 组件中 data 为什么是一个函数？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-v-model-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">14. v-model 的原理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">15. vue 组件间通信有哪几种方式？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87-vuex-%E5%90%97%EF%BC%9F"><span class="toc-text">16. 你使用过 vuex 吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E4%BD%BF%E7%94%A8%E8%BF%87-Vue-SSR-%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4SSR%EF%BC%9F"><span class="toc-text">17. 使用过 Vue SSR 吗？说说SSR？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-vue-router-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">18. vue-router 路由模式有几种？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E8%83%BD%E8%AF%B4%E4%B8%8B-vue-router-%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84-hash-%E5%92%8C-history-%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%90%97%EF%BC%9F"><span class="toc-text">19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E4%BB%80%E4%B9%88%E6%98%AF-MVVM"><span class="toc-text">20. 什么是 MVVM?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-Vue-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">21. Vue 是如何实现数据双向绑定的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-vue-%E6%A1%86%E6%9E%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%91%E5%90%AC%EF%BC%9F"><span class="toc-text">22. vue 框架怎么实现对象和数组的监听？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-Proxy-%E4%B8%8E-Object-defineProperty-%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="toc-text">23. Proxy 与 Object.defineProperty 优劣对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-Vue-%E6%80%8E%E4%B9%88%E7%94%A8vm-set-%EF%BC%89-%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E5%93%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">24. Vue 怎么用vm.$set(） 解决对象新增属性不能响应的问题？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-%E8%99%9B%E6%8B%9F-DOM-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-text">25. 虛拟 DOM 的优缺点？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26-%E8%99%9A%E6%8B%9F-DOM-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-text">26. 虚拟 DOM 实现原理？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27-Vue%E4%B8%AD%E7%9A%84key%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">27. Vue中的key有什么作用？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28-%E4%BD%A0%E6%9C%89%E5%AF%B9Vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-text">28. 你有对Vue项目进行哪些优化？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29-%E5%AF%B9%E4%BA%8E%E7%9A%84Vue3-0%E7%89%B9%E6%80%A7%E4%BD%A0%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-text">29. 对于的Vue3.0特性你有什么了解的吗？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BD%BF%E7%94%A8-vue-%E6%A1%86%E6%9E%B6%E8%B8%A9%E8%BF%87%E6%9C%80%E5%A4%A7%E7%9A%84%E5%9D%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-text">30. 说说你使用 vue 框架踩过最大的坑是什么？怎么解决的？</span></a></li></ol>
    </div>
</div>

    

    
    <article class="post-wrap">
<!--         <header class="post-header"> -->
<!--             <h1 class="post-title">30道常见Vue面试题</h1> -->
<!--         </header> -->

        <div class="post-content">
            <h1 id="1-说说你对SPA单页面的理解，它的优缺点分别是什么？"><a href="#1-说说你对SPA单页面的理解，它的优缺点分别是什么？" class="headerlink" title="1. 说说你对SPA单页面的理解，它的优缺点分别是什么？"></a>1. 说说你对SPA单页面的理解，它的优缺点分别是什么？</h1><p>SPA ( single-page application ）仅在Web 页面初始化时加载相应的 HTML、JavaScript和CSS.一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI与用户的交互避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
</ul>
<p>基于上面一点，SPA 相对对服务器压力小；前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将JavaScript、css 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h1 id="2-v-show与v-if有什么区别？"><a href="#2-v-show与v-if有什么区别？" class="headerlink" title="2. v-show与v-if有什么区别？"></a>2. v-show与v-if有什么区别？</h1><p><strong>v-if</strong> 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>情性</strong>的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p><strong>v-show</strong> 就简单得多 ——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的“display” 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<h1 id="3-class与style如何动态绑定？"><a href="#3-class与style如何动态绑定？" class="headerlink" title="3. class与style如何动态绑定？"></a>3. class与style如何动态绑定？</h1><p>class可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li><p>对象语法：</p>
<pre><code>&lt;div v-bind:class=&quot;&#123; &#39;active&#39;: isActive, &#39;text-danger&#39;: hasError &#125;&quot;&gt;&lt;/div&gt;
data: &#123;
  isActive: true,
  hasError: false
&#125;
</code></pre>
</li>
<li><p>数组语法：</p>
<pre><code>&lt;div v-bind:class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;
data: &#123;
  activeClass: &#39;active&#39;,
  errorClass: &#39;text-danger&#39;
&#125;
</code></pre>
</li>
</ul>
<p>style也可以通过对象语法和数组语法进行动态绑定：</p>
<ul>
<li><p>对象语法：</p>
<pre><code>&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#39;px&#39; &#125;&quot;&gt;&lt;/div&gt;
data: &#123;
  activeColor: &#39;red&#39;,
  fontSize: 30
&#125;
</code></pre>
</li>
<li><p>数组语法： </p>
<pre><code>&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;
data: &#123;
  styleColor: &#123;
  color: &#39;red&#39;
  styleSize:&#123;
    fontSize:&quot;&#39;23px&#39;
  &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="4-怎样理解Vue的单向数据流？"><a href="#4-怎样理解Vue的单向数据流？" class="headerlink" title="4. 怎样理解Vue的单向数据流？"></a>4. 怎样理解Vue的单向数据流？</h1><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行鄉定：父级prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>
<p>有两种常见的试图改变一个prop 的情形：</p>
<ul>
<li><p><strong>这个prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop数据来使用。</strong>在这种情况下，最好定义一个本地的data 属性并将这个 prop 用作其初始值：</p>
<pre><code>props: [&#39;initialCounter&#39;],
data: function() &#123;
  return &#123;
    counter: this.initialCounter
  &#125;
&#125;
</code></pre>
</li>
<li><p><strong>这个prop 以一种原始的值传入且需要进行转换</strong>。在这种情况下，最好使用这个prop 的值来定义一个计算属性</p>
<pre><code>props: [&#39;size&#39;]
computed: &#123;
  normalizedSize: function() &#123;
    return this.size.trim().toLowerCase()
  &#125;
&#125;
</code></pre>
</li>
</ul>
<h1 id="5-computed和watch的区别和运用的场景？"><a href="#5-computed和watch的区别和运用的场景？" class="headerlink" title="5. computed和watch的区别和运用的场景？"></a>5. computed和watch的区别和运用的场景？</h1><p><strong>computed</strong>：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p><strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed， 因为可以利用computed 的缓存特性，避免每次获取值时，都要重新计算;</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用watch，使用watch 选项允许我们执行异步操作（访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h1 id="6-直接给一个数组项赋值，Vue能检测到变化吗？"><a href="#6-直接给一个数组项赋值，Vue能检测到变化吗？" class="headerlink" title="6. 直接给一个数组项赋值，Vue能检测到变化吗？"></a>6. 直接给一个数组项赋值，Vue能检测到变化吗？</h1><p>由于JavaScript 的限制，vue 不能检测到以下数组的变动：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfltem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ul>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<pre><code class="javascript">// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set, Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
</code></pre>
<p>为了解决第二个问题，Vue提供了一下操作方法：</p>
<pre><code class="javascript">// Array.prototype.splice
vm.items.splice(newLength)
</code></pre>
<h1 id="7-谈谈你对Vue生命周期的理解？"><a href="#7-谈谈你对Vue生命周期的理解？" class="headerlink" title="7. 谈谈你对Vue生命周期的理解？"></a>7. 谈谈你对Vue生命周期的理解？</h1><p>(1) 生命周期是什么？</p>
<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom-＞渲染、更新-＞渲染、卸载等一系列过程，我们称这是 vue 的生命周期。</p>
<p>(2) 各个生命周期的作用</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el被新创建的 vm.$el替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>update</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activated</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destroyed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<h1 id="8-Vue的父组件和子组件生命周期钩子函数执行顺序？"><a href="#8-Vue的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="8. Vue的父组件和子组件生命周期钩子函数执行顺序？"></a>8. Vue的父组件和子组件生命周期钩子函数执行顺序？</h1><p>Vue的父组件和子组件生命周期钩子函数执行顺序可以归类为以下4部分：</p>
<ul>
<li>加载渲染过程</li>
<li>子组件更新过程</li>
<li>父组件更新过程</li>
<li>销毁过程</li>
</ul>
<h1 id="9-在哪个生命周期内调用异步请求？"><a href="#9-在哪个生命周期内调用异步请求？" class="headerlink" title="9. 在哪个生命周期内调用异步请求？"></a>9. 在哪个生命周期内调用异步请求？</h1><p>可以在钩子西数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 己经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在created 钩子西数中调用异步请求，因为在 created 钩子西数中调用异步请求有以下优点：</p>
<ul>
<li>能更怏获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount、mounted 钩子函数，所以放在created 中有助于一致性；</li>
</ul>
<h1 id="10-在什么阶段才能访问操作DOM？"><a href="#10-在什么阶段才能访问操作DOM？" class="headerlink" title="10. 在什么阶段才能访问操作DOM？"></a>10. 在什么阶段才能访问操作DOM？</h1><p>在钩子函数 mounted 被调用前，vue 已经将编译好的模板挂载到页面上，所以在mounted 中可以访问操作 DOM。 vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p>
<h1 id="11-父组件可以监听到子组件的生命周期吗？"><a href="#11-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11. 父组件可以监听到子组件的生命周期吗？"></a>11. 父组件可以监听到子组件的生命周期吗？</h1><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<pre><code>/ Parent.vue
&lt;Child @mounted= &quot;doSomething&quot; /&gt;

// Child.vue
mounted()&#123;
  this.$emit(&quot;mounted&quot;);
&#125;
</code></pre>
<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p>
<pre><code>// Parent.vue
&lt;Child @hook:mounted= &quot;doSomething&quot;&gt;&lt;/Child&gt;
doSomething()&#123;
  console.log(&#39;父组件监听到 mounted 钩子函数...&#39;)
&#125;

// Child.vue
mounted()&#123;
  console.log(&#39;子组件触发mounted 钩子函数...&#39;)
&#125;

// 以上输出顺序为：
// 子组件触发mounted钩子函数.
// 父组件监听到mounted钩子函数.
当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created, updated 等都可以监听。
</code></pre>
<h1 id="12-谈谈你对keep-alive的了解？"><a href="#12-谈谈你对keep-alive的了解？" class="headerlink" title="12. 谈谈你对keep-alive的了解？"></a>12. 谈谈你对keep-alive的了解？</h1><p>keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供 include 和exclude 属性，两者都支持宇符串或正则表达式，include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 的优先级比 include 高；</li>
<li>对应两个钩子函数 activated 和 deactivated，当组件被激活时，触发钩子函数activated， 当组件被移除时，触发钩子函数 deactivated.</li>
</ul>
<h1 id="13-组件中-data-为什么是一个函数？"><a href="#13-组件中-data-为什么是一个函数？" class="headerlink" title="13. 组件中 data 为什么是一个函数？"></a>13. 组件中 data 为什么是一个函数？</h1><p>为什么组件中的 data 必须是一个函数，然后return 一个对象，而new vue 实例里，data 可以直接是一个对象？</p>
<pre><code class="javascript">// data
data() &#123;
  return &#123;
    message:&quot;子组件&quot;,
    childName:this.name
  &#125;
&#125;

// new Vue
new Vue(&#123;
  el: &#39;#app&#39;,
  router,
  template: &#39;&lt;App/&gt;,
  components: &#123;App&#125;
&#125;)
</code></pre>
<p>因为组件是用来复用的，且JS里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的data 属性值会相互影响，如果组件中 data 选项是一个西数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的data 属性值不会互相影响；而new vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h1 id="14-v-model-的原理？"><a href="#14-v-model-的原理？" class="headerlink" title="14. v-model 的原理？"></a>14. v-model 的原理？</h1><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和textarea 元素使用 value 属性和input 事件；</li>
<li>checkbox 和radio 使用 checked 属性和change 事件；</li>
<li>select 字段将value 作为 prop并将change 作为事件。</li>
</ul>
<p>以input 表单元素为例：</p>
<pre><code class="javascript">&lt;input v-model=&#39;something&#39;&gt;
</code></pre>
<p>相当于</p>
<pre><code>&lt;input v-bind:value =&quot;something&quot; v-on:input=&quot;something = Sevent.target.value&quot;&gt;
</code></pre>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的prop 和名为 input 的事件，<br>如下所示：<br>父组件：</p>
<pre><code>&lt;ModelChild -model= &quot;message&quot;&gt;&lt;/ModelChild&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="javascript">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;

props:&#123;
  value: String
&#125;,
methods: &#123;
  test()&#123;
    this. $emit (&#39;input&#39;, &quot;小红&quot;)
  &#125;,
&#125;,
</code></pre>
<h1 id="15-vue-组件间通信有哪几种方式？"><a href="#15-vue-组件间通信有哪几种方式？" class="headerlink" title="15. vue 组件间通信有哪几种方式？"></a>15. vue 组件间通信有哪几种方式？</h1><p>Vue组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 vue 掌握的越熟练。vue 组件问通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。<br>(1)  props &#x2F; $emit 适用 父子组件通信</p>
<p>这种方法是 vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>
<p>(2) ref 与 $parent &#x2F; $children 适用 父子组件通信</p>
<ul>
<li>ref：如果在普通的 DOM 元素上使用，引1用指向的就是DOM 元素；如果用在子组件上，引用就指向组件实例；</li>
<li>$parent &#x2F; $children：访问父&#x2F; 子实例</li>
</ul>
<p>(3) EventBus($emit &#x2F; $on）适用于 父子、隔代、兄弟组件通信</p>
<p>这种方法通过一个空的 vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>
<p>(4) $attrs&#x2F;$listeners 适用于 隔代组件通信</p>
<ul>
<li>$attrs：包含了父作用域中不被 prop 所识别(且获取）的特性绑定（class 和stvle除外）。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定（class 和style 除外），并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件。通常配合inheritAttrs 选项一起使用。</li>
<li>$listeners：包含了父作用域中的(不含 native 修饰器的）v-on 事件监听器。它可以通过 v-On&#x3D;”$listeners” 传入内部组件。</li>
</ul>
<p>(5) provide &#x2F; inject 适用于隔代组件通信</p>
<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<p>(6) Vuex 适用于 父子、隔代、兄弟组件通信</p>
<p>Vuex 是一个专为 vuejs 应用程序开发的状态管理模式。每一个vuex 应用的核心就是store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态（ state ）。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h1 id="16-你使用过-vuex-吗？"><a href="#16-你使用过-vuex-吗？" class="headerlink" title="16. 你使用过 vuex 吗？"></a>16. 你使用过 vuex 吗？</h1><p>Vuex是一个专为Vue.js应用程序开发的状态管理模式。每一个Vuex应用的核心就是store(仓库)。“store”基本上就是一个容器，它包含着你的应用中大部分的状态（ state ）。</p>
<p>(1) vuex 的状态存储是响应式的。当 vue 组件从 store 中读取状态的时候，若 store中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>(2) 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>
<p>主要包括以下几个模块：</p>
<ul>
<li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
<li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的getter 映射到局部计算属性。</li>
<li>Mutation：是唯一更改store 中状态的方法，且必须是同步函数。</li>
<li>Action：用于提交mutation， 而不是直接变更状态，可以包含任意异步操作。</li>
<li>Module：允许将单一的Store 拆分为多个store 且同时保存在单一的状态树中。</li>
</ul>
<h1 id="17-使用过-Vue-SSR-吗？说说SSR？"><a href="#17-使用过-Vue-SSR-吗？说说SSR？" class="headerlink" title="17. 使用过 Vue SSR 吗？说说SSR？"></a>17. 使用过 Vue SSR 吗？说说SSR？</h1><p>Vue.js是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出Vue组件进行生成DOM 和操作DOM。然而，也可以将同一个组件渲染为服务端的 HTML字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>
<p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<p><strong>服务端渲染 SSR 的优缺点如下：</strong><br>(1) 服务端渲染的优点：</p>
<ul>
<li>更好的SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜素引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过Ajax 荻取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）：SPA 会等待所有vue 编译后的 is 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间;SSR 直接由服务端渲染好页 面直接返回显示，无需等待下载 is 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p>(2) 服务端渲染的缺点：</p>
<ul>
<li>更多的开发条件限制：例如服务端渲染只支持 beforcreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node js server 运行环境；</li>
<li>更多的服务器负载：在Node js 中渲染完整的应用程序，显然会比仅仅提供静态文件的server 更加大量占用CPU 资源 (CPU-intensive-CPU 密集)，因此如果你预料在高流量环境（high traffic）下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h1 id="18-vue-router-路由模式有几种？"><a href="#18-vue-router-路由模式有几种？" class="headerlink" title="18. vue-router 路由模式有几种？"></a>18. vue-router 路由模式有几种？</h1><p>vue-router 有3种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<pre><code class="javascript">switch(mode) &#123;
  case &#39;history&#39;:
    this.history = new HTML5History(this, options.base)
    break
  case &#39;hash&#39;:
    this.history = new HashHistory(this, options.base, this.fallback)
    break
  case &#39;abstract&#39;:
    this. history = new AbstractHistory(this, options.base)
    break
  default:
    if (process.env.NODE ENV!== &#39;production&#39;) &#123;
      assert(false, &quot;invalid mode: $&#123;mode&#125;&quot;)
    &#125;
&#125;
</code></pre>
<p>其中，3种路由模式的说明如下：</p>
<ul>
<li>hash: 使用 URLhash 值来作路由。支持所有浏览器，包括不支持 HTML5 History API 的浏览器；</li>
<li>history: 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
<li>abstract: 支持所有 Javascript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 APl，路由会自动强制进入这个模式。</li>
</ul>
<h1 id="19-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#19-能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>19. 能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h1><p>(1) hash 模式的实现原理</p>
<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是URL 中＃后面的内容。比如下面这个网站，它的location.hash 的值为”#search’：</p>
<p><a target="_blank" rel="noopener" href="https://www.word.com/#search">https://www.word.com#search</a></p>
<p>hash 路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过a标签，并设置href 属性，当用户点击这个标签后，URL的hash 值会发生改变；或者使用 Javascript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染)。</li>
</ul>
<p>(2) history 模式的实现原理</p>
<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：<code>history.pushState()</code> 和 <code>history.repalceState()</code> 。这两个 API可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>
<pre><code>window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
</code></pre>
<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化；</li>
<li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染)；</li>
<li><code>history.pushState()</code> 或 <code>history.replaceState()</code> 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
<h1 id="20-什么是-MVVM"><a href="#20-什么是-MVVM" class="headerlink" title="20. 什么是 MVVM?"></a>20. 什么是 MVVM?</h1><p>ModelView-ViewModel (MvvM)是一个软件架构设计模式，由微软 WPF 和Silverlight 的架构师 Ken Cooper 和Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表MVVM 源自于经典的 Model-View-Controller (MVC)模式，MvVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是ViewModel 层，它就像是一个中转站 (value converter)，负责转换Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model 层通过接口请求进行数据交互，起呈上启下作用。</p>
<p>(1) View 层<br>View 是视图层，也就是用户界面。前端主要由 HTML 和CSS 来构建。<br>(2) Model 层<br>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p>
<h1 id="21-Vue-是如何实现数据双向绑定的？"><a href="#21-Vue-是如何实现数据双向绑定的？" class="headerlink" title="21. Vue 是如何实现数据双向绑定的？"></a>21. Vue 是如何实现数据双向绑定的？</h1><p>Vue 数据双向鄉定主要是指：数据变化更新视图，视图变化更新数据。</p>
<p>即：</p>
<ul>
<li>输入框内容变化时，Data 中的数据同步 变化。即 View&#x3D;＞Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即Data &#x3D;＞ View 的变化。其中，View 变化更新 Data，可以通过事件监听的方式来实现，所以 vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</li>
</ul>
<p>vue 主要通过以下 4个步骤来实现数据双向绑定的</p>
<ul>
<li>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty()对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter， 那么就能监听到了数据变化。</li>
<li>实现个解析器 Compile：解析 vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li>
<li>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li>
<li>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher ，对监听器 Observer 和订阅者 Watcher 进行统一管理。</li>
</ul>
<h1 id="22-vue-框架怎么实现对象和数组的监听？"><a href="#22-vue-框架怎么实现对象和数组的监听？" class="headerlink" title="22. vue 框架怎么实现对象和数组的监听？"></a>22. vue 框架怎么实现对象和数组的监听？</h1><p>如果被问到 vue 怎么实现数据双向绑定，大家肯定都会回答通过 Object.defineProperty() 对数据进行劫持，但是 Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 vue框架中都知道，vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<pre><code class="javascript">/**
* Observe a list of Array items.
*/
observeArray(items: Array&lt;any&gt;) &#123;
  for (let i = 0, | = items.length; i &lt; I; i++) &#123;
    observe(items[i]) // observe 功能为监测数据的变化
  &#125;
&#125;

/**
* 对属性进行递归遍历
*/
let childob = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化
</code></pre>
<p>通过以上 vue 源码部分 查看，我们就能知道 vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty( 也能对对象和数组（部分方法的操作）进行监听。</p>
<h1 id="23-Proxy-与-Object-defineProperty-优劣对比"><a href="#23-Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="23. Proxy 与 Object.defineProperty 优劣对比"></a>23. Proxy 与 Object.defineProperty 优劣对比</h1><p><strong>Proxy 的优势如下：</strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达13种拦截方法，不限于 apply、ownkeys、delete Property、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p>Object.defineProperty 的优势如下：</p>
<ul>
<li>兼容性好，支持 1E9，而Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此vue 的作者才声明需要等到下个大版本（3.0）才能用 Proxy 重写。</li>
</ul>
<h1 id="24-Vue-怎么用vm-set-）-解决对象新增属性不能响应的问题？"><a href="#24-Vue-怎么用vm-set-）-解决对象新增属性不能响应的问题？" class="headerlink" title="24. Vue 怎么用vm.$set(） 解决对象新增属性不能响应的问题？"></a>24. Vue 怎么用vm.$set(） 解决对象新增属性不能响应的问题？</h1><p>受现代 JavaScript 的限制，vue 无法检测到对象属性的添加或删除。由于 vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化，所以属性必须在 data 对象上存在才能让vue 将它转换为响应式的。但是vue 提供了 Vue.set (object, propertyName, value) &#x2F; vm.$set (object, propertyName, value) 来实现为对象添加响应式属性，那框架本身是如何实现的呢？<br>我们查看对应的 vue 源码：vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p>
<pre><code class="javascript">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;
  // target 为数组
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;
    // 修改数组的长度，避免索引&gt;数组长度导致splcie()执行有误
    target.length = Math.max(target.length, key)
    //利用数组的splice变异方法触发响应式
    target.splice(key, 1, val)
    return val
  &#125;
  // key 已经存在，直接修改属性值
  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;
    target[key] = val
    return val
  &#125;
  
  const ob = (target: any)._ob_
    // target 本身就不是响应式数据,直接赋值
  if (!ob) &#123;
    target[key] = val
    return val
  &#125;
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
&#125;
</code></pre>
<p>我们阅读以上源码可知，vm.$set 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 define Reactive 方法进行响应式处理。</li>
</ul>
<h1 id="25-虛拟-DOM-的优缺点？"><a href="#25-虛拟-DOM-的优缺点？" class="headerlink" title="25. 虛拟 DOM 的优缺点？"></a>25. 虛拟 DOM 的优缺点？</h1><p><strong>优点：</strong></p>
<ul>
<li>保证性能下限：框架的虛拟 DOM 需要适配任何上层 API 可能产生的操作，它的些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的DOM操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情況下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li>无需手动操作 DOM：我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虛拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li>跨平台：虚拟 DOM 本质上是Javascript 对象,而 DOM 与平台强相关，相比之下虛拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法进行极致优化：虽然虛拟 DOM+合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虛拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<h1 id="26-虚拟-DOM-实现原理？"><a href="#26-虚拟-DOM-实现原理？" class="headerlink" title="26. 虚拟 DOM 实现原理？"></a>26. 虚拟 DOM 实现原理？</h1><p>虛拟 DOM 的实现原理主要包括以下3部分：</p>
<ul>
<li>用Javascript 对象模拟真实 DOM 树，对真实DOM 进行抽象；</li>
<li>diff 算法一比较两棵虚拟 DOM树的差异；</li>
<li>pach 算法 一将两个虚拟 DOM 对象的差异应用到真正的 DOM树。</li>
</ul>
<h1 id="27-Vue中的key有什么作用？"><a href="#27-Vue中的key有什么作用？" class="headerlink" title="27. Vue中的key有什么作用？"></a>27. Vue中的key有什么作用？</h1><p>key 是为 Vue 中 Vnode 的唯一标记，通过这个key，我们的diff 操作可以更准确、更快速。vue 的 diff 过程可以概括为：oldCh 和newCh 各有两个头尾的变量 oldStartindex、oldEndindex 和 newStartindex、newEndlindex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartindex 和 oldStartindex 、newEndIndex 和 oldEndindex、newStartIndex 和 oldEndIndex , newEndIndex 和oldStartindex， 如果以上 4种比较都没匹配，如果设置了key，就会用key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIndex＞EndIndex 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。</p>
<p>所以 vue 中 key 的作用是：key是为vue 中 vnode 的唯一标记，通过这个key，我们的 diff 操作可以更准确、更快速。</p>
<p>更准确：因为带 key 就不是就地复用了，在sameNode 函数 a.key &#x3D;&#x3D;&#x3D; b.key 对比中可以避免就地复用的情况。所以会更加准确。</p>
<p>更快速：利用key 的唯一性生成map 对象来获取对应节点，比遍历方式更快，源码如下：</p>
<pre><code class="javascript">function createKeyToOldIdx (children, beginIdx, endIdx)&#123;
  let i, key
  const map = 0
  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;
    key = children[i].key
    if (isDef(key)) map[key] = i
  &#125;
  return map
&#125;
</code></pre>
<h1 id="28-你有对Vue项目进行哪些优化？"><a href="#28-你有对Vue项目进行哪些优化？" class="headerlink" title="28. 你有对Vue项目进行哪些优化？"></a>28. 你有对Vue项目进行哪些优化？</h1><p>(1) 代码层面的优化</p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和watch 区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
</ul>
<p>(2) Webpack 层面的优化</p>
<ul>
<li>webpack 对图片进行压缩</li>
<li>减少ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 cSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>vue 项目的编译优化</li>
</ul>
<p>(3) 基础的Web技术的优化</p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h1 id="29-对于的Vue3-0特性你有什么了解的吗？"><a href="#29-对于的Vue3-0特性你有什么了解的吗？" class="headerlink" title="29. 对于的Vue3.0特性你有什么了解的吗？"></a>29. 对于的Vue3.0特性你有什么了解的吗？</h1><p>Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p>
<p>(1) 监测机制的改变</p>
<p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p>
<ul>
<li>只能监测属性，不能监测对象</li>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 Weak Seto</li>
</ul>
<p>新的 observer 还提供了以下特性：</p>
<ul>
<li>用于创建observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li>
<li>默认采用惰性观察。在2.x 中，不管反应式数据有多大，都会在启动时被观察到，如果你的数据集很大，这可能会在应用启动时带来明显的开销。在3.x中，只观察用于渲染应用程序最初可见部分的数据。</li>
<li>更精确的变更通知。在2.x中，通过 vue.set 强制添加新属性将导致依赖于该对象的watcher 收到变更通知。在3.x中，只有依赖于特定属性的watcher 才会收到通知。</li>
<li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 vuex 状态树以外的变化。</li>
<li>更好的调试功能：我们可以使用新的renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li>
</ul>
<p>(2) 模板</p>
<p>模板方面没有大的变更，只改了作用域插槽，2.× 的机制导致作用域插槽变了，父组件会重新渲染，而3.0把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于render 西数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom.</p>
<p>(3) 对象式的组件声明方式</p>
<p>Vue2.x 中的组件是通过声明的方式传入一系列 option，和Type Script 的结合需要通过一 些装饰器的方式来做，量然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 Type Script 的结合变得很容易。</p>
<p>此外，Vue 的源码也改用了 Type Script 来写。其实当代码的功能复杂之后，必须有。个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p>
<p>(4) 其它方面的更改</p>
<p>Vue 3.0 的改变是全面的，上面只涉及到主要的 3个方面，还有一些其他的更改：</p>
<ul>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接fork 源码来改的方式。</li>
<li>支持 Fragment （多个根节点） 和Protal（在dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 treeshaking 优化，提供了更多的内置功能。</li>
</ul>
<h1 id="30-说说你使用-vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#30-说说你使用-vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="30. 说说你使用 vue 框架踩过最大的坑是什么？怎么解决的？"></a>30. 说说你使用 vue 框架踩过最大的坑是什么？怎么解决的？</h1>
        </div>

        
            <section class="post-copyright">
                
                    <div>
                        <span>Author:</span>
                        <span>ismdeep</span>
                    </div>
                
                
                    <div>
                    Date: <a href="#">June 16, 2022&nbsp;&nbsp;15:51:09</a>
                    </div>
                
                
                    <div>
                        <span>Permalink:</span>
                        <span><a href="https://ismdeep.github.io/posts/2022-06-16-30-vue-interview-questions.html">https://ismdeep.github.io/posts/2022-06-16-30-vue-interview-questions.html</a></span>
                    </div>
                
                
                    <div>
                        <span>License:</span>
                        <span>Copyright (c) 2025 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </div>
                
                
            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                        
                            <a href="/tags/Development/">#Development</a>
                        
                            <a href="/tags/Vue/">#Vue</a>
                        
                    
                </span>
            </div>
        </section>

        <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
        <script src="/js/md5.js"></script>
        <div style="margin-top: 2rem" id="gitalk-container"></div>
        <script>
          const gitalk = new Gitalk({
            clientID: 'fbdbc0d8c335f558f9b7',
            clientSecret: 'ee8a5301d43b6a7334ac0f34081006c097f75aa9',
            repo: 'ismdeep.github.io',
            owner: 'ismdeep',
            admin: ['ismdeep'],
            id: md5(location.pathname),
            language: 'en'
          })
          gitalk.render('gitalk-container')
        </script>


    </article>
</div>


              </div>
            </div>
          </div>
        </div>
        <div class="visualClear"></div>
      </div>
      <div id="column-one" lang="zh-Hans-CN" dir="ltr">
        <div role="navigation" class="portlet" id="p-personal" aria-labelledby="p-personal-label">
          <div class="pBody" style="margin-top: 4px;">
            <ul lang="zh-Hans-CN" dir="ltr">
              <li>
                <a href="/">首页</a>
              </li>
              <li>
                <a href="/archives/">文章列表</a>
              </li>
              <li>
                <a href="/tags/">分类索引</a>
              </li>
              <li>
                <a href="/posts/resource.html">资源列表</a>
              </li>
              <li>
                <a href="/about/">关于我</a>
              </li>
            </ul>
          </div>
        </div>
        <div class="portlet" id="p-logo" role="banner">
          <a href="/" class="mw-wiki-logo"></a>
        </div>
        <div id="sidebar">
          <div role="navigation" class="portlet mw-portlet mw-portlet-navigation" id="p-navigation" aria-labelledby="p-navigation-label">
            <h3 id="p-navigation-label" lang="zh-Hans-CN" dir="ltr">导航</h3>
            <div class="pBody">
              <ul lang="zh-Hans-CN" dir="ltr">
                <li id="n-mainpage-description" class="mw-list-item">
                  <a href="/">首页</a>
                </li>
                <li id="n-indexpage" class="mw-list-item">
                  <a href="/archives/">文章列表</a>
                </li>
                <li id="n-indexpage" class="mw-list-item">
                  <a href="/tags/">分类索引</a>
                </li>
                <li id="n-Featured_content" class="mw-list-item">
                  <a href="/posts/resource.html">资源列表</a>
                </li>
                <li id="n-Featured_content" class="mw-list-item">
                  <a href="/about/">关于我</a>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <!-- end of the left (by default at least) column -->
      <div class="visualClear"></div>
      <div id="footer" class="mw-footer" role="contentinfo" lang="zh-Hans-CN" dir="ltr">
        <ul id="f-list">
          <li id="about">
            <a href="/about/">关于我</a>
          </li>
        </ul>
      </div>
    </div>

  </body>
  <div id="immersive-translate-browser-popup" style="all: initial"></div>

</html>
